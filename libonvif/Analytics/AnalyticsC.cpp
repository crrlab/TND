/* AnalyticsC.cpp
   Generated by gSOAP 2.8.0 from ./libonvif/analytics.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   The generated code is released under one of the following licenses:
   GPL OR Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "AnalyticsH.h"

SOAP_SOURCE_STAMP("@(#) AnalyticsC.cpp ver 2.8.0 2010-11-12 18:02:15 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_tt__IANA_IfTypes:
		return soap_in_tt__IANA_IfTypes(soap, NULL, NULL, "tt:IANA-IfTypes");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_xsd__duration:
		return soap_in_xsd__duration(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLONG64:
		return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_tt__ClassType:
		return soap_in_tt__ClassType(soap, NULL, NULL, "tt:ClassType");
	case SOAP_TYPE_tt__Direction:
		return soap_in_tt__Direction(soap, NULL, NULL, "tt:Direction");
	case SOAP_TYPE_tt__PropertyOperation:
		return soap_in_tt__PropertyOperation(soap, NULL, NULL, "tt:PropertyOperation");
	case SOAP_TYPE_tt__IrCutFilterMode:
		return soap_in_tt__IrCutFilterMode(soap, NULL, NULL, "tt:IrCutFilterMode");
	case SOAP_TYPE_tt__WhiteBalanceMode:
		return soap_in_tt__WhiteBalanceMode(soap, NULL, NULL, "tt:WhiteBalanceMode");
	case SOAP_TYPE_tt__Enabled:
		return soap_in_tt__Enabled(soap, NULL, NULL, "tt:Enabled");
	case SOAP_TYPE_tt__ExposureMode:
		return soap_in_tt__ExposureMode(soap, NULL, NULL, "tt:ExposureMode");
	case SOAP_TYPE_tt__ExposurePriority:
		return soap_in_tt__ExposurePriority(soap, NULL, NULL, "tt:ExposurePriority");
	case SOAP_TYPE_tt__BacklightCompensationMode:
		return soap_in_tt__BacklightCompensationMode(soap, NULL, NULL, "tt:BacklightCompensationMode");
	case SOAP_TYPE_tt__WideDynamicMode:
		return soap_in_tt__WideDynamicMode(soap, NULL, NULL, "tt:WideDynamicMode");
	case SOAP_TYPE_tt__AutoFocusMode:
		return soap_in_tt__AutoFocusMode(soap, NULL, NULL, "tt:AutoFocusMode");
	case SOAP_TYPE_tt__MoveStatus:
		return soap_in_tt__MoveStatus(soap, NULL, NULL, "tt:MoveStatus");
	case SOAP_TYPE_tt__RelayMode:
		return soap_in_tt__RelayMode(soap, NULL, NULL, "tt:RelayMode");
	case SOAP_TYPE_tt__RelayIdleState:
		return soap_in_tt__RelayIdleState(soap, NULL, NULL, "tt:RelayIdleState");
	case SOAP_TYPE_tt__RelayLogicalState:
		return soap_in_tt__RelayLogicalState(soap, NULL, NULL, "tt:RelayLogicalState");
	case SOAP_TYPE_tt__UserLevel:
		return soap_in_tt__UserLevel(soap, NULL, NULL, "tt:UserLevel");
	case SOAP_TYPE_tt__SetDateTimeType:
		return soap_in_tt__SetDateTimeType(soap, NULL, NULL, "tt:SetDateTimeType");
	case SOAP_TYPE_tt__FactoryDefaultType:
		return soap_in_tt__FactoryDefaultType(soap, NULL, NULL, "tt:FactoryDefaultType");
	case SOAP_TYPE_tt__SystemLogType:
		return soap_in_tt__SystemLogType(soap, NULL, NULL, "tt:SystemLogType");
	case SOAP_TYPE_tt__CapabilityCategory:
		return soap_in_tt__CapabilityCategory(soap, NULL, NULL, "tt:CapabilityCategory");
	case SOAP_TYPE_tt__DynamicDNSType:
		return soap_in_tt__DynamicDNSType(soap, NULL, NULL, "tt:DynamicDNSType");
	case SOAP_TYPE_tt__IPAddressFilterType:
		return soap_in_tt__IPAddressFilterType(soap, NULL, NULL, "tt:IPAddressFilterType");
	case SOAP_TYPE_tt__IPType:
		return soap_in_tt__IPType(soap, NULL, NULL, "tt:IPType");
	case SOAP_TYPE_tt__NetworkHostType:
		return soap_in_tt__NetworkHostType(soap, NULL, NULL, "tt:NetworkHostType");
	case SOAP_TYPE_tt__NetworkProtocolType:
		return soap_in_tt__NetworkProtocolType(soap, NULL, NULL, "tt:NetworkProtocolType");
	case SOAP_TYPE_tt__IPv6DHCPConfiguration:
		return soap_in_tt__IPv6DHCPConfiguration(soap, NULL, NULL, "tt:IPv6DHCPConfiguration");
	case SOAP_TYPE_tt__Duplex:
		return soap_in_tt__Duplex(soap, NULL, NULL, "tt:Duplex");
	case SOAP_TYPE_tt__DiscoveryMode:
		return soap_in_tt__DiscoveryMode(soap, NULL, NULL, "tt:DiscoveryMode");
	case SOAP_TYPE_tt__ScopeDefinition:
		return soap_in_tt__ScopeDefinition(soap, NULL, NULL, "tt:ScopeDefinition");
	case SOAP_TYPE_tt__TransportProtocol:
		return soap_in_tt__TransportProtocol(soap, NULL, NULL, "tt:TransportProtocol");
	case SOAP_TYPE_tt__StreamType:
		return soap_in_tt__StreamType(soap, NULL, NULL, "tt:StreamType");
	case SOAP_TYPE_tt__AudioEncoding:
		return soap_in_tt__AudioEncoding(soap, NULL, NULL, "tt:AudioEncoding");
	case SOAP_TYPE_tt__H264Profile:
		return soap_in_tt__H264Profile(soap, NULL, NULL, "tt:H264Profile");
	case SOAP_TYPE_tt__Mpeg4Profile:
		return soap_in_tt__Mpeg4Profile(soap, NULL, NULL, "tt:Mpeg4Profile");
	case SOAP_TYPE_tt__VideoEncoding:
		return soap_in_tt__VideoEncoding(soap, NULL, NULL, "tt:VideoEncoding");
	case SOAP_TYPE_wsse__FaultcodeEnum:
		return soap_in_wsse__FaultcodeEnum(soap, NULL, NULL, "wsse:FaultcodeEnum");
	case SOAP_TYPE_wsu__tTimestampFault:
		return soap_in_wsu__tTimestampFault(soap, NULL, NULL, "wsu:tTimestampFault");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_in__wsa5__IsReferenceParameter(soap, NULL, NULL, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_in_wsa5__FaultCodesType(soap, NULL, NULL, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_in_wsa5__RelationshipType(soap, NULL, NULL, "wsa5:RelationshipType");
	case SOAP_TYPE_wstop__SimpleTopicExpression:
		return soap_in_wstop__SimpleTopicExpression(soap, NULL, NULL, "wstop:SimpleTopicExpression");
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
		return soap_in_wstop__ConcreteTopicExpression(soap, NULL, NULL, "wstop:ConcreteTopicExpression");
	case SOAP_TYPE_wstop__FullTopicExpression:
		return soap_in_wstop__FullTopicExpression(soap, NULL, NULL, "wstop:FullTopicExpression");
	case SOAP_TYPE_tt__TopicNamespaceLocation:
		return soap_in_tt__TopicNamespaceLocation(soap, NULL, NULL, "tt:TopicNamespaceLocation");
	case SOAP_TYPE_tt__AuxiliaryData:
		return soap_in_tt__AuxiliaryData(soap, NULL, NULL, "tt:AuxiliaryData");
	case SOAP_TYPE_tt__Domain:
		return soap_in_tt__Domain(soap, NULL, NULL, "tt:Domain");
	case SOAP_TYPE_tt__DNSName:
		return soap_in_tt__DNSName(soap, NULL, NULL, "tt:DNSName");
	case SOAP_TYPE_tt__HwAddress:
		return soap_in_tt__HwAddress(soap, NULL, NULL, "tt:HwAddress");
	case SOAP_TYPE_tt__IPv6Address:
		return soap_in_tt__IPv6Address(soap, NULL, NULL, "tt:IPv6Address");
	case SOAP_TYPE_tt__IPv4Address:
		return soap_in_tt__IPv4Address(soap, NULL, NULL, "tt:IPv4Address");
	case SOAP_TYPE_tt__Name:
		return soap_in_tt__Name(soap, NULL, NULL, "tt:Name");
	case SOAP_TYPE_tt__ReferenceToken:
		return soap_in_tt__ReferenceToken(soap, NULL, NULL, "tt:ReferenceToken");
	case SOAP_TYPE_wsnb__AbsoluteOrRelativeTimeType:
		return soap_in_wsnb__AbsoluteOrRelativeTimeType(soap, NULL, NULL, "wsnb:AbsoluteOrRelativeTimeType");
	case SOAP_TYPE_wstop__TopicSetType:
		return soap_in_wstop__TopicSetType(soap, NULL, NULL, "wstop:TopicSetType");
	case SOAP_TYPE_wstop__TopicType:
		return soap_in_wstop__TopicType(soap, NULL, NULL, "wstop:TopicType");
	case SOAP_TYPE_wstop__TopicNamespaceType:
		return soap_in_wstop__TopicNamespaceType(soap, NULL, NULL, "wstop:TopicNamespaceType");
	case SOAP_TYPE_wstop__QueryExpressionType:
		return soap_in_wstop__QueryExpressionType(soap, NULL, NULL, "wstop:QueryExpressionType");
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		return soap_in_wstop__ExtensibleDocumented(soap, NULL, NULL, "wstop:ExtensibleDocumented");
	case SOAP_TYPE_wstop__Documentation:
		return soap_in_wstop__Documentation(soap, NULL, NULL, "wstop:Documentation");
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		return soap_in_wsrfbf__BaseFaultType(soap, NULL, NULL, "wsrfbf:BaseFaultType");
	case SOAP_TYPE_wsnb__ResumeFailedFaultType:
		return soap_in_wsnb__ResumeFailedFaultType(soap, NULL, NULL, "wsnb:ResumeFailedFaultType");
	case SOAP_TYPE_wsnb__PauseFailedFaultType:
		return soap_in_wsnb__PauseFailedFaultType(soap, NULL, NULL, "wsnb:PauseFailedFaultType");
	case SOAP_TYPE_wsnb__UnableToDestroySubscriptionFaultType:
		return soap_in_wsnb__UnableToDestroySubscriptionFaultType(soap, NULL, NULL, "wsnb:UnableToDestroySubscriptionFaultType");
	case SOAP_TYPE_wsnb__UnacceptableTerminationTimeFaultType:
		return soap_in_wsnb__UnacceptableTerminationTimeFaultType(soap, NULL, NULL, "wsnb:UnacceptableTerminationTimeFaultType");
	case SOAP_TYPE_wsnb__UnableToCreatePullPointFaultType:
		return soap_in_wsnb__UnableToCreatePullPointFaultType(soap, NULL, NULL, "wsnb:UnableToCreatePullPointFaultType");
	case SOAP_TYPE_wsnb__UnableToDestroyPullPointFaultType:
		return soap_in_wsnb__UnableToDestroyPullPointFaultType(soap, NULL, NULL, "wsnb:UnableToDestroyPullPointFaultType");
	case SOAP_TYPE_wsnb__UnableToGetMessagesFaultType:
		return soap_in_wsnb__UnableToGetMessagesFaultType(soap, NULL, NULL, "wsnb:UnableToGetMessagesFaultType");
	case SOAP_TYPE_wsnb__NoCurrentMessageOnTopicFaultType:
		return soap_in_wsnb__NoCurrentMessageOnTopicFaultType(soap, NULL, NULL, "wsnb:NoCurrentMessageOnTopicFaultType");
	case SOAP_TYPE_wsnb__UnacceptableInitialTerminationTimeFaultType:
		return soap_in_wsnb__UnacceptableInitialTerminationTimeFaultType(soap, NULL, NULL, "wsnb:UnacceptableInitialTerminationTimeFaultType");
	case SOAP_TYPE_wsnb__NotifyMessageNotSupportedFaultType:
		return soap_in_wsnb__NotifyMessageNotSupportedFaultType(soap, NULL, NULL, "wsnb:NotifyMessageNotSupportedFaultType");
	case SOAP_TYPE_wsnb__UnsupportedPolicyRequestFaultType:
		return soap_in_wsnb__UnsupportedPolicyRequestFaultType(soap, NULL, NULL, "wsnb:UnsupportedPolicyRequestFaultType");
	case SOAP_TYPE_wsnb__UnrecognizedPolicyRequestFaultType:
		return soap_in_wsnb__UnrecognizedPolicyRequestFaultType(soap, NULL, NULL, "wsnb:UnrecognizedPolicyRequestFaultType");
	case SOAP_TYPE_wsnb__InvalidMessageContentExpressionFaultType:
		return soap_in_wsnb__InvalidMessageContentExpressionFaultType(soap, NULL, NULL, "wsnb:InvalidMessageContentExpressionFaultType");
	case SOAP_TYPE_wsnb__InvalidProducerPropertiesExpressionFaultType:
		return soap_in_wsnb__InvalidProducerPropertiesExpressionFaultType(soap, NULL, NULL, "wsnb:InvalidProducerPropertiesExpressionFaultType");
	case SOAP_TYPE_wsnb__MultipleTopicsSpecifiedFaultType:
		return soap_in_wsnb__MultipleTopicsSpecifiedFaultType(soap, NULL, NULL, "wsnb:MultipleTopicsSpecifiedFaultType");
	case SOAP_TYPE_wsnb__TopicNotSupportedFaultType:
		return soap_in_wsnb__TopicNotSupportedFaultType(soap, NULL, NULL, "wsnb:TopicNotSupportedFaultType");
	case SOAP_TYPE_wsnb__InvalidTopicExpressionFaultType:
		return soap_in_wsnb__InvalidTopicExpressionFaultType(soap, NULL, NULL, "wsnb:InvalidTopicExpressionFaultType");
	case SOAP_TYPE_wsnb__TopicExpressionDialectUnknownFaultType:
		return soap_in_wsnb__TopicExpressionDialectUnknownFaultType(soap, NULL, NULL, "wsnb:TopicExpressionDialectUnknownFaultType");
	case SOAP_TYPE_wsnb__InvalidFilterFaultType:
		return soap_in_wsnb__InvalidFilterFaultType(soap, NULL, NULL, "wsnb:InvalidFilterFaultType");
	case SOAP_TYPE_wsnb__SubscribeCreationFailedFaultType:
		return soap_in_wsnb__SubscribeCreationFailedFaultType(soap, NULL, NULL, "wsnb:SubscribeCreationFailedFaultType");
	case SOAP_TYPE_wsnb__NotificationMessageHolderType:
		return soap_in_wsnb__NotificationMessageHolderType(soap, NULL, NULL, "wsnb:NotificationMessageHolderType");
	case SOAP_TYPE_wsnb__SubscriptionPolicyType:
		return soap_in_wsnb__SubscriptionPolicyType(soap, NULL, NULL, "wsnb:SubscriptionPolicyType");
	case SOAP_TYPE_wsnb__FilterType:
		return soap_in_wsnb__FilterType(soap, NULL, NULL, "wsnb:FilterType");
	case SOAP_TYPE_wsnb__TopicExpressionType:
		return soap_in_wsnb__TopicExpressionType(soap, NULL, NULL, "wsnb:TopicExpressionType");
	case SOAP_TYPE_wsnb__QueryExpressionType:
		return soap_in_wsnb__QueryExpressionType(soap, NULL, NULL, "wsnb:QueryExpressionType");
	case SOAP_TYPE_tt__EventStreamExtension:
		return soap_in_tt__EventStreamExtension(soap, NULL, NULL, "tt:EventStreamExtension");
	case SOAP_TYPE_tt__EventStream:
		return soap_in_tt__EventStream(soap, NULL, NULL, "tt:EventStream");
	case SOAP_TYPE_tt__PTZStreamExtension:
		return soap_in_tt__PTZStreamExtension(soap, NULL, NULL, "tt:PTZStreamExtension");
	case SOAP_TYPE_tt__PTZStream:
		return soap_in_tt__PTZStream(soap, NULL, NULL, "tt:PTZStream");
	case SOAP_TYPE_tt__VideoAnalyticsStreamExtension:
		return soap_in_tt__VideoAnalyticsStreamExtension(soap, NULL, NULL, "tt:VideoAnalyticsStreamExtension");
	case SOAP_TYPE_tt__VideoAnalyticsStream:
		return soap_in_tt__VideoAnalyticsStream(soap, NULL, NULL, "tt:VideoAnalyticsStream");
	case SOAP_TYPE_tt__MetadataStreamExtension:
		return soap_in_tt__MetadataStreamExtension(soap, NULL, NULL, "tt:MetadataStreamExtension");
	case SOAP_TYPE_tt__MetadataStream:
		return soap_in_tt__MetadataStream(soap, NULL, NULL, "tt:MetadataStream");
	case SOAP_TYPE_tt__SupportedAnalyticsModulesExtension:
		return soap_in_tt__SupportedAnalyticsModulesExtension(soap, NULL, NULL, "tt:SupportedAnalyticsModulesExtension");
	case SOAP_TYPE_tt__SupportedAnalyticsModules:
		return soap_in_tt__SupportedAnalyticsModules(soap, NULL, NULL, "tt:SupportedAnalyticsModules");
	case SOAP_TYPE_tt__SupportedRulesExtension:
		return soap_in_tt__SupportedRulesExtension(soap, NULL, NULL, "tt:SupportedRulesExtension");
	case SOAP_TYPE_tt__SupportedRules:
		return soap_in_tt__SupportedRules(soap, NULL, NULL, "tt:SupportedRules");
	case SOAP_TYPE_tt__ConfigDescriptionExtension:
		return soap_in_tt__ConfigDescriptionExtension(soap, NULL, NULL, "tt:ConfigDescriptionExtension");
	case SOAP_TYPE_tt__ConfigDescription:
		return soap_in_tt__ConfigDescription(soap, NULL, NULL, "tt:ConfigDescription");
	case SOAP_TYPE_tt__Config:
		return soap_in_tt__Config(soap, NULL, NULL, "tt:Config");
	case SOAP_TYPE_tt__RuleEngineConfigurationExtension:
		return soap_in_tt__RuleEngineConfigurationExtension(soap, NULL, NULL, "tt:RuleEngineConfigurationExtension");
	case SOAP_TYPE_tt__RuleEngineConfiguration:
		return soap_in_tt__RuleEngineConfiguration(soap, NULL, NULL, "tt:RuleEngineConfiguration");
	case SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension:
		return soap_in_tt__AnalyticsEngineConfigurationExtension(soap, NULL, NULL, "tt:AnalyticsEngineConfigurationExtension");
	case SOAP_TYPE_tt__AnalyticsEngineConfiguration:
		return soap_in_tt__AnalyticsEngineConfiguration(soap, NULL, NULL, "tt:AnalyticsEngineConfiguration");
	case SOAP_TYPE_tt__ObjectTreeExtension:
		return soap_in_tt__ObjectTreeExtension(soap, NULL, NULL, "tt:ObjectTreeExtension");
	case SOAP_TYPE_tt__ObjectTree:
		return soap_in_tt__ObjectTree(soap, NULL, NULL, "tt:ObjectTree");
	case SOAP_TYPE_tt__BehaviourExtension:
		return soap_in_tt__BehaviourExtension(soap, NULL, NULL, "tt:BehaviourExtension");
	case SOAP_TYPE_tt__Behaviour:
		return soap_in_tt__Behaviour(soap, NULL, NULL, "tt:Behaviour");
	case SOAP_TYPE_tt__ObjectId:
		return soap_in_tt__ObjectId(soap, NULL, NULL, "tt:ObjectId");
	case SOAP_TYPE_tt__Rename:
		return soap_in_tt__Rename(soap, NULL, NULL, "tt:Rename");
	case SOAP_TYPE_tt__Split:
		return soap_in_tt__Split(soap, NULL, NULL, "tt:Split");
	case SOAP_TYPE_tt__Merge:
		return soap_in_tt__Merge(soap, NULL, NULL, "tt:Merge");
	case SOAP_TYPE_tt__FrameExtension:
		return soap_in_tt__FrameExtension(soap, NULL, NULL, "tt:FrameExtension");
	case SOAP_TYPE_tt__Frame:
		return soap_in_tt__Frame(soap, NULL, NULL, "tt:Frame");
	case SOAP_TYPE_tt__TransformationExtension:
		return soap_in_tt__TransformationExtension(soap, NULL, NULL, "tt:TransformationExtension");
	case SOAP_TYPE_tt__Transformation:
		return soap_in_tt__Transformation(soap, NULL, NULL, "tt:Transformation");
	case SOAP_TYPE_tt__ObjectExtension:
		return soap_in_tt__ObjectExtension(soap, NULL, NULL, "tt:ObjectExtension");
	case SOAP_TYPE_tt__Object:
		return soap_in_tt__Object(soap, NULL, NULL, "tt:Object");
	case SOAP_TYPE_tt__ClassDescriptorExtension:
		return soap_in_tt__ClassDescriptorExtension(soap, NULL, NULL, "tt:ClassDescriptorExtension");
	case SOAP_TYPE_tt__ClassDescriptor:
		return soap_in_tt__ClassDescriptor(soap, NULL, NULL, "tt:ClassDescriptor");
	case SOAP_TYPE_tt__ColorDescriptorExtension:
		return soap_in_tt__ColorDescriptorExtension(soap, NULL, NULL, "tt:ColorDescriptorExtension");
	case SOAP_TYPE_tt__ColorDescriptor:
		return soap_in_tt__ColorDescriptor(soap, NULL, NULL, "tt:ColorDescriptor");
	case SOAP_TYPE_tt__ShapeDescriptorExtension:
		return soap_in_tt__ShapeDescriptorExtension(soap, NULL, NULL, "tt:ShapeDescriptorExtension");
	case SOAP_TYPE_tt__ShapeDescriptor:
		return soap_in_tt__ShapeDescriptor(soap, NULL, NULL, "tt:ShapeDescriptor");
	case SOAP_TYPE_tt__AppearanceExtension:
		return soap_in_tt__AppearanceExtension(soap, NULL, NULL, "tt:AppearanceExtension");
	case SOAP_TYPE_tt__Appearance:
		return soap_in_tt__Appearance(soap, NULL, NULL, "tt:Appearance");
	case SOAP_TYPE_tt__ColorCovariance:
		return soap_in_tt__ColorCovariance(soap, NULL, NULL, "tt:ColorCovariance");
	case SOAP_TYPE_tt__Color:
		return soap_in_tt__Color(soap, NULL, NULL, "tt:Color");
	case SOAP_TYPE_tt__Polyline:
		return soap_in_tt__Polyline(soap, NULL, NULL, "tt:Polyline");
	case SOAP_TYPE_tt__Polygon:
		return soap_in_tt__Polygon(soap, NULL, NULL, "tt:Polygon");
	case SOAP_TYPE_tt__Rectangle:
		return soap_in_tt__Rectangle(soap, NULL, NULL, "tt:Rectangle");
	case SOAP_TYPE_tt__Vector:
		return soap_in_tt__Vector(soap, NULL, NULL, "tt:Vector");
	case SOAP_TYPE_tt__ItemListDescriptionExtension:
		return soap_in_tt__ItemListDescriptionExtension(soap, NULL, NULL, "tt:ItemListDescriptionExtension");
	case SOAP_TYPE_tt__ItemListDescription:
		return soap_in_tt__ItemListDescription(soap, NULL, NULL, "tt:ItemListDescription");
	case SOAP_TYPE_tt__MessageDescriptionExtension:
		return soap_in_tt__MessageDescriptionExtension(soap, NULL, NULL, "tt:MessageDescriptionExtension");
	case SOAP_TYPE_tt__MessageDescription:
		return soap_in_tt__MessageDescription(soap, NULL, NULL, "tt:MessageDescription");
	case SOAP_TYPE_tt__ItemListExtension:
		return soap_in_tt__ItemListExtension(soap, NULL, NULL, "tt:ItemListExtension");
	case SOAP_TYPE_tt__ItemList:
		return soap_in_tt__ItemList(soap, NULL, NULL, "tt:ItemList");
	case SOAP_TYPE_tt__MessageExtension:
		return soap_in_tt__MessageExtension(soap, NULL, NULL, "tt:MessageExtension");
	case SOAP_TYPE_tt__FocusOptions20Extension:
		return soap_in_tt__FocusOptions20Extension(soap, NULL, NULL, "tt:FocusOptions20Extension");
	case SOAP_TYPE_tt__FocusOptions20:
		return soap_in_tt__FocusOptions20(soap, NULL, NULL, "tt:FocusOptions20");
	case SOAP_TYPE_tt__WhiteBalanceOptions20Extension:
		return soap_in_tt__WhiteBalanceOptions20Extension(soap, NULL, NULL, "tt:WhiteBalanceOptions20Extension");
	case SOAP_TYPE_tt__WhiteBalanceOptions20:
		return soap_in_tt__WhiteBalanceOptions20(soap, NULL, NULL, "tt:WhiteBalanceOptions20");
	case SOAP_TYPE_tt__FocusConfiguration20Extension:
		return soap_in_tt__FocusConfiguration20Extension(soap, NULL, NULL, "tt:FocusConfiguration20Extension");
	case SOAP_TYPE_tt__FocusConfiguration20:
		return soap_in_tt__FocusConfiguration20(soap, NULL, NULL, "tt:FocusConfiguration20");
	case SOAP_TYPE_tt__WhiteBalance20Extension:
		return soap_in_tt__WhiteBalance20Extension(soap, NULL, NULL, "tt:WhiteBalance20Extension");
	case SOAP_TYPE_tt__WhiteBalance20:
		return soap_in_tt__WhiteBalance20(soap, NULL, NULL, "tt:WhiteBalance20");
	case SOAP_TYPE_tt__RelativeFocusOptions20:
		return soap_in_tt__RelativeFocusOptions20(soap, NULL, NULL, "tt:RelativeFocusOptions20");
	case SOAP_TYPE_tt__MoveOptions20:
		return soap_in_tt__MoveOptions20(soap, NULL, NULL, "tt:MoveOptions20");
	case SOAP_TYPE_tt__ExposureOptions20:
		return soap_in_tt__ExposureOptions20(soap, NULL, NULL, "tt:ExposureOptions20");
	case SOAP_TYPE_tt__BacklightCompensationOptions20:
		return soap_in_tt__BacklightCompensationOptions20(soap, NULL, NULL, "tt:BacklightCompensationOptions20");
	case SOAP_TYPE_tt__WideDynamicRangeOptions20:
		return soap_in_tt__WideDynamicRangeOptions20(soap, NULL, NULL, "tt:WideDynamicRangeOptions20");
	case SOAP_TYPE_tt__ImagingOptions20Extension:
		return soap_in_tt__ImagingOptions20Extension(soap, NULL, NULL, "tt:ImagingOptions20Extension");
	case SOAP_TYPE_tt__ImagingOptions20:
		return soap_in_tt__ImagingOptions20(soap, NULL, NULL, "tt:ImagingOptions20");
	case SOAP_TYPE_tt__Exposure20:
		return soap_in_tt__Exposure20(soap, NULL, NULL, "tt:Exposure20");
	case SOAP_TYPE_tt__BacklightCompensation20:
		return soap_in_tt__BacklightCompensation20(soap, NULL, NULL, "tt:BacklightCompensation20");
	case SOAP_TYPE_tt__WideDynamicRange20:
		return soap_in_tt__WideDynamicRange20(soap, NULL, NULL, "tt:WideDynamicRange20");
	case SOAP_TYPE_tt__ImagingSettingsExtension20:
		return soap_in_tt__ImagingSettingsExtension20(soap, NULL, NULL, "tt:ImagingSettingsExtension20");
	case SOAP_TYPE_tt__ImagingSettings20:
		return soap_in_tt__ImagingSettings20(soap, NULL, NULL, "tt:ImagingSettings20");
	case SOAP_TYPE_tt__FocusStatus20Extension:
		return soap_in_tt__FocusStatus20Extension(soap, NULL, NULL, "tt:FocusStatus20Extension");
	case SOAP_TYPE_tt__FocusStatus20:
		return soap_in_tt__FocusStatus20(soap, NULL, NULL, "tt:FocusStatus20");
	case SOAP_TYPE_tt__ImagingStatus20Extension:
		return soap_in_tt__ImagingStatus20Extension(soap, NULL, NULL, "tt:ImagingStatus20Extension");
	case SOAP_TYPE_tt__ImagingStatus20:
		return soap_in_tt__ImagingStatus20(soap, NULL, NULL, "tt:ImagingStatus20");
	case SOAP_TYPE_tt__WhiteBalance:
		return soap_in_tt__WhiteBalance(soap, NULL, NULL, "tt:WhiteBalance");
	case SOAP_TYPE_tt__ContinuousFocusOptions:
		return soap_in_tt__ContinuousFocusOptions(soap, NULL, NULL, "tt:ContinuousFocusOptions");
	case SOAP_TYPE_tt__RelativeFocusOptions:
		return soap_in_tt__RelativeFocusOptions(soap, NULL, NULL, "tt:RelativeFocusOptions");
	case SOAP_TYPE_tt__AbsoluteFocusOptions:
		return soap_in_tt__AbsoluteFocusOptions(soap, NULL, NULL, "tt:AbsoluteFocusOptions");
	case SOAP_TYPE_tt__MoveOptions:
		return soap_in_tt__MoveOptions(soap, NULL, NULL, "tt:MoveOptions");
	case SOAP_TYPE_tt__ContinuousFocus:
		return soap_in_tt__ContinuousFocus(soap, NULL, NULL, "tt:ContinuousFocus");
	case SOAP_TYPE_tt__RelativeFocus:
		return soap_in_tt__RelativeFocus(soap, NULL, NULL, "tt:RelativeFocus");
	case SOAP_TYPE_tt__AbsoluteFocus:
		return soap_in_tt__AbsoluteFocus(soap, NULL, NULL, "tt:AbsoluteFocus");
	case SOAP_TYPE_tt__FocusMove:
		return soap_in_tt__FocusMove(soap, NULL, NULL, "tt:FocusMove");
	case SOAP_TYPE_tt__WhiteBalanceOptions:
		return soap_in_tt__WhiteBalanceOptions(soap, NULL, NULL, "tt:WhiteBalanceOptions");
	case SOAP_TYPE_tt__ExposureOptions:
		return soap_in_tt__ExposureOptions(soap, NULL, NULL, "tt:ExposureOptions");
	case SOAP_TYPE_tt__FocusOptions:
		return soap_in_tt__FocusOptions(soap, NULL, NULL, "tt:FocusOptions");
	case SOAP_TYPE_tt__BacklightCompensationOptions:
		return soap_in_tt__BacklightCompensationOptions(soap, NULL, NULL, "tt:BacklightCompensationOptions");
	case SOAP_TYPE_tt__WideDynamicRangeOptions:
		return soap_in_tt__WideDynamicRangeOptions(soap, NULL, NULL, "tt:WideDynamicRangeOptions");
	case SOAP_TYPE_tt__ImagingOptions:
		return soap_in_tt__ImagingOptions(soap, NULL, NULL, "tt:ImagingOptions");
	case SOAP_TYPE_tt__BacklightCompensation:
		return soap_in_tt__BacklightCompensation(soap, NULL, NULL, "tt:BacklightCompensation");
	case SOAP_TYPE_tt__WideDynamicRange:
		return soap_in_tt__WideDynamicRange(soap, NULL, NULL, "tt:WideDynamicRange");
	case SOAP_TYPE_tt__Exposure:
		return soap_in_tt__Exposure(soap, NULL, NULL, "tt:Exposure");
	case SOAP_TYPE_tt__ImagingSettingsExtension:
		return soap_in_tt__ImagingSettingsExtension(soap, NULL, NULL, "tt:ImagingSettingsExtension");
	case SOAP_TYPE_tt__ImagingSettings:
		return soap_in_tt__ImagingSettings(soap, NULL, NULL, "tt:ImagingSettings");
	case SOAP_TYPE_tt__FocusConfiguration:
		return soap_in_tt__FocusConfiguration(soap, NULL, NULL, "tt:FocusConfiguration");
	case SOAP_TYPE_tt__FocusStatus:
		return soap_in_tt__FocusStatus(soap, NULL, NULL, "tt:FocusStatus");
	case SOAP_TYPE_tt__ImagingStatus:
		return soap_in_tt__ImagingStatus(soap, NULL, NULL, "tt:ImagingStatus");
	case SOAP_TYPE_tt__PTZMoveStatus:
		return soap_in_tt__PTZMoveStatus(soap, NULL, NULL, "tt:PTZMoveStatus");
	case SOAP_TYPE_tt__PTZPreset:
		return soap_in_tt__PTZPreset(soap, NULL, NULL, "tt:PTZPreset");
	case SOAP_TYPE_tt__PTZStatus:
		return soap_in_tt__PTZStatus(soap, NULL, NULL, "tt:PTZStatus");
	case SOAP_TYPE_tt__PTZSpeed:
		return soap_in_tt__PTZSpeed(soap, NULL, NULL, "tt:PTZSpeed");
	case SOAP_TYPE_tt__PTZVector:
		return soap_in_tt__PTZVector(soap, NULL, NULL, "tt:PTZVector");
	case SOAP_TYPE_tt__Vector1D:
		return soap_in_tt__Vector1D(soap, NULL, NULL, "tt:Vector1D");
	case SOAP_TYPE_tt__Vector2D:
		return soap_in_tt__Vector2D(soap, NULL, NULL, "tt:Vector2D");
	case SOAP_TYPE_tt__Space1DDescription:
		return soap_in_tt__Space1DDescription(soap, NULL, NULL, "tt:Space1DDescription");
	case SOAP_TYPE_tt__Space2DDescription:
		return soap_in_tt__Space2DDescription(soap, NULL, NULL, "tt:Space2DDescription");
	case SOAP_TYPE_tt__PTZSpacesExtension:
		return soap_in_tt__PTZSpacesExtension(soap, NULL, NULL, "tt:PTZSpacesExtension");
	case SOAP_TYPE_tt__PTZSpaces:
		return soap_in_tt__PTZSpaces(soap, NULL, NULL, "tt:PTZSpaces");
	case SOAP_TYPE_tt__ZoomLimits:
		return soap_in_tt__ZoomLimits(soap, NULL, NULL, "tt:ZoomLimits");
	case SOAP_TYPE_tt__PanTiltLimits:
		return soap_in_tt__PanTiltLimits(soap, NULL, NULL, "tt:PanTiltLimits");
	case SOAP_TYPE_tt__PTZConfigurationOptions:
		return soap_in_tt__PTZConfigurationOptions(soap, NULL, NULL, "tt:PTZConfigurationOptions");
	case SOAP_TYPE_tt__PTZConfigurationExtension:
		return soap_in_tt__PTZConfigurationExtension(soap, NULL, NULL, "tt:PTZConfigurationExtension");
	case SOAP_TYPE_tt__PTZConfiguration:
		return soap_in_tt__PTZConfiguration(soap, NULL, NULL, "tt:PTZConfiguration");
	case SOAP_TYPE_tt__PTZNodeExtension:
		return soap_in_tt__PTZNodeExtension(soap, NULL, NULL, "tt:PTZNodeExtension");
	case SOAP_TYPE_tt__PTZNode:
		return soap_in_tt__PTZNode(soap, NULL, NULL, "tt:PTZNode");
	case SOAP_TYPE_tt__RelayOutput:
		return soap_in_tt__RelayOutput(soap, NULL, NULL, "tt:RelayOutput");
	case SOAP_TYPE_tt__RelayOutputSettings:
		return soap_in_tt__RelayOutputSettings(soap, NULL, NULL, "tt:RelayOutputSettings");
	case SOAP_TYPE_tt__CertificateStatus:
		return soap_in_tt__CertificateStatus(soap, NULL, NULL, "tt:CertificateStatus");
	case SOAP_TYPE_tt__Certificate:
		return soap_in_tt__Certificate(soap, NULL, NULL, "tt:Certificate");
	case SOAP_TYPE_tt__CertificateGenerationParametersExtension:
		return soap_in_tt__CertificateGenerationParametersExtension(soap, NULL, NULL, "tt:CertificateGenerationParametersExtension");
	case SOAP_TYPE_tt__CertificateGenerationParameters:
		return soap_in_tt__CertificateGenerationParameters(soap, NULL, NULL, "tt:CertificateGenerationParameters");
	case SOAP_TYPE_tt__UserExtension:
		return soap_in_tt__UserExtension(soap, NULL, NULL, "tt:UserExtension");
	case SOAP_TYPE_tt__User:
		return soap_in_tt__User(soap, NULL, NULL, "tt:User");
	case SOAP_TYPE_tt__TimeZone:
		return soap_in_tt__TimeZone(soap, NULL, NULL, "tt:TimeZone");
	case SOAP_TYPE_tt__Time:
		return soap_in_tt__Time(soap, NULL, NULL, "tt:Time");
	case SOAP_TYPE_tt__Date:
		return soap_in_tt__Date(soap, NULL, NULL, "tt:Date");
	case SOAP_TYPE_tt__DateTime:
		return soap_in_tt__DateTime(soap, NULL, NULL, "tt:DateTime");
	case SOAP_TYPE_tt__SystemDateTimeExtension:
		return soap_in_tt__SystemDateTimeExtension(soap, NULL, NULL, "tt:SystemDateTimeExtension");
	case SOAP_TYPE_tt__SystemDateTime:
		return soap_in_tt__SystemDateTime(soap, NULL, NULL, "tt:SystemDateTime");
	case SOAP_TYPE_tt__BackupFile:
		return soap_in_tt__BackupFile(soap, NULL, NULL, "tt:BackupFile");
	case SOAP_TYPE_tt__AttachmentData:
		return soap_in_tt__AttachmentData(soap, NULL, NULL, "tt:AttachmentData");
	case SOAP_TYPE_tt__BinaryData:
		return soap_in_tt__BinaryData(soap, NULL, NULL, "tt:BinaryData");
	case SOAP_TYPE_tt__SupportInformation:
		return soap_in_tt__SupportInformation(soap, NULL, NULL, "tt:SupportInformation");
	case SOAP_TYPE_tt__SystemLog:
		return soap_in_tt__SystemLog(soap, NULL, NULL, "tt:SystemLog");
	case SOAP_TYPE_tt__PTZCapabilities:
		return soap_in_tt__PTZCapabilities(soap, NULL, NULL, "tt:PTZCapabilities");
	case SOAP_TYPE_tt__ImagingCapabilities:
		return soap_in_tt__ImagingCapabilities(soap, NULL, NULL, "tt:ImagingCapabilities");
	case SOAP_TYPE_tt__OnvifVersion:
		return soap_in_tt__OnvifVersion(soap, NULL, NULL, "tt:OnvifVersion");
	case SOAP_TYPE_tt__SystemCapabilitiesExtension:
		return soap_in_tt__SystemCapabilitiesExtension(soap, NULL, NULL, "tt:SystemCapabilitiesExtension");
	case SOAP_TYPE_tt__SystemCapabilities:
		return soap_in_tt__SystemCapabilities(soap, NULL, NULL, "tt:SystemCapabilities");
	case SOAP_TYPE_tt__StorageCapabilities:
		return soap_in_tt__StorageCapabilities(soap, NULL, NULL, "tt:StorageCapabilities");
	case SOAP_TYPE_tt__SecurityCapabilitiesExtension:
		return soap_in_tt__SecurityCapabilitiesExtension(soap, NULL, NULL, "tt:SecurityCapabilitiesExtension");
	case SOAP_TYPE_tt__SecurityCapabilities:
		return soap_in_tt__SecurityCapabilities(soap, NULL, NULL, "tt:SecurityCapabilities");
	case SOAP_TYPE_tt__NetworkCapabilitiesExtension:
		return soap_in_tt__NetworkCapabilitiesExtension(soap, NULL, NULL, "tt:NetworkCapabilitiesExtension");
	case SOAP_TYPE_tt__NetworkCapabilities:
		return soap_in_tt__NetworkCapabilities(soap, NULL, NULL, "tt:NetworkCapabilities");
	case SOAP_TYPE_tt__ProfileCapabilities:
		return soap_in_tt__ProfileCapabilities(soap, NULL, NULL, "tt:ProfileCapabilities");
	case SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension:
		return soap_in_tt__RealTimeStreamingCapabilitiesExtension(soap, NULL, NULL, "tt:RealTimeStreamingCapabilitiesExtension");
	case SOAP_TYPE_tt__RealTimeStreamingCapabilities:
		return soap_in_tt__RealTimeStreamingCapabilities(soap, NULL, NULL, "tt:RealTimeStreamingCapabilities");
	case SOAP_TYPE_tt__MediaCapabilitiesExtension:
		return soap_in_tt__MediaCapabilitiesExtension(soap, NULL, NULL, "tt:MediaCapabilitiesExtension");
	case SOAP_TYPE_tt__MediaCapabilities:
		return soap_in_tt__MediaCapabilities(soap, NULL, NULL, "tt:MediaCapabilities");
	case SOAP_TYPE_tt__IOCapabilitiesExtension:
		return soap_in_tt__IOCapabilitiesExtension(soap, NULL, NULL, "tt:IOCapabilitiesExtension");
	case SOAP_TYPE_tt__IOCapabilities:
		return soap_in_tt__IOCapabilities(soap, NULL, NULL, "tt:IOCapabilities");
	case SOAP_TYPE_tt__EventCapabilities:
		return soap_in_tt__EventCapabilities(soap, NULL, NULL, "tt:EventCapabilities");
	case SOAP_TYPE_tt__DeviceCapabilitiesExtension:
		return soap_in_tt__DeviceCapabilitiesExtension(soap, NULL, NULL, "tt:DeviceCapabilitiesExtension");
	case SOAP_TYPE_tt__DeviceCapabilities:
		return soap_in_tt__DeviceCapabilities(soap, NULL, NULL, "tt:DeviceCapabilities");
	case SOAP_TYPE_tt__AnalyticsCapabilities:
		return soap_in_tt__AnalyticsCapabilities(soap, NULL, NULL, "tt:AnalyticsCapabilities");
	case SOAP_TYPE_tt__CapabilitiesExtension:
		return soap_in_tt__CapabilitiesExtension(soap, NULL, NULL, "tt:CapabilitiesExtension");
	case SOAP_TYPE_tt__Capabilities:
		return soap_in_tt__Capabilities(soap, NULL, NULL, "tt:Capabilities");
	case SOAP_TYPE_tt__IPAddressFilterExtension:
		return soap_in_tt__IPAddressFilterExtension(soap, NULL, NULL, "tt:IPAddressFilterExtension");
	case SOAP_TYPE_tt__IPAddressFilter:
		return soap_in_tt__IPAddressFilter(soap, NULL, NULL, "tt:IPAddressFilter");
	case SOAP_TYPE_tt__NetworkZeroConfigurationExtension:
		return soap_in_tt__NetworkZeroConfigurationExtension(soap, NULL, NULL, "tt:NetworkZeroConfigurationExtension");
	case SOAP_TYPE_tt__NetworkZeroConfiguration:
		return soap_in_tt__NetworkZeroConfiguration(soap, NULL, NULL, "tt:NetworkZeroConfiguration");
	case SOAP_TYPE_tt__NetworkGateway:
		return soap_in_tt__NetworkGateway(soap, NULL, NULL, "tt:NetworkGateway");
	case SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration:
		return soap_in_tt__IPv4NetworkInterfaceSetConfiguration(soap, NULL, NULL, "tt:IPv4NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration:
		return soap_in_tt__IPv6NetworkInterfaceSetConfiguration(soap, NULL, NULL, "tt:IPv6NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension:
		return soap_in_tt__NetworkInterfaceSetConfigurationExtension(soap, NULL, NULL, "tt:NetworkInterfaceSetConfigurationExtension");
	case SOAP_TYPE_tt__NetworkInterfaceSetConfiguration:
		return soap_in_tt__NetworkInterfaceSetConfiguration(soap, NULL, NULL, "tt:NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_tt__DynamicDNSInformationExtension:
		return soap_in_tt__DynamicDNSInformationExtension(soap, NULL, NULL, "tt:DynamicDNSInformationExtension");
	case SOAP_TYPE_tt__DynamicDNSInformation:
		return soap_in_tt__DynamicDNSInformation(soap, NULL, NULL, "tt:DynamicDNSInformation");
	case SOAP_TYPE_tt__NTPInformationExtension:
		return soap_in_tt__NTPInformationExtension(soap, NULL, NULL, "tt:NTPInformationExtension");
	case SOAP_TYPE_tt__NTPInformation:
		return soap_in_tt__NTPInformation(soap, NULL, NULL, "tt:NTPInformation");
	case SOAP_TYPE_tt__DNSInformationExtension:
		return soap_in_tt__DNSInformationExtension(soap, NULL, NULL, "tt:DNSInformationExtension");
	case SOAP_TYPE_tt__DNSInformation:
		return soap_in_tt__DNSInformation(soap, NULL, NULL, "tt:DNSInformation");
	case SOAP_TYPE_tt__HostnameInformationExtension:
		return soap_in_tt__HostnameInformationExtension(soap, NULL, NULL, "tt:HostnameInformationExtension");
	case SOAP_TYPE_tt__HostnameInformation:
		return soap_in_tt__HostnameInformation(soap, NULL, NULL, "tt:HostnameInformation");
	case SOAP_TYPE_tt__PrefixedIPv6Address:
		return soap_in_tt__PrefixedIPv6Address(soap, NULL, NULL, "tt:PrefixedIPv6Address");
	case SOAP_TYPE_tt__PrefixedIPv4Address:
		return soap_in_tt__PrefixedIPv4Address(soap, NULL, NULL, "tt:PrefixedIPv4Address");
	case SOAP_TYPE_tt__IPAddress:
		return soap_in_tt__IPAddress(soap, NULL, NULL, "tt:IPAddress");
	case SOAP_TYPE_tt__NetworkHostExtension:
		return soap_in_tt__NetworkHostExtension(soap, NULL, NULL, "tt:NetworkHostExtension");
	case SOAP_TYPE_tt__NetworkHost:
		return soap_in_tt__NetworkHost(soap, NULL, NULL, "tt:NetworkHost");
	case SOAP_TYPE_tt__NetworkProtocolExtension:
		return soap_in_tt__NetworkProtocolExtension(soap, NULL, NULL, "tt:NetworkProtocolExtension");
	case SOAP_TYPE_tt__NetworkProtocol:
		return soap_in_tt__NetworkProtocol(soap, NULL, NULL, "tt:NetworkProtocol");
	case SOAP_TYPE_tt__IPv6ConfigurationExtension:
		return soap_in_tt__IPv6ConfigurationExtension(soap, NULL, NULL, "tt:IPv6ConfigurationExtension");
	case SOAP_TYPE_tt__IPv6Configuration:
		return soap_in_tt__IPv6Configuration(soap, NULL, NULL, "tt:IPv6Configuration");
	case SOAP_TYPE_tt__IPv4Configuration:
		return soap_in_tt__IPv4Configuration(soap, NULL, NULL, "tt:IPv4Configuration");
	case SOAP_TYPE_tt__IPv4NetworkInterface:
		return soap_in_tt__IPv4NetworkInterface(soap, NULL, NULL, "tt:IPv4NetworkInterface");
	case SOAP_TYPE_tt__IPv6NetworkInterface:
		return soap_in_tt__IPv6NetworkInterface(soap, NULL, NULL, "tt:IPv6NetworkInterface");
	case SOAP_TYPE_tt__NetworkInterfaceInfo:
		return soap_in_tt__NetworkInterfaceInfo(soap, NULL, NULL, "tt:NetworkInterfaceInfo");
	case SOAP_TYPE_tt__NetworkInterfaceConnectionSetting:
		return soap_in_tt__NetworkInterfaceConnectionSetting(soap, NULL, NULL, "tt:NetworkInterfaceConnectionSetting");
	case SOAP_TYPE_tt__NetworkInterfaceLink:
		return soap_in_tt__NetworkInterfaceLink(soap, NULL, NULL, "tt:NetworkInterfaceLink");
	case SOAP_TYPE_tt__NetworkInterfaceExtension:
		return soap_in_tt__NetworkInterfaceExtension(soap, NULL, NULL, "tt:NetworkInterfaceExtension");
	case SOAP_TYPE_tt__NetworkInterface:
		return soap_in_tt__NetworkInterface(soap, NULL, NULL, "tt:NetworkInterface");
	case SOAP_TYPE_tt__Scope:
		return soap_in_tt__Scope(soap, NULL, NULL, "tt:Scope");
	case SOAP_TYPE_tt__MediaUri:
		return soap_in_tt__MediaUri(soap, NULL, NULL, "tt:MediaUri");
	case SOAP_TYPE_tt__Transport:
		return soap_in_tt__Transport(soap, NULL, NULL, "tt:Transport");
	case SOAP_TYPE_tt__StreamSetup:
		return soap_in_tt__StreamSetup(soap, NULL, NULL, "tt:StreamSetup");
	case SOAP_TYPE_tt__MulticastConfiguration:
		return soap_in_tt__MulticastConfiguration(soap, NULL, NULL, "tt:MulticastConfiguration");
	case SOAP_TYPE_tt__PTZStatusFilterOptions:
		return soap_in_tt__PTZStatusFilterOptions(soap, NULL, NULL, "tt:PTZStatusFilterOptions");
	case SOAP_TYPE_tt__MetadataConfigurationOptions:
		return soap_in_tt__MetadataConfigurationOptions(soap, NULL, NULL, "tt:MetadataConfigurationOptions");
	case SOAP_TYPE_tt__EventSubscription:
		return soap_in_tt__EventSubscription(soap, NULL, NULL, "tt:EventSubscription");
	case SOAP_TYPE_tt__PTZFilter:
		return soap_in_tt__PTZFilter(soap, NULL, NULL, "tt:PTZFilter");
	case SOAP_TYPE_tt__MetadataConfiguration:
		return soap_in_tt__MetadataConfiguration(soap, NULL, NULL, "tt:MetadataConfiguration");
	case SOAP_TYPE_tt__VideoAnalyticsConfiguration:
		return soap_in_tt__VideoAnalyticsConfiguration(soap, NULL, NULL, "tt:VideoAnalyticsConfiguration");
	case SOAP_TYPE_tt__AudioEncoderConfigurationOption:
		return soap_in_tt__AudioEncoderConfigurationOption(soap, NULL, NULL, "tt:AudioEncoderConfigurationOption");
	case SOAP_TYPE_tt__AudioEncoderConfigurationOptions:
		return soap_in_tt__AudioEncoderConfigurationOptions(soap, NULL, NULL, "tt:AudioEncoderConfigurationOptions");
	case SOAP_TYPE_tt__AudioEncoderConfiguration:
		return soap_in_tt__AudioEncoderConfiguration(soap, NULL, NULL, "tt:AudioEncoderConfiguration");
	case SOAP_TYPE_tt__AudioSourceOptionsExtension:
		return soap_in_tt__AudioSourceOptionsExtension(soap, NULL, NULL, "tt:AudioSourceOptionsExtension");
	case SOAP_TYPE_tt__AudioSourceConfigurationOptions:
		return soap_in_tt__AudioSourceConfigurationOptions(soap, NULL, NULL, "tt:AudioSourceConfigurationOptions");
	case SOAP_TYPE_tt__AudioSourceConfiguration:
		return soap_in_tt__AudioSourceConfiguration(soap, NULL, NULL, "tt:AudioSourceConfiguration");
	case SOAP_TYPE_tt__H264Options:
		return soap_in_tt__H264Options(soap, NULL, NULL, "tt:H264Options");
	case SOAP_TYPE_tt__Mpeg4Options:
		return soap_in_tt__Mpeg4Options(soap, NULL, NULL, "tt:Mpeg4Options");
	case SOAP_TYPE_tt__JpegOptions:
		return soap_in_tt__JpegOptions(soap, NULL, NULL, "tt:JpegOptions");
	case SOAP_TYPE_tt__VideoEncoderOptionsExtension:
		return soap_in_tt__VideoEncoderOptionsExtension(soap, NULL, NULL, "tt:VideoEncoderOptionsExtension");
	case SOAP_TYPE_tt__VideoEncoderConfigurationOptions:
		return soap_in_tt__VideoEncoderConfigurationOptions(soap, NULL, NULL, "tt:VideoEncoderConfigurationOptions");
	case SOAP_TYPE_tt__H264Configuration:
		return soap_in_tt__H264Configuration(soap, NULL, NULL, "tt:H264Configuration");
	case SOAP_TYPE_tt__Mpeg4Configuration:
		return soap_in_tt__Mpeg4Configuration(soap, NULL, NULL, "tt:Mpeg4Configuration");
	case SOAP_TYPE_tt__VideoRateControl:
		return soap_in_tt__VideoRateControl(soap, NULL, NULL, "tt:VideoRateControl");
	case SOAP_TYPE_tt__VideoResolution:
		return soap_in_tt__VideoResolution(soap, NULL, NULL, "tt:VideoResolution");
	case SOAP_TYPE_tt__VideoEncoderConfiguration:
		return soap_in_tt__VideoEncoderConfiguration(soap, NULL, NULL, "tt:VideoEncoderConfiguration");
	case SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension:
		return soap_in_tt__VideoSourceConfigurationOptionsExtension(soap, NULL, NULL, "tt:VideoSourceConfigurationOptionsExtension");
	case SOAP_TYPE_tt__VideoSourceConfigurationOptions:
		return soap_in_tt__VideoSourceConfigurationOptions(soap, NULL, NULL, "tt:VideoSourceConfigurationOptions");
	case SOAP_TYPE_tt__VideoSourceConfiguration:
		return soap_in_tt__VideoSourceConfiguration(soap, NULL, NULL, "tt:VideoSourceConfiguration");
	case SOAP_TYPE_tt__ConfigurationEntity:
		return soap_in_tt__ConfigurationEntity(soap, NULL, NULL, "tt:ConfigurationEntity");
	case SOAP_TYPE_tt__ProfileExtension:
		return soap_in_tt__ProfileExtension(soap, NULL, NULL, "tt:ProfileExtension");
	case SOAP_TYPE_tt__Profile:
		return soap_in_tt__Profile(soap, NULL, NULL, "tt:Profile");
	case SOAP_TYPE_tt__AudioSource:
		return soap_in_tt__AudioSource(soap, NULL, NULL, "tt:AudioSource");
	case SOAP_TYPE_tt__VideoSourceExtension:
		return soap_in_tt__VideoSourceExtension(soap, NULL, NULL, "tt:VideoSourceExtension");
	case SOAP_TYPE_tt__VideoSource:
		return soap_in_tt__VideoSource(soap, NULL, NULL, "tt:VideoSource");
	case SOAP_TYPE_tt__IntList:
		return soap_in_tt__IntList(soap, NULL, NULL, "tt:IntList");
	case SOAP_TYPE_tt__DurationRange:
		return soap_in_tt__DurationRange(soap, NULL, NULL, "tt:DurationRange");
	case SOAP_TYPE_tt__FloatRange:
		return soap_in_tt__FloatRange(soap, NULL, NULL, "tt:FloatRange");
	case SOAP_TYPE_tt__IntRange:
		return soap_in_tt__IntRange(soap, NULL, NULL, "tt:IntRange");
	case SOAP_TYPE_tt__IntRectangleRange:
		return soap_in_tt__IntRectangleRange(soap, NULL, NULL, "tt:IntRectangleRange");
	case SOAP_TYPE_tt__IntRectangle:
		return soap_in_tt__IntRectangle(soap, NULL, NULL, "tt:IntRectangle");
	case SOAP_TYPE_tt__DeviceEntity:
		return soap_in_tt__DeviceEntity(soap, NULL, NULL, "tt:DeviceEntity");
	case SOAP_TYPE_xsd__token:
		return soap_in_xsd__token(soap, NULL, NULL, "xsd:token");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__integer:
		return soap_in_xsd__integer(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__anySimpleType:
		return soap_in_xsd__anySimpleType(soap, NULL, NULL, "xsd:anySimpleType");
	case SOAP_TYPE_xsd__QName:
		return soap_in_xsd__QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_xsd__NCName:
		return soap_in_xsd__NCName(soap, NULL, NULL, "xsd:NCName");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ds__RSAKeyValueType:
		return soap_in_ds__RSAKeyValueType(soap, NULL, NULL, "ds:RSAKeyValueType");
	case SOAP_TYPE_ds__DSAKeyValueType:
		return soap_in_ds__DSAKeyValueType(soap, NULL, NULL, "ds:DSAKeyValueType");
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return soap_in_ds__X509IssuerSerialType(soap, NULL, NULL, "ds:X509IssuerSerialType");
	case SOAP_TYPE_ds__X509DataType:
		return soap_in_ds__X509DataType(soap, NULL, NULL, "ds:X509DataType");
	case SOAP_TYPE_ds__RetrievalMethodType:
		return soap_in_ds__RetrievalMethodType(soap, NULL, NULL, "ds:RetrievalMethodType");
	case SOAP_TYPE_ds__KeyValueType:
		return soap_in_ds__KeyValueType(soap, NULL, NULL, "ds:KeyValueType");
	case SOAP_TYPE_ds__DigestMethodType:
		return soap_in_ds__DigestMethodType(soap, NULL, NULL, "ds:DigestMethodType");
	case SOAP_TYPE_ds__TransformType:
		return soap_in_ds__TransformType(soap, NULL, NULL, "ds:TransformType");
	case SOAP_TYPE_ds__TransformsType:
		return soap_in_ds__TransformsType(soap, NULL, NULL, "ds:TransformsType");
	case SOAP_TYPE_ds__ReferenceType:
		return soap_in_ds__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_ds__SignatureMethodType:
		return soap_in_ds__SignatureMethodType(soap, NULL, NULL, "ds:SignatureMethodType");
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return soap_in_ds__CanonicalizationMethodType(soap, NULL, NULL, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_ds__KeyInfoType:
		return soap_in_ds__KeyInfoType(soap, NULL, NULL, "ds:KeyInfoType");
	case SOAP_TYPE_ds__SignedInfoType:
		return soap_in_ds__SignedInfoType(soap, NULL, NULL, "ds:SignedInfoType");
	case SOAP_TYPE_ds__SignatureType:
		return soap_in_ds__SignatureType(soap, NULL, NULL, "ds:SignatureType");
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_in_wsa5__ProblemActionType(soap, NULL, NULL, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_in_wsa5__RelatesToType(soap, NULL, NULL, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_in_wsa5__MetadataType(soap, NULL, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_in_wsa5__ReferenceParametersType(soap, NULL, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_in_wsa5__EndpointReferenceType(soap, NULL, NULL, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_xsd__anyAttribute:
		return soap_in_xsd__anyAttribute(soap, NULL, NULL, "xsd:anyAttribute");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerTo_tan__ModifyAnalyticsModulesResponse:
		return soap_in_PointerTo_tan__ModifyAnalyticsModulesResponse(soap, NULL, NULL, "tan:ModifyAnalyticsModulesResponse");
	case SOAP_TYPE_PointerTo_tan__ModifyAnalyticsModules:
		return soap_in_PointerTo_tan__ModifyAnalyticsModules(soap, NULL, NULL, "tan:ModifyAnalyticsModules");
	case SOAP_TYPE_PointerTo_tan__GetAnalyticsModulesResponse:
		return soap_in_PointerTo_tan__GetAnalyticsModulesResponse(soap, NULL, NULL, "tan:GetAnalyticsModulesResponse");
	case SOAP_TYPE_PointerTo_tan__GetAnalyticsModules:
		return soap_in_PointerTo_tan__GetAnalyticsModules(soap, NULL, NULL, "tan:GetAnalyticsModules");
	case SOAP_TYPE_PointerTo_tan__DeleteAnalyticsModulesResponse:
		return soap_in_PointerTo_tan__DeleteAnalyticsModulesResponse(soap, NULL, NULL, "tan:DeleteAnalyticsModulesResponse");
	case SOAP_TYPE_PointerTo_tan__DeleteAnalyticsModules:
		return soap_in_PointerTo_tan__DeleteAnalyticsModules(soap, NULL, NULL, "tan:DeleteAnalyticsModules");
	case SOAP_TYPE_PointerTo_tan__CreateAnalyticsModulesResponse:
		return soap_in_PointerTo_tan__CreateAnalyticsModulesResponse(soap, NULL, NULL, "tan:CreateAnalyticsModulesResponse");
	case SOAP_TYPE_PointerTo_tan__CreateAnalyticsModules:
		return soap_in_PointerTo_tan__CreateAnalyticsModules(soap, NULL, NULL, "tan:CreateAnalyticsModules");
	case SOAP_TYPE_PointerTo_tan__GetSupportedAnalyticsModulesResponse:
		return soap_in_PointerTo_tan__GetSupportedAnalyticsModulesResponse(soap, NULL, NULL, "tan:GetSupportedAnalyticsModulesResponse");
	case SOAP_TYPE_PointerTo_tan__GetSupportedAnalyticsModules:
		return soap_in_PointerTo_tan__GetSupportedAnalyticsModules(soap, NULL, NULL, "tan:GetSupportedAnalyticsModules");
	case SOAP_TYPE_PointerTo_tan__ModifyRulesResponse:
		return soap_in_PointerTo_tan__ModifyRulesResponse(soap, NULL, NULL, "tan:ModifyRulesResponse");
	case SOAP_TYPE_PointerTo_tan__ModifyRules:
		return soap_in_PointerTo_tan__ModifyRules(soap, NULL, NULL, "tan:ModifyRules");
	case SOAP_TYPE_PointerTo_tan__GetRulesResponse:
		return soap_in_PointerTo_tan__GetRulesResponse(soap, NULL, NULL, "tan:GetRulesResponse");
	case SOAP_TYPE_PointerTo_tan__GetRules:
		return soap_in_PointerTo_tan__GetRules(soap, NULL, NULL, "tan:GetRules");
	case SOAP_TYPE_PointerTo_tan__DeleteRulesResponse:
		return soap_in_PointerTo_tan__DeleteRulesResponse(soap, NULL, NULL, "tan:DeleteRulesResponse");
	case SOAP_TYPE_PointerTo_tan__DeleteRules:
		return soap_in_PointerTo_tan__DeleteRules(soap, NULL, NULL, "tan:DeleteRules");
	case SOAP_TYPE_PointerTo_tan__CreateRulesResponse:
		return soap_in_PointerTo_tan__CreateRulesResponse(soap, NULL, NULL, "tan:CreateRulesResponse");
	case SOAP_TYPE_PointerTo_tan__CreateRules:
		return soap_in_PointerTo_tan__CreateRules(soap, NULL, NULL, "tan:CreateRules");
	case SOAP_TYPE_PointerTo_tan__GetSupportedRulesResponse:
		return soap_in_PointerTo_tan__GetSupportedRulesResponse(soap, NULL, NULL, "tan:GetSupportedRulesResponse");
	case SOAP_TYPE_PointerTo_tan__GetSupportedRules:
		return soap_in_PointerTo_tan__GetSupportedRules(soap, NULL, NULL, "tan:GetSupportedRules");
	case SOAP_TYPE_PointerToxsd__NCName:
		return soap_in_PointerToxsd__NCName(soap, NULL, NULL, "xsd:NCName");
	case SOAP_TYPE_PointerTo_wstop__TopicNamespaceType_Topic:
		return soap_in_PointerTo_wstop__TopicNamespaceType_Topic(soap, NULL, NULL, "wstop:TopicNamespaceType-Topic");
	case SOAP_TYPE_PointerTowstop__ConcreteTopicExpression:
		return soap_in_PointerTowstop__ConcreteTopicExpression(soap, NULL, NULL, "wstop:ConcreteTopicExpression");
	case SOAP_TYPE_PointerTowstop__TopicType:
		return soap_in_PointerTowstop__TopicType(soap, NULL, NULL, "wstop:TopicType");
	case SOAP_TYPE_PointerTowstop__QueryExpressionType:
		return soap_in_PointerTowstop__QueryExpressionType(soap, NULL, NULL, "wstop:QueryExpressionType");
	case SOAP_TYPE_PointerTott__ObjectExtension:
		return soap_in_PointerTott__ObjectExtension(soap, NULL, NULL, "tt:ObjectExtension");
	case SOAP_TYPE_PointerTott__Behaviour:
		return soap_in_PointerTott__Behaviour(soap, NULL, NULL, "tt:Behaviour");
	case SOAP_TYPE_PointerTott__Appearance:
		return soap_in_PointerTott__Appearance(soap, NULL, NULL, "tt:Appearance");
	case SOAP_TYPE_PointerTott__PTZConfigurationExtension:
		return soap_in_PointerTott__PTZConfigurationExtension(soap, NULL, NULL, "tt:PTZConfigurationExtension");
	case SOAP_TYPE_PointerTott__ZoomLimits:
		return soap_in_PointerTott__ZoomLimits(soap, NULL, NULL, "tt:ZoomLimits");
	case SOAP_TYPE_PointerTott__PanTiltLimits:
		return soap_in_PointerTott__PanTiltLimits(soap, NULL, NULL, "tt:PanTiltLimits");
	case SOAP_TYPE_PointerTott__PTZSpeed:
		return soap_in_PointerTott__PTZSpeed(soap, NULL, NULL, "tt:PTZSpeed");
	case SOAP_TYPE_PointerTott__PTZNodeExtension:
		return soap_in_PointerTott__PTZNodeExtension(soap, NULL, NULL, "tt:PTZNodeExtension");
	case SOAP_TYPE_PointerTott__RelayOutputSettings:
		return soap_in_PointerTott__RelayOutputSettings(soap, NULL, NULL, "tt:RelayOutputSettings");
	case SOAP_TYPE_PointerTott__NetworkInterfaceExtension:
		return soap_in_PointerTott__NetworkInterfaceExtension(soap, NULL, NULL, "tt:NetworkInterfaceExtension");
	case SOAP_TYPE_PointerTott__IPv6NetworkInterface:
		return soap_in_PointerTott__IPv6NetworkInterface(soap, NULL, NULL, "tt:IPv6NetworkInterface");
	case SOAP_TYPE_PointerTott__IPv4NetworkInterface:
		return soap_in_PointerTott__IPv4NetworkInterface(soap, NULL, NULL, "tt:IPv4NetworkInterface");
	case SOAP_TYPE_PointerTott__NetworkInterfaceLink:
		return soap_in_PointerTott__NetworkInterfaceLink(soap, NULL, NULL, "tt:NetworkInterfaceLink");
	case SOAP_TYPE_PointerTott__NetworkInterfaceInfo:
		return soap_in_PointerTott__NetworkInterfaceInfo(soap, NULL, NULL, "tt:NetworkInterfaceInfo");
	case SOAP_TYPE_PointerTott__EventSubscription:
		return soap_in_PointerTott__EventSubscription(soap, NULL, NULL, "tt:EventSubscription");
	case SOAP_TYPE_PointerTott__PTZFilter:
		return soap_in_PointerTott__PTZFilter(soap, NULL, NULL, "tt:PTZFilter");
	case SOAP_TYPE_PointerTott__RuleEngineConfiguration:
		return soap_in_PointerTott__RuleEngineConfiguration(soap, NULL, NULL, "tt:RuleEngineConfiguration");
	case SOAP_TYPE_PointerTott__AnalyticsEngineConfiguration:
		return soap_in_PointerTott__AnalyticsEngineConfiguration(soap, NULL, NULL, "tt:AnalyticsEngineConfiguration");
	case SOAP_TYPE_PointerTott__MulticastConfiguration:
		return soap_in_PointerTott__MulticastConfiguration(soap, NULL, NULL, "tt:MulticastConfiguration");
	case SOAP_TYPE_PointerTott__H264Configuration:
		return soap_in_PointerTott__H264Configuration(soap, NULL, NULL, "tt:H264Configuration");
	case SOAP_TYPE_PointerTott__Mpeg4Configuration:
		return soap_in_PointerTott__Mpeg4Configuration(soap, NULL, NULL, "tt:Mpeg4Configuration");
	case SOAP_TYPE_PointerTott__VideoRateControl:
		return soap_in_PointerTott__VideoRateControl(soap, NULL, NULL, "tt:VideoRateControl");
	case SOAP_TYPE_PointerTott__IntRectangle:
		return soap_in_PointerTott__IntRectangle(soap, NULL, NULL, "tt:IntRectangle");
	case SOAP_TYPE_PointerTott__VideoSourceExtension:
		return soap_in_PointerTott__VideoSourceExtension(soap, NULL, NULL, "tt:VideoSourceExtension");
	case SOAP_TYPE_PointerTott__ImagingSettings:
		return soap_in_PointerTott__ImagingSettings(soap, NULL, NULL, "tt:ImagingSettings");
	case SOAP_TYPE_PointerTowstop__Documentation:
		return soap_in_PointerTowstop__Documentation(soap, NULL, NULL, "wstop:Documentation");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause:
		return soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, NULL, NULL, "wsrfbf:BaseFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_Description:
		return soap_in_PointerTo_wsrfbf__BaseFaultType_Description(soap, NULL, NULL, "wsrfbf:BaseFaultType-Description");
	case SOAP_TYPE_PointerTo_xml__lang:
		return soap_in_PointerTo_xml__lang(soap, NULL, NULL, "xml:lang");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode:
		return soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, NULL, NULL, "wsrfbf:BaseFaultType-ErrorCode");
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		return soap_in_PointerToxsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_PointerTo_wsnb__Subscribe_SubscriptionPolicy:
		return soap_in_PointerTo_wsnb__Subscribe_SubscriptionPolicy(soap, NULL, NULL, "wsnb:Subscribe-SubscriptionPolicy");
	case SOAP_TYPE_PointerTowsnb__AbsoluteOrRelativeTimeType:
		return soap_in_PointerTowsnb__AbsoluteOrRelativeTimeType(soap, NULL, NULL, "wsnb:AbsoluteOrRelativeTimeType");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTowsnb__SubscriptionPolicyType:
		return soap_in_PointerTowsnb__SubscriptionPolicyType(soap, NULL, NULL, "wsnb:SubscriptionPolicyType");
	case SOAP_TYPE_PointerTowstop__TopicSetType:
		return soap_in_PointerTowstop__TopicSetType(soap, NULL, NULL, "wstop:TopicSetType");
	case SOAP_TYPE_PointerTowsnb__TopicExpressionType:
		return soap_in_PointerTowsnb__TopicExpressionType(soap, NULL, NULL, "wsnb:TopicExpressionType");
	case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
		return soap_in_PointerTowsa5__EndpointReferenceType(soap, NULL, NULL, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTott__PropertyOperation:
		return soap_in_PointerTott__PropertyOperation(soap, NULL, NULL, "tt:PropertyOperation");
	case SOAP_TYPE_PointerTott__MessageExtension:
		return soap_in_PointerTott__MessageExtension(soap, NULL, NULL, "tt:MessageExtension");
	case SOAP_TYPE_PointerTott__EventStreamExtension:
		return soap_in_PointerTott__EventStreamExtension(soap, NULL, NULL, "tt:EventStreamExtension");
	case SOAP_TYPE_PointerTowsnb__NotificationMessageHolderType:
		return soap_in_PointerTowsnb__NotificationMessageHolderType(soap, NULL, NULL, "wsnb:NotificationMessageHolderType");
	case SOAP_TYPE_PointerTott__PTZStreamExtension:
		return soap_in_PointerTott__PTZStreamExtension(soap, NULL, NULL, "tt:PTZStreamExtension");
	case SOAP_TYPE_PointerTott__VideoAnalyticsStreamExtension:
		return soap_in_PointerTott__VideoAnalyticsStreamExtension(soap, NULL, NULL, "tt:VideoAnalyticsStreamExtension");
	case SOAP_TYPE_PointerTott__Frame:
		return soap_in_PointerTott__Frame(soap, NULL, NULL, "tt:Frame");
	case SOAP_TYPE_PointerTott__MetadataStreamExtension:
		return soap_in_PointerTott__MetadataStreamExtension(soap, NULL, NULL, "tt:MetadataStreamExtension");
	case SOAP_TYPE_PointerTott__EventStream:
		return soap_in_PointerTott__EventStream(soap, NULL, NULL, "tt:EventStream");
	case SOAP_TYPE_PointerTott__PTZStream:
		return soap_in_PointerTott__PTZStream(soap, NULL, NULL, "tt:PTZStream");
	case SOAP_TYPE_PointerTott__VideoAnalyticsStream:
		return soap_in_PointerTott__VideoAnalyticsStream(soap, NULL, NULL, "tt:VideoAnalyticsStream");
	case SOAP_TYPE_PointerTott__SupportedAnalyticsModulesExtension:
		return soap_in_PointerTott__SupportedAnalyticsModulesExtension(soap, NULL, NULL, "tt:SupportedAnalyticsModulesExtension");
	case SOAP_TYPE_PointerTott__SupportedRulesExtension:
		return soap_in_PointerTott__SupportedRulesExtension(soap, NULL, NULL, "tt:SupportedRulesExtension");
	case SOAP_TYPE_PointerTott__ConfigDescription:
		return soap_in_PointerTott__ConfigDescription(soap, NULL, NULL, "tt:ConfigDescription");
	case SOAP_TYPE_PointerTott__ConfigDescriptionExtension:
		return soap_in_PointerTott__ConfigDescriptionExtension(soap, NULL, NULL, "tt:ConfigDescriptionExtension");
	case SOAP_TYPE_PointerTo_tt__ConfigDescription_Messages:
		return soap_in_PointerTo_tt__ConfigDescription_Messages(soap, NULL, NULL, "tt:ConfigDescription-Messages");
	case SOAP_TYPE_PointerTott__ItemList:
		return soap_in_PointerTott__ItemList(soap, NULL, NULL, "tt:ItemList");
	case SOAP_TYPE_PointerTott__RuleEngineConfigurationExtension:
		return soap_in_PointerTott__RuleEngineConfigurationExtension(soap, NULL, NULL, "tt:RuleEngineConfigurationExtension");
	case SOAP_TYPE_PointerTott__AnalyticsEngineConfigurationExtension:
		return soap_in_PointerTott__AnalyticsEngineConfigurationExtension(soap, NULL, NULL, "tt:AnalyticsEngineConfigurationExtension");
	case SOAP_TYPE_PointerTott__ObjectTreeExtension:
		return soap_in_PointerTott__ObjectTreeExtension(soap, NULL, NULL, "tt:ObjectTreeExtension");
	case SOAP_TYPE_PointerTott__Merge:
		return soap_in_PointerTott__Merge(soap, NULL, NULL, "tt:Merge");
	case SOAP_TYPE_PointerTott__Split:
		return soap_in_PointerTott__Split(soap, NULL, NULL, "tt:Split");
	case SOAP_TYPE_PointerTott__Rename:
		return soap_in_PointerTott__Rename(soap, NULL, NULL, "tt:Rename");
	case SOAP_TYPE_PointerTott__BehaviourExtension:
		return soap_in_PointerTott__BehaviourExtension(soap, NULL, NULL, "tt:BehaviourExtension");
	case SOAP_TYPE_PointerTo_tt__Behaviour_Idle:
		return soap_in_PointerTo_tt__Behaviour_Idle(soap, NULL, NULL, "tt:Behaviour-Idle");
	case SOAP_TYPE_PointerTo_tt__Behaviour_Removed:
		return soap_in_PointerTo_tt__Behaviour_Removed(soap, NULL, NULL, "tt:Behaviour-Removed");
	case SOAP_TYPE_PointerToxsd__integer:
		return soap_in_PointerToxsd__integer(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_PointerTott__ObjectId:
		return soap_in_PointerTott__ObjectId(soap, NULL, NULL, "tt:ObjectId");
	case SOAP_TYPE_PointerTott__FrameExtension:
		return soap_in_PointerTott__FrameExtension(soap, NULL, NULL, "tt:FrameExtension");
	case SOAP_TYPE_PointerTott__ObjectTree:
		return soap_in_PointerTott__ObjectTree(soap, NULL, NULL, "tt:ObjectTree");
	case SOAP_TYPE_PointerTott__Object:
		return soap_in_PointerTott__Object(soap, NULL, NULL, "tt:Object");
	case SOAP_TYPE_PointerTott__PTZStatus:
		return soap_in_PointerTott__PTZStatus(soap, NULL, NULL, "tt:PTZStatus");
	case SOAP_TYPE_PointerTott__TransformationExtension:
		return soap_in_PointerTott__TransformationExtension(soap, NULL, NULL, "tt:TransformationExtension");
	case SOAP_TYPE_PointerTott__ClassDescriptorExtension:
		return soap_in_PointerTott__ClassDescriptorExtension(soap, NULL, NULL, "tt:ClassDescriptorExtension");
	case SOAP_TYPE_PointerTo_tt__ClassDescriptor_ClassCandidate:
		return soap_in_PointerTo_tt__ClassDescriptor_ClassCandidate(soap, NULL, NULL, "tt:ClassDescriptor-ClassCandidate");
	case SOAP_TYPE_PointerTott__ColorDescriptorExtension:
		return soap_in_PointerTott__ColorDescriptorExtension(soap, NULL, NULL, "tt:ColorDescriptorExtension");
	case SOAP_TYPE_PointerTo_tt__ColorDescriptor_ColorCluster:
		return soap_in_PointerTo_tt__ColorDescriptor_ColorCluster(soap, NULL, NULL, "tt:ColorDescriptor-ColorCluster");
	case SOAP_TYPE_PointerTott__ColorCovariance:
		return soap_in_PointerTott__ColorCovariance(soap, NULL, NULL, "tt:ColorCovariance");
	case SOAP_TYPE_PointerTott__Color:
		return soap_in_PointerTott__Color(soap, NULL, NULL, "tt:Color");
	case SOAP_TYPE_PointerTott__ShapeDescriptorExtension:
		return soap_in_PointerTott__ShapeDescriptorExtension(soap, NULL, NULL, "tt:ShapeDescriptorExtension");
	case SOAP_TYPE_PointerTott__Polygon:
		return soap_in_PointerTott__Polygon(soap, NULL, NULL, "tt:Polygon");
	case SOAP_TYPE_PointerTott__AppearanceExtension:
		return soap_in_PointerTott__AppearanceExtension(soap, NULL, NULL, "tt:AppearanceExtension");
	case SOAP_TYPE_PointerTott__ClassDescriptor:
		return soap_in_PointerTott__ClassDescriptor(soap, NULL, NULL, "tt:ClassDescriptor");
	case SOAP_TYPE_PointerTott__ColorDescriptor:
		return soap_in_PointerTott__ColorDescriptor(soap, NULL, NULL, "tt:ColorDescriptor");
	case SOAP_TYPE_PointerTott__ShapeDescriptor:
		return soap_in_PointerTott__ShapeDescriptor(soap, NULL, NULL, "tt:ShapeDescriptor");
	case SOAP_TYPE_PointerTott__Transformation:
		return soap_in_PointerTott__Transformation(soap, NULL, NULL, "tt:Transformation");
	case SOAP_TYPE_PointerTott__Vector:
		return soap_in_PointerTott__Vector(soap, NULL, NULL, "tt:Vector");
	case SOAP_TYPE_PointerTott__ItemListDescriptionExtension:
		return soap_in_PointerTott__ItemListDescriptionExtension(soap, NULL, NULL, "tt:ItemListDescriptionExtension");
	case SOAP_TYPE_PointerTo_tt__ItemListDescription_ElementItemDescription:
		return soap_in_PointerTo_tt__ItemListDescription_ElementItemDescription(soap, NULL, NULL, "tt:ItemListDescription-ElementItemDescription");
	case SOAP_TYPE_PointerTo_tt__ItemListDescription_SimpleItemDescription:
		return soap_in_PointerTo_tt__ItemListDescription_SimpleItemDescription(soap, NULL, NULL, "tt:ItemListDescription-SimpleItemDescription");
	case SOAP_TYPE_PointerTott__MessageDescriptionExtension:
		return soap_in_PointerTott__MessageDescriptionExtension(soap, NULL, NULL, "tt:MessageDescriptionExtension");
	case SOAP_TYPE_PointerTott__ItemListDescription:
		return soap_in_PointerTott__ItemListDescription(soap, NULL, NULL, "tt:ItemListDescription");
	case SOAP_TYPE_PointerTott__ItemListExtension:
		return soap_in_PointerTott__ItemListExtension(soap, NULL, NULL, "tt:ItemListExtension");
	case SOAP_TYPE_PointerTo_tt__ItemList_ElementItem:
		return soap_in_PointerTo_tt__ItemList_ElementItem(soap, NULL, NULL, "tt:ItemList-ElementItem");
	case SOAP_TYPE_PointerTo_tt__ItemList_SimpleItem:
		return soap_in_PointerTo_tt__ItemList_SimpleItem(soap, NULL, NULL, "tt:ItemList-SimpleItem");
	case SOAP_TYPE_PointerTott__FocusOptions20Extension:
		return soap_in_PointerTott__FocusOptions20Extension(soap, NULL, NULL, "tt:FocusOptions20Extension");
	case SOAP_TYPE_PointerTott__WhiteBalanceOptions20Extension:
		return soap_in_PointerTott__WhiteBalanceOptions20Extension(soap, NULL, NULL, "tt:WhiteBalanceOptions20Extension");
	case SOAP_TYPE_PointerTott__FocusConfiguration20Extension:
		return soap_in_PointerTott__FocusConfiguration20Extension(soap, NULL, NULL, "tt:FocusConfiguration20Extension");
	case SOAP_TYPE_PointerTott__WhiteBalance20Extension:
		return soap_in_PointerTott__WhiteBalance20Extension(soap, NULL, NULL, "tt:WhiteBalance20Extension");
	case SOAP_TYPE_PointerTott__RelativeFocusOptions20:
		return soap_in_PointerTott__RelativeFocusOptions20(soap, NULL, NULL, "tt:RelativeFocusOptions20");
	case SOAP_TYPE_PointerTott__ImagingOptions20Extension:
		return soap_in_PointerTott__ImagingOptions20Extension(soap, NULL, NULL, "tt:ImagingOptions20Extension");
	case SOAP_TYPE_PointerTott__WhiteBalanceOptions20:
		return soap_in_PointerTott__WhiteBalanceOptions20(soap, NULL, NULL, "tt:WhiteBalanceOptions20");
	case SOAP_TYPE_PointerTott__WideDynamicRangeOptions20:
		return soap_in_PointerTott__WideDynamicRangeOptions20(soap, NULL, NULL, "tt:WideDynamicRangeOptions20");
	case SOAP_TYPE_PointerTott__FocusOptions20:
		return soap_in_PointerTott__FocusOptions20(soap, NULL, NULL, "tt:FocusOptions20");
	case SOAP_TYPE_PointerTott__ExposureOptions20:
		return soap_in_PointerTott__ExposureOptions20(soap, NULL, NULL, "tt:ExposureOptions20");
	case SOAP_TYPE_PointerTott__BacklightCompensationOptions20:
		return soap_in_PointerTott__BacklightCompensationOptions20(soap, NULL, NULL, "tt:BacklightCompensationOptions20");
	case SOAP_TYPE_PointerTott__ExposurePriority:
		return soap_in_PointerTott__ExposurePriority(soap, NULL, NULL, "tt:ExposurePriority");
	case SOAP_TYPE_PointerTott__ImagingSettingsExtension20:
		return soap_in_PointerTott__ImagingSettingsExtension20(soap, NULL, NULL, "tt:ImagingSettingsExtension20");
	case SOAP_TYPE_PointerTott__WhiteBalance20:
		return soap_in_PointerTott__WhiteBalance20(soap, NULL, NULL, "tt:WhiteBalance20");
	case SOAP_TYPE_PointerTott__WideDynamicRange20:
		return soap_in_PointerTott__WideDynamicRange20(soap, NULL, NULL, "tt:WideDynamicRange20");
	case SOAP_TYPE_PointerTott__FocusConfiguration20:
		return soap_in_PointerTott__FocusConfiguration20(soap, NULL, NULL, "tt:FocusConfiguration20");
	case SOAP_TYPE_PointerTott__Exposure20:
		return soap_in_PointerTott__Exposure20(soap, NULL, NULL, "tt:Exposure20");
	case SOAP_TYPE_PointerTott__BacklightCompensation20:
		return soap_in_PointerTott__BacklightCompensation20(soap, NULL, NULL, "tt:BacklightCompensation20");
	case SOAP_TYPE_PointerTott__FocusStatus20Extension:
		return soap_in_PointerTott__FocusStatus20Extension(soap, NULL, NULL, "tt:FocusStatus20Extension");
	case SOAP_TYPE_PointerTott__ImagingStatus20Extension:
		return soap_in_PointerTott__ImagingStatus20Extension(soap, NULL, NULL, "tt:ImagingStatus20Extension");
	case SOAP_TYPE_PointerTott__FocusStatus20:
		return soap_in_PointerTott__FocusStatus20(soap, NULL, NULL, "tt:FocusStatus20");
	case SOAP_TYPE_PointerTott__ContinuousFocusOptions:
		return soap_in_PointerTott__ContinuousFocusOptions(soap, NULL, NULL, "tt:ContinuousFocusOptions");
	case SOAP_TYPE_PointerTott__RelativeFocusOptions:
		return soap_in_PointerTott__RelativeFocusOptions(soap, NULL, NULL, "tt:RelativeFocusOptions");
	case SOAP_TYPE_PointerTott__AbsoluteFocusOptions:
		return soap_in_PointerTott__AbsoluteFocusOptions(soap, NULL, NULL, "tt:AbsoluteFocusOptions");
	case SOAP_TYPE_PointerTott__ContinuousFocus:
		return soap_in_PointerTott__ContinuousFocus(soap, NULL, NULL, "tt:ContinuousFocus");
	case SOAP_TYPE_PointerTott__RelativeFocus:
		return soap_in_PointerTott__RelativeFocus(soap, NULL, NULL, "tt:RelativeFocus");
	case SOAP_TYPE_PointerTott__AbsoluteFocus:
		return soap_in_PointerTott__AbsoluteFocus(soap, NULL, NULL, "tt:AbsoluteFocus");
	case SOAP_TYPE_PointerTott__WhiteBalanceOptions:
		return soap_in_PointerTott__WhiteBalanceOptions(soap, NULL, NULL, "tt:WhiteBalanceOptions");
	case SOAP_TYPE_PointerTott__WideDynamicRangeOptions:
		return soap_in_PointerTott__WideDynamicRangeOptions(soap, NULL, NULL, "tt:WideDynamicRangeOptions");
	case SOAP_TYPE_PointerTott__FocusOptions:
		return soap_in_PointerTott__FocusOptions(soap, NULL, NULL, "tt:FocusOptions");
	case SOAP_TYPE_PointerTott__ExposureOptions:
		return soap_in_PointerTott__ExposureOptions(soap, NULL, NULL, "tt:ExposureOptions");
	case SOAP_TYPE_PointerTott__BacklightCompensationOptions:
		return soap_in_PointerTott__BacklightCompensationOptions(soap, NULL, NULL, "tt:BacklightCompensationOptions");
	case SOAP_TYPE_PointerTott__Rectangle:
		return soap_in_PointerTott__Rectangle(soap, NULL, NULL, "tt:Rectangle");
	case SOAP_TYPE_PointerTott__ImagingSettingsExtension:
		return soap_in_PointerTott__ImagingSettingsExtension(soap, NULL, NULL, "tt:ImagingSettingsExtension");
	case SOAP_TYPE_PointerTott__WhiteBalance:
		return soap_in_PointerTott__WhiteBalance(soap, NULL, NULL, "tt:WhiteBalance");
	case SOAP_TYPE_PointerTott__WideDynamicRange:
		return soap_in_PointerTott__WideDynamicRange(soap, NULL, NULL, "tt:WideDynamicRange");
	case SOAP_TYPE_PointerTott__IrCutFilterMode:
		return soap_in_PointerTott__IrCutFilterMode(soap, NULL, NULL, "tt:IrCutFilterMode");
	case SOAP_TYPE_PointerTott__FocusConfiguration:
		return soap_in_PointerTott__FocusConfiguration(soap, NULL, NULL, "tt:FocusConfiguration");
	case SOAP_TYPE_PointerTott__Exposure:
		return soap_in_PointerTott__Exposure(soap, NULL, NULL, "tt:Exposure");
	case SOAP_TYPE_PointerTofloat:
		return soap_in_PointerTofloat(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_PointerTott__BacklightCompensation:
		return soap_in_PointerTott__BacklightCompensation(soap, NULL, NULL, "tt:BacklightCompensation");
	case SOAP_TYPE_PointerTott__FocusStatus:
		return soap_in_PointerTott__FocusStatus(soap, NULL, NULL, "tt:FocusStatus");
	case SOAP_TYPE_PointerTott__MoveStatus:
		return soap_in_PointerTott__MoveStatus(soap, NULL, NULL, "tt:MoveStatus");
	case SOAP_TYPE_PointerTott__ReferenceToken:
		return soap_in_PointerTott__ReferenceToken(soap, NULL, NULL, "tt:ReferenceToken");
	case SOAP_TYPE_PointerTott__Name:
		return soap_in_PointerTott__Name(soap, NULL, NULL, "tt:Name");
	case SOAP_TYPE_PointerTott__PTZMoveStatus:
		return soap_in_PointerTott__PTZMoveStatus(soap, NULL, NULL, "tt:PTZMoveStatus");
	case SOAP_TYPE_PointerTott__PTZVector:
		return soap_in_PointerTott__PTZVector(soap, NULL, NULL, "tt:PTZVector");
	case SOAP_TYPE_PointerTott__Vector1D:
		return soap_in_PointerTott__Vector1D(soap, NULL, NULL, "tt:Vector1D");
	case SOAP_TYPE_PointerTott__Vector2D:
		return soap_in_PointerTott__Vector2D(soap, NULL, NULL, "tt:Vector2D");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_in_PointerToxsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_PointerTott__FloatRange:
		return soap_in_PointerTott__FloatRange(soap, NULL, NULL, "tt:FloatRange");
	case SOAP_TYPE_PointerTott__PTZSpacesExtension:
		return soap_in_PointerTott__PTZSpacesExtension(soap, NULL, NULL, "tt:PTZSpacesExtension");
	case SOAP_TYPE_PointerTott__Space1DDescription:
		return soap_in_PointerTott__Space1DDescription(soap, NULL, NULL, "tt:Space1DDescription");
	case SOAP_TYPE_PointerTott__Space2DDescription:
		return soap_in_PointerTott__Space2DDescription(soap, NULL, NULL, "tt:Space2DDescription");
	case SOAP_TYPE_PointerTott__DurationRange:
		return soap_in_PointerTott__DurationRange(soap, NULL, NULL, "tt:DurationRange");
	case SOAP_TYPE_PointerTott__PTZSpaces:
		return soap_in_PointerTott__PTZSpaces(soap, NULL, NULL, "tt:PTZSpaces");
	case SOAP_TYPE_PointerTott__BinaryData:
		return soap_in_PointerTott__BinaryData(soap, NULL, NULL, "tt:BinaryData");
	case SOAP_TYPE_PointerTott__CertificateGenerationParametersExtension:
		return soap_in_PointerTott__CertificateGenerationParametersExtension(soap, NULL, NULL, "tt:CertificateGenerationParametersExtension");
	case SOAP_TYPE_PointerTott__UserExtension:
		return soap_in_PointerTott__UserExtension(soap, NULL, NULL, "tt:UserExtension");
	case SOAP_TYPE_PointerTott__Date:
		return soap_in_PointerTott__Date(soap, NULL, NULL, "tt:Date");
	case SOAP_TYPE_PointerTott__Time:
		return soap_in_PointerTott__Time(soap, NULL, NULL, "tt:Time");
	case SOAP_TYPE_PointerTott__SystemDateTimeExtension:
		return soap_in_PointerTott__SystemDateTimeExtension(soap, NULL, NULL, "tt:SystemDateTimeExtension");
	case SOAP_TYPE_PointerTott__DateTime:
		return soap_in_PointerTott__DateTime(soap, NULL, NULL, "tt:DateTime");
	case SOAP_TYPE_PointerTott__TimeZone:
		return soap_in_PointerTott__TimeZone(soap, NULL, NULL, "tt:TimeZone");
	case SOAP_TYPE_PointerTott__AttachmentData:
		return soap_in_PointerTott__AttachmentData(soap, NULL, NULL, "tt:AttachmentData");
	case SOAP_TYPE_PointerTott__SystemCapabilitiesExtension:
		return soap_in_PointerTott__SystemCapabilitiesExtension(soap, NULL, NULL, "tt:SystemCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__OnvifVersion:
		return soap_in_PointerTott__OnvifVersion(soap, NULL, NULL, "tt:OnvifVersion");
	case SOAP_TYPE_PointerTott__SecurityCapabilitiesExtension:
		return soap_in_PointerTott__SecurityCapabilitiesExtension(soap, NULL, NULL, "tt:SecurityCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__NetworkCapabilitiesExtension:
		return soap_in_PointerTott__NetworkCapabilitiesExtension(soap, NULL, NULL, "tt:NetworkCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__RealTimeStreamingCapabilitiesExtension:
		return soap_in_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, NULL, NULL, "tt:RealTimeStreamingCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__ProfileCapabilities:
		return soap_in_PointerTott__ProfileCapabilities(soap, NULL, NULL, "tt:ProfileCapabilities");
	case SOAP_TYPE_PointerTott__MediaCapabilitiesExtension:
		return soap_in_PointerTott__MediaCapabilitiesExtension(soap, NULL, NULL, "tt:MediaCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__RealTimeStreamingCapabilities:
		return soap_in_PointerTott__RealTimeStreamingCapabilities(soap, NULL, NULL, "tt:RealTimeStreamingCapabilities");
	case SOAP_TYPE_PointerTott__IOCapabilitiesExtension:
		return soap_in_PointerTott__IOCapabilitiesExtension(soap, NULL, NULL, "tt:IOCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__DeviceCapabilitiesExtension:
		return soap_in_PointerTott__DeviceCapabilitiesExtension(soap, NULL, NULL, "tt:DeviceCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__SecurityCapabilities:
		return soap_in_PointerTott__SecurityCapabilities(soap, NULL, NULL, "tt:SecurityCapabilities");
	case SOAP_TYPE_PointerTott__IOCapabilities:
		return soap_in_PointerTott__IOCapabilities(soap, NULL, NULL, "tt:IOCapabilities");
	case SOAP_TYPE_PointerTott__SystemCapabilities:
		return soap_in_PointerTott__SystemCapabilities(soap, NULL, NULL, "tt:SystemCapabilities");
	case SOAP_TYPE_PointerTott__NetworkCapabilities:
		return soap_in_PointerTott__NetworkCapabilities(soap, NULL, NULL, "tt:NetworkCapabilities");
	case SOAP_TYPE_PointerTott__CapabilitiesExtension:
		return soap_in_PointerTott__CapabilitiesExtension(soap, NULL, NULL, "tt:CapabilitiesExtension");
	case SOAP_TYPE_PointerTott__PTZCapabilities:
		return soap_in_PointerTott__PTZCapabilities(soap, NULL, NULL, "tt:PTZCapabilities");
	case SOAP_TYPE_PointerTott__MediaCapabilities:
		return soap_in_PointerTott__MediaCapabilities(soap, NULL, NULL, "tt:MediaCapabilities");
	case SOAP_TYPE_PointerTott__ImagingCapabilities:
		return soap_in_PointerTott__ImagingCapabilities(soap, NULL, NULL, "tt:ImagingCapabilities");
	case SOAP_TYPE_PointerTott__EventCapabilities:
		return soap_in_PointerTott__EventCapabilities(soap, NULL, NULL, "tt:EventCapabilities");
	case SOAP_TYPE_PointerTott__DeviceCapabilities:
		return soap_in_PointerTott__DeviceCapabilities(soap, NULL, NULL, "tt:DeviceCapabilities");
	case SOAP_TYPE_PointerTott__AnalyticsCapabilities:
		return soap_in_PointerTott__AnalyticsCapabilities(soap, NULL, NULL, "tt:AnalyticsCapabilities");
	case SOAP_TYPE_PointerTott__IPAddressFilterExtension:
		return soap_in_PointerTott__IPAddressFilterExtension(soap, NULL, NULL, "tt:IPAddressFilterExtension");
	case SOAP_TYPE_PointerTott__NetworkZeroConfigurationExtension:
		return soap_in_PointerTott__NetworkZeroConfigurationExtension(soap, NULL, NULL, "tt:NetworkZeroConfigurationExtension");
	case SOAP_TYPE_PointerTott__IPv6DHCPConfiguration:
		return soap_in_PointerTott__IPv6DHCPConfiguration(soap, NULL, NULL, "tt:IPv6DHCPConfiguration");
	case SOAP_TYPE_PointerTott__NetworkInterfaceSetConfigurationExtension:
		return soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, NULL, NULL, "tt:NetworkInterfaceSetConfigurationExtension");
	case SOAP_TYPE_PointerTott__IPv6NetworkInterfaceSetConfiguration:
		return soap_in_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, NULL, NULL, "tt:IPv6NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_PointerTott__IPv4NetworkInterfaceSetConfiguration:
		return soap_in_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, NULL, NULL, "tt:IPv4NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_PointerTott__DynamicDNSInformationExtension:
		return soap_in_PointerTott__DynamicDNSInformationExtension(soap, NULL, NULL, "tt:DynamicDNSInformationExtension");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_in_PointerToxsd__duration(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_PointerTott__NTPInformationExtension:
		return soap_in_PointerTott__NTPInformationExtension(soap, NULL, NULL, "tt:NTPInformationExtension");
	case SOAP_TYPE_PointerTott__NetworkHost:
		return soap_in_PointerTott__NetworkHost(soap, NULL, NULL, "tt:NetworkHost");
	case SOAP_TYPE_PointerTott__DNSInformationExtension:
		return soap_in_PointerTott__DNSInformationExtension(soap, NULL, NULL, "tt:DNSInformationExtension");
	case SOAP_TYPE_PointerTott__HostnameInformationExtension:
		return soap_in_PointerTott__HostnameInformationExtension(soap, NULL, NULL, "tt:HostnameInformationExtension");
	case SOAP_TYPE_PointerToxsd__token:
		return soap_in_PointerToxsd__token(soap, NULL, NULL, "xsd:token");
	case SOAP_TYPE_PointerTott__NetworkHostExtension:
		return soap_in_PointerTott__NetworkHostExtension(soap, NULL, NULL, "tt:NetworkHostExtension");
	case SOAP_TYPE_PointerTott__DNSName:
		return soap_in_PointerTott__DNSName(soap, NULL, NULL, "tt:DNSName");
	case SOAP_TYPE_PointerTott__IPv6Address:
		return soap_in_PointerTott__IPv6Address(soap, NULL, NULL, "tt:IPv6Address");
	case SOAP_TYPE_PointerTott__IPv4Address:
		return soap_in_PointerTott__IPv4Address(soap, NULL, NULL, "tt:IPv4Address");
	case SOAP_TYPE_PointerTott__NetworkProtocolExtension:
		return soap_in_PointerTott__NetworkProtocolExtension(soap, NULL, NULL, "tt:NetworkProtocolExtension");
	case SOAP_TYPE_PointerTott__IPv6ConfigurationExtension:
		return soap_in_PointerTott__IPv6ConfigurationExtension(soap, NULL, NULL, "tt:IPv6ConfigurationExtension");
	case SOAP_TYPE_PointerTott__PrefixedIPv6Address:
		return soap_in_PointerTott__PrefixedIPv6Address(soap, NULL, NULL, "tt:PrefixedIPv6Address");
	case SOAP_TYPE_PointerTott__PrefixedIPv4Address:
		return soap_in_PointerTott__PrefixedIPv4Address(soap, NULL, NULL, "tt:PrefixedIPv4Address");
	case SOAP_TYPE_PointerTott__IPv4Configuration:
		return soap_in_PointerTott__IPv4Configuration(soap, NULL, NULL, "tt:IPv4Configuration");
	case SOAP_TYPE_PointerTott__IPv6Configuration:
		return soap_in_PointerTott__IPv6Configuration(soap, NULL, NULL, "tt:IPv6Configuration");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTott__NetworkInterfaceConnectionSetting:
		return soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, NULL, NULL, "tt:NetworkInterfaceConnectionSetting");
	case SOAP_TYPE_PointerTott__Transport:
		return soap_in_PointerTott__Transport(soap, NULL, NULL, "tt:Transport");
	case SOAP_TYPE_PointerTott__IPAddress:
		return soap_in_PointerTott__IPAddress(soap, NULL, NULL, "tt:IPAddress");
	case SOAP_TYPE_PointerTott__PTZStatusFilterOptions:
		return soap_in_PointerTott__PTZStatusFilterOptions(soap, NULL, NULL, "tt:PTZStatusFilterOptions");
	case SOAP_TYPE_PointerTo_tt__EventSubscription_SubscriptionPolicy:
		return soap_in_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, NULL, NULL, "tt:EventSubscription-SubscriptionPolicy");
	case SOAP_TYPE_PointerTowsnb__FilterType:
		return soap_in_PointerTowsnb__FilterType(soap, NULL, NULL, "wsnb:FilterType");
	case SOAP_TYPE_PointerTott__IntList:
		return soap_in_PointerTott__IntList(soap, NULL, NULL, "tt:IntList");
	case SOAP_TYPE_PointerTott__AudioEncoderConfigurationOption:
		return soap_in_PointerTott__AudioEncoderConfigurationOption(soap, NULL, NULL, "tt:AudioEncoderConfigurationOption");
	case SOAP_TYPE_PointerTott__AudioSourceOptionsExtension:
		return soap_in_PointerTott__AudioSourceOptionsExtension(soap, NULL, NULL, "tt:AudioSourceOptionsExtension");
	case SOAP_TYPE_PointerTott__VideoResolution:
		return soap_in_PointerTott__VideoResolution(soap, NULL, NULL, "tt:VideoResolution");
	case SOAP_TYPE_PointerTott__VideoEncoderOptionsExtension:
		return soap_in_PointerTott__VideoEncoderOptionsExtension(soap, NULL, NULL, "tt:VideoEncoderOptionsExtension");
	case SOAP_TYPE_PointerTott__H264Options:
		return soap_in_PointerTott__H264Options(soap, NULL, NULL, "tt:H264Options");
	case SOAP_TYPE_PointerTott__Mpeg4Options:
		return soap_in_PointerTott__Mpeg4Options(soap, NULL, NULL, "tt:Mpeg4Options");
	case SOAP_TYPE_PointerTott__JpegOptions:
		return soap_in_PointerTott__JpegOptions(soap, NULL, NULL, "tt:JpegOptions");
	case SOAP_TYPE_PointerTott__VideoSourceConfigurationOptionsExtension:
		return soap_in_PointerTott__VideoSourceConfigurationOptionsExtension(soap, NULL, NULL, "tt:VideoSourceConfigurationOptionsExtension");
	case SOAP_TYPE_PointerTott__IntRectangleRange:
		return soap_in_PointerTott__IntRectangleRange(soap, NULL, NULL, "tt:IntRectangleRange");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTott__ProfileExtension:
		return soap_in_PointerTott__ProfileExtension(soap, NULL, NULL, "tt:ProfileExtension");
	case SOAP_TYPE_PointerTott__MetadataConfiguration:
		return soap_in_PointerTott__MetadataConfiguration(soap, NULL, NULL, "tt:MetadataConfiguration");
	case SOAP_TYPE_PointerTott__PTZConfiguration:
		return soap_in_PointerTott__PTZConfiguration(soap, NULL, NULL, "tt:PTZConfiguration");
	case SOAP_TYPE_PointerTott__VideoAnalyticsConfiguration:
		return soap_in_PointerTott__VideoAnalyticsConfiguration(soap, NULL, NULL, "tt:VideoAnalyticsConfiguration");
	case SOAP_TYPE_PointerTott__AudioEncoderConfiguration:
		return soap_in_PointerTott__AudioEncoderConfiguration(soap, NULL, NULL, "tt:AudioEncoderConfiguration");
	case SOAP_TYPE_PointerTott__VideoEncoderConfiguration:
		return soap_in_PointerTott__VideoEncoderConfiguration(soap, NULL, NULL, "tt:VideoEncoderConfiguration");
	case SOAP_TYPE_PointerTott__AudioSourceConfiguration:
		return soap_in_PointerTott__AudioSourceConfiguration(soap, NULL, NULL, "tt:AudioSourceConfiguration");
	case SOAP_TYPE_PointerTott__VideoSourceConfiguration:
		return soap_in_PointerTott__VideoSourceConfiguration(soap, NULL, NULL, "tt:VideoSourceConfiguration");
	case SOAP_TYPE_PointerTott__IntRange:
		return soap_in_PointerTott__IntRange(soap, NULL, NULL, "tt:IntRange");
	case SOAP_TYPE_PointerTott__SupportedAnalyticsModules:
		return soap_in_PointerTott__SupportedAnalyticsModules(soap, NULL, NULL, "tt:SupportedAnalyticsModules");
	case SOAP_TYPE_PointerTott__Config:
		return soap_in_PointerTott__Config(soap, NULL, NULL, "tt:Config");
	case SOAP_TYPE_PointerTott__SupportedRules:
		return soap_in_PointerTott__SupportedRules(soap, NULL, NULL, "tt:SupportedRules");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_in_PointerTo_wsa5__FaultTo(soap, NULL, NULL, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_in_PointerTo_wsa5__ReplyTo(soap, NULL, NULL, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_in_PointerTo_wsa5__From(soap, NULL, NULL, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_in_PointerTo_wsa5__RelatesTo(soap, NULL, NULL, "wsa5:RelatesTo");
	case SOAP_TYPE_PointerTo_wsse__Security:
		return soap_in_PointerTo_wsse__Security(soap, NULL, NULL, "wsse:Security");
	case SOAP_TYPE_PointerTods__SignatureType:
		return soap_in_PointerTods__SignatureType(soap, NULL, NULL, "ds:SignatureType");
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		return soap_in_PointerTo_wsse__BinarySecurityToken(soap, NULL, NULL, "wsse:BinarySecurityToken");
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		return soap_in_PointerTo_wsse__UsernameToken(soap, NULL, NULL, "wsse:UsernameToken");
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		return soap_in_PointerTo_wsu__Timestamp(soap, NULL, NULL, "wsu:Timestamp");
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		return soap_in_PointerTods__X509IssuerSerialType(soap, NULL, NULL, "ds:X509IssuerSerialType");
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		return soap_in_PointerTods__RSAKeyValueType(soap, NULL, NULL, "ds:RSAKeyValueType");
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		return soap_in_PointerTods__DSAKeyValueType(soap, NULL, NULL, "ds:DSAKeyValueType");
	case SOAP_TYPE_PointerTods__TransformType:
		return soap_in_PointerTods__TransformType(soap, NULL, NULL, "ds:TransformType");
	case SOAP_TYPE_PointerTods__DigestMethodType:
		return soap_in_PointerTods__DigestMethodType(soap, NULL, NULL, "ds:DigestMethodType");
	case SOAP_TYPE_PointerTods__TransformsType:
		return soap_in_PointerTods__TransformsType(soap, NULL, NULL, "ds:TransformsType");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		return soap_in_PointerToPointerTods__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__ReferenceType:
		return soap_in_PointerTods__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		return soap_in_PointerTods__SignatureMethodType(soap, NULL, NULL, "ds:SignatureMethodType");
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		return soap_in_PointerTods__CanonicalizationMethodType(soap, NULL, NULL, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		return soap_in_PointerTo_wsse__SecurityTokenReference(soap, NULL, NULL, "wsse:SecurityTokenReference");
	case SOAP_TYPE_PointerTods__X509DataType:
		return soap_in_PointerTods__X509DataType(soap, NULL, NULL, "ds:X509DataType");
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		return soap_in_PointerTods__RetrievalMethodType(soap, NULL, NULL, "ds:RetrievalMethodType");
	case SOAP_TYPE_PointerTods__KeyValueType:
		return soap_in_PointerTods__KeyValueType(soap, NULL, NULL, "ds:KeyValueType");
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		return soap_in_PointerTo_c14n__InclusiveNamespaces(soap, NULL, NULL, "c14n:InclusiveNamespaces");
	case SOAP_TYPE_PointerTods__KeyInfoType:
		return soap_in_PointerTods__KeyInfoType(soap, NULL, NULL, "ds:KeyInfoType");
	case SOAP_TYPE_PointerTods__SignedInfoType:
		return soap_in_PointerTods__SignedInfoType(soap, NULL, NULL, "ds:SignedInfoType");
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		return soap_in_PointerTo_wsse__Embedded(soap, NULL, NULL, "wsse:Embedded");
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		return soap_in_PointerTo_wsse__KeyIdentifier(soap, NULL, NULL, "wsse:KeyIdentifier");
	case SOAP_TYPE_PointerTo_wsse__Reference:
		return soap_in_PointerTo_wsse__Reference(soap, NULL, NULL, "wsse:Reference");
	case SOAP_TYPE_PointerTo_wsse__Password:
		return soap_in_PointerTo_wsse__Password(soap, NULL, NULL, "wsse:Password");
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
	{	char **s;
		s = soap_in__wsa5__ProblemHeaderQName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_in_PointerTowsa5__MetadataType(soap, NULL, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_in_PointerTowsa5__ReferenceParametersType(soap, NULL, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
	{	char **s;
		s = soap_in_wsa5__FaultCodesOpenEnumType(soap, NULL, NULL, "wsa5:FaultCodesOpenEnumType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
	{	char **s;
		s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, NULL, NULL, "wsa5:RelationshipTypeOpenEnum");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "wstop:SimpleTopicExpression"))
		{	*type = SOAP_TYPE_wstop__SimpleTopicExpression;
			return soap_in_wstop__SimpleTopicExpression(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:ConcreteTopicExpression"))
		{	*type = SOAP_TYPE_wstop__ConcreteTopicExpression;
			return soap_in_wstop__ConcreteTopicExpression(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:FullTopicExpression"))
		{	*type = SOAP_TYPE_wstop__FullTopicExpression;
			return soap_in_wstop__FullTopicExpression(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:TopicNamespaceLocation"))
		{	*type = SOAP_TYPE_tt__TopicNamespaceLocation;
			return soap_in_tt__TopicNamespaceLocation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AuxiliaryData"))
		{	*type = SOAP_TYPE_tt__AuxiliaryData;
			return soap_in_tt__AuxiliaryData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Domain"))
		{	*type = SOAP_TYPE_tt__Domain;
			return soap_in_tt__Domain(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DNSName"))
		{	*type = SOAP_TYPE_tt__DNSName;
			return soap_in_tt__DNSName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:HwAddress"))
		{	*type = SOAP_TYPE_tt__HwAddress;
			return soap_in_tt__HwAddress(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv6Address"))
		{	*type = SOAP_TYPE_tt__IPv6Address;
			return soap_in_tt__IPv6Address(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv4Address"))
		{	*type = SOAP_TYPE_tt__IPv4Address;
			return soap_in_tt__IPv4Address(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Name"))
		{	*type = SOAP_TYPE_tt__Name;
			return soap_in_tt__Name(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ReferenceToken"))
		{	*type = SOAP_TYPE_tt__ReferenceToken;
			return soap_in_tt__ReferenceToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:AbsoluteOrRelativeTimeType"))
		{	*type = SOAP_TYPE_wsnb__AbsoluteOrRelativeTimeType;
			return soap_in_wsnb__AbsoluteOrRelativeTimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:TopicSetType"))
		{	*type = SOAP_TYPE_wstop__TopicSetType;
			return soap_in_wstop__TopicSetType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:TopicType"))
		{	*type = SOAP_TYPE_wstop__TopicType;
			return soap_in_wstop__TopicType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:TopicNamespaceType"))
		{	*type = SOAP_TYPE_wstop__TopicNamespaceType;
			return soap_in_wstop__TopicNamespaceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:QueryExpressionType"))
		{	*type = SOAP_TYPE_wstop__QueryExpressionType;
			return soap_in_wstop__QueryExpressionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:ExtensibleDocumented"))
		{	*type = SOAP_TYPE_wstop__ExtensibleDocumented;
			return soap_in_wstop__ExtensibleDocumented(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:Documentation"))
		{	*type = SOAP_TYPE_wstop__Documentation;
			return soap_in_wstop__Documentation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfbf:BaseFaultType"))
		{	*type = SOAP_TYPE_wsrfbf__BaseFaultType;
			return soap_in_wsrfbf__BaseFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:ResumeFailedFaultType"))
		{	*type = SOAP_TYPE_wsnb__ResumeFailedFaultType;
			return soap_in_wsnb__ResumeFailedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:PauseFailedFaultType"))
		{	*type = SOAP_TYPE_wsnb__PauseFailedFaultType;
			return soap_in_wsnb__PauseFailedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:UnableToDestroySubscriptionFaultType"))
		{	*type = SOAP_TYPE_wsnb__UnableToDestroySubscriptionFaultType;
			return soap_in_wsnb__UnableToDestroySubscriptionFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:UnacceptableTerminationTimeFaultType"))
		{	*type = SOAP_TYPE_wsnb__UnacceptableTerminationTimeFaultType;
			return soap_in_wsnb__UnacceptableTerminationTimeFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:UnableToCreatePullPointFaultType"))
		{	*type = SOAP_TYPE_wsnb__UnableToCreatePullPointFaultType;
			return soap_in_wsnb__UnableToCreatePullPointFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:UnableToDestroyPullPointFaultType"))
		{	*type = SOAP_TYPE_wsnb__UnableToDestroyPullPointFaultType;
			return soap_in_wsnb__UnableToDestroyPullPointFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:UnableToGetMessagesFaultType"))
		{	*type = SOAP_TYPE_wsnb__UnableToGetMessagesFaultType;
			return soap_in_wsnb__UnableToGetMessagesFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:NoCurrentMessageOnTopicFaultType"))
		{	*type = SOAP_TYPE_wsnb__NoCurrentMessageOnTopicFaultType;
			return soap_in_wsnb__NoCurrentMessageOnTopicFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:UnacceptableInitialTerminationTimeFaultType"))
		{	*type = SOAP_TYPE_wsnb__UnacceptableInitialTerminationTimeFaultType;
			return soap_in_wsnb__UnacceptableInitialTerminationTimeFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:NotifyMessageNotSupportedFaultType"))
		{	*type = SOAP_TYPE_wsnb__NotifyMessageNotSupportedFaultType;
			return soap_in_wsnb__NotifyMessageNotSupportedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:UnsupportedPolicyRequestFaultType"))
		{	*type = SOAP_TYPE_wsnb__UnsupportedPolicyRequestFaultType;
			return soap_in_wsnb__UnsupportedPolicyRequestFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:UnrecognizedPolicyRequestFaultType"))
		{	*type = SOAP_TYPE_wsnb__UnrecognizedPolicyRequestFaultType;
			return soap_in_wsnb__UnrecognizedPolicyRequestFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:InvalidMessageContentExpressionFaultType"))
		{	*type = SOAP_TYPE_wsnb__InvalidMessageContentExpressionFaultType;
			return soap_in_wsnb__InvalidMessageContentExpressionFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:InvalidProducerPropertiesExpressionFaultType"))
		{	*type = SOAP_TYPE_wsnb__InvalidProducerPropertiesExpressionFaultType;
			return soap_in_wsnb__InvalidProducerPropertiesExpressionFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:MultipleTopicsSpecifiedFaultType"))
		{	*type = SOAP_TYPE_wsnb__MultipleTopicsSpecifiedFaultType;
			return soap_in_wsnb__MultipleTopicsSpecifiedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:TopicNotSupportedFaultType"))
		{	*type = SOAP_TYPE_wsnb__TopicNotSupportedFaultType;
			return soap_in_wsnb__TopicNotSupportedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:InvalidTopicExpressionFaultType"))
		{	*type = SOAP_TYPE_wsnb__InvalidTopicExpressionFaultType;
			return soap_in_wsnb__InvalidTopicExpressionFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:TopicExpressionDialectUnknownFaultType"))
		{	*type = SOAP_TYPE_wsnb__TopicExpressionDialectUnknownFaultType;
			return soap_in_wsnb__TopicExpressionDialectUnknownFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:InvalidFilterFaultType"))
		{	*type = SOAP_TYPE_wsnb__InvalidFilterFaultType;
			return soap_in_wsnb__InvalidFilterFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:SubscribeCreationFailedFaultType"))
		{	*type = SOAP_TYPE_wsnb__SubscribeCreationFailedFaultType;
			return soap_in_wsnb__SubscribeCreationFailedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:NotificationMessageHolderType"))
		{	*type = SOAP_TYPE_wsnb__NotificationMessageHolderType;
			return soap_in_wsnb__NotificationMessageHolderType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:SubscriptionPolicyType"))
		{	*type = SOAP_TYPE_wsnb__SubscriptionPolicyType;
			return soap_in_wsnb__SubscriptionPolicyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:FilterType"))
		{	*type = SOAP_TYPE_wsnb__FilterType;
			return soap_in_wsnb__FilterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:TopicExpressionType"))
		{	*type = SOAP_TYPE_wsnb__TopicExpressionType;
			return soap_in_wsnb__TopicExpressionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:QueryExpressionType"))
		{	*type = SOAP_TYPE_wsnb__QueryExpressionType;
			return soap_in_wsnb__QueryExpressionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:EventStreamExtension"))
		{	*type = SOAP_TYPE_tt__EventStreamExtension;
			return soap_in_tt__EventStreamExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:EventStream"))
		{	*type = SOAP_TYPE_tt__EventStream;
			return soap_in_tt__EventStream(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZStreamExtension"))
		{	*type = SOAP_TYPE_tt__PTZStreamExtension;
			return soap_in_tt__PTZStreamExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZStream"))
		{	*type = SOAP_TYPE_tt__PTZStream;
			return soap_in_tt__PTZStream(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoAnalyticsStreamExtension"))
		{	*type = SOAP_TYPE_tt__VideoAnalyticsStreamExtension;
			return soap_in_tt__VideoAnalyticsStreamExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoAnalyticsStream"))
		{	*type = SOAP_TYPE_tt__VideoAnalyticsStream;
			return soap_in_tt__VideoAnalyticsStream(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MetadataStreamExtension"))
		{	*type = SOAP_TYPE_tt__MetadataStreamExtension;
			return soap_in_tt__MetadataStreamExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MetadataStream"))
		{	*type = SOAP_TYPE_tt__MetadataStream;
			return soap_in_tt__MetadataStream(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SupportedAnalyticsModulesExtension"))
		{	*type = SOAP_TYPE_tt__SupportedAnalyticsModulesExtension;
			return soap_in_tt__SupportedAnalyticsModulesExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SupportedAnalyticsModules"))
		{	*type = SOAP_TYPE_tt__SupportedAnalyticsModules;
			return soap_in_tt__SupportedAnalyticsModules(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SupportedRulesExtension"))
		{	*type = SOAP_TYPE_tt__SupportedRulesExtension;
			return soap_in_tt__SupportedRulesExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SupportedRules"))
		{	*type = SOAP_TYPE_tt__SupportedRules;
			return soap_in_tt__SupportedRules(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ConfigDescriptionExtension"))
		{	*type = SOAP_TYPE_tt__ConfigDescriptionExtension;
			return soap_in_tt__ConfigDescriptionExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ConfigDescription"))
		{	*type = SOAP_TYPE_tt__ConfigDescription;
			return soap_in_tt__ConfigDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Config"))
		{	*type = SOAP_TYPE_tt__Config;
			return soap_in_tt__Config(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RuleEngineConfigurationExtension"))
		{	*type = SOAP_TYPE_tt__RuleEngineConfigurationExtension;
			return soap_in_tt__RuleEngineConfigurationExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RuleEngineConfiguration"))
		{	*type = SOAP_TYPE_tt__RuleEngineConfiguration;
			return soap_in_tt__RuleEngineConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AnalyticsEngineConfigurationExtension"))
		{	*type = SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension;
			return soap_in_tt__AnalyticsEngineConfigurationExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AnalyticsEngineConfiguration"))
		{	*type = SOAP_TYPE_tt__AnalyticsEngineConfiguration;
			return soap_in_tt__AnalyticsEngineConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ObjectTreeExtension"))
		{	*type = SOAP_TYPE_tt__ObjectTreeExtension;
			return soap_in_tt__ObjectTreeExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ObjectTree"))
		{	*type = SOAP_TYPE_tt__ObjectTree;
			return soap_in_tt__ObjectTree(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:BehaviourExtension"))
		{	*type = SOAP_TYPE_tt__BehaviourExtension;
			return soap_in_tt__BehaviourExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Behaviour"))
		{	*type = SOAP_TYPE_tt__Behaviour;
			return soap_in_tt__Behaviour(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ObjectId"))
		{	*type = SOAP_TYPE_tt__ObjectId;
			return soap_in_tt__ObjectId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Rename"))
		{	*type = SOAP_TYPE_tt__Rename;
			return soap_in_tt__Rename(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Split"))
		{	*type = SOAP_TYPE_tt__Split;
			return soap_in_tt__Split(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Merge"))
		{	*type = SOAP_TYPE_tt__Merge;
			return soap_in_tt__Merge(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FrameExtension"))
		{	*type = SOAP_TYPE_tt__FrameExtension;
			return soap_in_tt__FrameExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Frame"))
		{	*type = SOAP_TYPE_tt__Frame;
			return soap_in_tt__Frame(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:TransformationExtension"))
		{	*type = SOAP_TYPE_tt__TransformationExtension;
			return soap_in_tt__TransformationExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Transformation"))
		{	*type = SOAP_TYPE_tt__Transformation;
			return soap_in_tt__Transformation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ObjectExtension"))
		{	*type = SOAP_TYPE_tt__ObjectExtension;
			return soap_in_tt__ObjectExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Object"))
		{	*type = SOAP_TYPE_tt__Object;
			return soap_in_tt__Object(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ClassDescriptorExtension"))
		{	*type = SOAP_TYPE_tt__ClassDescriptorExtension;
			return soap_in_tt__ClassDescriptorExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ClassDescriptor"))
		{	*type = SOAP_TYPE_tt__ClassDescriptor;
			return soap_in_tt__ClassDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ColorDescriptorExtension"))
		{	*type = SOAP_TYPE_tt__ColorDescriptorExtension;
			return soap_in_tt__ColorDescriptorExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ColorDescriptor"))
		{	*type = SOAP_TYPE_tt__ColorDescriptor;
			return soap_in_tt__ColorDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ShapeDescriptorExtension"))
		{	*type = SOAP_TYPE_tt__ShapeDescriptorExtension;
			return soap_in_tt__ShapeDescriptorExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ShapeDescriptor"))
		{	*type = SOAP_TYPE_tt__ShapeDescriptor;
			return soap_in_tt__ShapeDescriptor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AppearanceExtension"))
		{	*type = SOAP_TYPE_tt__AppearanceExtension;
			return soap_in_tt__AppearanceExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Appearance"))
		{	*type = SOAP_TYPE_tt__Appearance;
			return soap_in_tt__Appearance(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ColorCovariance"))
		{	*type = SOAP_TYPE_tt__ColorCovariance;
			return soap_in_tt__ColorCovariance(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Color"))
		{	*type = SOAP_TYPE_tt__Color;
			return soap_in_tt__Color(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Polyline"))
		{	*type = SOAP_TYPE_tt__Polyline;
			return soap_in_tt__Polyline(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Polygon"))
		{	*type = SOAP_TYPE_tt__Polygon;
			return soap_in_tt__Polygon(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Rectangle"))
		{	*type = SOAP_TYPE_tt__Rectangle;
			return soap_in_tt__Rectangle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Vector"))
		{	*type = SOAP_TYPE_tt__Vector;
			return soap_in_tt__Vector(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ItemListDescriptionExtension"))
		{	*type = SOAP_TYPE_tt__ItemListDescriptionExtension;
			return soap_in_tt__ItemListDescriptionExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ItemListDescription"))
		{	*type = SOAP_TYPE_tt__ItemListDescription;
			return soap_in_tt__ItemListDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MessageDescriptionExtension"))
		{	*type = SOAP_TYPE_tt__MessageDescriptionExtension;
			return soap_in_tt__MessageDescriptionExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MessageDescription"))
		{	*type = SOAP_TYPE_tt__MessageDescription;
			return soap_in_tt__MessageDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ItemListExtension"))
		{	*type = SOAP_TYPE_tt__ItemListExtension;
			return soap_in_tt__ItemListExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ItemList"))
		{	*type = SOAP_TYPE_tt__ItemList;
			return soap_in_tt__ItemList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MessageExtension"))
		{	*type = SOAP_TYPE_tt__MessageExtension;
			return soap_in_tt__MessageExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FocusOptions20Extension"))
		{	*type = SOAP_TYPE_tt__FocusOptions20Extension;
			return soap_in_tt__FocusOptions20Extension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FocusOptions20"))
		{	*type = SOAP_TYPE_tt__FocusOptions20;
			return soap_in_tt__FocusOptions20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:WhiteBalanceOptions20Extension"))
		{	*type = SOAP_TYPE_tt__WhiteBalanceOptions20Extension;
			return soap_in_tt__WhiteBalanceOptions20Extension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:WhiteBalanceOptions20"))
		{	*type = SOAP_TYPE_tt__WhiteBalanceOptions20;
			return soap_in_tt__WhiteBalanceOptions20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FocusConfiguration20Extension"))
		{	*type = SOAP_TYPE_tt__FocusConfiguration20Extension;
			return soap_in_tt__FocusConfiguration20Extension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FocusConfiguration20"))
		{	*type = SOAP_TYPE_tt__FocusConfiguration20;
			return soap_in_tt__FocusConfiguration20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:WhiteBalance20Extension"))
		{	*type = SOAP_TYPE_tt__WhiteBalance20Extension;
			return soap_in_tt__WhiteBalance20Extension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:WhiteBalance20"))
		{	*type = SOAP_TYPE_tt__WhiteBalance20;
			return soap_in_tt__WhiteBalance20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RelativeFocusOptions20"))
		{	*type = SOAP_TYPE_tt__RelativeFocusOptions20;
			return soap_in_tt__RelativeFocusOptions20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MoveOptions20"))
		{	*type = SOAP_TYPE_tt__MoveOptions20;
			return soap_in_tt__MoveOptions20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ExposureOptions20"))
		{	*type = SOAP_TYPE_tt__ExposureOptions20;
			return soap_in_tt__ExposureOptions20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:BacklightCompensationOptions20"))
		{	*type = SOAP_TYPE_tt__BacklightCompensationOptions20;
			return soap_in_tt__BacklightCompensationOptions20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:WideDynamicRangeOptions20"))
		{	*type = SOAP_TYPE_tt__WideDynamicRangeOptions20;
			return soap_in_tt__WideDynamicRangeOptions20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingOptions20Extension"))
		{	*type = SOAP_TYPE_tt__ImagingOptions20Extension;
			return soap_in_tt__ImagingOptions20Extension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingOptions20"))
		{	*type = SOAP_TYPE_tt__ImagingOptions20;
			return soap_in_tt__ImagingOptions20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Exposure20"))
		{	*type = SOAP_TYPE_tt__Exposure20;
			return soap_in_tt__Exposure20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:BacklightCompensation20"))
		{	*type = SOAP_TYPE_tt__BacklightCompensation20;
			return soap_in_tt__BacklightCompensation20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:WideDynamicRange20"))
		{	*type = SOAP_TYPE_tt__WideDynamicRange20;
			return soap_in_tt__WideDynamicRange20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingSettingsExtension20"))
		{	*type = SOAP_TYPE_tt__ImagingSettingsExtension20;
			return soap_in_tt__ImagingSettingsExtension20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingSettings20"))
		{	*type = SOAP_TYPE_tt__ImagingSettings20;
			return soap_in_tt__ImagingSettings20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FocusStatus20Extension"))
		{	*type = SOAP_TYPE_tt__FocusStatus20Extension;
			return soap_in_tt__FocusStatus20Extension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FocusStatus20"))
		{	*type = SOAP_TYPE_tt__FocusStatus20;
			return soap_in_tt__FocusStatus20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingStatus20Extension"))
		{	*type = SOAP_TYPE_tt__ImagingStatus20Extension;
			return soap_in_tt__ImagingStatus20Extension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingStatus20"))
		{	*type = SOAP_TYPE_tt__ImagingStatus20;
			return soap_in_tt__ImagingStatus20(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:WhiteBalance"))
		{	*type = SOAP_TYPE_tt__WhiteBalance;
			return soap_in_tt__WhiteBalance(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ContinuousFocusOptions"))
		{	*type = SOAP_TYPE_tt__ContinuousFocusOptions;
			return soap_in_tt__ContinuousFocusOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RelativeFocusOptions"))
		{	*type = SOAP_TYPE_tt__RelativeFocusOptions;
			return soap_in_tt__RelativeFocusOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AbsoluteFocusOptions"))
		{	*type = SOAP_TYPE_tt__AbsoluteFocusOptions;
			return soap_in_tt__AbsoluteFocusOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MoveOptions"))
		{	*type = SOAP_TYPE_tt__MoveOptions;
			return soap_in_tt__MoveOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ContinuousFocus"))
		{	*type = SOAP_TYPE_tt__ContinuousFocus;
			return soap_in_tt__ContinuousFocus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RelativeFocus"))
		{	*type = SOAP_TYPE_tt__RelativeFocus;
			return soap_in_tt__RelativeFocus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AbsoluteFocus"))
		{	*type = SOAP_TYPE_tt__AbsoluteFocus;
			return soap_in_tt__AbsoluteFocus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FocusMove"))
		{	*type = SOAP_TYPE_tt__FocusMove;
			return soap_in_tt__FocusMove(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:WhiteBalanceOptions"))
		{	*type = SOAP_TYPE_tt__WhiteBalanceOptions;
			return soap_in_tt__WhiteBalanceOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ExposureOptions"))
		{	*type = SOAP_TYPE_tt__ExposureOptions;
			return soap_in_tt__ExposureOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FocusOptions"))
		{	*type = SOAP_TYPE_tt__FocusOptions;
			return soap_in_tt__FocusOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:BacklightCompensationOptions"))
		{	*type = SOAP_TYPE_tt__BacklightCompensationOptions;
			return soap_in_tt__BacklightCompensationOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:WideDynamicRangeOptions"))
		{	*type = SOAP_TYPE_tt__WideDynamicRangeOptions;
			return soap_in_tt__WideDynamicRangeOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingOptions"))
		{	*type = SOAP_TYPE_tt__ImagingOptions;
			return soap_in_tt__ImagingOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:BacklightCompensation"))
		{	*type = SOAP_TYPE_tt__BacklightCompensation;
			return soap_in_tt__BacklightCompensation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:WideDynamicRange"))
		{	*type = SOAP_TYPE_tt__WideDynamicRange;
			return soap_in_tt__WideDynamicRange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Exposure"))
		{	*type = SOAP_TYPE_tt__Exposure;
			return soap_in_tt__Exposure(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingSettingsExtension"))
		{	*type = SOAP_TYPE_tt__ImagingSettingsExtension;
			return soap_in_tt__ImagingSettingsExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingSettings"))
		{	*type = SOAP_TYPE_tt__ImagingSettings;
			return soap_in_tt__ImagingSettings(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FocusConfiguration"))
		{	*type = SOAP_TYPE_tt__FocusConfiguration;
			return soap_in_tt__FocusConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FocusStatus"))
		{	*type = SOAP_TYPE_tt__FocusStatus;
			return soap_in_tt__FocusStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingStatus"))
		{	*type = SOAP_TYPE_tt__ImagingStatus;
			return soap_in_tt__ImagingStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZMoveStatus"))
		{	*type = SOAP_TYPE_tt__PTZMoveStatus;
			return soap_in_tt__PTZMoveStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPreset"))
		{	*type = SOAP_TYPE_tt__PTZPreset;
			return soap_in_tt__PTZPreset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZStatus"))
		{	*type = SOAP_TYPE_tt__PTZStatus;
			return soap_in_tt__PTZStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZSpeed"))
		{	*type = SOAP_TYPE_tt__PTZSpeed;
			return soap_in_tt__PTZSpeed(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZVector"))
		{	*type = SOAP_TYPE_tt__PTZVector;
			return soap_in_tt__PTZVector(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Vector1D"))
		{	*type = SOAP_TYPE_tt__Vector1D;
			return soap_in_tt__Vector1D(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Vector2D"))
		{	*type = SOAP_TYPE_tt__Vector2D;
			return soap_in_tt__Vector2D(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Space1DDescription"))
		{	*type = SOAP_TYPE_tt__Space1DDescription;
			return soap_in_tt__Space1DDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Space2DDescription"))
		{	*type = SOAP_TYPE_tt__Space2DDescription;
			return soap_in_tt__Space2DDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZSpacesExtension"))
		{	*type = SOAP_TYPE_tt__PTZSpacesExtension;
			return soap_in_tt__PTZSpacesExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZSpaces"))
		{	*type = SOAP_TYPE_tt__PTZSpaces;
			return soap_in_tt__PTZSpaces(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ZoomLimits"))
		{	*type = SOAP_TYPE_tt__ZoomLimits;
			return soap_in_tt__ZoomLimits(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PanTiltLimits"))
		{	*type = SOAP_TYPE_tt__PanTiltLimits;
			return soap_in_tt__PanTiltLimits(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZConfigurationOptions"))
		{	*type = SOAP_TYPE_tt__PTZConfigurationOptions;
			return soap_in_tt__PTZConfigurationOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZConfigurationExtension"))
		{	*type = SOAP_TYPE_tt__PTZConfigurationExtension;
			return soap_in_tt__PTZConfigurationExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZConfiguration"))
		{	*type = SOAP_TYPE_tt__PTZConfiguration;
			return soap_in_tt__PTZConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZNodeExtension"))
		{	*type = SOAP_TYPE_tt__PTZNodeExtension;
			return soap_in_tt__PTZNodeExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZNode"))
		{	*type = SOAP_TYPE_tt__PTZNode;
			return soap_in_tt__PTZNode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RelayOutput"))
		{	*type = SOAP_TYPE_tt__RelayOutput;
			return soap_in_tt__RelayOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RelayOutputSettings"))
		{	*type = SOAP_TYPE_tt__RelayOutputSettings;
			return soap_in_tt__RelayOutputSettings(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:CertificateStatus"))
		{	*type = SOAP_TYPE_tt__CertificateStatus;
			return soap_in_tt__CertificateStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Certificate"))
		{	*type = SOAP_TYPE_tt__Certificate;
			return soap_in_tt__Certificate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:CertificateGenerationParametersExtension"))
		{	*type = SOAP_TYPE_tt__CertificateGenerationParametersExtension;
			return soap_in_tt__CertificateGenerationParametersExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:CertificateGenerationParameters"))
		{	*type = SOAP_TYPE_tt__CertificateGenerationParameters;
			return soap_in_tt__CertificateGenerationParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:UserExtension"))
		{	*type = SOAP_TYPE_tt__UserExtension;
			return soap_in_tt__UserExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:User"))
		{	*type = SOAP_TYPE_tt__User;
			return soap_in_tt__User(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:TimeZone"))
		{	*type = SOAP_TYPE_tt__TimeZone;
			return soap_in_tt__TimeZone(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Time"))
		{	*type = SOAP_TYPE_tt__Time;
			return soap_in_tt__Time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Date"))
		{	*type = SOAP_TYPE_tt__Date;
			return soap_in_tt__Date(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DateTime"))
		{	*type = SOAP_TYPE_tt__DateTime;
			return soap_in_tt__DateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SystemDateTimeExtension"))
		{	*type = SOAP_TYPE_tt__SystemDateTimeExtension;
			return soap_in_tt__SystemDateTimeExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SystemDateTime"))
		{	*type = SOAP_TYPE_tt__SystemDateTime;
			return soap_in_tt__SystemDateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:BackupFile"))
		{	*type = SOAP_TYPE_tt__BackupFile;
			return soap_in_tt__BackupFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AttachmentData"))
		{	*type = SOAP_TYPE_tt__AttachmentData;
			return soap_in_tt__AttachmentData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:BinaryData"))
		{	*type = SOAP_TYPE_tt__BinaryData;
			return soap_in_tt__BinaryData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SupportInformation"))
		{	*type = SOAP_TYPE_tt__SupportInformation;
			return soap_in_tt__SupportInformation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SystemLog"))
		{	*type = SOAP_TYPE_tt__SystemLog;
			return soap_in_tt__SystemLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZCapabilities"))
		{	*type = SOAP_TYPE_tt__PTZCapabilities;
			return soap_in_tt__PTZCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingCapabilities"))
		{	*type = SOAP_TYPE_tt__ImagingCapabilities;
			return soap_in_tt__ImagingCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:OnvifVersion"))
		{	*type = SOAP_TYPE_tt__OnvifVersion;
			return soap_in_tt__OnvifVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SystemCapabilitiesExtension"))
		{	*type = SOAP_TYPE_tt__SystemCapabilitiesExtension;
			return soap_in_tt__SystemCapabilitiesExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SystemCapabilities"))
		{	*type = SOAP_TYPE_tt__SystemCapabilities;
			return soap_in_tt__SystemCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:StorageCapabilities"))
		{	*type = SOAP_TYPE_tt__StorageCapabilities;
			return soap_in_tt__StorageCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SecurityCapabilitiesExtension"))
		{	*type = SOAP_TYPE_tt__SecurityCapabilitiesExtension;
			return soap_in_tt__SecurityCapabilitiesExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SecurityCapabilities"))
		{	*type = SOAP_TYPE_tt__SecurityCapabilities;
			return soap_in_tt__SecurityCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkCapabilitiesExtension"))
		{	*type = SOAP_TYPE_tt__NetworkCapabilitiesExtension;
			return soap_in_tt__NetworkCapabilitiesExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkCapabilities"))
		{	*type = SOAP_TYPE_tt__NetworkCapabilities;
			return soap_in_tt__NetworkCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ProfileCapabilities"))
		{	*type = SOAP_TYPE_tt__ProfileCapabilities;
			return soap_in_tt__ProfileCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RealTimeStreamingCapabilitiesExtension"))
		{	*type = SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension;
			return soap_in_tt__RealTimeStreamingCapabilitiesExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RealTimeStreamingCapabilities"))
		{	*type = SOAP_TYPE_tt__RealTimeStreamingCapabilities;
			return soap_in_tt__RealTimeStreamingCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MediaCapabilitiesExtension"))
		{	*type = SOAP_TYPE_tt__MediaCapabilitiesExtension;
			return soap_in_tt__MediaCapabilitiesExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MediaCapabilities"))
		{	*type = SOAP_TYPE_tt__MediaCapabilities;
			return soap_in_tt__MediaCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IOCapabilitiesExtension"))
		{	*type = SOAP_TYPE_tt__IOCapabilitiesExtension;
			return soap_in_tt__IOCapabilitiesExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IOCapabilities"))
		{	*type = SOAP_TYPE_tt__IOCapabilities;
			return soap_in_tt__IOCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:EventCapabilities"))
		{	*type = SOAP_TYPE_tt__EventCapabilities;
			return soap_in_tt__EventCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DeviceCapabilitiesExtension"))
		{	*type = SOAP_TYPE_tt__DeviceCapabilitiesExtension;
			return soap_in_tt__DeviceCapabilitiesExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DeviceCapabilities"))
		{	*type = SOAP_TYPE_tt__DeviceCapabilities;
			return soap_in_tt__DeviceCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AnalyticsCapabilities"))
		{	*type = SOAP_TYPE_tt__AnalyticsCapabilities;
			return soap_in_tt__AnalyticsCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:CapabilitiesExtension"))
		{	*type = SOAP_TYPE_tt__CapabilitiesExtension;
			return soap_in_tt__CapabilitiesExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Capabilities"))
		{	*type = SOAP_TYPE_tt__Capabilities;
			return soap_in_tt__Capabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPAddressFilterExtension"))
		{	*type = SOAP_TYPE_tt__IPAddressFilterExtension;
			return soap_in_tt__IPAddressFilterExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPAddressFilter"))
		{	*type = SOAP_TYPE_tt__IPAddressFilter;
			return soap_in_tt__IPAddressFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkZeroConfigurationExtension"))
		{	*type = SOAP_TYPE_tt__NetworkZeroConfigurationExtension;
			return soap_in_tt__NetworkZeroConfigurationExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkZeroConfiguration"))
		{	*type = SOAP_TYPE_tt__NetworkZeroConfiguration;
			return soap_in_tt__NetworkZeroConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkGateway"))
		{	*type = SOAP_TYPE_tt__NetworkGateway;
			return soap_in_tt__NetworkGateway(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv4NetworkInterfaceSetConfiguration"))
		{	*type = SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration;
			return soap_in_tt__IPv4NetworkInterfaceSetConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv6NetworkInterfaceSetConfiguration"))
		{	*type = SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration;
			return soap_in_tt__IPv6NetworkInterfaceSetConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkInterfaceSetConfigurationExtension"))
		{	*type = SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension;
			return soap_in_tt__NetworkInterfaceSetConfigurationExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkInterfaceSetConfiguration"))
		{	*type = SOAP_TYPE_tt__NetworkInterfaceSetConfiguration;
			return soap_in_tt__NetworkInterfaceSetConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DynamicDNSInformationExtension"))
		{	*type = SOAP_TYPE_tt__DynamicDNSInformationExtension;
			return soap_in_tt__DynamicDNSInformationExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DynamicDNSInformation"))
		{	*type = SOAP_TYPE_tt__DynamicDNSInformation;
			return soap_in_tt__DynamicDNSInformation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NTPInformationExtension"))
		{	*type = SOAP_TYPE_tt__NTPInformationExtension;
			return soap_in_tt__NTPInformationExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NTPInformation"))
		{	*type = SOAP_TYPE_tt__NTPInformation;
			return soap_in_tt__NTPInformation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DNSInformationExtension"))
		{	*type = SOAP_TYPE_tt__DNSInformationExtension;
			return soap_in_tt__DNSInformationExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DNSInformation"))
		{	*type = SOAP_TYPE_tt__DNSInformation;
			return soap_in_tt__DNSInformation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:HostnameInformationExtension"))
		{	*type = SOAP_TYPE_tt__HostnameInformationExtension;
			return soap_in_tt__HostnameInformationExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:HostnameInformation"))
		{	*type = SOAP_TYPE_tt__HostnameInformation;
			return soap_in_tt__HostnameInformation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PrefixedIPv6Address"))
		{	*type = SOAP_TYPE_tt__PrefixedIPv6Address;
			return soap_in_tt__PrefixedIPv6Address(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PrefixedIPv4Address"))
		{	*type = SOAP_TYPE_tt__PrefixedIPv4Address;
			return soap_in_tt__PrefixedIPv4Address(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPAddress"))
		{	*type = SOAP_TYPE_tt__IPAddress;
			return soap_in_tt__IPAddress(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkHostExtension"))
		{	*type = SOAP_TYPE_tt__NetworkHostExtension;
			return soap_in_tt__NetworkHostExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkHost"))
		{	*type = SOAP_TYPE_tt__NetworkHost;
			return soap_in_tt__NetworkHost(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkProtocolExtension"))
		{	*type = SOAP_TYPE_tt__NetworkProtocolExtension;
			return soap_in_tt__NetworkProtocolExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkProtocol"))
		{	*type = SOAP_TYPE_tt__NetworkProtocol;
			return soap_in_tt__NetworkProtocol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv6ConfigurationExtension"))
		{	*type = SOAP_TYPE_tt__IPv6ConfigurationExtension;
			return soap_in_tt__IPv6ConfigurationExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv6Configuration"))
		{	*type = SOAP_TYPE_tt__IPv6Configuration;
			return soap_in_tt__IPv6Configuration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv4Configuration"))
		{	*type = SOAP_TYPE_tt__IPv4Configuration;
			return soap_in_tt__IPv4Configuration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv4NetworkInterface"))
		{	*type = SOAP_TYPE_tt__IPv4NetworkInterface;
			return soap_in_tt__IPv4NetworkInterface(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv6NetworkInterface"))
		{	*type = SOAP_TYPE_tt__IPv6NetworkInterface;
			return soap_in_tt__IPv6NetworkInterface(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkInterfaceInfo"))
		{	*type = SOAP_TYPE_tt__NetworkInterfaceInfo;
			return soap_in_tt__NetworkInterfaceInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkInterfaceConnectionSetting"))
		{	*type = SOAP_TYPE_tt__NetworkInterfaceConnectionSetting;
			return soap_in_tt__NetworkInterfaceConnectionSetting(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkInterfaceLink"))
		{	*type = SOAP_TYPE_tt__NetworkInterfaceLink;
			return soap_in_tt__NetworkInterfaceLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkInterfaceExtension"))
		{	*type = SOAP_TYPE_tt__NetworkInterfaceExtension;
			return soap_in_tt__NetworkInterfaceExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkInterface"))
		{	*type = SOAP_TYPE_tt__NetworkInterface;
			return soap_in_tt__NetworkInterface(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Scope"))
		{	*type = SOAP_TYPE_tt__Scope;
			return soap_in_tt__Scope(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MediaUri"))
		{	*type = SOAP_TYPE_tt__MediaUri;
			return soap_in_tt__MediaUri(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Transport"))
		{	*type = SOAP_TYPE_tt__Transport;
			return soap_in_tt__Transport(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:StreamSetup"))
		{	*type = SOAP_TYPE_tt__StreamSetup;
			return soap_in_tt__StreamSetup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MulticastConfiguration"))
		{	*type = SOAP_TYPE_tt__MulticastConfiguration;
			return soap_in_tt__MulticastConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZStatusFilterOptions"))
		{	*type = SOAP_TYPE_tt__PTZStatusFilterOptions;
			return soap_in_tt__PTZStatusFilterOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MetadataConfigurationOptions"))
		{	*type = SOAP_TYPE_tt__MetadataConfigurationOptions;
			return soap_in_tt__MetadataConfigurationOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:EventSubscription"))
		{	*type = SOAP_TYPE_tt__EventSubscription;
			return soap_in_tt__EventSubscription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZFilter"))
		{	*type = SOAP_TYPE_tt__PTZFilter;
			return soap_in_tt__PTZFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MetadataConfiguration"))
		{	*type = SOAP_TYPE_tt__MetadataConfiguration;
			return soap_in_tt__MetadataConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoAnalyticsConfiguration"))
		{	*type = SOAP_TYPE_tt__VideoAnalyticsConfiguration;
			return soap_in_tt__VideoAnalyticsConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AudioEncoderConfigurationOption"))
		{	*type = SOAP_TYPE_tt__AudioEncoderConfigurationOption;
			return soap_in_tt__AudioEncoderConfigurationOption(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AudioEncoderConfigurationOptions"))
		{	*type = SOAP_TYPE_tt__AudioEncoderConfigurationOptions;
			return soap_in_tt__AudioEncoderConfigurationOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AudioEncoderConfiguration"))
		{	*type = SOAP_TYPE_tt__AudioEncoderConfiguration;
			return soap_in_tt__AudioEncoderConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AudioSourceOptionsExtension"))
		{	*type = SOAP_TYPE_tt__AudioSourceOptionsExtension;
			return soap_in_tt__AudioSourceOptionsExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AudioSourceConfigurationOptions"))
		{	*type = SOAP_TYPE_tt__AudioSourceConfigurationOptions;
			return soap_in_tt__AudioSourceConfigurationOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AudioSourceConfiguration"))
		{	*type = SOAP_TYPE_tt__AudioSourceConfiguration;
			return soap_in_tt__AudioSourceConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:H264Options"))
		{	*type = SOAP_TYPE_tt__H264Options;
			return soap_in_tt__H264Options(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Mpeg4Options"))
		{	*type = SOAP_TYPE_tt__Mpeg4Options;
			return soap_in_tt__Mpeg4Options(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:JpegOptions"))
		{	*type = SOAP_TYPE_tt__JpegOptions;
			return soap_in_tt__JpegOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoEncoderOptionsExtension"))
		{	*type = SOAP_TYPE_tt__VideoEncoderOptionsExtension;
			return soap_in_tt__VideoEncoderOptionsExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoEncoderConfigurationOptions"))
		{	*type = SOAP_TYPE_tt__VideoEncoderConfigurationOptions;
			return soap_in_tt__VideoEncoderConfigurationOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:H264Configuration"))
		{	*type = SOAP_TYPE_tt__H264Configuration;
			return soap_in_tt__H264Configuration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Mpeg4Configuration"))
		{	*type = SOAP_TYPE_tt__Mpeg4Configuration;
			return soap_in_tt__Mpeg4Configuration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoRateControl"))
		{	*type = SOAP_TYPE_tt__VideoRateControl;
			return soap_in_tt__VideoRateControl(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoResolution"))
		{	*type = SOAP_TYPE_tt__VideoResolution;
			return soap_in_tt__VideoResolution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoEncoderConfiguration"))
		{	*type = SOAP_TYPE_tt__VideoEncoderConfiguration;
			return soap_in_tt__VideoEncoderConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoSourceConfigurationOptionsExtension"))
		{	*type = SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension;
			return soap_in_tt__VideoSourceConfigurationOptionsExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoSourceConfigurationOptions"))
		{	*type = SOAP_TYPE_tt__VideoSourceConfigurationOptions;
			return soap_in_tt__VideoSourceConfigurationOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoSourceConfiguration"))
		{	*type = SOAP_TYPE_tt__VideoSourceConfiguration;
			return soap_in_tt__VideoSourceConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ConfigurationEntity"))
		{	*type = SOAP_TYPE_tt__ConfigurationEntity;
			return soap_in_tt__ConfigurationEntity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ProfileExtension"))
		{	*type = SOAP_TYPE_tt__ProfileExtension;
			return soap_in_tt__ProfileExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Profile"))
		{	*type = SOAP_TYPE_tt__Profile;
			return soap_in_tt__Profile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AudioSource"))
		{	*type = SOAP_TYPE_tt__AudioSource;
			return soap_in_tt__AudioSource(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoSourceExtension"))
		{	*type = SOAP_TYPE_tt__VideoSourceExtension;
			return soap_in_tt__VideoSourceExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoSource"))
		{	*type = SOAP_TYPE_tt__VideoSource;
			return soap_in_tt__VideoSource(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IntList"))
		{	*type = SOAP_TYPE_tt__IntList;
			return soap_in_tt__IntList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DurationRange"))
		{	*type = SOAP_TYPE_tt__DurationRange;
			return soap_in_tt__DurationRange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FloatRange"))
		{	*type = SOAP_TYPE_tt__FloatRange;
			return soap_in_tt__FloatRange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IntRange"))
		{	*type = SOAP_TYPE_tt__IntRange;
			return soap_in_tt__IntRange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IntRectangleRange"))
		{	*type = SOAP_TYPE_tt__IntRectangleRange;
			return soap_in_tt__IntRectangleRange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IntRectangle"))
		{	*type = SOAP_TYPE_tt__IntRectangle;
			return soap_in_tt__IntRectangle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DeviceEntity"))
		{	*type = SOAP_TYPE_tt__DeviceEntity;
			return soap_in_tt__DeviceEntity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:token"))
		{	*type = SOAP_TYPE_xsd__token;
			return soap_in_xsd__token(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	*type = SOAP_TYPE_xsd__nonNegativeInteger;
			return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	*type = SOAP_TYPE_xsd__integer;
			return soap_in_xsd__integer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anySimpleType"))
		{	*type = SOAP_TYPE_xsd__anySimpleType;
			return soap_in_xsd__anySimpleType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName;
			return soap_in_xsd__QName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:NCName"))
		{	*type = SOAP_TYPE_xsd__NCName;
			return soap_in_xsd__NCName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IANA-IfTypes"))
		{	*type = SOAP_TYPE_tt__IANA_IfTypes;
			return soap_in_tt__IANA_IfTypes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration;
			return soap_in_xsd__duration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLONG64;
			return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ClassType"))
		{	*type = SOAP_TYPE_tt__ClassType;
			return soap_in_tt__ClassType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Direction"))
		{	*type = SOAP_TYPE_tt__Direction;
			return soap_in_tt__Direction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PropertyOperation"))
		{	*type = SOAP_TYPE_tt__PropertyOperation;
			return soap_in_tt__PropertyOperation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IrCutFilterMode"))
		{	*type = SOAP_TYPE_tt__IrCutFilterMode;
			return soap_in_tt__IrCutFilterMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:WhiteBalanceMode"))
		{	*type = SOAP_TYPE_tt__WhiteBalanceMode;
			return soap_in_tt__WhiteBalanceMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Enabled"))
		{	*type = SOAP_TYPE_tt__Enabled;
			return soap_in_tt__Enabled(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ExposureMode"))
		{	*type = SOAP_TYPE_tt__ExposureMode;
			return soap_in_tt__ExposureMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ExposurePriority"))
		{	*type = SOAP_TYPE_tt__ExposurePriority;
			return soap_in_tt__ExposurePriority(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:BacklightCompensationMode"))
		{	*type = SOAP_TYPE_tt__BacklightCompensationMode;
			return soap_in_tt__BacklightCompensationMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:WideDynamicMode"))
		{	*type = SOAP_TYPE_tt__WideDynamicMode;
			return soap_in_tt__WideDynamicMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AutoFocusMode"))
		{	*type = SOAP_TYPE_tt__AutoFocusMode;
			return soap_in_tt__AutoFocusMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MoveStatus"))
		{	*type = SOAP_TYPE_tt__MoveStatus;
			return soap_in_tt__MoveStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RelayMode"))
		{	*type = SOAP_TYPE_tt__RelayMode;
			return soap_in_tt__RelayMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RelayIdleState"))
		{	*type = SOAP_TYPE_tt__RelayIdleState;
			return soap_in_tt__RelayIdleState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RelayLogicalState"))
		{	*type = SOAP_TYPE_tt__RelayLogicalState;
			return soap_in_tt__RelayLogicalState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:UserLevel"))
		{	*type = SOAP_TYPE_tt__UserLevel;
			return soap_in_tt__UserLevel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SetDateTimeType"))
		{	*type = SOAP_TYPE_tt__SetDateTimeType;
			return soap_in_tt__SetDateTimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FactoryDefaultType"))
		{	*type = SOAP_TYPE_tt__FactoryDefaultType;
			return soap_in_tt__FactoryDefaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SystemLogType"))
		{	*type = SOAP_TYPE_tt__SystemLogType;
			return soap_in_tt__SystemLogType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:CapabilityCategory"))
		{	*type = SOAP_TYPE_tt__CapabilityCategory;
			return soap_in_tt__CapabilityCategory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DynamicDNSType"))
		{	*type = SOAP_TYPE_tt__DynamicDNSType;
			return soap_in_tt__DynamicDNSType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPAddressFilterType"))
		{	*type = SOAP_TYPE_tt__IPAddressFilterType;
			return soap_in_tt__IPAddressFilterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPType"))
		{	*type = SOAP_TYPE_tt__IPType;
			return soap_in_tt__IPType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkHostType"))
		{	*type = SOAP_TYPE_tt__NetworkHostType;
			return soap_in_tt__NetworkHostType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkProtocolType"))
		{	*type = SOAP_TYPE_tt__NetworkProtocolType;
			return soap_in_tt__NetworkProtocolType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv6DHCPConfiguration"))
		{	*type = SOAP_TYPE_tt__IPv6DHCPConfiguration;
			return soap_in_tt__IPv6DHCPConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Duplex"))
		{	*type = SOAP_TYPE_tt__Duplex;
			return soap_in_tt__Duplex(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DiscoveryMode"))
		{	*type = SOAP_TYPE_tt__DiscoveryMode;
			return soap_in_tt__DiscoveryMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ScopeDefinition"))
		{	*type = SOAP_TYPE_tt__ScopeDefinition;
			return soap_in_tt__ScopeDefinition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:TransportProtocol"))
		{	*type = SOAP_TYPE_tt__TransportProtocol;
			return soap_in_tt__TransportProtocol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:StreamType"))
		{	*type = SOAP_TYPE_tt__StreamType;
			return soap_in_tt__StreamType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AudioEncoding"))
		{	*type = SOAP_TYPE_tt__AudioEncoding;
			return soap_in_tt__AudioEncoding(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:H264Profile"))
		{	*type = SOAP_TYPE_tt__H264Profile;
			return soap_in_tt__H264Profile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Mpeg4Profile"))
		{	*type = SOAP_TYPE_tt__Mpeg4Profile;
			return soap_in_tt__Mpeg4Profile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:VideoEncoding"))
		{	*type = SOAP_TYPE_tt__VideoEncoding;
			return soap_in_tt__VideoEncoding(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:FaultcodeEnum"))
		{	*type = SOAP_TYPE_wsse__FaultcodeEnum;
			return soap_in_wsse__FaultcodeEnum(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsu:tTimestampFault"))
		{	*type = SOAP_TYPE_wsu__tTimestampFault;
			return soap_in_wsu__tTimestampFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:IsReferenceParameter"))
		{	*type = SOAP_TYPE__wsa5__IsReferenceParameter;
			return soap_in__wsa5__IsReferenceParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesType"))
		{	*type = SOAP_TYPE_wsa5__FaultCodesType;
			return soap_in_wsa5__FaultCodesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipType"))
		{	*type = SOAP_TYPE_wsa5__RelationshipType;
			return soap_in_wsa5__RelationshipType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:RSAKeyValueType"))
		{	*type = SOAP_TYPE_ds__RSAKeyValueType;
			return soap_in_ds__RSAKeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:DSAKeyValueType"))
		{	*type = SOAP_TYPE_ds__DSAKeyValueType;
			return soap_in_ds__DSAKeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:X509IssuerSerialType"))
		{	*type = SOAP_TYPE_ds__X509IssuerSerialType;
			return soap_in_ds__X509IssuerSerialType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:X509DataType"))
		{	*type = SOAP_TYPE_ds__X509DataType;
			return soap_in_ds__X509DataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:RetrievalMethodType"))
		{	*type = SOAP_TYPE_ds__RetrievalMethodType;
			return soap_in_ds__RetrievalMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyValueType"))
		{	*type = SOAP_TYPE_ds__KeyValueType;
			return soap_in_ds__KeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:DigestMethodType"))
		{	*type = SOAP_TYPE_ds__DigestMethodType;
			return soap_in_ds__DigestMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:TransformType"))
		{	*type = SOAP_TYPE_ds__TransformType;
			return soap_in_ds__TransformType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:TransformsType"))
		{	*type = SOAP_TYPE_ds__TransformsType;
			return soap_in_ds__TransformsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:ReferenceType"))
		{	*type = SOAP_TYPE_ds__ReferenceType;
			return soap_in_ds__ReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureMethodType"))
		{	*type = SOAP_TYPE_ds__SignatureMethodType;
			return soap_in_ds__SignatureMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:CanonicalizationMethodType"))
		{	*type = SOAP_TYPE_ds__CanonicalizationMethodType;
			return soap_in_ds__CanonicalizationMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyInfoType"))
		{	*type = SOAP_TYPE_ds__KeyInfoType;
			return soap_in_ds__KeyInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignedInfoType"))
		{	*type = SOAP_TYPE_ds__SignedInfoType;
			return soap_in_ds__SignedInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureType"))
		{	*type = SOAP_TYPE_ds__SignatureType;
			return soap_in_ds__SignatureType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemActionType"))
		{	*type = SOAP_TYPE_wsa5__ProblemActionType;
			return soap_in_wsa5__ProblemActionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesToType"))
		{	*type = SOAP_TYPE_wsa5__RelatesToType;
			return soap_in_wsa5__RelatesToType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:MetadataType"))
		{	*type = SOAP_TYPE_wsa5__MetadataType;
			return soap_in_wsa5__MetadataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParametersType"))
		{	*type = SOAP_TYPE_wsa5__ReferenceParametersType;
			return soap_in_wsa5__ReferenceParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReferenceType"))
		{	*type = SOAP_TYPE_wsa5__EndpointReferenceType;
			return soap_in_wsa5__EndpointReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyAttribute"))
		{	*type = SOAP_TYPE_xsd__anyAttribute;
			return soap_in_xsd__anyAttribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemHeaderQName;
			s = soap_in__wsa5__ProblemHeaderQName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesOpenEnumType"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__FaultCodesOpenEnumType;
			s = soap_in_wsa5__FaultCodesOpenEnumType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipTypeOpenEnum"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__RelationshipTypeOpenEnum;
			s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "wsa5:RetryAfter"))
		{	*type = SOAP_TYPE__wsa5__RetryAfter;
			return soap_in__wsa5__RetryAfter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wstop:TopicNamespaceType-Topic"))
		{	*type = SOAP_TYPE__wstop__TopicNamespaceType_Topic;
			return soap_in__wstop__TopicNamespaceType_Topic(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfbf:BaseFaultType-FaultCause"))
		{	*type = SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause;
			return soap_in__wsrfbf__BaseFaultType_FaultCause(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfbf:BaseFaultType-Description"))
		{	*type = SOAP_TYPE__wsrfbf__BaseFaultType_Description;
			return soap_in__wsrfbf__BaseFaultType_Description(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrfbf:BaseFaultType-ErrorCode"))
		{	*type = SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode;
			return soap_in__wsrfbf__BaseFaultType_ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:Subscribe-SubscriptionPolicy"))
		{	*type = SOAP_TYPE__wsnb__Subscribe_SubscriptionPolicy;
			return soap_in__wsnb__Subscribe_SubscriptionPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:NotificationMessageHolderType-Message"))
		{	*type = SOAP_TYPE__wsnb__NotificationMessageHolderType_Message;
			return soap_in__wsnb__NotificationMessageHolderType_Message(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ConfigDescription-Messages"))
		{	*type = SOAP_TYPE__tt__ConfigDescription_Messages;
			return soap_in__tt__ConfigDescription_Messages(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Behaviour-Idle"))
		{	*type = SOAP_TYPE__tt__Behaviour_Idle;
			return soap_in__tt__Behaviour_Idle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Behaviour-Removed"))
		{	*type = SOAP_TYPE__tt__Behaviour_Removed;
			return soap_in__tt__Behaviour_Removed(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ClassDescriptor-ClassCandidate"))
		{	*type = SOAP_TYPE__tt__ClassDescriptor_ClassCandidate;
			return soap_in__tt__ClassDescriptor_ClassCandidate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ColorDescriptor-ColorCluster"))
		{	*type = SOAP_TYPE__tt__ColorDescriptor_ColorCluster;
			return soap_in__tt__ColorDescriptor_ColorCluster(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ItemListDescription-ElementItemDescription"))
		{	*type = SOAP_TYPE__tt__ItemListDescription_ElementItemDescription;
			return soap_in__tt__ItemListDescription_ElementItemDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ItemListDescription-SimpleItemDescription"))
		{	*type = SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription;
			return soap_in__tt__ItemListDescription_SimpleItemDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ItemList-ElementItem"))
		{	*type = SOAP_TYPE__tt__ItemList_ElementItem;
			return soap_in__tt__ItemList_ElementItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ItemList-SimpleItem"))
		{	*type = SOAP_TYPE__tt__ItemList_SimpleItem;
			return soap_in__tt__ItemList_SimpleItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:EventSubscription-SubscriptionPolicy"))
		{	*type = SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy;
			return soap_in__tt__EventSubscription_SubscriptionPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:ResumeSubscriptionResponse"))
		{	*type = SOAP_TYPE__wsnb__ResumeSubscriptionResponse;
			return soap_in__wsnb__ResumeSubscriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:ResumeSubscription"))
		{	*type = SOAP_TYPE__wsnb__ResumeSubscription;
			return soap_in__wsnb__ResumeSubscription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:PauseSubscriptionResponse"))
		{	*type = SOAP_TYPE__wsnb__PauseSubscriptionResponse;
			return soap_in__wsnb__PauseSubscriptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:PauseSubscription"))
		{	*type = SOAP_TYPE__wsnb__PauseSubscription;
			return soap_in__wsnb__PauseSubscription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:UnsubscribeResponse"))
		{	*type = SOAP_TYPE__wsnb__UnsubscribeResponse;
			return soap_in__wsnb__UnsubscribeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:Unsubscribe"))
		{	*type = SOAP_TYPE__wsnb__Unsubscribe;
			return soap_in__wsnb__Unsubscribe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:RenewResponse"))
		{	*type = SOAP_TYPE__wsnb__RenewResponse;
			return soap_in__wsnb__RenewResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:Renew"))
		{	*type = SOAP_TYPE__wsnb__Renew;
			return soap_in__wsnb__Renew(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:CreatePullPointResponse"))
		{	*type = SOAP_TYPE__wsnb__CreatePullPointResponse;
			return soap_in__wsnb__CreatePullPointResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:CreatePullPoint"))
		{	*type = SOAP_TYPE__wsnb__CreatePullPoint;
			return soap_in__wsnb__CreatePullPoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:DestroyPullPointResponse"))
		{	*type = SOAP_TYPE__wsnb__DestroyPullPointResponse;
			return soap_in__wsnb__DestroyPullPointResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:DestroyPullPoint"))
		{	*type = SOAP_TYPE__wsnb__DestroyPullPoint;
			return soap_in__wsnb__DestroyPullPoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:GetMessagesResponse"))
		{	*type = SOAP_TYPE__wsnb__GetMessagesResponse;
			return soap_in__wsnb__GetMessagesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:GetMessages"))
		{	*type = SOAP_TYPE__wsnb__GetMessages;
			return soap_in__wsnb__GetMessages(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:GetCurrentMessageResponse"))
		{	*type = SOAP_TYPE__wsnb__GetCurrentMessageResponse;
			return soap_in__wsnb__GetCurrentMessageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:GetCurrentMessage"))
		{	*type = SOAP_TYPE__wsnb__GetCurrentMessage;
			return soap_in__wsnb__GetCurrentMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:SubscribeResponse"))
		{	*type = SOAP_TYPE__wsnb__SubscribeResponse;
			return soap_in__wsnb__SubscribeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:Subscribe"))
		{	*type = SOAP_TYPE__wsnb__Subscribe;
			return soap_in__wsnb__Subscribe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:UseRaw"))
		{	*type = SOAP_TYPE__wsnb__UseRaw;
			return soap_in__wsnb__UseRaw(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:Notify"))
		{	*type = SOAP_TYPE__wsnb__Notify;
			return soap_in__wsnb__Notify(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:SubscriptionManagerRP"))
		{	*type = SOAP_TYPE__wsnb__SubscriptionManagerRP;
			return soap_in__wsnb__SubscriptionManagerRP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsnb:NotificationProducerRP"))
		{	*type = SOAP_TYPE__wsnb__NotificationProducerRP;
			return soap_in__wsnb__NotificationProducerRP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Message"))
		{	*type = SOAP_TYPE__tt__Message;
			return soap_in__tt__Message(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tan:GetAnalyticsModulesResponse"))
		{	*type = SOAP_TYPE__tan__GetAnalyticsModulesResponse;
			return soap_in__tan__GetAnalyticsModulesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tan:GetAnalyticsModules"))
		{	*type = SOAP_TYPE__tan__GetAnalyticsModules;
			return soap_in__tan__GetAnalyticsModules(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tan:ModifyAnalyticsModulesResponse"))
		{	*type = SOAP_TYPE__tan__ModifyAnalyticsModulesResponse;
			return soap_in__tan__ModifyAnalyticsModulesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tan:ModifyAnalyticsModules"))
		{	*type = SOAP_TYPE__tan__ModifyAnalyticsModules;
			return soap_in__tan__ModifyAnalyticsModules(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tan:DeleteAnalyticsModulesResponse"))
		{	*type = SOAP_TYPE__tan__DeleteAnalyticsModulesResponse;
			return soap_in__tan__DeleteAnalyticsModulesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tan:DeleteAnalyticsModules"))
		{	*type = SOAP_TYPE__tan__DeleteAnalyticsModules;
			return soap_in__tan__DeleteAnalyticsModules(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tan:CreateAnalyticsModulesResponse"))
		{	*type = SOAP_TYPE__tan__CreateAnalyticsModulesResponse;
			return soap_in__tan__CreateAnalyticsModulesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tan:CreateAnalyticsModules"))
		{	*type = SOAP_TYPE__tan__CreateAnalyticsModules;
			return soap_in__tan__CreateAnalyticsModules(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tan:GetSupportedAnalyticsModulesResponse"))
		{	*type = SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse;
			return soap_in__tan__GetSupportedAnalyticsModulesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tan:GetSupportedAnalyticsModules"))
		{	*type = SOAP_TYPE__tan__GetSupportedAnalyticsModules;
			return soap_in__tan__GetSupportedAnalyticsModules(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tan:GetRulesResponse"))
		{	*type = SOAP_TYPE__tan__GetRulesResponse;
			return soap_in__tan__GetRulesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tan:GetRules"))
		{	*type = SOAP_TYPE__tan__GetRules;
			return soap_in__tan__GetRules(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tan:ModifyRulesResponse"))
		{	*type = SOAP_TYPE__tan__ModifyRulesResponse;
			return soap_in__tan__ModifyRulesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tan:ModifyRules"))
		{	*type = SOAP_TYPE__tan__ModifyRules;
			return soap_in__tan__ModifyRules(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tan:DeleteRulesResponse"))
		{	*type = SOAP_TYPE__tan__DeleteRulesResponse;
			return soap_in__tan__DeleteRulesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tan:DeleteRules"))
		{	*type = SOAP_TYPE__tan__DeleteRules;
			return soap_in__tan__DeleteRules(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tan:CreateRulesResponse"))
		{	*type = SOAP_TYPE__tan__CreateRulesResponse;
			return soap_in__tan__CreateRulesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tan:CreateRules"))
		{	*type = SOAP_TYPE__tan__CreateRules;
			return soap_in__tan__CreateRules(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tan:GetSupportedRulesResponse"))
		{	*type = SOAP_TYPE__tan__GetSupportedRulesResponse;
			return soap_in__tan__GetSupportedRulesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tan:GetSupportedRules"))
		{	*type = SOAP_TYPE__tan__GetSupportedRules;
			return soap_in__tan__GetSupportedRules(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xml:lang"))
		{	*type = SOAP_TYPE__xml__lang;
			return soap_in__xml__lang(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Security"))
		{	*type = SOAP_TYPE__wsse__Security;
			return soap_in__wsse__Security(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "c14n:InclusiveNamespaces"))
		{	*type = SOAP_TYPE__c14n__InclusiveNamespaces;
			return soap_in__c14n__InclusiveNamespaces(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:SecurityTokenReference"))
		{	*type = SOAP_TYPE__wsse__SecurityTokenReference;
			return soap_in__wsse__SecurityTokenReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:KeyIdentifier"))
		{	*type = SOAP_TYPE__wsse__KeyIdentifier;
			return soap_in__wsse__KeyIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Embedded"))
		{	*type = SOAP_TYPE__wsse__Embedded;
			return soap_in__wsse__Embedded(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Reference"))
		{	*type = SOAP_TYPE__wsse__Reference;
			return soap_in__wsse__Reference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:BinarySecurityToken"))
		{	*type = SOAP_TYPE__wsse__BinarySecurityToken;
			return soap_in__wsse__BinarySecurityToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Password"))
		{	*type = SOAP_TYPE__wsse__Password;
			return soap_in__wsse__Password(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:UsernameToken"))
		{	*type = SOAP_TYPE__wsse__UsernameToken;
			return soap_in__wsse__UsernameToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsu:Timestamp"))
		{	*type = SOAP_TYPE__wsu__Timestamp;
			return soap_in__wsu__Timestamp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemAction"))
		{	*type = SOAP_TYPE__wsa5__ProblemAction;
			return soap_in__wsa5__ProblemAction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultTo"))
		{	*type = SOAP_TYPE__wsa5__FaultTo;
			return soap_in__wsa5__FaultTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:From"))
		{	*type = SOAP_TYPE__wsa5__From;
			return soap_in__wsa5__From(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReplyTo"))
		{	*type = SOAP_TYPE__wsa5__ReplyTo;
			return soap_in__wsa5__ReplyTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesTo"))
		{	*type = SOAP_TYPE__wsa5__RelatesTo;
			return soap_in__wsa5__RelatesTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:Metadata"))
		{	*type = SOAP_TYPE__wsa5__Metadata;
			return soap_in__wsa5__Metadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParameters"))
		{	*type = SOAP_TYPE__wsa5__ReferenceParameters;
			return soap_in__wsa5__ReferenceParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReference"))
		{	*type = SOAP_TYPE__wsa5__EndpointReference;
			return soap_in__wsa5__EndpointReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xop:Include"))
		{	*type = SOAP_TYPE__xop__Include;
			return soap_in__xop__Include(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemIRI"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemIRI;
			s = soap_in__wsa5__ProblemIRI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:Action"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__Action;
			s = soap_in__wsa5__Action(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:To"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__To;
			s = soap_in__wsa5__To(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:MessageID"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__MessageID;
			s = soap_in__wsa5__MessageID(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_tt__IANA_IfTypes:
		return soap_out_tt__IANA_IfTypes(soap, tag, id, (const int *)ptr, "tt:IANA-IfTypes");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_xsd__duration:
		return soap_out_xsd__duration(soap, tag, id, (const LONG64 *)ptr, "xsd:duration");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE__wsa5__RetryAfter:
		return soap_out__wsa5__RetryAfter(soap, "wsa5:RetryAfter", id, (const ULONG64 *)ptr, NULL);
	case SOAP_TYPE_unsignedLONG64:
		return soap_out_unsignedLONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_tt__ClassType:
		return soap_out_tt__ClassType(soap, tag, id, (const enum tt__ClassType *)ptr, "tt:ClassType");
	case SOAP_TYPE_tt__Direction:
		return soap_out_tt__Direction(soap, tag, id, (const enum tt__Direction *)ptr, "tt:Direction");
	case SOAP_TYPE_tt__PropertyOperation:
		return soap_out_tt__PropertyOperation(soap, tag, id, (const enum tt__PropertyOperation *)ptr, "tt:PropertyOperation");
	case SOAP_TYPE_tt__IrCutFilterMode:
		return soap_out_tt__IrCutFilterMode(soap, tag, id, (const enum tt__IrCutFilterMode *)ptr, "tt:IrCutFilterMode");
	case SOAP_TYPE_tt__WhiteBalanceMode:
		return soap_out_tt__WhiteBalanceMode(soap, tag, id, (const enum tt__WhiteBalanceMode *)ptr, "tt:WhiteBalanceMode");
	case SOAP_TYPE_tt__Enabled:
		return soap_out_tt__Enabled(soap, tag, id, (const enum tt__Enabled *)ptr, "tt:Enabled");
	case SOAP_TYPE_tt__ExposureMode:
		return soap_out_tt__ExposureMode(soap, tag, id, (const enum tt__ExposureMode *)ptr, "tt:ExposureMode");
	case SOAP_TYPE_tt__ExposurePriority:
		return soap_out_tt__ExposurePriority(soap, tag, id, (const enum tt__ExposurePriority *)ptr, "tt:ExposurePriority");
	case SOAP_TYPE_tt__BacklightCompensationMode:
		return soap_out_tt__BacklightCompensationMode(soap, tag, id, (const enum tt__BacklightCompensationMode *)ptr, "tt:BacklightCompensationMode");
	case SOAP_TYPE_tt__WideDynamicMode:
		return soap_out_tt__WideDynamicMode(soap, tag, id, (const enum tt__WideDynamicMode *)ptr, "tt:WideDynamicMode");
	case SOAP_TYPE_tt__AutoFocusMode:
		return soap_out_tt__AutoFocusMode(soap, tag, id, (const enum tt__AutoFocusMode *)ptr, "tt:AutoFocusMode");
	case SOAP_TYPE_tt__MoveStatus:
		return soap_out_tt__MoveStatus(soap, tag, id, (const enum tt__MoveStatus *)ptr, "tt:MoveStatus");
	case SOAP_TYPE_tt__RelayMode:
		return soap_out_tt__RelayMode(soap, tag, id, (const enum tt__RelayMode *)ptr, "tt:RelayMode");
	case SOAP_TYPE_tt__RelayIdleState:
		return soap_out_tt__RelayIdleState(soap, tag, id, (const enum tt__RelayIdleState *)ptr, "tt:RelayIdleState");
	case SOAP_TYPE_tt__RelayLogicalState:
		return soap_out_tt__RelayLogicalState(soap, tag, id, (const enum tt__RelayLogicalState *)ptr, "tt:RelayLogicalState");
	case SOAP_TYPE_tt__UserLevel:
		return soap_out_tt__UserLevel(soap, tag, id, (const enum tt__UserLevel *)ptr, "tt:UserLevel");
	case SOAP_TYPE_tt__SetDateTimeType:
		return soap_out_tt__SetDateTimeType(soap, tag, id, (const enum tt__SetDateTimeType *)ptr, "tt:SetDateTimeType");
	case SOAP_TYPE_tt__FactoryDefaultType:
		return soap_out_tt__FactoryDefaultType(soap, tag, id, (const enum tt__FactoryDefaultType *)ptr, "tt:FactoryDefaultType");
	case SOAP_TYPE_tt__SystemLogType:
		return soap_out_tt__SystemLogType(soap, tag, id, (const enum tt__SystemLogType *)ptr, "tt:SystemLogType");
	case SOAP_TYPE_tt__CapabilityCategory:
		return soap_out_tt__CapabilityCategory(soap, tag, id, (const enum tt__CapabilityCategory *)ptr, "tt:CapabilityCategory");
	case SOAP_TYPE_tt__DynamicDNSType:
		return soap_out_tt__DynamicDNSType(soap, tag, id, (const enum tt__DynamicDNSType *)ptr, "tt:DynamicDNSType");
	case SOAP_TYPE_tt__IPAddressFilterType:
		return soap_out_tt__IPAddressFilterType(soap, tag, id, (const enum tt__IPAddressFilterType *)ptr, "tt:IPAddressFilterType");
	case SOAP_TYPE_tt__IPType:
		return soap_out_tt__IPType(soap, tag, id, (const enum tt__IPType *)ptr, "tt:IPType");
	case SOAP_TYPE_tt__NetworkHostType:
		return soap_out_tt__NetworkHostType(soap, tag, id, (const enum tt__NetworkHostType *)ptr, "tt:NetworkHostType");
	case SOAP_TYPE_tt__NetworkProtocolType:
		return soap_out_tt__NetworkProtocolType(soap, tag, id, (const enum tt__NetworkProtocolType *)ptr, "tt:NetworkProtocolType");
	case SOAP_TYPE_tt__IPv6DHCPConfiguration:
		return soap_out_tt__IPv6DHCPConfiguration(soap, tag, id, (const enum tt__IPv6DHCPConfiguration *)ptr, "tt:IPv6DHCPConfiguration");
	case SOAP_TYPE_tt__Duplex:
		return soap_out_tt__Duplex(soap, tag, id, (const enum tt__Duplex *)ptr, "tt:Duplex");
	case SOAP_TYPE_tt__DiscoveryMode:
		return soap_out_tt__DiscoveryMode(soap, tag, id, (const enum tt__DiscoveryMode *)ptr, "tt:DiscoveryMode");
	case SOAP_TYPE_tt__ScopeDefinition:
		return soap_out_tt__ScopeDefinition(soap, tag, id, (const enum tt__ScopeDefinition *)ptr, "tt:ScopeDefinition");
	case SOAP_TYPE_tt__TransportProtocol:
		return soap_out_tt__TransportProtocol(soap, tag, id, (const enum tt__TransportProtocol *)ptr, "tt:TransportProtocol");
	case SOAP_TYPE_tt__StreamType:
		return soap_out_tt__StreamType(soap, tag, id, (const enum tt__StreamType *)ptr, "tt:StreamType");
	case SOAP_TYPE_tt__AudioEncoding:
		return soap_out_tt__AudioEncoding(soap, tag, id, (const enum tt__AudioEncoding *)ptr, "tt:AudioEncoding");
	case SOAP_TYPE_tt__H264Profile:
		return soap_out_tt__H264Profile(soap, tag, id, (const enum tt__H264Profile *)ptr, "tt:H264Profile");
	case SOAP_TYPE_tt__Mpeg4Profile:
		return soap_out_tt__Mpeg4Profile(soap, tag, id, (const enum tt__Mpeg4Profile *)ptr, "tt:Mpeg4Profile");
	case SOAP_TYPE_tt__VideoEncoding:
		return soap_out_tt__VideoEncoding(soap, tag, id, (const enum tt__VideoEncoding *)ptr, "tt:VideoEncoding");
	case SOAP_TYPE_wsse__FaultcodeEnum:
		return soap_out_wsse__FaultcodeEnum(soap, tag, id, (const enum wsse__FaultcodeEnum *)ptr, "wsse:FaultcodeEnum");
	case SOAP_TYPE_wsu__tTimestampFault:
		return soap_out_wsu__tTimestampFault(soap, tag, id, (const enum wsu__tTimestampFault *)ptr, "wsu:tTimestampFault");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_out__wsa5__IsReferenceParameter(soap, tag, id, (const enum _wsa5__IsReferenceParameter *)ptr, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_out_wsa5__FaultCodesType(soap, tag, id, (const enum wsa5__FaultCodesType *)ptr, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_out_wsa5__RelationshipType(soap, tag, id, (const enum wsa5__RelationshipType *)ptr, "wsa5:RelationshipType");
	case SOAP_TYPE__wstop__TopicNamespaceType_Topic:
		return ((_wstop__TopicNamespaceType_Topic *)ptr)->soap_out(soap, "wstop:TopicNamespaceType-Topic", id, NULL);
	case SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause:
		return ((_wsrfbf__BaseFaultType_FaultCause *)ptr)->soap_out(soap, "wsrfbf:BaseFaultType-FaultCause", id, NULL);
	case SOAP_TYPE__wsrfbf__BaseFaultType_Description:
		return ((_wsrfbf__BaseFaultType_Description *)ptr)->soap_out(soap, "wsrfbf:BaseFaultType-Description", id, NULL);
	case SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode:
		return ((_wsrfbf__BaseFaultType_ErrorCode *)ptr)->soap_out(soap, "wsrfbf:BaseFaultType-ErrorCode", id, NULL);
	case SOAP_TYPE__wsnb__Subscribe_SubscriptionPolicy:
		return ((_wsnb__Subscribe_SubscriptionPolicy *)ptr)->soap_out(soap, "wsnb:Subscribe-SubscriptionPolicy", id, NULL);
	case SOAP_TYPE__wsnb__NotificationMessageHolderType_Message:
		return ((_wsnb__NotificationMessageHolderType_Message *)ptr)->soap_out(soap, "wsnb:NotificationMessageHolderType-Message", id, NULL);
	case SOAP_TYPE__tt__ConfigDescription_Messages:
		return ((_tt__ConfigDescription_Messages *)ptr)->soap_out(soap, "tt:ConfigDescription-Messages", id, NULL);
	case SOAP_TYPE__tt__Behaviour_Idle:
		return ((_tt__Behaviour_Idle *)ptr)->soap_out(soap, "tt:Behaviour-Idle", id, NULL);
	case SOAP_TYPE__tt__Behaviour_Removed:
		return ((_tt__Behaviour_Removed *)ptr)->soap_out(soap, "tt:Behaviour-Removed", id, NULL);
	case SOAP_TYPE__tt__ClassDescriptor_ClassCandidate:
		return ((_tt__ClassDescriptor_ClassCandidate *)ptr)->soap_out(soap, "tt:ClassDescriptor-ClassCandidate", id, NULL);
	case SOAP_TYPE__tt__ColorDescriptor_ColorCluster:
		return ((_tt__ColorDescriptor_ColorCluster *)ptr)->soap_out(soap, "tt:ColorDescriptor-ColorCluster", id, NULL);
	case SOAP_TYPE__tt__ItemListDescription_ElementItemDescription:
		return ((_tt__ItemListDescription_ElementItemDescription *)ptr)->soap_out(soap, "tt:ItemListDescription-ElementItemDescription", id, NULL);
	case SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription:
		return ((_tt__ItemListDescription_SimpleItemDescription *)ptr)->soap_out(soap, "tt:ItemListDescription-SimpleItemDescription", id, NULL);
	case SOAP_TYPE__tt__ItemList_ElementItem:
		return ((_tt__ItemList_ElementItem *)ptr)->soap_out(soap, "tt:ItemList-ElementItem", id, NULL);
	case SOAP_TYPE__tt__ItemList_SimpleItem:
		return ((_tt__ItemList_SimpleItem *)ptr)->soap_out(soap, "tt:ItemList-SimpleItem", id, NULL);
	case SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy:
		return ((_tt__EventSubscription_SubscriptionPolicy *)ptr)->soap_out(soap, "tt:EventSubscription-SubscriptionPolicy", id, NULL);
	case SOAP_TYPE_wstop__SimpleTopicExpression:
		return soap_out_wstop__SimpleTopicExpression(soap, tag, id, (const xsd__QName *)ptr, "wstop:SimpleTopicExpression");
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
		return soap_out_wstop__ConcreteTopicExpression(soap, tag, id, (const std::string *)ptr, "wstop:ConcreteTopicExpression");
	case SOAP_TYPE_wstop__FullTopicExpression:
		return soap_out_wstop__FullTopicExpression(soap, tag, id, (const std::string *)ptr, "wstop:FullTopicExpression");
	case SOAP_TYPE_tt__TopicNamespaceLocation:
		return soap_out_tt__TopicNamespaceLocation(soap, tag, id, (const std::string *)ptr, "tt:TopicNamespaceLocation");
	case SOAP_TYPE_tt__AuxiliaryData:
		return soap_out_tt__AuxiliaryData(soap, tag, id, (const std::string *)ptr, "tt:AuxiliaryData");
	case SOAP_TYPE_tt__Domain:
		return soap_out_tt__Domain(soap, tag, id, (const std::string *)ptr, "tt:Domain");
	case SOAP_TYPE_tt__DNSName:
		return soap_out_tt__DNSName(soap, tag, id, (const std::string *)ptr, "tt:DNSName");
	case SOAP_TYPE_tt__HwAddress:
		return soap_out_tt__HwAddress(soap, tag, id, (const std::string *)ptr, "tt:HwAddress");
	case SOAP_TYPE_tt__IPv6Address:
		return soap_out_tt__IPv6Address(soap, tag, id, (const std::string *)ptr, "tt:IPv6Address");
	case SOAP_TYPE_tt__IPv4Address:
		return soap_out_tt__IPv4Address(soap, tag, id, (const std::string *)ptr, "tt:IPv4Address");
	case SOAP_TYPE_tt__Name:
		return soap_out_tt__Name(soap, tag, id, (const std::string *)ptr, "tt:Name");
	case SOAP_TYPE_tt__ReferenceToken:
		return soap_out_tt__ReferenceToken(soap, tag, id, (const std::string *)ptr, "tt:ReferenceToken");
	case SOAP_TYPE_wsnb__AbsoluteOrRelativeTimeType:
		return soap_out_wsnb__AbsoluteOrRelativeTimeType(soap, tag, id, (const std::string *)ptr, "wsnb:AbsoluteOrRelativeTimeType");
	case SOAP_TYPE_wstop__TopicSetType:
		return ((wstop__TopicSetType *)ptr)->soap_out(soap, tag, id, "wstop:TopicSetType");
	case SOAP_TYPE_wstop__TopicType:
		return ((wstop__TopicType *)ptr)->soap_out(soap, tag, id, "wstop:TopicType");
	case SOAP_TYPE_wstop__TopicNamespaceType:
		return ((wstop__TopicNamespaceType *)ptr)->soap_out(soap, tag, id, "wstop:TopicNamespaceType");
	case SOAP_TYPE_wstop__QueryExpressionType:
		return ((wstop__QueryExpressionType *)ptr)->soap_out(soap, tag, id, "wstop:QueryExpressionType");
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		return ((wstop__ExtensibleDocumented *)ptr)->soap_out(soap, tag, id, "wstop:ExtensibleDocumented");
	case SOAP_TYPE_wstop__Documentation:
		return ((wstop__Documentation *)ptr)->soap_out(soap, tag, id, "wstop:Documentation");
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		return ((wsrfbf__BaseFaultType *)ptr)->soap_out(soap, tag, id, "wsrfbf:BaseFaultType");
	case SOAP_TYPE__wsnb__ResumeSubscriptionResponse:
		return ((_wsnb__ResumeSubscriptionResponse *)ptr)->soap_out(soap, "wsnb:ResumeSubscriptionResponse", id, NULL);
	case SOAP_TYPE__wsnb__ResumeSubscription:
		return ((_wsnb__ResumeSubscription *)ptr)->soap_out(soap, "wsnb:ResumeSubscription", id, NULL);
	case SOAP_TYPE__wsnb__PauseSubscriptionResponse:
		return ((_wsnb__PauseSubscriptionResponse *)ptr)->soap_out(soap, "wsnb:PauseSubscriptionResponse", id, NULL);
	case SOAP_TYPE__wsnb__PauseSubscription:
		return ((_wsnb__PauseSubscription *)ptr)->soap_out(soap, "wsnb:PauseSubscription", id, NULL);
	case SOAP_TYPE__wsnb__UnsubscribeResponse:
		return ((_wsnb__UnsubscribeResponse *)ptr)->soap_out(soap, "wsnb:UnsubscribeResponse", id, NULL);
	case SOAP_TYPE__wsnb__Unsubscribe:
		return ((_wsnb__Unsubscribe *)ptr)->soap_out(soap, "wsnb:Unsubscribe", id, NULL);
	case SOAP_TYPE__wsnb__RenewResponse:
		return ((_wsnb__RenewResponse *)ptr)->soap_out(soap, "wsnb:RenewResponse", id, NULL);
	case SOAP_TYPE__wsnb__Renew:
		return ((_wsnb__Renew *)ptr)->soap_out(soap, "wsnb:Renew", id, NULL);
	case SOAP_TYPE__wsnb__CreatePullPointResponse:
		return ((_wsnb__CreatePullPointResponse *)ptr)->soap_out(soap, "wsnb:CreatePullPointResponse", id, NULL);
	case SOAP_TYPE__wsnb__CreatePullPoint:
		return ((_wsnb__CreatePullPoint *)ptr)->soap_out(soap, "wsnb:CreatePullPoint", id, NULL);
	case SOAP_TYPE__wsnb__DestroyPullPointResponse:
		return ((_wsnb__DestroyPullPointResponse *)ptr)->soap_out(soap, "wsnb:DestroyPullPointResponse", id, NULL);
	case SOAP_TYPE__wsnb__DestroyPullPoint:
		return ((_wsnb__DestroyPullPoint *)ptr)->soap_out(soap, "wsnb:DestroyPullPoint", id, NULL);
	case SOAP_TYPE__wsnb__GetMessagesResponse:
		return ((_wsnb__GetMessagesResponse *)ptr)->soap_out(soap, "wsnb:GetMessagesResponse", id, NULL);
	case SOAP_TYPE__wsnb__GetMessages:
		return ((_wsnb__GetMessages *)ptr)->soap_out(soap, "wsnb:GetMessages", id, NULL);
	case SOAP_TYPE__wsnb__GetCurrentMessageResponse:
		return ((_wsnb__GetCurrentMessageResponse *)ptr)->soap_out(soap, "wsnb:GetCurrentMessageResponse", id, NULL);
	case SOAP_TYPE__wsnb__GetCurrentMessage:
		return ((_wsnb__GetCurrentMessage *)ptr)->soap_out(soap, "wsnb:GetCurrentMessage", id, NULL);
	case SOAP_TYPE__wsnb__SubscribeResponse:
		return ((_wsnb__SubscribeResponse *)ptr)->soap_out(soap, "wsnb:SubscribeResponse", id, NULL);
	case SOAP_TYPE__wsnb__Subscribe:
		return ((_wsnb__Subscribe *)ptr)->soap_out(soap, "wsnb:Subscribe", id, NULL);
	case SOAP_TYPE__wsnb__UseRaw:
		return ((_wsnb__UseRaw *)ptr)->soap_out(soap, "wsnb:UseRaw", id, NULL);
	case SOAP_TYPE__wsnb__Notify:
		return ((_wsnb__Notify *)ptr)->soap_out(soap, "wsnb:Notify", id, NULL);
	case SOAP_TYPE__wsnb__SubscriptionManagerRP:
		return ((_wsnb__SubscriptionManagerRP *)ptr)->soap_out(soap, "wsnb:SubscriptionManagerRP", id, NULL);
	case SOAP_TYPE__wsnb__NotificationProducerRP:
		return ((_wsnb__NotificationProducerRP *)ptr)->soap_out(soap, "wsnb:NotificationProducerRP", id, NULL);
	case SOAP_TYPE_wsnb__ResumeFailedFaultType:
		return ((wsnb__ResumeFailedFaultType *)ptr)->soap_out(soap, tag, id, "wsnb:ResumeFailedFaultType");
	case SOAP_TYPE_wsnb__PauseFailedFaultType:
		return ((wsnb__PauseFailedFaultType *)ptr)->soap_out(soap, tag, id, "wsnb:PauseFailedFaultType");
	case SOAP_TYPE_wsnb__UnableToDestroySubscriptionFaultType:
		return ((wsnb__UnableToDestroySubscriptionFaultType *)ptr)->soap_out(soap, tag, id, "wsnb:UnableToDestroySubscriptionFaultType");
	case SOAP_TYPE_wsnb__UnacceptableTerminationTimeFaultType:
		return ((wsnb__UnacceptableTerminationTimeFaultType *)ptr)->soap_out(soap, tag, id, "wsnb:UnacceptableTerminationTimeFaultType");
	case SOAP_TYPE_wsnb__UnableToCreatePullPointFaultType:
		return ((wsnb__UnableToCreatePullPointFaultType *)ptr)->soap_out(soap, tag, id, "wsnb:UnableToCreatePullPointFaultType");
	case SOAP_TYPE_wsnb__UnableToDestroyPullPointFaultType:
		return ((wsnb__UnableToDestroyPullPointFaultType *)ptr)->soap_out(soap, tag, id, "wsnb:UnableToDestroyPullPointFaultType");
	case SOAP_TYPE_wsnb__UnableToGetMessagesFaultType:
		return ((wsnb__UnableToGetMessagesFaultType *)ptr)->soap_out(soap, tag, id, "wsnb:UnableToGetMessagesFaultType");
	case SOAP_TYPE_wsnb__NoCurrentMessageOnTopicFaultType:
		return ((wsnb__NoCurrentMessageOnTopicFaultType *)ptr)->soap_out(soap, tag, id, "wsnb:NoCurrentMessageOnTopicFaultType");
	case SOAP_TYPE_wsnb__UnacceptableInitialTerminationTimeFaultType:
		return ((wsnb__UnacceptableInitialTerminationTimeFaultType *)ptr)->soap_out(soap, tag, id, "wsnb:UnacceptableInitialTerminationTimeFaultType");
	case SOAP_TYPE_wsnb__NotifyMessageNotSupportedFaultType:
		return ((wsnb__NotifyMessageNotSupportedFaultType *)ptr)->soap_out(soap, tag, id, "wsnb:NotifyMessageNotSupportedFaultType");
	case SOAP_TYPE_wsnb__UnsupportedPolicyRequestFaultType:
		return ((wsnb__UnsupportedPolicyRequestFaultType *)ptr)->soap_out(soap, tag, id, "wsnb:UnsupportedPolicyRequestFaultType");
	case SOAP_TYPE_wsnb__UnrecognizedPolicyRequestFaultType:
		return ((wsnb__UnrecognizedPolicyRequestFaultType *)ptr)->soap_out(soap, tag, id, "wsnb:UnrecognizedPolicyRequestFaultType");
	case SOAP_TYPE_wsnb__InvalidMessageContentExpressionFaultType:
		return ((wsnb__InvalidMessageContentExpressionFaultType *)ptr)->soap_out(soap, tag, id, "wsnb:InvalidMessageContentExpressionFaultType");
	case SOAP_TYPE_wsnb__InvalidProducerPropertiesExpressionFaultType:
		return ((wsnb__InvalidProducerPropertiesExpressionFaultType *)ptr)->soap_out(soap, tag, id, "wsnb:InvalidProducerPropertiesExpressionFaultType");
	case SOAP_TYPE_wsnb__MultipleTopicsSpecifiedFaultType:
		return ((wsnb__MultipleTopicsSpecifiedFaultType *)ptr)->soap_out(soap, tag, id, "wsnb:MultipleTopicsSpecifiedFaultType");
	case SOAP_TYPE_wsnb__TopicNotSupportedFaultType:
		return ((wsnb__TopicNotSupportedFaultType *)ptr)->soap_out(soap, tag, id, "wsnb:TopicNotSupportedFaultType");
	case SOAP_TYPE_wsnb__InvalidTopicExpressionFaultType:
		return ((wsnb__InvalidTopicExpressionFaultType *)ptr)->soap_out(soap, tag, id, "wsnb:InvalidTopicExpressionFaultType");
	case SOAP_TYPE_wsnb__TopicExpressionDialectUnknownFaultType:
		return ((wsnb__TopicExpressionDialectUnknownFaultType *)ptr)->soap_out(soap, tag, id, "wsnb:TopicExpressionDialectUnknownFaultType");
	case SOAP_TYPE_wsnb__InvalidFilterFaultType:
		return ((wsnb__InvalidFilterFaultType *)ptr)->soap_out(soap, tag, id, "wsnb:InvalidFilterFaultType");
	case SOAP_TYPE_wsnb__SubscribeCreationFailedFaultType:
		return ((wsnb__SubscribeCreationFailedFaultType *)ptr)->soap_out(soap, tag, id, "wsnb:SubscribeCreationFailedFaultType");
	case SOAP_TYPE_wsnb__NotificationMessageHolderType:
		return ((wsnb__NotificationMessageHolderType *)ptr)->soap_out(soap, tag, id, "wsnb:NotificationMessageHolderType");
	case SOAP_TYPE_wsnb__SubscriptionPolicyType:
		return ((wsnb__SubscriptionPolicyType *)ptr)->soap_out(soap, tag, id, "wsnb:SubscriptionPolicyType");
	case SOAP_TYPE_wsnb__FilterType:
		return ((wsnb__FilterType *)ptr)->soap_out(soap, tag, id, "wsnb:FilterType");
	case SOAP_TYPE_wsnb__TopicExpressionType:
		return ((wsnb__TopicExpressionType *)ptr)->soap_out(soap, tag, id, "wsnb:TopicExpressionType");
	case SOAP_TYPE_wsnb__QueryExpressionType:
		return ((wsnb__QueryExpressionType *)ptr)->soap_out(soap, tag, id, "wsnb:QueryExpressionType");
	case SOAP_TYPE__tt__Message:
		return ((_tt__Message *)ptr)->soap_out(soap, "tt:Message", id, NULL);
	case SOAP_TYPE_tt__EventStreamExtension:
		return ((tt__EventStreamExtension *)ptr)->soap_out(soap, tag, id, "tt:EventStreamExtension");
	case SOAP_TYPE_tt__EventStream:
		return ((tt__EventStream *)ptr)->soap_out(soap, tag, id, "tt:EventStream");
	case SOAP_TYPE_tt__PTZStreamExtension:
		return ((tt__PTZStreamExtension *)ptr)->soap_out(soap, tag, id, "tt:PTZStreamExtension");
	case SOAP_TYPE_tt__PTZStream:
		return ((tt__PTZStream *)ptr)->soap_out(soap, tag, id, "tt:PTZStream");
	case SOAP_TYPE_tt__VideoAnalyticsStreamExtension:
		return ((tt__VideoAnalyticsStreamExtension *)ptr)->soap_out(soap, tag, id, "tt:VideoAnalyticsStreamExtension");
	case SOAP_TYPE_tt__VideoAnalyticsStream:
		return ((tt__VideoAnalyticsStream *)ptr)->soap_out(soap, tag, id, "tt:VideoAnalyticsStream");
	case SOAP_TYPE_tt__MetadataStreamExtension:
		return ((tt__MetadataStreamExtension *)ptr)->soap_out(soap, tag, id, "tt:MetadataStreamExtension");
	case SOAP_TYPE_tt__MetadataStream:
		return ((tt__MetadataStream *)ptr)->soap_out(soap, tag, id, "tt:MetadataStream");
	case SOAP_TYPE_tt__SupportedAnalyticsModulesExtension:
		return ((tt__SupportedAnalyticsModulesExtension *)ptr)->soap_out(soap, tag, id, "tt:SupportedAnalyticsModulesExtension");
	case SOAP_TYPE_tt__SupportedAnalyticsModules:
		return ((tt__SupportedAnalyticsModules *)ptr)->soap_out(soap, tag, id, "tt:SupportedAnalyticsModules");
	case SOAP_TYPE_tt__SupportedRulesExtension:
		return ((tt__SupportedRulesExtension *)ptr)->soap_out(soap, tag, id, "tt:SupportedRulesExtension");
	case SOAP_TYPE_tt__SupportedRules:
		return ((tt__SupportedRules *)ptr)->soap_out(soap, tag, id, "tt:SupportedRules");
	case SOAP_TYPE_tt__ConfigDescriptionExtension:
		return ((tt__ConfigDescriptionExtension *)ptr)->soap_out(soap, tag, id, "tt:ConfigDescriptionExtension");
	case SOAP_TYPE_tt__ConfigDescription:
		return ((tt__ConfigDescription *)ptr)->soap_out(soap, tag, id, "tt:ConfigDescription");
	case SOAP_TYPE_tt__Config:
		return ((tt__Config *)ptr)->soap_out(soap, tag, id, "tt:Config");
	case SOAP_TYPE_tt__RuleEngineConfigurationExtension:
		return ((tt__RuleEngineConfigurationExtension *)ptr)->soap_out(soap, tag, id, "tt:RuleEngineConfigurationExtension");
	case SOAP_TYPE_tt__RuleEngineConfiguration:
		return ((tt__RuleEngineConfiguration *)ptr)->soap_out(soap, tag, id, "tt:RuleEngineConfiguration");
	case SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension:
		return ((tt__AnalyticsEngineConfigurationExtension *)ptr)->soap_out(soap, tag, id, "tt:AnalyticsEngineConfigurationExtension");
	case SOAP_TYPE_tt__AnalyticsEngineConfiguration:
		return ((tt__AnalyticsEngineConfiguration *)ptr)->soap_out(soap, tag, id, "tt:AnalyticsEngineConfiguration");
	case SOAP_TYPE_tt__ObjectTreeExtension:
		return ((tt__ObjectTreeExtension *)ptr)->soap_out(soap, tag, id, "tt:ObjectTreeExtension");
	case SOAP_TYPE_tt__ObjectTree:
		return ((tt__ObjectTree *)ptr)->soap_out(soap, tag, id, "tt:ObjectTree");
	case SOAP_TYPE_tt__BehaviourExtension:
		return ((tt__BehaviourExtension *)ptr)->soap_out(soap, tag, id, "tt:BehaviourExtension");
	case SOAP_TYPE_tt__Behaviour:
		return ((tt__Behaviour *)ptr)->soap_out(soap, tag, id, "tt:Behaviour");
	case SOAP_TYPE_tt__ObjectId:
		return ((tt__ObjectId *)ptr)->soap_out(soap, tag, id, "tt:ObjectId");
	case SOAP_TYPE_tt__Rename:
		return ((tt__Rename *)ptr)->soap_out(soap, tag, id, "tt:Rename");
	case SOAP_TYPE_tt__Split:
		return ((tt__Split *)ptr)->soap_out(soap, tag, id, "tt:Split");
	case SOAP_TYPE_tt__Merge:
		return ((tt__Merge *)ptr)->soap_out(soap, tag, id, "tt:Merge");
	case SOAP_TYPE_tt__FrameExtension:
		return ((tt__FrameExtension *)ptr)->soap_out(soap, tag, id, "tt:FrameExtension");
	case SOAP_TYPE_tt__Frame:
		return ((tt__Frame *)ptr)->soap_out(soap, tag, id, "tt:Frame");
	case SOAP_TYPE_tt__TransformationExtension:
		return ((tt__TransformationExtension *)ptr)->soap_out(soap, tag, id, "tt:TransformationExtension");
	case SOAP_TYPE_tt__Transformation:
		return ((tt__Transformation *)ptr)->soap_out(soap, tag, id, "tt:Transformation");
	case SOAP_TYPE_tt__ObjectExtension:
		return ((tt__ObjectExtension *)ptr)->soap_out(soap, tag, id, "tt:ObjectExtension");
	case SOAP_TYPE_tt__Object:
		return ((tt__Object *)ptr)->soap_out(soap, tag, id, "tt:Object");
	case SOAP_TYPE_tt__ClassDescriptorExtension:
		return ((tt__ClassDescriptorExtension *)ptr)->soap_out(soap, tag, id, "tt:ClassDescriptorExtension");
	case SOAP_TYPE_tt__ClassDescriptor:
		return ((tt__ClassDescriptor *)ptr)->soap_out(soap, tag, id, "tt:ClassDescriptor");
	case SOAP_TYPE_tt__ColorDescriptorExtension:
		return ((tt__ColorDescriptorExtension *)ptr)->soap_out(soap, tag, id, "tt:ColorDescriptorExtension");
	case SOAP_TYPE_tt__ColorDescriptor:
		return ((tt__ColorDescriptor *)ptr)->soap_out(soap, tag, id, "tt:ColorDescriptor");
	case SOAP_TYPE_tt__ShapeDescriptorExtension:
		return ((tt__ShapeDescriptorExtension *)ptr)->soap_out(soap, tag, id, "tt:ShapeDescriptorExtension");
	case SOAP_TYPE_tt__ShapeDescriptor:
		return ((tt__ShapeDescriptor *)ptr)->soap_out(soap, tag, id, "tt:ShapeDescriptor");
	case SOAP_TYPE_tt__AppearanceExtension:
		return ((tt__AppearanceExtension *)ptr)->soap_out(soap, tag, id, "tt:AppearanceExtension");
	case SOAP_TYPE_tt__Appearance:
		return ((tt__Appearance *)ptr)->soap_out(soap, tag, id, "tt:Appearance");
	case SOAP_TYPE_tt__ColorCovariance:
		return ((tt__ColorCovariance *)ptr)->soap_out(soap, tag, id, "tt:ColorCovariance");
	case SOAP_TYPE_tt__Color:
		return ((tt__Color *)ptr)->soap_out(soap, tag, id, "tt:Color");
	case SOAP_TYPE_tt__Polyline:
		return ((tt__Polyline *)ptr)->soap_out(soap, tag, id, "tt:Polyline");
	case SOAP_TYPE_tt__Polygon:
		return ((tt__Polygon *)ptr)->soap_out(soap, tag, id, "tt:Polygon");
	case SOAP_TYPE_tt__Rectangle:
		return ((tt__Rectangle *)ptr)->soap_out(soap, tag, id, "tt:Rectangle");
	case SOAP_TYPE_tt__Vector:
		return ((tt__Vector *)ptr)->soap_out(soap, tag, id, "tt:Vector");
	case SOAP_TYPE_tt__ItemListDescriptionExtension:
		return ((tt__ItemListDescriptionExtension *)ptr)->soap_out(soap, tag, id, "tt:ItemListDescriptionExtension");
	case SOAP_TYPE_tt__ItemListDescription:
		return ((tt__ItemListDescription *)ptr)->soap_out(soap, tag, id, "tt:ItemListDescription");
	case SOAP_TYPE_tt__MessageDescriptionExtension:
		return ((tt__MessageDescriptionExtension *)ptr)->soap_out(soap, tag, id, "tt:MessageDescriptionExtension");
	case SOAP_TYPE_tt__MessageDescription:
		return ((tt__MessageDescription *)ptr)->soap_out(soap, tag, id, "tt:MessageDescription");
	case SOAP_TYPE_tt__ItemListExtension:
		return ((tt__ItemListExtension *)ptr)->soap_out(soap, tag, id, "tt:ItemListExtension");
	case SOAP_TYPE_tt__ItemList:
		return ((tt__ItemList *)ptr)->soap_out(soap, tag, id, "tt:ItemList");
	case SOAP_TYPE_tt__MessageExtension:
		return ((tt__MessageExtension *)ptr)->soap_out(soap, tag, id, "tt:MessageExtension");
	case SOAP_TYPE_tt__FocusOptions20Extension:
		return ((tt__FocusOptions20Extension *)ptr)->soap_out(soap, tag, id, "tt:FocusOptions20Extension");
	case SOAP_TYPE_tt__FocusOptions20:
		return ((tt__FocusOptions20 *)ptr)->soap_out(soap, tag, id, "tt:FocusOptions20");
	case SOAP_TYPE_tt__WhiteBalanceOptions20Extension:
		return ((tt__WhiteBalanceOptions20Extension *)ptr)->soap_out(soap, tag, id, "tt:WhiteBalanceOptions20Extension");
	case SOAP_TYPE_tt__WhiteBalanceOptions20:
		return ((tt__WhiteBalanceOptions20 *)ptr)->soap_out(soap, tag, id, "tt:WhiteBalanceOptions20");
	case SOAP_TYPE_tt__FocusConfiguration20Extension:
		return ((tt__FocusConfiguration20Extension *)ptr)->soap_out(soap, tag, id, "tt:FocusConfiguration20Extension");
	case SOAP_TYPE_tt__FocusConfiguration20:
		return ((tt__FocusConfiguration20 *)ptr)->soap_out(soap, tag, id, "tt:FocusConfiguration20");
	case SOAP_TYPE_tt__WhiteBalance20Extension:
		return ((tt__WhiteBalance20Extension *)ptr)->soap_out(soap, tag, id, "tt:WhiteBalance20Extension");
	case SOAP_TYPE_tt__WhiteBalance20:
		return ((tt__WhiteBalance20 *)ptr)->soap_out(soap, tag, id, "tt:WhiteBalance20");
	case SOAP_TYPE_tt__RelativeFocusOptions20:
		return ((tt__RelativeFocusOptions20 *)ptr)->soap_out(soap, tag, id, "tt:RelativeFocusOptions20");
	case SOAP_TYPE_tt__MoveOptions20:
		return ((tt__MoveOptions20 *)ptr)->soap_out(soap, tag, id, "tt:MoveOptions20");
	case SOAP_TYPE_tt__ExposureOptions20:
		return ((tt__ExposureOptions20 *)ptr)->soap_out(soap, tag, id, "tt:ExposureOptions20");
	case SOAP_TYPE_tt__BacklightCompensationOptions20:
		return ((tt__BacklightCompensationOptions20 *)ptr)->soap_out(soap, tag, id, "tt:BacklightCompensationOptions20");
	case SOAP_TYPE_tt__WideDynamicRangeOptions20:
		return ((tt__WideDynamicRangeOptions20 *)ptr)->soap_out(soap, tag, id, "tt:WideDynamicRangeOptions20");
	case SOAP_TYPE_tt__ImagingOptions20Extension:
		return ((tt__ImagingOptions20Extension *)ptr)->soap_out(soap, tag, id, "tt:ImagingOptions20Extension");
	case SOAP_TYPE_tt__ImagingOptions20:
		return ((tt__ImagingOptions20 *)ptr)->soap_out(soap, tag, id, "tt:ImagingOptions20");
	case SOAP_TYPE_tt__Exposure20:
		return ((tt__Exposure20 *)ptr)->soap_out(soap, tag, id, "tt:Exposure20");
	case SOAP_TYPE_tt__BacklightCompensation20:
		return ((tt__BacklightCompensation20 *)ptr)->soap_out(soap, tag, id, "tt:BacklightCompensation20");
	case SOAP_TYPE_tt__WideDynamicRange20:
		return ((tt__WideDynamicRange20 *)ptr)->soap_out(soap, tag, id, "tt:WideDynamicRange20");
	case SOAP_TYPE_tt__ImagingSettingsExtension20:
		return ((tt__ImagingSettingsExtension20 *)ptr)->soap_out(soap, tag, id, "tt:ImagingSettingsExtension20");
	case SOAP_TYPE_tt__ImagingSettings20:
		return ((tt__ImagingSettings20 *)ptr)->soap_out(soap, tag, id, "tt:ImagingSettings20");
	case SOAP_TYPE_tt__FocusStatus20Extension:
		return ((tt__FocusStatus20Extension *)ptr)->soap_out(soap, tag, id, "tt:FocusStatus20Extension");
	case SOAP_TYPE_tt__FocusStatus20:
		return ((tt__FocusStatus20 *)ptr)->soap_out(soap, tag, id, "tt:FocusStatus20");
	case SOAP_TYPE_tt__ImagingStatus20Extension:
		return ((tt__ImagingStatus20Extension *)ptr)->soap_out(soap, tag, id, "tt:ImagingStatus20Extension");
	case SOAP_TYPE_tt__ImagingStatus20:
		return ((tt__ImagingStatus20 *)ptr)->soap_out(soap, tag, id, "tt:ImagingStatus20");
	case SOAP_TYPE_tt__WhiteBalance:
		return ((tt__WhiteBalance *)ptr)->soap_out(soap, tag, id, "tt:WhiteBalance");
	case SOAP_TYPE_tt__ContinuousFocusOptions:
		return ((tt__ContinuousFocusOptions *)ptr)->soap_out(soap, tag, id, "tt:ContinuousFocusOptions");
	case SOAP_TYPE_tt__RelativeFocusOptions:
		return ((tt__RelativeFocusOptions *)ptr)->soap_out(soap, tag, id, "tt:RelativeFocusOptions");
	case SOAP_TYPE_tt__AbsoluteFocusOptions:
		return ((tt__AbsoluteFocusOptions *)ptr)->soap_out(soap, tag, id, "tt:AbsoluteFocusOptions");
	case SOAP_TYPE_tt__MoveOptions:
		return ((tt__MoveOptions *)ptr)->soap_out(soap, tag, id, "tt:MoveOptions");
	case SOAP_TYPE_tt__ContinuousFocus:
		return ((tt__ContinuousFocus *)ptr)->soap_out(soap, tag, id, "tt:ContinuousFocus");
	case SOAP_TYPE_tt__RelativeFocus:
		return ((tt__RelativeFocus *)ptr)->soap_out(soap, tag, id, "tt:RelativeFocus");
	case SOAP_TYPE_tt__AbsoluteFocus:
		return ((tt__AbsoluteFocus *)ptr)->soap_out(soap, tag, id, "tt:AbsoluteFocus");
	case SOAP_TYPE_tt__FocusMove:
		return ((tt__FocusMove *)ptr)->soap_out(soap, tag, id, "tt:FocusMove");
	case SOAP_TYPE_tt__WhiteBalanceOptions:
		return ((tt__WhiteBalanceOptions *)ptr)->soap_out(soap, tag, id, "tt:WhiteBalanceOptions");
	case SOAP_TYPE_tt__ExposureOptions:
		return ((tt__ExposureOptions *)ptr)->soap_out(soap, tag, id, "tt:ExposureOptions");
	case SOAP_TYPE_tt__FocusOptions:
		return ((tt__FocusOptions *)ptr)->soap_out(soap, tag, id, "tt:FocusOptions");
	case SOAP_TYPE_tt__BacklightCompensationOptions:
		return ((tt__BacklightCompensationOptions *)ptr)->soap_out(soap, tag, id, "tt:BacklightCompensationOptions");
	case SOAP_TYPE_tt__WideDynamicRangeOptions:
		return ((tt__WideDynamicRangeOptions *)ptr)->soap_out(soap, tag, id, "tt:WideDynamicRangeOptions");
	case SOAP_TYPE_tt__ImagingOptions:
		return ((tt__ImagingOptions *)ptr)->soap_out(soap, tag, id, "tt:ImagingOptions");
	case SOAP_TYPE_tt__BacklightCompensation:
		return ((tt__BacklightCompensation *)ptr)->soap_out(soap, tag, id, "tt:BacklightCompensation");
	case SOAP_TYPE_tt__WideDynamicRange:
		return ((tt__WideDynamicRange *)ptr)->soap_out(soap, tag, id, "tt:WideDynamicRange");
	case SOAP_TYPE_tt__Exposure:
		return ((tt__Exposure *)ptr)->soap_out(soap, tag, id, "tt:Exposure");
	case SOAP_TYPE_tt__ImagingSettingsExtension:
		return ((tt__ImagingSettingsExtension *)ptr)->soap_out(soap, tag, id, "tt:ImagingSettingsExtension");
	case SOAP_TYPE_tt__ImagingSettings:
		return ((tt__ImagingSettings *)ptr)->soap_out(soap, tag, id, "tt:ImagingSettings");
	case SOAP_TYPE_tt__FocusConfiguration:
		return ((tt__FocusConfiguration *)ptr)->soap_out(soap, tag, id, "tt:FocusConfiguration");
	case SOAP_TYPE_tt__FocusStatus:
		return ((tt__FocusStatus *)ptr)->soap_out(soap, tag, id, "tt:FocusStatus");
	case SOAP_TYPE_tt__ImagingStatus:
		return ((tt__ImagingStatus *)ptr)->soap_out(soap, tag, id, "tt:ImagingStatus");
	case SOAP_TYPE_tt__PTZMoveStatus:
		return ((tt__PTZMoveStatus *)ptr)->soap_out(soap, tag, id, "tt:PTZMoveStatus");
	case SOAP_TYPE_tt__PTZPreset:
		return ((tt__PTZPreset *)ptr)->soap_out(soap, tag, id, "tt:PTZPreset");
	case SOAP_TYPE_tt__PTZStatus:
		return ((tt__PTZStatus *)ptr)->soap_out(soap, tag, id, "tt:PTZStatus");
	case SOAP_TYPE_tt__PTZSpeed:
		return ((tt__PTZSpeed *)ptr)->soap_out(soap, tag, id, "tt:PTZSpeed");
	case SOAP_TYPE_tt__PTZVector:
		return ((tt__PTZVector *)ptr)->soap_out(soap, tag, id, "tt:PTZVector");
	case SOAP_TYPE_tt__Vector1D:
		return ((tt__Vector1D *)ptr)->soap_out(soap, tag, id, "tt:Vector1D");
	case SOAP_TYPE_tt__Vector2D:
		return ((tt__Vector2D *)ptr)->soap_out(soap, tag, id, "tt:Vector2D");
	case SOAP_TYPE_tt__Space1DDescription:
		return ((tt__Space1DDescription *)ptr)->soap_out(soap, tag, id, "tt:Space1DDescription");
	case SOAP_TYPE_tt__Space2DDescription:
		return ((tt__Space2DDescription *)ptr)->soap_out(soap, tag, id, "tt:Space2DDescription");
	case SOAP_TYPE_tt__PTZSpacesExtension:
		return ((tt__PTZSpacesExtension *)ptr)->soap_out(soap, tag, id, "tt:PTZSpacesExtension");
	case SOAP_TYPE_tt__PTZSpaces:
		return ((tt__PTZSpaces *)ptr)->soap_out(soap, tag, id, "tt:PTZSpaces");
	case SOAP_TYPE_tt__ZoomLimits:
		return ((tt__ZoomLimits *)ptr)->soap_out(soap, tag, id, "tt:ZoomLimits");
	case SOAP_TYPE_tt__PanTiltLimits:
		return ((tt__PanTiltLimits *)ptr)->soap_out(soap, tag, id, "tt:PanTiltLimits");
	case SOAP_TYPE_tt__PTZConfigurationOptions:
		return ((tt__PTZConfigurationOptions *)ptr)->soap_out(soap, tag, id, "tt:PTZConfigurationOptions");
	case SOAP_TYPE_tt__PTZConfigurationExtension:
		return ((tt__PTZConfigurationExtension *)ptr)->soap_out(soap, tag, id, "tt:PTZConfigurationExtension");
	case SOAP_TYPE_tt__PTZConfiguration:
		return ((tt__PTZConfiguration *)ptr)->soap_out(soap, tag, id, "tt:PTZConfiguration");
	case SOAP_TYPE_tt__PTZNodeExtension:
		return ((tt__PTZNodeExtension *)ptr)->soap_out(soap, tag, id, "tt:PTZNodeExtension");
	case SOAP_TYPE_tt__PTZNode:
		return ((tt__PTZNode *)ptr)->soap_out(soap, tag, id, "tt:PTZNode");
	case SOAP_TYPE_tt__RelayOutput:
		return ((tt__RelayOutput *)ptr)->soap_out(soap, tag, id, "tt:RelayOutput");
	case SOAP_TYPE_tt__RelayOutputSettings:
		return ((tt__RelayOutputSettings *)ptr)->soap_out(soap, tag, id, "tt:RelayOutputSettings");
	case SOAP_TYPE_tt__CertificateStatus:
		return ((tt__CertificateStatus *)ptr)->soap_out(soap, tag, id, "tt:CertificateStatus");
	case SOAP_TYPE_tt__Certificate:
		return ((tt__Certificate *)ptr)->soap_out(soap, tag, id, "tt:Certificate");
	case SOAP_TYPE_tt__CertificateGenerationParametersExtension:
		return ((tt__CertificateGenerationParametersExtension *)ptr)->soap_out(soap, tag, id, "tt:CertificateGenerationParametersExtension");
	case SOAP_TYPE_tt__CertificateGenerationParameters:
		return ((tt__CertificateGenerationParameters *)ptr)->soap_out(soap, tag, id, "tt:CertificateGenerationParameters");
	case SOAP_TYPE_tt__UserExtension:
		return ((tt__UserExtension *)ptr)->soap_out(soap, tag, id, "tt:UserExtension");
	case SOAP_TYPE_tt__User:
		return ((tt__User *)ptr)->soap_out(soap, tag, id, "tt:User");
	case SOAP_TYPE_tt__TimeZone:
		return ((tt__TimeZone *)ptr)->soap_out(soap, tag, id, "tt:TimeZone");
	case SOAP_TYPE_tt__Time:
		return ((tt__Time *)ptr)->soap_out(soap, tag, id, "tt:Time");
	case SOAP_TYPE_tt__Date:
		return ((tt__Date *)ptr)->soap_out(soap, tag, id, "tt:Date");
	case SOAP_TYPE_tt__DateTime:
		return ((tt__DateTime *)ptr)->soap_out(soap, tag, id, "tt:DateTime");
	case SOAP_TYPE_tt__SystemDateTimeExtension:
		return ((tt__SystemDateTimeExtension *)ptr)->soap_out(soap, tag, id, "tt:SystemDateTimeExtension");
	case SOAP_TYPE_tt__SystemDateTime:
		return ((tt__SystemDateTime *)ptr)->soap_out(soap, tag, id, "tt:SystemDateTime");
	case SOAP_TYPE_tt__BackupFile:
		return ((tt__BackupFile *)ptr)->soap_out(soap, tag, id, "tt:BackupFile");
	case SOAP_TYPE_tt__AttachmentData:
		return ((tt__AttachmentData *)ptr)->soap_out(soap, tag, id, "tt:AttachmentData");
	case SOAP_TYPE_tt__BinaryData:
		return ((tt__BinaryData *)ptr)->soap_out(soap, tag, id, "tt:BinaryData");
	case SOAP_TYPE_tt__SupportInformation:
		return ((tt__SupportInformation *)ptr)->soap_out(soap, tag, id, "tt:SupportInformation");
	case SOAP_TYPE_tt__SystemLog:
		return ((tt__SystemLog *)ptr)->soap_out(soap, tag, id, "tt:SystemLog");
	case SOAP_TYPE_tt__PTZCapabilities:
		return ((tt__PTZCapabilities *)ptr)->soap_out(soap, tag, id, "tt:PTZCapabilities");
	case SOAP_TYPE_tt__ImagingCapabilities:
		return ((tt__ImagingCapabilities *)ptr)->soap_out(soap, tag, id, "tt:ImagingCapabilities");
	case SOAP_TYPE_tt__OnvifVersion:
		return ((tt__OnvifVersion *)ptr)->soap_out(soap, tag, id, "tt:OnvifVersion");
	case SOAP_TYPE_tt__SystemCapabilitiesExtension:
		return ((tt__SystemCapabilitiesExtension *)ptr)->soap_out(soap, tag, id, "tt:SystemCapabilitiesExtension");
	case SOAP_TYPE_tt__SystemCapabilities:
		return ((tt__SystemCapabilities *)ptr)->soap_out(soap, tag, id, "tt:SystemCapabilities");
	case SOAP_TYPE_tt__StorageCapabilities:
		return ((tt__StorageCapabilities *)ptr)->soap_out(soap, tag, id, "tt:StorageCapabilities");
	case SOAP_TYPE_tt__SecurityCapabilitiesExtension:
		return ((tt__SecurityCapabilitiesExtension *)ptr)->soap_out(soap, tag, id, "tt:SecurityCapabilitiesExtension");
	case SOAP_TYPE_tt__SecurityCapabilities:
		return ((tt__SecurityCapabilities *)ptr)->soap_out(soap, tag, id, "tt:SecurityCapabilities");
	case SOAP_TYPE_tt__NetworkCapabilitiesExtension:
		return ((tt__NetworkCapabilitiesExtension *)ptr)->soap_out(soap, tag, id, "tt:NetworkCapabilitiesExtension");
	case SOAP_TYPE_tt__NetworkCapabilities:
		return ((tt__NetworkCapabilities *)ptr)->soap_out(soap, tag, id, "tt:NetworkCapabilities");
	case SOAP_TYPE_tt__ProfileCapabilities:
		return ((tt__ProfileCapabilities *)ptr)->soap_out(soap, tag, id, "tt:ProfileCapabilities");
	case SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension:
		return ((tt__RealTimeStreamingCapabilitiesExtension *)ptr)->soap_out(soap, tag, id, "tt:RealTimeStreamingCapabilitiesExtension");
	case SOAP_TYPE_tt__RealTimeStreamingCapabilities:
		return ((tt__RealTimeStreamingCapabilities *)ptr)->soap_out(soap, tag, id, "tt:RealTimeStreamingCapabilities");
	case SOAP_TYPE_tt__MediaCapabilitiesExtension:
		return ((tt__MediaCapabilitiesExtension *)ptr)->soap_out(soap, tag, id, "tt:MediaCapabilitiesExtension");
	case SOAP_TYPE_tt__MediaCapabilities:
		return ((tt__MediaCapabilities *)ptr)->soap_out(soap, tag, id, "tt:MediaCapabilities");
	case SOAP_TYPE_tt__IOCapabilitiesExtension:
		return ((tt__IOCapabilitiesExtension *)ptr)->soap_out(soap, tag, id, "tt:IOCapabilitiesExtension");
	case SOAP_TYPE_tt__IOCapabilities:
		return ((tt__IOCapabilities *)ptr)->soap_out(soap, tag, id, "tt:IOCapabilities");
	case SOAP_TYPE_tt__EventCapabilities:
		return ((tt__EventCapabilities *)ptr)->soap_out(soap, tag, id, "tt:EventCapabilities");
	case SOAP_TYPE_tt__DeviceCapabilitiesExtension:
		return ((tt__DeviceCapabilitiesExtension *)ptr)->soap_out(soap, tag, id, "tt:DeviceCapabilitiesExtension");
	case SOAP_TYPE_tt__DeviceCapabilities:
		return ((tt__DeviceCapabilities *)ptr)->soap_out(soap, tag, id, "tt:DeviceCapabilities");
	case SOAP_TYPE_tt__AnalyticsCapabilities:
		return ((tt__AnalyticsCapabilities *)ptr)->soap_out(soap, tag, id, "tt:AnalyticsCapabilities");
	case SOAP_TYPE_tt__CapabilitiesExtension:
		return ((tt__CapabilitiesExtension *)ptr)->soap_out(soap, tag, id, "tt:CapabilitiesExtension");
	case SOAP_TYPE_tt__Capabilities:
		return ((tt__Capabilities *)ptr)->soap_out(soap, tag, id, "tt:Capabilities");
	case SOAP_TYPE_tt__IPAddressFilterExtension:
		return ((tt__IPAddressFilterExtension *)ptr)->soap_out(soap, tag, id, "tt:IPAddressFilterExtension");
	case SOAP_TYPE_tt__IPAddressFilter:
		return ((tt__IPAddressFilter *)ptr)->soap_out(soap, tag, id, "tt:IPAddressFilter");
	case SOAP_TYPE_tt__NetworkZeroConfigurationExtension:
		return ((tt__NetworkZeroConfigurationExtension *)ptr)->soap_out(soap, tag, id, "tt:NetworkZeroConfigurationExtension");
	case SOAP_TYPE_tt__NetworkZeroConfiguration:
		return ((tt__NetworkZeroConfiguration *)ptr)->soap_out(soap, tag, id, "tt:NetworkZeroConfiguration");
	case SOAP_TYPE_tt__NetworkGateway:
		return ((tt__NetworkGateway *)ptr)->soap_out(soap, tag, id, "tt:NetworkGateway");
	case SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration:
		return ((tt__IPv4NetworkInterfaceSetConfiguration *)ptr)->soap_out(soap, tag, id, "tt:IPv4NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration:
		return ((tt__IPv6NetworkInterfaceSetConfiguration *)ptr)->soap_out(soap, tag, id, "tt:IPv6NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension:
		return ((tt__NetworkInterfaceSetConfigurationExtension *)ptr)->soap_out(soap, tag, id, "tt:NetworkInterfaceSetConfigurationExtension");
	case SOAP_TYPE_tt__NetworkInterfaceSetConfiguration:
		return ((tt__NetworkInterfaceSetConfiguration *)ptr)->soap_out(soap, tag, id, "tt:NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_tt__DynamicDNSInformationExtension:
		return ((tt__DynamicDNSInformationExtension *)ptr)->soap_out(soap, tag, id, "tt:DynamicDNSInformationExtension");
	case SOAP_TYPE_tt__DynamicDNSInformation:
		return ((tt__DynamicDNSInformation *)ptr)->soap_out(soap, tag, id, "tt:DynamicDNSInformation");
	case SOAP_TYPE_tt__NTPInformationExtension:
		return ((tt__NTPInformationExtension *)ptr)->soap_out(soap, tag, id, "tt:NTPInformationExtension");
	case SOAP_TYPE_tt__NTPInformation:
		return ((tt__NTPInformation *)ptr)->soap_out(soap, tag, id, "tt:NTPInformation");
	case SOAP_TYPE_tt__DNSInformationExtension:
		return ((tt__DNSInformationExtension *)ptr)->soap_out(soap, tag, id, "tt:DNSInformationExtension");
	case SOAP_TYPE_tt__DNSInformation:
		return ((tt__DNSInformation *)ptr)->soap_out(soap, tag, id, "tt:DNSInformation");
	case SOAP_TYPE_tt__HostnameInformationExtension:
		return ((tt__HostnameInformationExtension *)ptr)->soap_out(soap, tag, id, "tt:HostnameInformationExtension");
	case SOAP_TYPE_tt__HostnameInformation:
		return ((tt__HostnameInformation *)ptr)->soap_out(soap, tag, id, "tt:HostnameInformation");
	case SOAP_TYPE_tt__PrefixedIPv6Address:
		return ((tt__PrefixedIPv6Address *)ptr)->soap_out(soap, tag, id, "tt:PrefixedIPv6Address");
	case SOAP_TYPE_tt__PrefixedIPv4Address:
		return ((tt__PrefixedIPv4Address *)ptr)->soap_out(soap, tag, id, "tt:PrefixedIPv4Address");
	case SOAP_TYPE_tt__IPAddress:
		return ((tt__IPAddress *)ptr)->soap_out(soap, tag, id, "tt:IPAddress");
	case SOAP_TYPE_tt__NetworkHostExtension:
		return ((tt__NetworkHostExtension *)ptr)->soap_out(soap, tag, id, "tt:NetworkHostExtension");
	case SOAP_TYPE_tt__NetworkHost:
		return ((tt__NetworkHost *)ptr)->soap_out(soap, tag, id, "tt:NetworkHost");
	case SOAP_TYPE_tt__NetworkProtocolExtension:
		return ((tt__NetworkProtocolExtension *)ptr)->soap_out(soap, tag, id, "tt:NetworkProtocolExtension");
	case SOAP_TYPE_tt__NetworkProtocol:
		return ((tt__NetworkProtocol *)ptr)->soap_out(soap, tag, id, "tt:NetworkProtocol");
	case SOAP_TYPE_tt__IPv6ConfigurationExtension:
		return ((tt__IPv6ConfigurationExtension *)ptr)->soap_out(soap, tag, id, "tt:IPv6ConfigurationExtension");
	case SOAP_TYPE_tt__IPv6Configuration:
		return ((tt__IPv6Configuration *)ptr)->soap_out(soap, tag, id, "tt:IPv6Configuration");
	case SOAP_TYPE_tt__IPv4Configuration:
		return ((tt__IPv4Configuration *)ptr)->soap_out(soap, tag, id, "tt:IPv4Configuration");
	case SOAP_TYPE_tt__IPv4NetworkInterface:
		return ((tt__IPv4NetworkInterface *)ptr)->soap_out(soap, tag, id, "tt:IPv4NetworkInterface");
	case SOAP_TYPE_tt__IPv6NetworkInterface:
		return ((tt__IPv6NetworkInterface *)ptr)->soap_out(soap, tag, id, "tt:IPv6NetworkInterface");
	case SOAP_TYPE_tt__NetworkInterfaceInfo:
		return ((tt__NetworkInterfaceInfo *)ptr)->soap_out(soap, tag, id, "tt:NetworkInterfaceInfo");
	case SOAP_TYPE_tt__NetworkInterfaceConnectionSetting:
		return ((tt__NetworkInterfaceConnectionSetting *)ptr)->soap_out(soap, tag, id, "tt:NetworkInterfaceConnectionSetting");
	case SOAP_TYPE_tt__NetworkInterfaceLink:
		return ((tt__NetworkInterfaceLink *)ptr)->soap_out(soap, tag, id, "tt:NetworkInterfaceLink");
	case SOAP_TYPE_tt__NetworkInterfaceExtension:
		return ((tt__NetworkInterfaceExtension *)ptr)->soap_out(soap, tag, id, "tt:NetworkInterfaceExtension");
	case SOAP_TYPE_tt__NetworkInterface:
		return ((tt__NetworkInterface *)ptr)->soap_out(soap, tag, id, "tt:NetworkInterface");
	case SOAP_TYPE_tt__Scope:
		return ((tt__Scope *)ptr)->soap_out(soap, tag, id, "tt:Scope");
	case SOAP_TYPE_tt__MediaUri:
		return ((tt__MediaUri *)ptr)->soap_out(soap, tag, id, "tt:MediaUri");
	case SOAP_TYPE_tt__Transport:
		return ((tt__Transport *)ptr)->soap_out(soap, tag, id, "tt:Transport");
	case SOAP_TYPE_tt__StreamSetup:
		return ((tt__StreamSetup *)ptr)->soap_out(soap, tag, id, "tt:StreamSetup");
	case SOAP_TYPE_tt__MulticastConfiguration:
		return ((tt__MulticastConfiguration *)ptr)->soap_out(soap, tag, id, "tt:MulticastConfiguration");
	case SOAP_TYPE_tt__PTZStatusFilterOptions:
		return ((tt__PTZStatusFilterOptions *)ptr)->soap_out(soap, tag, id, "tt:PTZStatusFilterOptions");
	case SOAP_TYPE_tt__MetadataConfigurationOptions:
		return ((tt__MetadataConfigurationOptions *)ptr)->soap_out(soap, tag, id, "tt:MetadataConfigurationOptions");
	case SOAP_TYPE_tt__EventSubscription:
		return ((tt__EventSubscription *)ptr)->soap_out(soap, tag, id, "tt:EventSubscription");
	case SOAP_TYPE_tt__PTZFilter:
		return ((tt__PTZFilter *)ptr)->soap_out(soap, tag, id, "tt:PTZFilter");
	case SOAP_TYPE_tt__MetadataConfiguration:
		return ((tt__MetadataConfiguration *)ptr)->soap_out(soap, tag, id, "tt:MetadataConfiguration");
	case SOAP_TYPE_tt__VideoAnalyticsConfiguration:
		return ((tt__VideoAnalyticsConfiguration *)ptr)->soap_out(soap, tag, id, "tt:VideoAnalyticsConfiguration");
	case SOAP_TYPE_tt__AudioEncoderConfigurationOption:
		return ((tt__AudioEncoderConfigurationOption *)ptr)->soap_out(soap, tag, id, "tt:AudioEncoderConfigurationOption");
	case SOAP_TYPE_tt__AudioEncoderConfigurationOptions:
		return ((tt__AudioEncoderConfigurationOptions *)ptr)->soap_out(soap, tag, id, "tt:AudioEncoderConfigurationOptions");
	case SOAP_TYPE_tt__AudioEncoderConfiguration:
		return ((tt__AudioEncoderConfiguration *)ptr)->soap_out(soap, tag, id, "tt:AudioEncoderConfiguration");
	case SOAP_TYPE_tt__AudioSourceOptionsExtension:
		return ((tt__AudioSourceOptionsExtension *)ptr)->soap_out(soap, tag, id, "tt:AudioSourceOptionsExtension");
	case SOAP_TYPE_tt__AudioSourceConfigurationOptions:
		return ((tt__AudioSourceConfigurationOptions *)ptr)->soap_out(soap, tag, id, "tt:AudioSourceConfigurationOptions");
	case SOAP_TYPE_tt__AudioSourceConfiguration:
		return ((tt__AudioSourceConfiguration *)ptr)->soap_out(soap, tag, id, "tt:AudioSourceConfiguration");
	case SOAP_TYPE_tt__H264Options:
		return ((tt__H264Options *)ptr)->soap_out(soap, tag, id, "tt:H264Options");
	case SOAP_TYPE_tt__Mpeg4Options:
		return ((tt__Mpeg4Options *)ptr)->soap_out(soap, tag, id, "tt:Mpeg4Options");
	case SOAP_TYPE_tt__JpegOptions:
		return ((tt__JpegOptions *)ptr)->soap_out(soap, tag, id, "tt:JpegOptions");
	case SOAP_TYPE_tt__VideoEncoderOptionsExtension:
		return ((tt__VideoEncoderOptionsExtension *)ptr)->soap_out(soap, tag, id, "tt:VideoEncoderOptionsExtension");
	case SOAP_TYPE_tt__VideoEncoderConfigurationOptions:
		return ((tt__VideoEncoderConfigurationOptions *)ptr)->soap_out(soap, tag, id, "tt:VideoEncoderConfigurationOptions");
	case SOAP_TYPE_tt__H264Configuration:
		return ((tt__H264Configuration *)ptr)->soap_out(soap, tag, id, "tt:H264Configuration");
	case SOAP_TYPE_tt__Mpeg4Configuration:
		return ((tt__Mpeg4Configuration *)ptr)->soap_out(soap, tag, id, "tt:Mpeg4Configuration");
	case SOAP_TYPE_tt__VideoRateControl:
		return ((tt__VideoRateControl *)ptr)->soap_out(soap, tag, id, "tt:VideoRateControl");
	case SOAP_TYPE_tt__VideoResolution:
		return ((tt__VideoResolution *)ptr)->soap_out(soap, tag, id, "tt:VideoResolution");
	case SOAP_TYPE_tt__VideoEncoderConfiguration:
		return ((tt__VideoEncoderConfiguration *)ptr)->soap_out(soap, tag, id, "tt:VideoEncoderConfiguration");
	case SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension:
		return ((tt__VideoSourceConfigurationOptionsExtension *)ptr)->soap_out(soap, tag, id, "tt:VideoSourceConfigurationOptionsExtension");
	case SOAP_TYPE_tt__VideoSourceConfigurationOptions:
		return ((tt__VideoSourceConfigurationOptions *)ptr)->soap_out(soap, tag, id, "tt:VideoSourceConfigurationOptions");
	case SOAP_TYPE_tt__VideoSourceConfiguration:
		return ((tt__VideoSourceConfiguration *)ptr)->soap_out(soap, tag, id, "tt:VideoSourceConfiguration");
	case SOAP_TYPE_tt__ConfigurationEntity:
		return ((tt__ConfigurationEntity *)ptr)->soap_out(soap, tag, id, "tt:ConfigurationEntity");
	case SOAP_TYPE_tt__ProfileExtension:
		return ((tt__ProfileExtension *)ptr)->soap_out(soap, tag, id, "tt:ProfileExtension");
	case SOAP_TYPE_tt__Profile:
		return ((tt__Profile *)ptr)->soap_out(soap, tag, id, "tt:Profile");
	case SOAP_TYPE_tt__AudioSource:
		return ((tt__AudioSource *)ptr)->soap_out(soap, tag, id, "tt:AudioSource");
	case SOAP_TYPE_tt__VideoSourceExtension:
		return ((tt__VideoSourceExtension *)ptr)->soap_out(soap, tag, id, "tt:VideoSourceExtension");
	case SOAP_TYPE_tt__VideoSource:
		return ((tt__VideoSource *)ptr)->soap_out(soap, tag, id, "tt:VideoSource");
	case SOAP_TYPE_tt__IntList:
		return ((tt__IntList *)ptr)->soap_out(soap, tag, id, "tt:IntList");
	case SOAP_TYPE_tt__DurationRange:
		return ((tt__DurationRange *)ptr)->soap_out(soap, tag, id, "tt:DurationRange");
	case SOAP_TYPE_tt__FloatRange:
		return ((tt__FloatRange *)ptr)->soap_out(soap, tag, id, "tt:FloatRange");
	case SOAP_TYPE_tt__IntRange:
		return ((tt__IntRange *)ptr)->soap_out(soap, tag, id, "tt:IntRange");
	case SOAP_TYPE_tt__IntRectangleRange:
		return ((tt__IntRectangleRange *)ptr)->soap_out(soap, tag, id, "tt:IntRectangleRange");
	case SOAP_TYPE_tt__IntRectangle:
		return ((tt__IntRectangle *)ptr)->soap_out(soap, tag, id, "tt:IntRectangle");
	case SOAP_TYPE_tt__DeviceEntity:
		return ((tt__DeviceEntity *)ptr)->soap_out(soap, tag, id, "tt:DeviceEntity");
	case SOAP_TYPE__tan__GetAnalyticsModulesResponse:
		return ((_tan__GetAnalyticsModulesResponse *)ptr)->soap_out(soap, "tan:GetAnalyticsModulesResponse", id, NULL);
	case SOAP_TYPE__tan__GetAnalyticsModules:
		return ((_tan__GetAnalyticsModules *)ptr)->soap_out(soap, "tan:GetAnalyticsModules", id, NULL);
	case SOAP_TYPE__tan__ModifyAnalyticsModulesResponse:
		return ((_tan__ModifyAnalyticsModulesResponse *)ptr)->soap_out(soap, "tan:ModifyAnalyticsModulesResponse", id, NULL);
	case SOAP_TYPE__tan__ModifyAnalyticsModules:
		return ((_tan__ModifyAnalyticsModules *)ptr)->soap_out(soap, "tan:ModifyAnalyticsModules", id, NULL);
	case SOAP_TYPE__tan__DeleteAnalyticsModulesResponse:
		return ((_tan__DeleteAnalyticsModulesResponse *)ptr)->soap_out(soap, "tan:DeleteAnalyticsModulesResponse", id, NULL);
	case SOAP_TYPE__tan__DeleteAnalyticsModules:
		return ((_tan__DeleteAnalyticsModules *)ptr)->soap_out(soap, "tan:DeleteAnalyticsModules", id, NULL);
	case SOAP_TYPE__tan__CreateAnalyticsModulesResponse:
		return ((_tan__CreateAnalyticsModulesResponse *)ptr)->soap_out(soap, "tan:CreateAnalyticsModulesResponse", id, NULL);
	case SOAP_TYPE__tan__CreateAnalyticsModules:
		return ((_tan__CreateAnalyticsModules *)ptr)->soap_out(soap, "tan:CreateAnalyticsModules", id, NULL);
	case SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse:
		return ((_tan__GetSupportedAnalyticsModulesResponse *)ptr)->soap_out(soap, "tan:GetSupportedAnalyticsModulesResponse", id, NULL);
	case SOAP_TYPE__tan__GetSupportedAnalyticsModules:
		return ((_tan__GetSupportedAnalyticsModules *)ptr)->soap_out(soap, "tan:GetSupportedAnalyticsModules", id, NULL);
	case SOAP_TYPE__tan__GetRulesResponse:
		return ((_tan__GetRulesResponse *)ptr)->soap_out(soap, "tan:GetRulesResponse", id, NULL);
	case SOAP_TYPE__tan__GetRules:
		return ((_tan__GetRules *)ptr)->soap_out(soap, "tan:GetRules", id, NULL);
	case SOAP_TYPE__tan__ModifyRulesResponse:
		return ((_tan__ModifyRulesResponse *)ptr)->soap_out(soap, "tan:ModifyRulesResponse", id, NULL);
	case SOAP_TYPE__tan__ModifyRules:
		return ((_tan__ModifyRules *)ptr)->soap_out(soap, "tan:ModifyRules", id, NULL);
	case SOAP_TYPE__tan__DeleteRulesResponse:
		return ((_tan__DeleteRulesResponse *)ptr)->soap_out(soap, "tan:DeleteRulesResponse", id, NULL);
	case SOAP_TYPE__tan__DeleteRules:
		return ((_tan__DeleteRules *)ptr)->soap_out(soap, "tan:DeleteRules", id, NULL);
	case SOAP_TYPE__tan__CreateRulesResponse:
		return ((_tan__CreateRulesResponse *)ptr)->soap_out(soap, "tan:CreateRulesResponse", id, NULL);
	case SOAP_TYPE__tan__CreateRules:
		return ((_tan__CreateRules *)ptr)->soap_out(soap, "tan:CreateRules", id, NULL);
	case SOAP_TYPE__tan__GetSupportedRulesResponse:
		return ((_tan__GetSupportedRulesResponse *)ptr)->soap_out(soap, "tan:GetSupportedRulesResponse", id, NULL);
	case SOAP_TYPE__tan__GetSupportedRules:
		return ((_tan__GetSupportedRules *)ptr)->soap_out(soap, "tan:GetSupportedRules", id, NULL);
	case SOAP_TYPE__xml__lang:
		return soap_out__xml__lang(soap, "xml:lang", id, (const std::string *)ptr, NULL);
	case SOAP_TYPE_xsd__token:
		return soap_out_xsd__token(soap, tag, id, (const std::string *)ptr, "xsd:token");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_out_xsd__nonNegativeInteger(soap, tag, id, (const std::string *)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__integer:
		return soap_out_xsd__integer(soap, tag, id, (const std::string *)ptr, "xsd:integer");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__anySimpleType:
		return soap_out_xsd__anySimpleType(soap, tag, id, (const std::string *)ptr, "xsd:anySimpleType");
	case SOAP_TYPE_xsd__QName:
		return soap_out_xsd__QName(soap, tag, id, (const xsd__QName *)ptr, "xsd:QName");
	case SOAP_TYPE_xsd__NCName:
		return soap_out_xsd__NCName(soap, tag, id, (const std::string *)ptr, "xsd:NCName");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE__wsse__Security:
		return soap_out__wsse__Security(soap, "wsse:Security", id, (const struct _wsse__Security *)ptr, NULL);
	case SOAP_TYPE_ds__RSAKeyValueType:
		return soap_out_ds__RSAKeyValueType(soap, tag, id, (const struct ds__RSAKeyValueType *)ptr, "ds:RSAKeyValueType");
	case SOAP_TYPE_ds__DSAKeyValueType:
		return soap_out_ds__DSAKeyValueType(soap, tag, id, (const struct ds__DSAKeyValueType *)ptr, "ds:DSAKeyValueType");
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return soap_out_ds__X509IssuerSerialType(soap, tag, id, (const struct ds__X509IssuerSerialType *)ptr, "ds:X509IssuerSerialType");
	case SOAP_TYPE_ds__X509DataType:
		return soap_out_ds__X509DataType(soap, tag, id, (const struct ds__X509DataType *)ptr, "ds:X509DataType");
	case SOAP_TYPE_ds__RetrievalMethodType:
		return soap_out_ds__RetrievalMethodType(soap, tag, id, (const struct ds__RetrievalMethodType *)ptr, "ds:RetrievalMethodType");
	case SOAP_TYPE_ds__KeyValueType:
		return soap_out_ds__KeyValueType(soap, tag, id, (const struct ds__KeyValueType *)ptr, "ds:KeyValueType");
	case SOAP_TYPE_ds__DigestMethodType:
		return soap_out_ds__DigestMethodType(soap, tag, id, (const struct ds__DigestMethodType *)ptr, "ds:DigestMethodType");
	case SOAP_TYPE_ds__TransformType:
		return soap_out_ds__TransformType(soap, tag, id, (const struct ds__TransformType *)ptr, "ds:TransformType");
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		return soap_out__c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", id, (const struct _c14n__InclusiveNamespaces *)ptr, NULL);
	case SOAP_TYPE_ds__TransformsType:
		return soap_out_ds__TransformsType(soap, tag, id, (const struct ds__TransformsType *)ptr, "ds:TransformsType");
	case SOAP_TYPE_ds__ReferenceType:
		return soap_out_ds__ReferenceType(soap, tag, id, (const struct ds__ReferenceType *)ptr, "ds:ReferenceType");
	case SOAP_TYPE_ds__SignatureMethodType:
		return soap_out_ds__SignatureMethodType(soap, tag, id, (const struct ds__SignatureMethodType *)ptr, "ds:SignatureMethodType");
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return soap_out_ds__CanonicalizationMethodType(soap, tag, id, (const struct ds__CanonicalizationMethodType *)ptr, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_ds__KeyInfoType:
		return soap_out_ds__KeyInfoType(soap, tag, id, (const struct ds__KeyInfoType *)ptr, "ds:KeyInfoType");
	case SOAP_TYPE_ds__SignedInfoType:
		return soap_out_ds__SignedInfoType(soap, tag, id, (const struct ds__SignedInfoType *)ptr, "ds:SignedInfoType");
	case SOAP_TYPE_ds__SignatureType:
		return soap_out_ds__SignatureType(soap, tag, id, (const struct ds__SignatureType *)ptr, "ds:SignatureType");
	case SOAP_TYPE__wsse__SecurityTokenReference:
		return soap_out__wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", id, (const struct _wsse__SecurityTokenReference *)ptr, NULL);
	case SOAP_TYPE__wsse__KeyIdentifier:
		return soap_out__wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", id, (const struct _wsse__KeyIdentifier *)ptr, NULL);
	case SOAP_TYPE__wsse__Embedded:
		return soap_out__wsse__Embedded(soap, "wsse:Embedded", id, (const struct _wsse__Embedded *)ptr, NULL);
	case SOAP_TYPE__wsse__Reference:
		return soap_out__wsse__Reference(soap, "wsse:Reference", id, (const struct _wsse__Reference *)ptr, NULL);
	case SOAP_TYPE__wsse__BinarySecurityToken:
		return soap_out__wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", id, (const struct _wsse__BinarySecurityToken *)ptr, NULL);
	case SOAP_TYPE__wsse__Password:
		return soap_out__wsse__Password(soap, "wsse:Password", id, (const struct _wsse__Password *)ptr, NULL);
	case SOAP_TYPE__wsse__UsernameToken:
		return soap_out__wsse__UsernameToken(soap, "wsse:UsernameToken", id, (const struct _wsse__UsernameToken *)ptr, NULL);
	case SOAP_TYPE__wsu__Timestamp:
		return soap_out__wsu__Timestamp(soap, "wsu:Timestamp", id, (const struct _wsu__Timestamp *)ptr, NULL);
	case SOAP_TYPE__wsa5__ProblemAction:
		return soap_out__wsa5__ProblemAction(soap, "wsa5:ProblemAction", id, (const struct wsa5__ProblemActionType *)ptr, NULL);
	case SOAP_TYPE__wsa5__FaultTo:
		return soap_out__wsa5__FaultTo(soap, "wsa5:FaultTo", id, (const struct wsa5__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE__wsa5__From:
		return soap_out__wsa5__From(soap, "wsa5:From", id, (const struct wsa5__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE__wsa5__ReplyTo:
		return soap_out__wsa5__ReplyTo(soap, "wsa5:ReplyTo", id, (const struct wsa5__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE__wsa5__RelatesTo:
		return soap_out__wsa5__RelatesTo(soap, "wsa5:RelatesTo", id, (const struct wsa5__RelatesToType *)ptr, NULL);
	case SOAP_TYPE__wsa5__Metadata:
		return soap_out__wsa5__Metadata(soap, "wsa5:Metadata", id, (const struct wsa5__MetadataType *)ptr, NULL);
	case SOAP_TYPE__wsa5__ReferenceParameters:
		return soap_out__wsa5__ReferenceParameters(soap, "wsa5:ReferenceParameters", id, (const struct wsa5__ReferenceParametersType *)ptr, NULL);
	case SOAP_TYPE__wsa5__EndpointReference:
		return soap_out__wsa5__EndpointReference(soap, "wsa5:EndpointReference", id, (const struct wsa5__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_out_wsa5__ProblemActionType(soap, tag, id, (const struct wsa5__ProblemActionType *)ptr, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_out_wsa5__RelatesToType(soap, tag, id, (const struct wsa5__RelatesToType *)ptr, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_out_wsa5__MetadataType(soap, tag, id, (const struct wsa5__MetadataType *)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_out_wsa5__ReferenceParametersType(soap, tag, id, (const struct wsa5__ReferenceParametersType *)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_out_wsa5__EndpointReferenceType(soap, tag, id, (const struct wsa5__EndpointReferenceType *)ptr, "wsa5:EndpointReferenceType");
	case SOAP_TYPE__xop__Include:
		return soap_out__xop__Include(soap, "xop:Include", id, (const struct _xop__Include *)ptr, NULL);
	case SOAP_TYPE_xsd__anyAttribute:
		return soap_out_xsd__anyAttribute(soap, tag, id, (const struct soap_dom_attribute *)ptr, "xsd:anyAttribute");
	case SOAP_TYPE_xsd__anyType:
		return soap_out_xsd__anyType(soap, tag, id, (const struct soap_dom_element *)ptr, "xsd:anyType");
	case SOAP_TYPE_PointerTo_tan__ModifyAnalyticsModulesResponse:
		return soap_out_PointerTo_tan__ModifyAnalyticsModulesResponse(soap, tag, id, (_tan__ModifyAnalyticsModulesResponse *const*)ptr, "tan:ModifyAnalyticsModulesResponse");
	case SOAP_TYPE_PointerTo_tan__ModifyAnalyticsModules:
		return soap_out_PointerTo_tan__ModifyAnalyticsModules(soap, tag, id, (_tan__ModifyAnalyticsModules *const*)ptr, "tan:ModifyAnalyticsModules");
	case SOAP_TYPE_PointerTo_tan__GetAnalyticsModulesResponse:
		return soap_out_PointerTo_tan__GetAnalyticsModulesResponse(soap, tag, id, (_tan__GetAnalyticsModulesResponse *const*)ptr, "tan:GetAnalyticsModulesResponse");
	case SOAP_TYPE_PointerTo_tan__GetAnalyticsModules:
		return soap_out_PointerTo_tan__GetAnalyticsModules(soap, tag, id, (_tan__GetAnalyticsModules *const*)ptr, "tan:GetAnalyticsModules");
	case SOAP_TYPE_PointerTo_tan__DeleteAnalyticsModulesResponse:
		return soap_out_PointerTo_tan__DeleteAnalyticsModulesResponse(soap, tag, id, (_tan__DeleteAnalyticsModulesResponse *const*)ptr, "tan:DeleteAnalyticsModulesResponse");
	case SOAP_TYPE_PointerTo_tan__DeleteAnalyticsModules:
		return soap_out_PointerTo_tan__DeleteAnalyticsModules(soap, tag, id, (_tan__DeleteAnalyticsModules *const*)ptr, "tan:DeleteAnalyticsModules");
	case SOAP_TYPE_PointerTo_tan__CreateAnalyticsModulesResponse:
		return soap_out_PointerTo_tan__CreateAnalyticsModulesResponse(soap, tag, id, (_tan__CreateAnalyticsModulesResponse *const*)ptr, "tan:CreateAnalyticsModulesResponse");
	case SOAP_TYPE_PointerTo_tan__CreateAnalyticsModules:
		return soap_out_PointerTo_tan__CreateAnalyticsModules(soap, tag, id, (_tan__CreateAnalyticsModules *const*)ptr, "tan:CreateAnalyticsModules");
	case SOAP_TYPE_PointerTo_tan__GetSupportedAnalyticsModulesResponse:
		return soap_out_PointerTo_tan__GetSupportedAnalyticsModulesResponse(soap, tag, id, (_tan__GetSupportedAnalyticsModulesResponse *const*)ptr, "tan:GetSupportedAnalyticsModulesResponse");
	case SOAP_TYPE_PointerTo_tan__GetSupportedAnalyticsModules:
		return soap_out_PointerTo_tan__GetSupportedAnalyticsModules(soap, tag, id, (_tan__GetSupportedAnalyticsModules *const*)ptr, "tan:GetSupportedAnalyticsModules");
	case SOAP_TYPE_PointerTo_tan__ModifyRulesResponse:
		return soap_out_PointerTo_tan__ModifyRulesResponse(soap, tag, id, (_tan__ModifyRulesResponse *const*)ptr, "tan:ModifyRulesResponse");
	case SOAP_TYPE_PointerTo_tan__ModifyRules:
		return soap_out_PointerTo_tan__ModifyRules(soap, tag, id, (_tan__ModifyRules *const*)ptr, "tan:ModifyRules");
	case SOAP_TYPE_PointerTo_tan__GetRulesResponse:
		return soap_out_PointerTo_tan__GetRulesResponse(soap, tag, id, (_tan__GetRulesResponse *const*)ptr, "tan:GetRulesResponse");
	case SOAP_TYPE_PointerTo_tan__GetRules:
		return soap_out_PointerTo_tan__GetRules(soap, tag, id, (_tan__GetRules *const*)ptr, "tan:GetRules");
	case SOAP_TYPE_PointerTo_tan__DeleteRulesResponse:
		return soap_out_PointerTo_tan__DeleteRulesResponse(soap, tag, id, (_tan__DeleteRulesResponse *const*)ptr, "tan:DeleteRulesResponse");
	case SOAP_TYPE_PointerTo_tan__DeleteRules:
		return soap_out_PointerTo_tan__DeleteRules(soap, tag, id, (_tan__DeleteRules *const*)ptr, "tan:DeleteRules");
	case SOAP_TYPE_PointerTo_tan__CreateRulesResponse:
		return soap_out_PointerTo_tan__CreateRulesResponse(soap, tag, id, (_tan__CreateRulesResponse *const*)ptr, "tan:CreateRulesResponse");
	case SOAP_TYPE_PointerTo_tan__CreateRules:
		return soap_out_PointerTo_tan__CreateRules(soap, tag, id, (_tan__CreateRules *const*)ptr, "tan:CreateRules");
	case SOAP_TYPE_PointerTo_tan__GetSupportedRulesResponse:
		return soap_out_PointerTo_tan__GetSupportedRulesResponse(soap, tag, id, (_tan__GetSupportedRulesResponse *const*)ptr, "tan:GetSupportedRulesResponse");
	case SOAP_TYPE_PointerTo_tan__GetSupportedRules:
		return soap_out_PointerTo_tan__GetSupportedRules(soap, tag, id, (_tan__GetSupportedRules *const*)ptr, "tan:GetSupportedRules");
	case SOAP_TYPE_PointerToxsd__NCName:
		return soap_out_PointerToxsd__NCName(soap, tag, id, (std::string *const*)ptr, "xsd:NCName");
	case SOAP_TYPE_PointerTo_wstop__TopicNamespaceType_Topic:
		return soap_out_PointerTo_wstop__TopicNamespaceType_Topic(soap, tag, id, (_wstop__TopicNamespaceType_Topic *const*)ptr, "wstop:TopicNamespaceType-Topic");
	case SOAP_TYPE_PointerTowstop__ConcreteTopicExpression:
		return soap_out_PointerTowstop__ConcreteTopicExpression(soap, tag, id, (std::string *const*)ptr, "wstop:ConcreteTopicExpression");
	case SOAP_TYPE_PointerTowstop__TopicType:
		return soap_out_PointerTowstop__TopicType(soap, tag, id, (wstop__TopicType *const*)ptr, "wstop:TopicType");
	case SOAP_TYPE_PointerTowstop__QueryExpressionType:
		return soap_out_PointerTowstop__QueryExpressionType(soap, tag, id, (wstop__QueryExpressionType *const*)ptr, "wstop:QueryExpressionType");
	case SOAP_TYPE_PointerTott__ObjectExtension:
		return soap_out_PointerTott__ObjectExtension(soap, tag, id, (tt__ObjectExtension *const*)ptr, "tt:ObjectExtension");
	case SOAP_TYPE_PointerTott__Behaviour:
		return soap_out_PointerTott__Behaviour(soap, tag, id, (tt__Behaviour *const*)ptr, "tt:Behaviour");
	case SOAP_TYPE_PointerTott__Appearance:
		return soap_out_PointerTott__Appearance(soap, tag, id, (tt__Appearance *const*)ptr, "tt:Appearance");
	case SOAP_TYPE_PointerTott__PTZConfigurationExtension:
		return soap_out_PointerTott__PTZConfigurationExtension(soap, tag, id, (tt__PTZConfigurationExtension *const*)ptr, "tt:PTZConfigurationExtension");
	case SOAP_TYPE_PointerTott__ZoomLimits:
		return soap_out_PointerTott__ZoomLimits(soap, tag, id, (tt__ZoomLimits *const*)ptr, "tt:ZoomLimits");
	case SOAP_TYPE_PointerTott__PanTiltLimits:
		return soap_out_PointerTott__PanTiltLimits(soap, tag, id, (tt__PanTiltLimits *const*)ptr, "tt:PanTiltLimits");
	case SOAP_TYPE_PointerTott__PTZSpeed:
		return soap_out_PointerTott__PTZSpeed(soap, tag, id, (tt__PTZSpeed *const*)ptr, "tt:PTZSpeed");
	case SOAP_TYPE_PointerTott__PTZNodeExtension:
		return soap_out_PointerTott__PTZNodeExtension(soap, tag, id, (tt__PTZNodeExtension *const*)ptr, "tt:PTZNodeExtension");
	case SOAP_TYPE_PointerTott__RelayOutputSettings:
		return soap_out_PointerTott__RelayOutputSettings(soap, tag, id, (tt__RelayOutputSettings *const*)ptr, "tt:RelayOutputSettings");
	case SOAP_TYPE_PointerTott__NetworkInterfaceExtension:
		return soap_out_PointerTott__NetworkInterfaceExtension(soap, tag, id, (tt__NetworkInterfaceExtension *const*)ptr, "tt:NetworkInterfaceExtension");
	case SOAP_TYPE_PointerTott__IPv6NetworkInterface:
		return soap_out_PointerTott__IPv6NetworkInterface(soap, tag, id, (tt__IPv6NetworkInterface *const*)ptr, "tt:IPv6NetworkInterface");
	case SOAP_TYPE_PointerTott__IPv4NetworkInterface:
		return soap_out_PointerTott__IPv4NetworkInterface(soap, tag, id, (tt__IPv4NetworkInterface *const*)ptr, "tt:IPv4NetworkInterface");
	case SOAP_TYPE_PointerTott__NetworkInterfaceLink:
		return soap_out_PointerTott__NetworkInterfaceLink(soap, tag, id, (tt__NetworkInterfaceLink *const*)ptr, "tt:NetworkInterfaceLink");
	case SOAP_TYPE_PointerTott__NetworkInterfaceInfo:
		return soap_out_PointerTott__NetworkInterfaceInfo(soap, tag, id, (tt__NetworkInterfaceInfo *const*)ptr, "tt:NetworkInterfaceInfo");
	case SOAP_TYPE_PointerTott__EventSubscription:
		return soap_out_PointerTott__EventSubscription(soap, tag, id, (tt__EventSubscription *const*)ptr, "tt:EventSubscription");
	case SOAP_TYPE_PointerTott__PTZFilter:
		return soap_out_PointerTott__PTZFilter(soap, tag, id, (tt__PTZFilter *const*)ptr, "tt:PTZFilter");
	case SOAP_TYPE_PointerTott__RuleEngineConfiguration:
		return soap_out_PointerTott__RuleEngineConfiguration(soap, tag, id, (tt__RuleEngineConfiguration *const*)ptr, "tt:RuleEngineConfiguration");
	case SOAP_TYPE_PointerTott__AnalyticsEngineConfiguration:
		return soap_out_PointerTott__AnalyticsEngineConfiguration(soap, tag, id, (tt__AnalyticsEngineConfiguration *const*)ptr, "tt:AnalyticsEngineConfiguration");
	case SOAP_TYPE_PointerTott__MulticastConfiguration:
		return soap_out_PointerTott__MulticastConfiguration(soap, tag, id, (tt__MulticastConfiguration *const*)ptr, "tt:MulticastConfiguration");
	case SOAP_TYPE_PointerTott__H264Configuration:
		return soap_out_PointerTott__H264Configuration(soap, tag, id, (tt__H264Configuration *const*)ptr, "tt:H264Configuration");
	case SOAP_TYPE_PointerTott__Mpeg4Configuration:
		return soap_out_PointerTott__Mpeg4Configuration(soap, tag, id, (tt__Mpeg4Configuration *const*)ptr, "tt:Mpeg4Configuration");
	case SOAP_TYPE_PointerTott__VideoRateControl:
		return soap_out_PointerTott__VideoRateControl(soap, tag, id, (tt__VideoRateControl *const*)ptr, "tt:VideoRateControl");
	case SOAP_TYPE_PointerTott__IntRectangle:
		return soap_out_PointerTott__IntRectangle(soap, tag, id, (tt__IntRectangle *const*)ptr, "tt:IntRectangle");
	case SOAP_TYPE_PointerTott__VideoSourceExtension:
		return soap_out_PointerTott__VideoSourceExtension(soap, tag, id, (tt__VideoSourceExtension *const*)ptr, "tt:VideoSourceExtension");
	case SOAP_TYPE_PointerTott__ImagingSettings:
		return soap_out_PointerTott__ImagingSettings(soap, tag, id, (tt__ImagingSettings *const*)ptr, "tt:ImagingSettings");
	case SOAP_TYPE_PointerTowstop__Documentation:
		return soap_out_PointerTowstop__Documentation(soap, tag, id, (wstop__Documentation *const*)ptr, "wstop:Documentation");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause:
		return soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag, id, (_wsrfbf__BaseFaultType_FaultCause *const*)ptr, "wsrfbf:BaseFaultType-FaultCause");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_Description:
		return soap_out_PointerTo_wsrfbf__BaseFaultType_Description(soap, tag, id, (_wsrfbf__BaseFaultType_Description *const*)ptr, "wsrfbf:BaseFaultType-Description");
	case SOAP_TYPE_PointerTo_xml__lang:
		return soap_out_PointerTo_xml__lang(soap, tag, id, (std::string *const*)ptr, "xml:lang");
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode:
		return soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag, id, (_wsrfbf__BaseFaultType_ErrorCode *const*)ptr, "wsrfbf:BaseFaultType-ErrorCode");
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		return soap_out_PointerToxsd__nonNegativeInteger(soap, tag, id, (std::string *const*)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_PointerTo_wsnb__Subscribe_SubscriptionPolicy:
		return soap_out_PointerTo_wsnb__Subscribe_SubscriptionPolicy(soap, tag, id, (_wsnb__Subscribe_SubscriptionPolicy *const*)ptr, "wsnb:Subscribe-SubscriptionPolicy");
	case SOAP_TYPE_PointerTowsnb__AbsoluteOrRelativeTimeType:
		return soap_out_PointerTowsnb__AbsoluteOrRelativeTimeType(soap, tag, id, (std::string *const*)ptr, "wsnb:AbsoluteOrRelativeTimeType");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTowsnb__SubscriptionPolicyType:
		return soap_out_PointerTowsnb__SubscriptionPolicyType(soap, tag, id, (wsnb__SubscriptionPolicyType *const*)ptr, "wsnb:SubscriptionPolicyType");
	case SOAP_TYPE_PointerTowstop__TopicSetType:
		return soap_out_PointerTowstop__TopicSetType(soap, tag, id, (wstop__TopicSetType *const*)ptr, "wstop:TopicSetType");
	case SOAP_TYPE_PointerTowsnb__TopicExpressionType:
		return soap_out_PointerTowsnb__TopicExpressionType(soap, tag, id, (wsnb__TopicExpressionType *const*)ptr, "wsnb:TopicExpressionType");
	case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
		return soap_out_PointerTowsa5__EndpointReferenceType(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTott__PropertyOperation:
		return soap_out_PointerTott__PropertyOperation(soap, tag, id, (enum tt__PropertyOperation *const*)ptr, "tt:PropertyOperation");
	case SOAP_TYPE_PointerTott__MessageExtension:
		return soap_out_PointerTott__MessageExtension(soap, tag, id, (tt__MessageExtension *const*)ptr, "tt:MessageExtension");
	case SOAP_TYPE_PointerTott__EventStreamExtension:
		return soap_out_PointerTott__EventStreamExtension(soap, tag, id, (tt__EventStreamExtension *const*)ptr, "tt:EventStreamExtension");
	case SOAP_TYPE_PointerTowsnb__NotificationMessageHolderType:
		return soap_out_PointerTowsnb__NotificationMessageHolderType(soap, tag, id, (wsnb__NotificationMessageHolderType *const*)ptr, "wsnb:NotificationMessageHolderType");
	case SOAP_TYPE_PointerTott__PTZStreamExtension:
		return soap_out_PointerTott__PTZStreamExtension(soap, tag, id, (tt__PTZStreamExtension *const*)ptr, "tt:PTZStreamExtension");
	case SOAP_TYPE_PointerTott__VideoAnalyticsStreamExtension:
		return soap_out_PointerTott__VideoAnalyticsStreamExtension(soap, tag, id, (tt__VideoAnalyticsStreamExtension *const*)ptr, "tt:VideoAnalyticsStreamExtension");
	case SOAP_TYPE_PointerTott__Frame:
		return soap_out_PointerTott__Frame(soap, tag, id, (tt__Frame *const*)ptr, "tt:Frame");
	case SOAP_TYPE_PointerTott__MetadataStreamExtension:
		return soap_out_PointerTott__MetadataStreamExtension(soap, tag, id, (tt__MetadataStreamExtension *const*)ptr, "tt:MetadataStreamExtension");
	case SOAP_TYPE_PointerTott__EventStream:
		return soap_out_PointerTott__EventStream(soap, tag, id, (tt__EventStream *const*)ptr, "tt:EventStream");
	case SOAP_TYPE_PointerTott__PTZStream:
		return soap_out_PointerTott__PTZStream(soap, tag, id, (tt__PTZStream *const*)ptr, "tt:PTZStream");
	case SOAP_TYPE_PointerTott__VideoAnalyticsStream:
		return soap_out_PointerTott__VideoAnalyticsStream(soap, tag, id, (tt__VideoAnalyticsStream *const*)ptr, "tt:VideoAnalyticsStream");
	case SOAP_TYPE_PointerTott__SupportedAnalyticsModulesExtension:
		return soap_out_PointerTott__SupportedAnalyticsModulesExtension(soap, tag, id, (tt__SupportedAnalyticsModulesExtension *const*)ptr, "tt:SupportedAnalyticsModulesExtension");
	case SOAP_TYPE_PointerTott__SupportedRulesExtension:
		return soap_out_PointerTott__SupportedRulesExtension(soap, tag, id, (tt__SupportedRulesExtension *const*)ptr, "tt:SupportedRulesExtension");
	case SOAP_TYPE_PointerTott__ConfigDescription:
		return soap_out_PointerTott__ConfigDescription(soap, tag, id, (tt__ConfigDescription *const*)ptr, "tt:ConfigDescription");
	case SOAP_TYPE_PointerTott__ConfigDescriptionExtension:
		return soap_out_PointerTott__ConfigDescriptionExtension(soap, tag, id, (tt__ConfigDescriptionExtension *const*)ptr, "tt:ConfigDescriptionExtension");
	case SOAP_TYPE_PointerTo_tt__ConfigDescription_Messages:
		return soap_out_PointerTo_tt__ConfigDescription_Messages(soap, tag, id, (_tt__ConfigDescription_Messages *const*)ptr, "tt:ConfigDescription-Messages");
	case SOAP_TYPE_PointerTott__ItemList:
		return soap_out_PointerTott__ItemList(soap, tag, id, (tt__ItemList *const*)ptr, "tt:ItemList");
	case SOAP_TYPE_PointerTott__RuleEngineConfigurationExtension:
		return soap_out_PointerTott__RuleEngineConfigurationExtension(soap, tag, id, (tt__RuleEngineConfigurationExtension *const*)ptr, "tt:RuleEngineConfigurationExtension");
	case SOAP_TYPE_PointerTott__AnalyticsEngineConfigurationExtension:
		return soap_out_PointerTott__AnalyticsEngineConfigurationExtension(soap, tag, id, (tt__AnalyticsEngineConfigurationExtension *const*)ptr, "tt:AnalyticsEngineConfigurationExtension");
	case SOAP_TYPE_PointerTott__ObjectTreeExtension:
		return soap_out_PointerTott__ObjectTreeExtension(soap, tag, id, (tt__ObjectTreeExtension *const*)ptr, "tt:ObjectTreeExtension");
	case SOAP_TYPE_PointerTott__Merge:
		return soap_out_PointerTott__Merge(soap, tag, id, (tt__Merge *const*)ptr, "tt:Merge");
	case SOAP_TYPE_PointerTott__Split:
		return soap_out_PointerTott__Split(soap, tag, id, (tt__Split *const*)ptr, "tt:Split");
	case SOAP_TYPE_PointerTott__Rename:
		return soap_out_PointerTott__Rename(soap, tag, id, (tt__Rename *const*)ptr, "tt:Rename");
	case SOAP_TYPE_PointerTott__BehaviourExtension:
		return soap_out_PointerTott__BehaviourExtension(soap, tag, id, (tt__BehaviourExtension *const*)ptr, "tt:BehaviourExtension");
	case SOAP_TYPE_PointerTo_tt__Behaviour_Idle:
		return soap_out_PointerTo_tt__Behaviour_Idle(soap, tag, id, (_tt__Behaviour_Idle *const*)ptr, "tt:Behaviour-Idle");
	case SOAP_TYPE_PointerTo_tt__Behaviour_Removed:
		return soap_out_PointerTo_tt__Behaviour_Removed(soap, tag, id, (_tt__Behaviour_Removed *const*)ptr, "tt:Behaviour-Removed");
	case SOAP_TYPE_PointerToxsd__integer:
		return soap_out_PointerToxsd__integer(soap, tag, id, (std::string *const*)ptr, "xsd:integer");
	case SOAP_TYPE_PointerTott__ObjectId:
		return soap_out_PointerTott__ObjectId(soap, tag, id, (tt__ObjectId *const*)ptr, "tt:ObjectId");
	case SOAP_TYPE_PointerTott__FrameExtension:
		return soap_out_PointerTott__FrameExtension(soap, tag, id, (tt__FrameExtension *const*)ptr, "tt:FrameExtension");
	case SOAP_TYPE_PointerTott__ObjectTree:
		return soap_out_PointerTott__ObjectTree(soap, tag, id, (tt__ObjectTree *const*)ptr, "tt:ObjectTree");
	case SOAP_TYPE_PointerTott__Object:
		return soap_out_PointerTott__Object(soap, tag, id, (tt__Object *const*)ptr, "tt:Object");
	case SOAP_TYPE_PointerTott__PTZStatus:
		return soap_out_PointerTott__PTZStatus(soap, tag, id, (tt__PTZStatus *const*)ptr, "tt:PTZStatus");
	case SOAP_TYPE_PointerTott__TransformationExtension:
		return soap_out_PointerTott__TransformationExtension(soap, tag, id, (tt__TransformationExtension *const*)ptr, "tt:TransformationExtension");
	case SOAP_TYPE_PointerTott__ClassDescriptorExtension:
		return soap_out_PointerTott__ClassDescriptorExtension(soap, tag, id, (tt__ClassDescriptorExtension *const*)ptr, "tt:ClassDescriptorExtension");
	case SOAP_TYPE_PointerTo_tt__ClassDescriptor_ClassCandidate:
		return soap_out_PointerTo_tt__ClassDescriptor_ClassCandidate(soap, tag, id, (_tt__ClassDescriptor_ClassCandidate *const*)ptr, "tt:ClassDescriptor-ClassCandidate");
	case SOAP_TYPE_PointerTott__ColorDescriptorExtension:
		return soap_out_PointerTott__ColorDescriptorExtension(soap, tag, id, (tt__ColorDescriptorExtension *const*)ptr, "tt:ColorDescriptorExtension");
	case SOAP_TYPE_PointerTo_tt__ColorDescriptor_ColorCluster:
		return soap_out_PointerTo_tt__ColorDescriptor_ColorCluster(soap, tag, id, (_tt__ColorDescriptor_ColorCluster *const*)ptr, "tt:ColorDescriptor-ColorCluster");
	case SOAP_TYPE_PointerTott__ColorCovariance:
		return soap_out_PointerTott__ColorCovariance(soap, tag, id, (tt__ColorCovariance *const*)ptr, "tt:ColorCovariance");
	case SOAP_TYPE_PointerTott__Color:
		return soap_out_PointerTott__Color(soap, tag, id, (tt__Color *const*)ptr, "tt:Color");
	case SOAP_TYPE_PointerTott__ShapeDescriptorExtension:
		return soap_out_PointerTott__ShapeDescriptorExtension(soap, tag, id, (tt__ShapeDescriptorExtension *const*)ptr, "tt:ShapeDescriptorExtension");
	case SOAP_TYPE_PointerTott__Polygon:
		return soap_out_PointerTott__Polygon(soap, tag, id, (tt__Polygon *const*)ptr, "tt:Polygon");
	case SOAP_TYPE_PointerTott__AppearanceExtension:
		return soap_out_PointerTott__AppearanceExtension(soap, tag, id, (tt__AppearanceExtension *const*)ptr, "tt:AppearanceExtension");
	case SOAP_TYPE_PointerTott__ClassDescriptor:
		return soap_out_PointerTott__ClassDescriptor(soap, tag, id, (tt__ClassDescriptor *const*)ptr, "tt:ClassDescriptor");
	case SOAP_TYPE_PointerTott__ColorDescriptor:
		return soap_out_PointerTott__ColorDescriptor(soap, tag, id, (tt__ColorDescriptor *const*)ptr, "tt:ColorDescriptor");
	case SOAP_TYPE_PointerTott__ShapeDescriptor:
		return soap_out_PointerTott__ShapeDescriptor(soap, tag, id, (tt__ShapeDescriptor *const*)ptr, "tt:ShapeDescriptor");
	case SOAP_TYPE_PointerTott__Transformation:
		return soap_out_PointerTott__Transformation(soap, tag, id, (tt__Transformation *const*)ptr, "tt:Transformation");
	case SOAP_TYPE_PointerTott__Vector:
		return soap_out_PointerTott__Vector(soap, tag, id, (tt__Vector *const*)ptr, "tt:Vector");
	case SOAP_TYPE_PointerTott__ItemListDescriptionExtension:
		return soap_out_PointerTott__ItemListDescriptionExtension(soap, tag, id, (tt__ItemListDescriptionExtension *const*)ptr, "tt:ItemListDescriptionExtension");
	case SOAP_TYPE_PointerTo_tt__ItemListDescription_ElementItemDescription:
		return soap_out_PointerTo_tt__ItemListDescription_ElementItemDescription(soap, tag, id, (_tt__ItemListDescription_ElementItemDescription *const*)ptr, "tt:ItemListDescription-ElementItemDescription");
	case SOAP_TYPE_PointerTo_tt__ItemListDescription_SimpleItemDescription:
		return soap_out_PointerTo_tt__ItemListDescription_SimpleItemDescription(soap, tag, id, (_tt__ItemListDescription_SimpleItemDescription *const*)ptr, "tt:ItemListDescription-SimpleItemDescription");
	case SOAP_TYPE_PointerTott__MessageDescriptionExtension:
		return soap_out_PointerTott__MessageDescriptionExtension(soap, tag, id, (tt__MessageDescriptionExtension *const*)ptr, "tt:MessageDescriptionExtension");
	case SOAP_TYPE_PointerTott__ItemListDescription:
		return soap_out_PointerTott__ItemListDescription(soap, tag, id, (tt__ItemListDescription *const*)ptr, "tt:ItemListDescription");
	case SOAP_TYPE_PointerTott__ItemListExtension:
		return soap_out_PointerTott__ItemListExtension(soap, tag, id, (tt__ItemListExtension *const*)ptr, "tt:ItemListExtension");
	case SOAP_TYPE_PointerTo_tt__ItemList_ElementItem:
		return soap_out_PointerTo_tt__ItemList_ElementItem(soap, tag, id, (_tt__ItemList_ElementItem *const*)ptr, "tt:ItemList-ElementItem");
	case SOAP_TYPE_PointerTo_tt__ItemList_SimpleItem:
		return soap_out_PointerTo_tt__ItemList_SimpleItem(soap, tag, id, (_tt__ItemList_SimpleItem *const*)ptr, "tt:ItemList-SimpleItem");
	case SOAP_TYPE_PointerTott__FocusOptions20Extension:
		return soap_out_PointerTott__FocusOptions20Extension(soap, tag, id, (tt__FocusOptions20Extension *const*)ptr, "tt:FocusOptions20Extension");
	case SOAP_TYPE_PointerTott__WhiteBalanceOptions20Extension:
		return soap_out_PointerTott__WhiteBalanceOptions20Extension(soap, tag, id, (tt__WhiteBalanceOptions20Extension *const*)ptr, "tt:WhiteBalanceOptions20Extension");
	case SOAP_TYPE_PointerTott__FocusConfiguration20Extension:
		return soap_out_PointerTott__FocusConfiguration20Extension(soap, tag, id, (tt__FocusConfiguration20Extension *const*)ptr, "tt:FocusConfiguration20Extension");
	case SOAP_TYPE_PointerTott__WhiteBalance20Extension:
		return soap_out_PointerTott__WhiteBalance20Extension(soap, tag, id, (tt__WhiteBalance20Extension *const*)ptr, "tt:WhiteBalance20Extension");
	case SOAP_TYPE_PointerTott__RelativeFocusOptions20:
		return soap_out_PointerTott__RelativeFocusOptions20(soap, tag, id, (tt__RelativeFocusOptions20 *const*)ptr, "tt:RelativeFocusOptions20");
	case SOAP_TYPE_PointerTott__ImagingOptions20Extension:
		return soap_out_PointerTott__ImagingOptions20Extension(soap, tag, id, (tt__ImagingOptions20Extension *const*)ptr, "tt:ImagingOptions20Extension");
	case SOAP_TYPE_PointerTott__WhiteBalanceOptions20:
		return soap_out_PointerTott__WhiteBalanceOptions20(soap, tag, id, (tt__WhiteBalanceOptions20 *const*)ptr, "tt:WhiteBalanceOptions20");
	case SOAP_TYPE_PointerTott__WideDynamicRangeOptions20:
		return soap_out_PointerTott__WideDynamicRangeOptions20(soap, tag, id, (tt__WideDynamicRangeOptions20 *const*)ptr, "tt:WideDynamicRangeOptions20");
	case SOAP_TYPE_PointerTott__FocusOptions20:
		return soap_out_PointerTott__FocusOptions20(soap, tag, id, (tt__FocusOptions20 *const*)ptr, "tt:FocusOptions20");
	case SOAP_TYPE_PointerTott__ExposureOptions20:
		return soap_out_PointerTott__ExposureOptions20(soap, tag, id, (tt__ExposureOptions20 *const*)ptr, "tt:ExposureOptions20");
	case SOAP_TYPE_PointerTott__BacklightCompensationOptions20:
		return soap_out_PointerTott__BacklightCompensationOptions20(soap, tag, id, (tt__BacklightCompensationOptions20 *const*)ptr, "tt:BacklightCompensationOptions20");
	case SOAP_TYPE_PointerTott__ExposurePriority:
		return soap_out_PointerTott__ExposurePriority(soap, tag, id, (enum tt__ExposurePriority *const*)ptr, "tt:ExposurePriority");
	case SOAP_TYPE_PointerTott__ImagingSettingsExtension20:
		return soap_out_PointerTott__ImagingSettingsExtension20(soap, tag, id, (tt__ImagingSettingsExtension20 *const*)ptr, "tt:ImagingSettingsExtension20");
	case SOAP_TYPE_PointerTott__WhiteBalance20:
		return soap_out_PointerTott__WhiteBalance20(soap, tag, id, (tt__WhiteBalance20 *const*)ptr, "tt:WhiteBalance20");
	case SOAP_TYPE_PointerTott__WideDynamicRange20:
		return soap_out_PointerTott__WideDynamicRange20(soap, tag, id, (tt__WideDynamicRange20 *const*)ptr, "tt:WideDynamicRange20");
	case SOAP_TYPE_PointerTott__FocusConfiguration20:
		return soap_out_PointerTott__FocusConfiguration20(soap, tag, id, (tt__FocusConfiguration20 *const*)ptr, "tt:FocusConfiguration20");
	case SOAP_TYPE_PointerTott__Exposure20:
		return soap_out_PointerTott__Exposure20(soap, tag, id, (tt__Exposure20 *const*)ptr, "tt:Exposure20");
	case SOAP_TYPE_PointerTott__BacklightCompensation20:
		return soap_out_PointerTott__BacklightCompensation20(soap, tag, id, (tt__BacklightCompensation20 *const*)ptr, "tt:BacklightCompensation20");
	case SOAP_TYPE_PointerTott__FocusStatus20Extension:
		return soap_out_PointerTott__FocusStatus20Extension(soap, tag, id, (tt__FocusStatus20Extension *const*)ptr, "tt:FocusStatus20Extension");
	case SOAP_TYPE_PointerTott__ImagingStatus20Extension:
		return soap_out_PointerTott__ImagingStatus20Extension(soap, tag, id, (tt__ImagingStatus20Extension *const*)ptr, "tt:ImagingStatus20Extension");
	case SOAP_TYPE_PointerTott__FocusStatus20:
		return soap_out_PointerTott__FocusStatus20(soap, tag, id, (tt__FocusStatus20 *const*)ptr, "tt:FocusStatus20");
	case SOAP_TYPE_PointerTott__ContinuousFocusOptions:
		return soap_out_PointerTott__ContinuousFocusOptions(soap, tag, id, (tt__ContinuousFocusOptions *const*)ptr, "tt:ContinuousFocusOptions");
	case SOAP_TYPE_PointerTott__RelativeFocusOptions:
		return soap_out_PointerTott__RelativeFocusOptions(soap, tag, id, (tt__RelativeFocusOptions *const*)ptr, "tt:RelativeFocusOptions");
	case SOAP_TYPE_PointerTott__AbsoluteFocusOptions:
		return soap_out_PointerTott__AbsoluteFocusOptions(soap, tag, id, (tt__AbsoluteFocusOptions *const*)ptr, "tt:AbsoluteFocusOptions");
	case SOAP_TYPE_PointerTott__ContinuousFocus:
		return soap_out_PointerTott__ContinuousFocus(soap, tag, id, (tt__ContinuousFocus *const*)ptr, "tt:ContinuousFocus");
	case SOAP_TYPE_PointerTott__RelativeFocus:
		return soap_out_PointerTott__RelativeFocus(soap, tag, id, (tt__RelativeFocus *const*)ptr, "tt:RelativeFocus");
	case SOAP_TYPE_PointerTott__AbsoluteFocus:
		return soap_out_PointerTott__AbsoluteFocus(soap, tag, id, (tt__AbsoluteFocus *const*)ptr, "tt:AbsoluteFocus");
	case SOAP_TYPE_PointerTott__WhiteBalanceOptions:
		return soap_out_PointerTott__WhiteBalanceOptions(soap, tag, id, (tt__WhiteBalanceOptions *const*)ptr, "tt:WhiteBalanceOptions");
	case SOAP_TYPE_PointerTott__WideDynamicRangeOptions:
		return soap_out_PointerTott__WideDynamicRangeOptions(soap, tag, id, (tt__WideDynamicRangeOptions *const*)ptr, "tt:WideDynamicRangeOptions");
	case SOAP_TYPE_PointerTott__FocusOptions:
		return soap_out_PointerTott__FocusOptions(soap, tag, id, (tt__FocusOptions *const*)ptr, "tt:FocusOptions");
	case SOAP_TYPE_PointerTott__ExposureOptions:
		return soap_out_PointerTott__ExposureOptions(soap, tag, id, (tt__ExposureOptions *const*)ptr, "tt:ExposureOptions");
	case SOAP_TYPE_PointerTott__BacklightCompensationOptions:
		return soap_out_PointerTott__BacklightCompensationOptions(soap, tag, id, (tt__BacklightCompensationOptions *const*)ptr, "tt:BacklightCompensationOptions");
	case SOAP_TYPE_PointerTott__Rectangle:
		return soap_out_PointerTott__Rectangle(soap, tag, id, (tt__Rectangle *const*)ptr, "tt:Rectangle");
	case SOAP_TYPE_PointerTott__ImagingSettingsExtension:
		return soap_out_PointerTott__ImagingSettingsExtension(soap, tag, id, (tt__ImagingSettingsExtension *const*)ptr, "tt:ImagingSettingsExtension");
	case SOAP_TYPE_PointerTott__WhiteBalance:
		return soap_out_PointerTott__WhiteBalance(soap, tag, id, (tt__WhiteBalance *const*)ptr, "tt:WhiteBalance");
	case SOAP_TYPE_PointerTott__WideDynamicRange:
		return soap_out_PointerTott__WideDynamicRange(soap, tag, id, (tt__WideDynamicRange *const*)ptr, "tt:WideDynamicRange");
	case SOAP_TYPE_PointerTott__IrCutFilterMode:
		return soap_out_PointerTott__IrCutFilterMode(soap, tag, id, (enum tt__IrCutFilterMode *const*)ptr, "tt:IrCutFilterMode");
	case SOAP_TYPE_PointerTott__FocusConfiguration:
		return soap_out_PointerTott__FocusConfiguration(soap, tag, id, (tt__FocusConfiguration *const*)ptr, "tt:FocusConfiguration");
	case SOAP_TYPE_PointerTott__Exposure:
		return soap_out_PointerTott__Exposure(soap, tag, id, (tt__Exposure *const*)ptr, "tt:Exposure");
	case SOAP_TYPE_PointerTofloat:
		return soap_out_PointerTofloat(soap, tag, id, (float *const*)ptr, "xsd:float");
	case SOAP_TYPE_PointerTott__BacklightCompensation:
		return soap_out_PointerTott__BacklightCompensation(soap, tag, id, (tt__BacklightCompensation *const*)ptr, "tt:BacklightCompensation");
	case SOAP_TYPE_PointerTott__FocusStatus:
		return soap_out_PointerTott__FocusStatus(soap, tag, id, (tt__FocusStatus *const*)ptr, "tt:FocusStatus");
	case SOAP_TYPE_PointerTott__MoveStatus:
		return soap_out_PointerTott__MoveStatus(soap, tag, id, (enum tt__MoveStatus *const*)ptr, "tt:MoveStatus");
	case SOAP_TYPE_PointerTott__ReferenceToken:
		return soap_out_PointerTott__ReferenceToken(soap, tag, id, (std::string *const*)ptr, "tt:ReferenceToken");
	case SOAP_TYPE_PointerTott__Name:
		return soap_out_PointerTott__Name(soap, tag, id, (std::string *const*)ptr, "tt:Name");
	case SOAP_TYPE_PointerTott__PTZMoveStatus:
		return soap_out_PointerTott__PTZMoveStatus(soap, tag, id, (tt__PTZMoveStatus *const*)ptr, "tt:PTZMoveStatus");
	case SOAP_TYPE_PointerTott__PTZVector:
		return soap_out_PointerTott__PTZVector(soap, tag, id, (tt__PTZVector *const*)ptr, "tt:PTZVector");
	case SOAP_TYPE_PointerTott__Vector1D:
		return soap_out_PointerTott__Vector1D(soap, tag, id, (tt__Vector1D *const*)ptr, "tt:Vector1D");
	case SOAP_TYPE_PointerTott__Vector2D:
		return soap_out_PointerTott__Vector2D(soap, tag, id, (tt__Vector2D *const*)ptr, "tt:Vector2D");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_out_PointerToxsd__anyURI(soap, tag, id, (std::string *const*)ptr, "xsd:anyURI");
	case SOAP_TYPE_PointerTott__FloatRange:
		return soap_out_PointerTott__FloatRange(soap, tag, id, (tt__FloatRange *const*)ptr, "tt:FloatRange");
	case SOAP_TYPE_PointerTott__PTZSpacesExtension:
		return soap_out_PointerTott__PTZSpacesExtension(soap, tag, id, (tt__PTZSpacesExtension *const*)ptr, "tt:PTZSpacesExtension");
	case SOAP_TYPE_PointerTott__Space1DDescription:
		return soap_out_PointerTott__Space1DDescription(soap, tag, id, (tt__Space1DDescription *const*)ptr, "tt:Space1DDescription");
	case SOAP_TYPE_PointerTott__Space2DDescription:
		return soap_out_PointerTott__Space2DDescription(soap, tag, id, (tt__Space2DDescription *const*)ptr, "tt:Space2DDescription");
	case SOAP_TYPE_PointerTott__DurationRange:
		return soap_out_PointerTott__DurationRange(soap, tag, id, (tt__DurationRange *const*)ptr, "tt:DurationRange");
	case SOAP_TYPE_PointerTott__PTZSpaces:
		return soap_out_PointerTott__PTZSpaces(soap, tag, id, (tt__PTZSpaces *const*)ptr, "tt:PTZSpaces");
	case SOAP_TYPE_PointerTott__BinaryData:
		return soap_out_PointerTott__BinaryData(soap, tag, id, (tt__BinaryData *const*)ptr, "tt:BinaryData");
	case SOAP_TYPE_PointerTott__CertificateGenerationParametersExtension:
		return soap_out_PointerTott__CertificateGenerationParametersExtension(soap, tag, id, (tt__CertificateGenerationParametersExtension *const*)ptr, "tt:CertificateGenerationParametersExtension");
	case SOAP_TYPE_PointerTott__UserExtension:
		return soap_out_PointerTott__UserExtension(soap, tag, id, (tt__UserExtension *const*)ptr, "tt:UserExtension");
	case SOAP_TYPE_PointerTott__Date:
		return soap_out_PointerTott__Date(soap, tag, id, (tt__Date *const*)ptr, "tt:Date");
	case SOAP_TYPE_PointerTott__Time:
		return soap_out_PointerTott__Time(soap, tag, id, (tt__Time *const*)ptr, "tt:Time");
	case SOAP_TYPE_PointerTott__SystemDateTimeExtension:
		return soap_out_PointerTott__SystemDateTimeExtension(soap, tag, id, (tt__SystemDateTimeExtension *const*)ptr, "tt:SystemDateTimeExtension");
	case SOAP_TYPE_PointerTott__DateTime:
		return soap_out_PointerTott__DateTime(soap, tag, id, (tt__DateTime *const*)ptr, "tt:DateTime");
	case SOAP_TYPE_PointerTott__TimeZone:
		return soap_out_PointerTott__TimeZone(soap, tag, id, (tt__TimeZone *const*)ptr, "tt:TimeZone");
	case SOAP_TYPE_PointerTott__AttachmentData:
		return soap_out_PointerTott__AttachmentData(soap, tag, id, (tt__AttachmentData *const*)ptr, "tt:AttachmentData");
	case SOAP_TYPE_PointerTott__SystemCapabilitiesExtension:
		return soap_out_PointerTott__SystemCapabilitiesExtension(soap, tag, id, (tt__SystemCapabilitiesExtension *const*)ptr, "tt:SystemCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__OnvifVersion:
		return soap_out_PointerTott__OnvifVersion(soap, tag, id, (tt__OnvifVersion *const*)ptr, "tt:OnvifVersion");
	case SOAP_TYPE_PointerTott__SecurityCapabilitiesExtension:
		return soap_out_PointerTott__SecurityCapabilitiesExtension(soap, tag, id, (tt__SecurityCapabilitiesExtension *const*)ptr, "tt:SecurityCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__NetworkCapabilitiesExtension:
		return soap_out_PointerTott__NetworkCapabilitiesExtension(soap, tag, id, (tt__NetworkCapabilitiesExtension *const*)ptr, "tt:NetworkCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__RealTimeStreamingCapabilitiesExtension:
		return soap_out_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, tag, id, (tt__RealTimeStreamingCapabilitiesExtension *const*)ptr, "tt:RealTimeStreamingCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__ProfileCapabilities:
		return soap_out_PointerTott__ProfileCapabilities(soap, tag, id, (tt__ProfileCapabilities *const*)ptr, "tt:ProfileCapabilities");
	case SOAP_TYPE_PointerTott__MediaCapabilitiesExtension:
		return soap_out_PointerTott__MediaCapabilitiesExtension(soap, tag, id, (tt__MediaCapabilitiesExtension *const*)ptr, "tt:MediaCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__RealTimeStreamingCapabilities:
		return soap_out_PointerTott__RealTimeStreamingCapabilities(soap, tag, id, (tt__RealTimeStreamingCapabilities *const*)ptr, "tt:RealTimeStreamingCapabilities");
	case SOAP_TYPE_PointerTott__IOCapabilitiesExtension:
		return soap_out_PointerTott__IOCapabilitiesExtension(soap, tag, id, (tt__IOCapabilitiesExtension *const*)ptr, "tt:IOCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__DeviceCapabilitiesExtension:
		return soap_out_PointerTott__DeviceCapabilitiesExtension(soap, tag, id, (tt__DeviceCapabilitiesExtension *const*)ptr, "tt:DeviceCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__SecurityCapabilities:
		return soap_out_PointerTott__SecurityCapabilities(soap, tag, id, (tt__SecurityCapabilities *const*)ptr, "tt:SecurityCapabilities");
	case SOAP_TYPE_PointerTott__IOCapabilities:
		return soap_out_PointerTott__IOCapabilities(soap, tag, id, (tt__IOCapabilities *const*)ptr, "tt:IOCapabilities");
	case SOAP_TYPE_PointerTott__SystemCapabilities:
		return soap_out_PointerTott__SystemCapabilities(soap, tag, id, (tt__SystemCapabilities *const*)ptr, "tt:SystemCapabilities");
	case SOAP_TYPE_PointerTott__NetworkCapabilities:
		return soap_out_PointerTott__NetworkCapabilities(soap, tag, id, (tt__NetworkCapabilities *const*)ptr, "tt:NetworkCapabilities");
	case SOAP_TYPE_PointerTott__CapabilitiesExtension:
		return soap_out_PointerTott__CapabilitiesExtension(soap, tag, id, (tt__CapabilitiesExtension *const*)ptr, "tt:CapabilitiesExtension");
	case SOAP_TYPE_PointerTott__PTZCapabilities:
		return soap_out_PointerTott__PTZCapabilities(soap, tag, id, (tt__PTZCapabilities *const*)ptr, "tt:PTZCapabilities");
	case SOAP_TYPE_PointerTott__MediaCapabilities:
		return soap_out_PointerTott__MediaCapabilities(soap, tag, id, (tt__MediaCapabilities *const*)ptr, "tt:MediaCapabilities");
	case SOAP_TYPE_PointerTott__ImagingCapabilities:
		return soap_out_PointerTott__ImagingCapabilities(soap, tag, id, (tt__ImagingCapabilities *const*)ptr, "tt:ImagingCapabilities");
	case SOAP_TYPE_PointerTott__EventCapabilities:
		return soap_out_PointerTott__EventCapabilities(soap, tag, id, (tt__EventCapabilities *const*)ptr, "tt:EventCapabilities");
	case SOAP_TYPE_PointerTott__DeviceCapabilities:
		return soap_out_PointerTott__DeviceCapabilities(soap, tag, id, (tt__DeviceCapabilities *const*)ptr, "tt:DeviceCapabilities");
	case SOAP_TYPE_PointerTott__AnalyticsCapabilities:
		return soap_out_PointerTott__AnalyticsCapabilities(soap, tag, id, (tt__AnalyticsCapabilities *const*)ptr, "tt:AnalyticsCapabilities");
	case SOAP_TYPE_PointerTott__IPAddressFilterExtension:
		return soap_out_PointerTott__IPAddressFilterExtension(soap, tag, id, (tt__IPAddressFilterExtension *const*)ptr, "tt:IPAddressFilterExtension");
	case SOAP_TYPE_PointerTott__NetworkZeroConfigurationExtension:
		return soap_out_PointerTott__NetworkZeroConfigurationExtension(soap, tag, id, (tt__NetworkZeroConfigurationExtension *const*)ptr, "tt:NetworkZeroConfigurationExtension");
	case SOAP_TYPE_PointerTott__IPv6DHCPConfiguration:
		return soap_out_PointerTott__IPv6DHCPConfiguration(soap, tag, id, (enum tt__IPv6DHCPConfiguration *const*)ptr, "tt:IPv6DHCPConfiguration");
	case SOAP_TYPE_PointerTott__NetworkInterfaceSetConfigurationExtension:
		return soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, tag, id, (tt__NetworkInterfaceSetConfigurationExtension *const*)ptr, "tt:NetworkInterfaceSetConfigurationExtension");
	case SOAP_TYPE_PointerTott__IPv6NetworkInterfaceSetConfiguration:
		return soap_out_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, tag, id, (tt__IPv6NetworkInterfaceSetConfiguration *const*)ptr, "tt:IPv6NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_PointerTott__IPv4NetworkInterfaceSetConfiguration:
		return soap_out_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, tag, id, (tt__IPv4NetworkInterfaceSetConfiguration *const*)ptr, "tt:IPv4NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_PointerTott__DynamicDNSInformationExtension:
		return soap_out_PointerTott__DynamicDNSInformationExtension(soap, tag, id, (tt__DynamicDNSInformationExtension *const*)ptr, "tt:DynamicDNSInformationExtension");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_out_PointerToxsd__duration(soap, tag, id, (LONG64 *const*)ptr, "xsd:duration");
	case SOAP_TYPE_PointerTott__NTPInformationExtension:
		return soap_out_PointerTott__NTPInformationExtension(soap, tag, id, (tt__NTPInformationExtension *const*)ptr, "tt:NTPInformationExtension");
	case SOAP_TYPE_PointerTott__NetworkHost:
		return soap_out_PointerTott__NetworkHost(soap, tag, id, (tt__NetworkHost *const*)ptr, "tt:NetworkHost");
	case SOAP_TYPE_PointerTott__DNSInformationExtension:
		return soap_out_PointerTott__DNSInformationExtension(soap, tag, id, (tt__DNSInformationExtension *const*)ptr, "tt:DNSInformationExtension");
	case SOAP_TYPE_PointerTott__HostnameInformationExtension:
		return soap_out_PointerTott__HostnameInformationExtension(soap, tag, id, (tt__HostnameInformationExtension *const*)ptr, "tt:HostnameInformationExtension");
	case SOAP_TYPE_PointerToxsd__token:
		return soap_out_PointerToxsd__token(soap, tag, id, (std::string *const*)ptr, "xsd:token");
	case SOAP_TYPE_PointerTott__NetworkHostExtension:
		return soap_out_PointerTott__NetworkHostExtension(soap, tag, id, (tt__NetworkHostExtension *const*)ptr, "tt:NetworkHostExtension");
	case SOAP_TYPE_PointerTott__DNSName:
		return soap_out_PointerTott__DNSName(soap, tag, id, (std::string *const*)ptr, "tt:DNSName");
	case SOAP_TYPE_PointerTott__IPv6Address:
		return soap_out_PointerTott__IPv6Address(soap, tag, id, (std::string *const*)ptr, "tt:IPv6Address");
	case SOAP_TYPE_PointerTott__IPv4Address:
		return soap_out_PointerTott__IPv4Address(soap, tag, id, (std::string *const*)ptr, "tt:IPv4Address");
	case SOAP_TYPE_PointerTott__NetworkProtocolExtension:
		return soap_out_PointerTott__NetworkProtocolExtension(soap, tag, id, (tt__NetworkProtocolExtension *const*)ptr, "tt:NetworkProtocolExtension");
	case SOAP_TYPE_PointerTott__IPv6ConfigurationExtension:
		return soap_out_PointerTott__IPv6ConfigurationExtension(soap, tag, id, (tt__IPv6ConfigurationExtension *const*)ptr, "tt:IPv6ConfigurationExtension");
	case SOAP_TYPE_PointerTott__PrefixedIPv6Address:
		return soap_out_PointerTott__PrefixedIPv6Address(soap, tag, id, (tt__PrefixedIPv6Address *const*)ptr, "tt:PrefixedIPv6Address");
	case SOAP_TYPE_PointerTott__PrefixedIPv4Address:
		return soap_out_PointerTott__PrefixedIPv4Address(soap, tag, id, (tt__PrefixedIPv4Address *const*)ptr, "tt:PrefixedIPv4Address");
	case SOAP_TYPE_PointerTott__IPv4Configuration:
		return soap_out_PointerTott__IPv4Configuration(soap, tag, id, (tt__IPv4Configuration *const*)ptr, "tt:IPv4Configuration");
	case SOAP_TYPE_PointerTott__IPv6Configuration:
		return soap_out_PointerTott__IPv6Configuration(soap, tag, id, (tt__IPv6Configuration *const*)ptr, "tt:IPv6Configuration");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTott__NetworkInterfaceConnectionSetting:
		return soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, tag, id, (tt__NetworkInterfaceConnectionSetting *const*)ptr, "tt:NetworkInterfaceConnectionSetting");
	case SOAP_TYPE_PointerTott__Transport:
		return soap_out_PointerTott__Transport(soap, tag, id, (tt__Transport *const*)ptr, "tt:Transport");
	case SOAP_TYPE_PointerTott__IPAddress:
		return soap_out_PointerTott__IPAddress(soap, tag, id, (tt__IPAddress *const*)ptr, "tt:IPAddress");
	case SOAP_TYPE_PointerTott__PTZStatusFilterOptions:
		return soap_out_PointerTott__PTZStatusFilterOptions(soap, tag, id, (tt__PTZStatusFilterOptions *const*)ptr, "tt:PTZStatusFilterOptions");
	case SOAP_TYPE_PointerTo_tt__EventSubscription_SubscriptionPolicy:
		return soap_out_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, tag, id, (_tt__EventSubscription_SubscriptionPolicy *const*)ptr, "tt:EventSubscription-SubscriptionPolicy");
	case SOAP_TYPE_PointerTowsnb__FilterType:
		return soap_out_PointerTowsnb__FilterType(soap, tag, id, (wsnb__FilterType *const*)ptr, "wsnb:FilterType");
	case SOAP_TYPE_PointerTott__IntList:
		return soap_out_PointerTott__IntList(soap, tag, id, (tt__IntList *const*)ptr, "tt:IntList");
	case SOAP_TYPE_PointerTott__AudioEncoderConfigurationOption:
		return soap_out_PointerTott__AudioEncoderConfigurationOption(soap, tag, id, (tt__AudioEncoderConfigurationOption *const*)ptr, "tt:AudioEncoderConfigurationOption");
	case SOAP_TYPE_PointerTott__AudioSourceOptionsExtension:
		return soap_out_PointerTott__AudioSourceOptionsExtension(soap, tag, id, (tt__AudioSourceOptionsExtension *const*)ptr, "tt:AudioSourceOptionsExtension");
	case SOAP_TYPE_PointerTott__VideoResolution:
		return soap_out_PointerTott__VideoResolution(soap, tag, id, (tt__VideoResolution *const*)ptr, "tt:VideoResolution");
	case SOAP_TYPE_PointerTott__VideoEncoderOptionsExtension:
		return soap_out_PointerTott__VideoEncoderOptionsExtension(soap, tag, id, (tt__VideoEncoderOptionsExtension *const*)ptr, "tt:VideoEncoderOptionsExtension");
	case SOAP_TYPE_PointerTott__H264Options:
		return soap_out_PointerTott__H264Options(soap, tag, id, (tt__H264Options *const*)ptr, "tt:H264Options");
	case SOAP_TYPE_PointerTott__Mpeg4Options:
		return soap_out_PointerTott__Mpeg4Options(soap, tag, id, (tt__Mpeg4Options *const*)ptr, "tt:Mpeg4Options");
	case SOAP_TYPE_PointerTott__JpegOptions:
		return soap_out_PointerTott__JpegOptions(soap, tag, id, (tt__JpegOptions *const*)ptr, "tt:JpegOptions");
	case SOAP_TYPE_PointerTott__VideoSourceConfigurationOptionsExtension:
		return soap_out_PointerTott__VideoSourceConfigurationOptionsExtension(soap, tag, id, (tt__VideoSourceConfigurationOptionsExtension *const*)ptr, "tt:VideoSourceConfigurationOptionsExtension");
	case SOAP_TYPE_PointerTott__IntRectangleRange:
		return soap_out_PointerTott__IntRectangleRange(soap, tag, id, (tt__IntRectangleRange *const*)ptr, "tt:IntRectangleRange");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTott__ProfileExtension:
		return soap_out_PointerTott__ProfileExtension(soap, tag, id, (tt__ProfileExtension *const*)ptr, "tt:ProfileExtension");
	case SOAP_TYPE_PointerTott__MetadataConfiguration:
		return soap_out_PointerTott__MetadataConfiguration(soap, tag, id, (tt__MetadataConfiguration *const*)ptr, "tt:MetadataConfiguration");
	case SOAP_TYPE_PointerTott__PTZConfiguration:
		return soap_out_PointerTott__PTZConfiguration(soap, tag, id, (tt__PTZConfiguration *const*)ptr, "tt:PTZConfiguration");
	case SOAP_TYPE_PointerTott__VideoAnalyticsConfiguration:
		return soap_out_PointerTott__VideoAnalyticsConfiguration(soap, tag, id, (tt__VideoAnalyticsConfiguration *const*)ptr, "tt:VideoAnalyticsConfiguration");
	case SOAP_TYPE_PointerTott__AudioEncoderConfiguration:
		return soap_out_PointerTott__AudioEncoderConfiguration(soap, tag, id, (tt__AudioEncoderConfiguration *const*)ptr, "tt:AudioEncoderConfiguration");
	case SOAP_TYPE_PointerTott__VideoEncoderConfiguration:
		return soap_out_PointerTott__VideoEncoderConfiguration(soap, tag, id, (tt__VideoEncoderConfiguration *const*)ptr, "tt:VideoEncoderConfiguration");
	case SOAP_TYPE_PointerTott__AudioSourceConfiguration:
		return soap_out_PointerTott__AudioSourceConfiguration(soap, tag, id, (tt__AudioSourceConfiguration *const*)ptr, "tt:AudioSourceConfiguration");
	case SOAP_TYPE_PointerTott__VideoSourceConfiguration:
		return soap_out_PointerTott__VideoSourceConfiguration(soap, tag, id, (tt__VideoSourceConfiguration *const*)ptr, "tt:VideoSourceConfiguration");
	case SOAP_TYPE_PointerTott__IntRange:
		return soap_out_PointerTott__IntRange(soap, tag, id, (tt__IntRange *const*)ptr, "tt:IntRange");
	case SOAP_TYPE_PointerTott__SupportedAnalyticsModules:
		return soap_out_PointerTott__SupportedAnalyticsModules(soap, tag, id, (tt__SupportedAnalyticsModules *const*)ptr, "tt:SupportedAnalyticsModules");
	case SOAP_TYPE_PointerTott__Config:
		return soap_out_PointerTott__Config(soap, tag, id, (tt__Config *const*)ptr, "tt:Config");
	case SOAP_TYPE_PointerTott__SupportedRules:
		return soap_out_PointerTott__SupportedRules(soap, tag, id, (tt__SupportedRules *const*)ptr, "tt:SupportedRules");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_out_PointerTo_wsa5__FaultTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_out_PointerTo_wsa5__ReplyTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_out_PointerTo_wsa5__From(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_out_PointerTo_wsa5__RelatesTo(soap, tag, id, (struct wsa5__RelatesToType *const*)ptr, "wsa5:RelatesTo");
	case SOAP_TYPE_PointerTo_wsse__Security:
		return soap_out_PointerTo_wsse__Security(soap, tag, id, (struct _wsse__Security *const*)ptr, "wsse:Security");
	case SOAP_TYPE_PointerTods__SignatureType:
		return soap_out_PointerTods__SignatureType(soap, tag, id, (struct ds__SignatureType *const*)ptr, "ds:SignatureType");
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		return soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag, id, (struct _wsse__BinarySecurityToken *const*)ptr, "wsse:BinarySecurityToken");
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		return soap_out_PointerTo_wsse__UsernameToken(soap, tag, id, (struct _wsse__UsernameToken *const*)ptr, "wsse:UsernameToken");
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		return soap_out_PointerTo_wsu__Timestamp(soap, tag, id, (struct _wsu__Timestamp *const*)ptr, "wsu:Timestamp");
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		return soap_out_PointerTods__X509IssuerSerialType(soap, tag, id, (struct ds__X509IssuerSerialType *const*)ptr, "ds:X509IssuerSerialType");
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		return soap_out_PointerTods__RSAKeyValueType(soap, tag, id, (struct ds__RSAKeyValueType *const*)ptr, "ds:RSAKeyValueType");
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		return soap_out_PointerTods__DSAKeyValueType(soap, tag, id, (struct ds__DSAKeyValueType *const*)ptr, "ds:DSAKeyValueType");
	case SOAP_TYPE_PointerTods__TransformType:
		return soap_out_PointerTods__TransformType(soap, tag, id, (struct ds__TransformType *const*)ptr, "ds:TransformType");
	case SOAP_TYPE_PointerTods__DigestMethodType:
		return soap_out_PointerTods__DigestMethodType(soap, tag, id, (struct ds__DigestMethodType *const*)ptr, "ds:DigestMethodType");
	case SOAP_TYPE_PointerTods__TransformsType:
		return soap_out_PointerTods__TransformsType(soap, tag, id, (struct ds__TransformsType *const*)ptr, "ds:TransformsType");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		return soap_out_PointerToPointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType **const*)ptr, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__ReferenceType:
		return soap_out_PointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType *const*)ptr, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		return soap_out_PointerTods__SignatureMethodType(soap, tag, id, (struct ds__SignatureMethodType *const*)ptr, "ds:SignatureMethodType");
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		return soap_out_PointerTods__CanonicalizationMethodType(soap, tag, id, (struct ds__CanonicalizationMethodType *const*)ptr, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		return soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag, id, (struct _wsse__SecurityTokenReference *const*)ptr, "wsse:SecurityTokenReference");
	case SOAP_TYPE_PointerTods__X509DataType:
		return soap_out_PointerTods__X509DataType(soap, tag, id, (struct ds__X509DataType *const*)ptr, "ds:X509DataType");
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		return soap_out_PointerTods__RetrievalMethodType(soap, tag, id, (struct ds__RetrievalMethodType *const*)ptr, "ds:RetrievalMethodType");
	case SOAP_TYPE_PointerTods__KeyValueType:
		return soap_out_PointerTods__KeyValueType(soap, tag, id, (struct ds__KeyValueType *const*)ptr, "ds:KeyValueType");
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		return soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag, id, (struct _c14n__InclusiveNamespaces *const*)ptr, "c14n:InclusiveNamespaces");
	case SOAP_TYPE_PointerTods__KeyInfoType:
		return soap_out_PointerTods__KeyInfoType(soap, tag, id, (struct ds__KeyInfoType *const*)ptr, "ds:KeyInfoType");
	case SOAP_TYPE_PointerTods__SignedInfoType:
		return soap_out_PointerTods__SignedInfoType(soap, tag, id, (struct ds__SignedInfoType *const*)ptr, "ds:SignedInfoType");
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		return soap_out_PointerTo_wsse__Embedded(soap, tag, id, (struct _wsse__Embedded *const*)ptr, "wsse:Embedded");
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		return soap_out_PointerTo_wsse__KeyIdentifier(soap, tag, id, (struct _wsse__KeyIdentifier *const*)ptr, "wsse:KeyIdentifier");
	case SOAP_TYPE_PointerTo_wsse__Reference:
		return soap_out_PointerTo_wsse__Reference(soap, tag, id, (struct _wsse__Reference *const*)ptr, "wsse:Reference");
	case SOAP_TYPE_PointerTo_wsse__Password:
		return soap_out_PointerTo_wsse__Password(soap, tag, id, (struct _wsse__Password *const*)ptr, "wsse:Password");
	case SOAP_TYPE__wsa5__ProblemIRI:
		return soap_out_string(soap, "wsa5:ProblemIRI", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE__wsa5__Action:
		return soap_out_string(soap, "wsa5:Action", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__wsa5__To:
		return soap_out_string(soap, "wsa5:To", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__wsa5__MessageID:
		return soap_out_string(soap, "wsa5:MessageID", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_out_PointerTowsa5__MetadataType(soap, tag, id, (struct wsa5__MetadataType *const*)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_out_PointerTowsa5__ReferenceParametersType(soap, tag, id, (struct wsa5__ReferenceParametersType *const*)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "wsa5:FaultCodesOpenEnumType");
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "wsa5:RelationshipTypeOpenEnum");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__wstop__TopicNamespaceType_Topic:
		((_wstop__TopicNamespaceType_Topic *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause:
		((_wsrfbf__BaseFaultType_FaultCause *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_Description:
		((_wsrfbf__BaseFaultType_Description *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode:
		((_wsrfbf__BaseFaultType_ErrorCode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__Subscribe_SubscriptionPolicy:
		((_wsnb__Subscribe_SubscriptionPolicy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__NotificationMessageHolderType_Message:
		((_wsnb__NotificationMessageHolderType_Message *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___tt__union_EventStream:
		((__tt__union_EventStream *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___tt__union_PTZStream:
		((__tt__union_PTZStream *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___tt__union_VideoAnalyticsStream:
		((__tt__union_VideoAnalyticsStream *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___tt__union_MetadataStream:
		((__tt__union_MetadataStream *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tt__ConfigDescription_Messages:
		((_tt__ConfigDescription_Messages *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tt__Behaviour_Idle:
		((_tt__Behaviour_Idle *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tt__Behaviour_Removed:
		((_tt__Behaviour_Removed *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tt__ClassDescriptor_ClassCandidate:
		((_tt__ClassDescriptor_ClassCandidate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tt__ColorDescriptor_ColorCluster:
		((_tt__ColorDescriptor_ColorCluster *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tt__ItemListDescription_ElementItemDescription:
		((_tt__ItemListDescription_ElementItemDescription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription:
		((_tt__ItemListDescription_SimpleItemDescription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tt__ItemList_ElementItem:
		((_tt__ItemList_ElementItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tt__ItemList_SimpleItem:
		((_tt__ItemList_SimpleItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy:
		((_tt__EventSubscription_SubscriptionPolicy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wstop__SimpleTopicExpression:
		soap_serialize_wstop__SimpleTopicExpression(soap, (const xsd__QName *)ptr);
		break;
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
		soap_serialize_wstop__ConcreteTopicExpression(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_wstop__FullTopicExpression:
		soap_serialize_wstop__FullTopicExpression(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__TopicNamespaceLocation:
		soap_serialize_tt__TopicNamespaceLocation(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__AuxiliaryData:
		soap_serialize_tt__AuxiliaryData(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__Domain:
		soap_serialize_tt__Domain(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__DNSName:
		soap_serialize_tt__DNSName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__HwAddress:
		soap_serialize_tt__HwAddress(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__IPv6Address:
		soap_serialize_tt__IPv6Address(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__IPv4Address:
		soap_serialize_tt__IPv4Address(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__Name:
		soap_serialize_tt__Name(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__ReferenceToken:
		soap_serialize_tt__ReferenceToken(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_wsnb__AbsoluteOrRelativeTimeType:
		soap_serialize_wsnb__AbsoluteOrRelativeTimeType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_wstop__TopicSetType:
		((wstop__TopicSetType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wstop__TopicType:
		((wstop__TopicType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wstop__TopicNamespaceType:
		((wstop__TopicNamespaceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wstop__QueryExpressionType:
		((wstop__QueryExpressionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		((wstop__ExtensibleDocumented *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wstop__Documentation:
		((wstop__Documentation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		((wsrfbf__BaseFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__ResumeSubscriptionResponse:
		((_wsnb__ResumeSubscriptionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__ResumeSubscription:
		((_wsnb__ResumeSubscription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__PauseSubscriptionResponse:
		((_wsnb__PauseSubscriptionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__PauseSubscription:
		((_wsnb__PauseSubscription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__UnsubscribeResponse:
		((_wsnb__UnsubscribeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__Unsubscribe:
		((_wsnb__Unsubscribe *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__RenewResponse:
		((_wsnb__RenewResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__Renew:
		((_wsnb__Renew *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__CreatePullPointResponse:
		((_wsnb__CreatePullPointResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__CreatePullPoint:
		((_wsnb__CreatePullPoint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__DestroyPullPointResponse:
		((_wsnb__DestroyPullPointResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__DestroyPullPoint:
		((_wsnb__DestroyPullPoint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__GetMessagesResponse:
		((_wsnb__GetMessagesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__GetMessages:
		((_wsnb__GetMessages *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__GetCurrentMessageResponse:
		((_wsnb__GetCurrentMessageResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__GetCurrentMessage:
		((_wsnb__GetCurrentMessage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__SubscribeResponse:
		((_wsnb__SubscribeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__Subscribe:
		((_wsnb__Subscribe *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__UseRaw:
		((_wsnb__UseRaw *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__Notify:
		((_wsnb__Notify *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__SubscriptionManagerRP:
		((_wsnb__SubscriptionManagerRP *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__wsnb__NotificationProducerRP:
		((_wsnb__NotificationProducerRP *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__ResumeFailedFaultType:
		((wsnb__ResumeFailedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__PauseFailedFaultType:
		((wsnb__PauseFailedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__UnableToDestroySubscriptionFaultType:
		((wsnb__UnableToDestroySubscriptionFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__UnacceptableTerminationTimeFaultType:
		((wsnb__UnacceptableTerminationTimeFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__UnableToCreatePullPointFaultType:
		((wsnb__UnableToCreatePullPointFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__UnableToDestroyPullPointFaultType:
		((wsnb__UnableToDestroyPullPointFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__UnableToGetMessagesFaultType:
		((wsnb__UnableToGetMessagesFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__NoCurrentMessageOnTopicFaultType:
		((wsnb__NoCurrentMessageOnTopicFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__UnacceptableInitialTerminationTimeFaultType:
		((wsnb__UnacceptableInitialTerminationTimeFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__NotifyMessageNotSupportedFaultType:
		((wsnb__NotifyMessageNotSupportedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__UnsupportedPolicyRequestFaultType:
		((wsnb__UnsupportedPolicyRequestFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__UnrecognizedPolicyRequestFaultType:
		((wsnb__UnrecognizedPolicyRequestFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__InvalidMessageContentExpressionFaultType:
		((wsnb__InvalidMessageContentExpressionFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__InvalidProducerPropertiesExpressionFaultType:
		((wsnb__InvalidProducerPropertiesExpressionFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__MultipleTopicsSpecifiedFaultType:
		((wsnb__MultipleTopicsSpecifiedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__TopicNotSupportedFaultType:
		((wsnb__TopicNotSupportedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__InvalidTopicExpressionFaultType:
		((wsnb__InvalidTopicExpressionFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__TopicExpressionDialectUnknownFaultType:
		((wsnb__TopicExpressionDialectUnknownFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__InvalidFilterFaultType:
		((wsnb__InvalidFilterFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__SubscribeCreationFailedFaultType:
		((wsnb__SubscribeCreationFailedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__NotificationMessageHolderType:
		((wsnb__NotificationMessageHolderType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__SubscriptionPolicyType:
		((wsnb__SubscriptionPolicyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__FilterType:
		((wsnb__FilterType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__TopicExpressionType:
		((wsnb__TopicExpressionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_wsnb__QueryExpressionType:
		((wsnb__QueryExpressionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tt__Message:
		((_tt__Message *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__EventStreamExtension:
		((tt__EventStreamExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__EventStream:
		((tt__EventStream *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZStreamExtension:
		((tt__PTZStreamExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZStream:
		((tt__PTZStream *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__VideoAnalyticsStreamExtension:
		((tt__VideoAnalyticsStreamExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__VideoAnalyticsStream:
		((tt__VideoAnalyticsStream *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__MetadataStreamExtension:
		((tt__MetadataStreamExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__MetadataStream:
		((tt__MetadataStream *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SupportedAnalyticsModulesExtension:
		((tt__SupportedAnalyticsModulesExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SupportedAnalyticsModules:
		((tt__SupportedAnalyticsModules *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SupportedRulesExtension:
		((tt__SupportedRulesExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SupportedRules:
		((tt__SupportedRules *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ConfigDescriptionExtension:
		((tt__ConfigDescriptionExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ConfigDescription:
		((tt__ConfigDescription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Config:
		((tt__Config *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__RuleEngineConfigurationExtension:
		((tt__RuleEngineConfigurationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__RuleEngineConfiguration:
		((tt__RuleEngineConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension:
		((tt__AnalyticsEngineConfigurationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AnalyticsEngineConfiguration:
		((tt__AnalyticsEngineConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ObjectTreeExtension:
		((tt__ObjectTreeExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ObjectTree:
		((tt__ObjectTree *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__BehaviourExtension:
		((tt__BehaviourExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Behaviour:
		((tt__Behaviour *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ObjectId:
		((tt__ObjectId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Rename:
		((tt__Rename *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Split:
		((tt__Split *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Merge:
		((tt__Merge *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__FrameExtension:
		((tt__FrameExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Frame:
		((tt__Frame *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__TransformationExtension:
		((tt__TransformationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Transformation:
		((tt__Transformation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ObjectExtension:
		((tt__ObjectExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Object:
		((tt__Object *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ClassDescriptorExtension:
		((tt__ClassDescriptorExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ClassDescriptor:
		((tt__ClassDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ColorDescriptorExtension:
		((tt__ColorDescriptorExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ColorDescriptor:
		((tt__ColorDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ShapeDescriptorExtension:
		((tt__ShapeDescriptorExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ShapeDescriptor:
		((tt__ShapeDescriptor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AppearanceExtension:
		((tt__AppearanceExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Appearance:
		((tt__Appearance *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ColorCovariance:
		((tt__ColorCovariance *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Color:
		((tt__Color *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Polyline:
		((tt__Polyline *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Polygon:
		((tt__Polygon *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Rectangle:
		((tt__Rectangle *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Vector:
		((tt__Vector *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ItemListDescriptionExtension:
		((tt__ItemListDescriptionExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ItemListDescription:
		((tt__ItemListDescription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__MessageDescriptionExtension:
		((tt__MessageDescriptionExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__MessageDescription:
		((tt__MessageDescription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ItemListExtension:
		((tt__ItemListExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ItemList:
		((tt__ItemList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__MessageExtension:
		((tt__MessageExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__FocusOptions20Extension:
		((tt__FocusOptions20Extension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__FocusOptions20:
		((tt__FocusOptions20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__WhiteBalanceOptions20Extension:
		((tt__WhiteBalanceOptions20Extension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__WhiteBalanceOptions20:
		((tt__WhiteBalanceOptions20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__FocusConfiguration20Extension:
		((tt__FocusConfiguration20Extension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__FocusConfiguration20:
		((tt__FocusConfiguration20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__WhiteBalance20Extension:
		((tt__WhiteBalance20Extension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__WhiteBalance20:
		((tt__WhiteBalance20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__RelativeFocusOptions20:
		((tt__RelativeFocusOptions20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__MoveOptions20:
		((tt__MoveOptions20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ExposureOptions20:
		((tt__ExposureOptions20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__BacklightCompensationOptions20:
		((tt__BacklightCompensationOptions20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__WideDynamicRangeOptions20:
		((tt__WideDynamicRangeOptions20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingOptions20Extension:
		((tt__ImagingOptions20Extension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingOptions20:
		((tt__ImagingOptions20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Exposure20:
		((tt__Exposure20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__BacklightCompensation20:
		((tt__BacklightCompensation20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__WideDynamicRange20:
		((tt__WideDynamicRange20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingSettingsExtension20:
		((tt__ImagingSettingsExtension20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingSettings20:
		((tt__ImagingSettings20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__FocusStatus20Extension:
		((tt__FocusStatus20Extension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__FocusStatus20:
		((tt__FocusStatus20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingStatus20Extension:
		((tt__ImagingStatus20Extension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingStatus20:
		((tt__ImagingStatus20 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__WhiteBalance:
		((tt__WhiteBalance *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ContinuousFocusOptions:
		((tt__ContinuousFocusOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__RelativeFocusOptions:
		((tt__RelativeFocusOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AbsoluteFocusOptions:
		((tt__AbsoluteFocusOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__MoveOptions:
		((tt__MoveOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ContinuousFocus:
		((tt__ContinuousFocus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__RelativeFocus:
		((tt__RelativeFocus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AbsoluteFocus:
		((tt__AbsoluteFocus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__FocusMove:
		((tt__FocusMove *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__WhiteBalanceOptions:
		((tt__WhiteBalanceOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ExposureOptions:
		((tt__ExposureOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__FocusOptions:
		((tt__FocusOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__BacklightCompensationOptions:
		((tt__BacklightCompensationOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__WideDynamicRangeOptions:
		((tt__WideDynamicRangeOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingOptions:
		((tt__ImagingOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__BacklightCompensation:
		((tt__BacklightCompensation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__WideDynamicRange:
		((tt__WideDynamicRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Exposure:
		((tt__Exposure *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingSettingsExtension:
		((tt__ImagingSettingsExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingSettings:
		((tt__ImagingSettings *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__FocusConfiguration:
		((tt__FocusConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__FocusStatus:
		((tt__FocusStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingStatus:
		((tt__ImagingStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZMoveStatus:
		((tt__PTZMoveStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZPreset:
		((tt__PTZPreset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZStatus:
		((tt__PTZStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZSpeed:
		((tt__PTZSpeed *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZVector:
		((tt__PTZVector *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Vector1D:
		((tt__Vector1D *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Vector2D:
		((tt__Vector2D *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Space1DDescription:
		((tt__Space1DDescription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Space2DDescription:
		((tt__Space2DDescription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZSpacesExtension:
		((tt__PTZSpacesExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZSpaces:
		((tt__PTZSpaces *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ZoomLimits:
		((tt__ZoomLimits *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PanTiltLimits:
		((tt__PanTiltLimits *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZConfigurationOptions:
		((tt__PTZConfigurationOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZConfigurationExtension:
		((tt__PTZConfigurationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZConfiguration:
		((tt__PTZConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZNodeExtension:
		((tt__PTZNodeExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZNode:
		((tt__PTZNode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__RelayOutput:
		((tt__RelayOutput *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__RelayOutputSettings:
		((tt__RelayOutputSettings *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__CertificateStatus:
		((tt__CertificateStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Certificate:
		((tt__Certificate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__CertificateGenerationParametersExtension:
		((tt__CertificateGenerationParametersExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__CertificateGenerationParameters:
		((tt__CertificateGenerationParameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__UserExtension:
		((tt__UserExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__User:
		((tt__User *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__TimeZone:
		((tt__TimeZone *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Time:
		((tt__Time *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Date:
		((tt__Date *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DateTime:
		((tt__DateTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SystemDateTimeExtension:
		((tt__SystemDateTimeExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SystemDateTime:
		((tt__SystemDateTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__BackupFile:
		((tt__BackupFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AttachmentData:
		((tt__AttachmentData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__BinaryData:
		((tt__BinaryData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SupportInformation:
		((tt__SupportInformation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SystemLog:
		((tt__SystemLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZCapabilities:
		((tt__PTZCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingCapabilities:
		((tt__ImagingCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__OnvifVersion:
		((tt__OnvifVersion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SystemCapabilitiesExtension:
		((tt__SystemCapabilitiesExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SystemCapabilities:
		((tt__SystemCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__StorageCapabilities:
		((tt__StorageCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SecurityCapabilitiesExtension:
		((tt__SecurityCapabilitiesExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SecurityCapabilities:
		((tt__SecurityCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkCapabilitiesExtension:
		((tt__NetworkCapabilitiesExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkCapabilities:
		((tt__NetworkCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ProfileCapabilities:
		((tt__ProfileCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension:
		((tt__RealTimeStreamingCapabilitiesExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__RealTimeStreamingCapabilities:
		((tt__RealTimeStreamingCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__MediaCapabilitiesExtension:
		((tt__MediaCapabilitiesExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__MediaCapabilities:
		((tt__MediaCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IOCapabilitiesExtension:
		((tt__IOCapabilitiesExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IOCapabilities:
		((tt__IOCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__EventCapabilities:
		((tt__EventCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DeviceCapabilitiesExtension:
		((tt__DeviceCapabilitiesExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DeviceCapabilities:
		((tt__DeviceCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AnalyticsCapabilities:
		((tt__AnalyticsCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__CapabilitiesExtension:
		((tt__CapabilitiesExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Capabilities:
		((tt__Capabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPAddressFilterExtension:
		((tt__IPAddressFilterExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPAddressFilter:
		((tt__IPAddressFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkZeroConfigurationExtension:
		((tt__NetworkZeroConfigurationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkZeroConfiguration:
		((tt__NetworkZeroConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkGateway:
		((tt__NetworkGateway *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration:
		((tt__IPv4NetworkInterfaceSetConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration:
		((tt__IPv6NetworkInterfaceSetConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension:
		((tt__NetworkInterfaceSetConfigurationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceSetConfiguration:
		((tt__NetworkInterfaceSetConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DynamicDNSInformationExtension:
		((tt__DynamicDNSInformationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DynamicDNSInformation:
		((tt__DynamicDNSInformation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NTPInformationExtension:
		((tt__NTPInformationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NTPInformation:
		((tt__NTPInformation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DNSInformationExtension:
		((tt__DNSInformationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DNSInformation:
		((tt__DNSInformation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__HostnameInformationExtension:
		((tt__HostnameInformationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__HostnameInformation:
		((tt__HostnameInformation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PrefixedIPv6Address:
		((tt__PrefixedIPv6Address *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PrefixedIPv4Address:
		((tt__PrefixedIPv4Address *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPAddress:
		((tt__IPAddress *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkHostExtension:
		((tt__NetworkHostExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkHost:
		((tt__NetworkHost *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkProtocolExtension:
		((tt__NetworkProtocolExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkProtocol:
		((tt__NetworkProtocol *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPv6ConfigurationExtension:
		((tt__IPv6ConfigurationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPv6Configuration:
		((tt__IPv6Configuration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPv4Configuration:
		((tt__IPv4Configuration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPv4NetworkInterface:
		((tt__IPv4NetworkInterface *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPv6NetworkInterface:
		((tt__IPv6NetworkInterface *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceInfo:
		((tt__NetworkInterfaceInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceConnectionSetting:
		((tt__NetworkInterfaceConnectionSetting *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceLink:
		((tt__NetworkInterfaceLink *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceExtension:
		((tt__NetworkInterfaceExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkInterface:
		((tt__NetworkInterface *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Scope:
		((tt__Scope *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__MediaUri:
		((tt__MediaUri *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Transport:
		((tt__Transport *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__StreamSetup:
		((tt__StreamSetup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__MulticastConfiguration:
		((tt__MulticastConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZStatusFilterOptions:
		((tt__PTZStatusFilterOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__MetadataConfigurationOptions:
		((tt__MetadataConfigurationOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__EventSubscription:
		((tt__EventSubscription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZFilter:
		((tt__PTZFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__MetadataConfiguration:
		((tt__MetadataConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__VideoAnalyticsConfiguration:
		((tt__VideoAnalyticsConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AudioEncoderConfigurationOption:
		((tt__AudioEncoderConfigurationOption *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AudioEncoderConfigurationOptions:
		((tt__AudioEncoderConfigurationOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AudioEncoderConfiguration:
		((tt__AudioEncoderConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AudioSourceOptionsExtension:
		((tt__AudioSourceOptionsExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AudioSourceConfigurationOptions:
		((tt__AudioSourceConfigurationOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AudioSourceConfiguration:
		((tt__AudioSourceConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__H264Options:
		((tt__H264Options *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Mpeg4Options:
		((tt__Mpeg4Options *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__JpegOptions:
		((tt__JpegOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__VideoEncoderOptionsExtension:
		((tt__VideoEncoderOptionsExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__VideoEncoderConfigurationOptions:
		((tt__VideoEncoderConfigurationOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__H264Configuration:
		((tt__H264Configuration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Mpeg4Configuration:
		((tt__Mpeg4Configuration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__VideoRateControl:
		((tt__VideoRateControl *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__VideoResolution:
		((tt__VideoResolution *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__VideoEncoderConfiguration:
		((tt__VideoEncoderConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension:
		((tt__VideoSourceConfigurationOptionsExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__VideoSourceConfigurationOptions:
		((tt__VideoSourceConfigurationOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__VideoSourceConfiguration:
		((tt__VideoSourceConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ConfigurationEntity:
		((tt__ConfigurationEntity *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ProfileExtension:
		((tt__ProfileExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Profile:
		((tt__Profile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AudioSource:
		((tt__AudioSource *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__VideoSourceExtension:
		((tt__VideoSourceExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__VideoSource:
		((tt__VideoSource *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IntList:
		((tt__IntList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DurationRange:
		((tt__DurationRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__FloatRange:
		((tt__FloatRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IntRange:
		((tt__IntRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IntRectangleRange:
		((tt__IntRectangleRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IntRectangle:
		((tt__IntRectangle *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DeviceEntity:
		((tt__DeviceEntity *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tan__GetAnalyticsModulesResponse:
		((_tan__GetAnalyticsModulesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tan__GetAnalyticsModules:
		((_tan__GetAnalyticsModules *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tan__ModifyAnalyticsModulesResponse:
		((_tan__ModifyAnalyticsModulesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tan__ModifyAnalyticsModules:
		((_tan__ModifyAnalyticsModules *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tan__DeleteAnalyticsModulesResponse:
		((_tan__DeleteAnalyticsModulesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tan__DeleteAnalyticsModules:
		((_tan__DeleteAnalyticsModules *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tan__CreateAnalyticsModulesResponse:
		((_tan__CreateAnalyticsModulesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tan__CreateAnalyticsModules:
		((_tan__CreateAnalyticsModules *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse:
		((_tan__GetSupportedAnalyticsModulesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tan__GetSupportedAnalyticsModules:
		((_tan__GetSupportedAnalyticsModules *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tan__GetRulesResponse:
		((_tan__GetRulesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tan__GetRules:
		((_tan__GetRules *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tan__ModifyRulesResponse:
		((_tan__ModifyRulesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tan__ModifyRules:
		((_tan__ModifyRules *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tan__DeleteRulesResponse:
		((_tan__DeleteRulesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tan__DeleteRules:
		((_tan__DeleteRules *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tan__CreateRulesResponse:
		((_tan__CreateRulesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tan__CreateRules:
		((_tan__CreateRules *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tan__GetSupportedRulesResponse:
		((_tan__GetSupportedRulesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tan__GetSupportedRules:
		((_tan__GetSupportedRules *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__xml__lang:
		soap_serialize__xml__lang(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__token:
		soap_serialize_xsd__token(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		soap_serialize_xsd__nonNegativeInteger(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__integer:
		soap_serialize_xsd__integer(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__anySimpleType:
		soap_serialize_xsd__anySimpleType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__QName:
		soap_serialize_xsd__QName(soap, (const xsd__QName *)ptr);
		break;
	case SOAP_TYPE_xsd__NCName:
		soap_serialize_xsd__NCName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE___ns2__ModifyAnalyticsModules:
		soap_serialize___ns2__ModifyAnalyticsModules(soap, (const struct __ns2__ModifyAnalyticsModules *)ptr);
		break;
	case SOAP_TYPE___ns2__GetAnalyticsModules:
		soap_serialize___ns2__GetAnalyticsModules(soap, (const struct __ns2__GetAnalyticsModules *)ptr);
		break;
	case SOAP_TYPE___ns2__DeleteAnalyticsModules:
		soap_serialize___ns2__DeleteAnalyticsModules(soap, (const struct __ns2__DeleteAnalyticsModules *)ptr);
		break;
	case SOAP_TYPE___ns2__CreateAnalyticsModules:
		soap_serialize___ns2__CreateAnalyticsModules(soap, (const struct __ns2__CreateAnalyticsModules *)ptr);
		break;
	case SOAP_TYPE___ns2__GetSupportedAnalyticsModules:
		soap_serialize___ns2__GetSupportedAnalyticsModules(soap, (const struct __ns2__GetSupportedAnalyticsModules *)ptr);
		break;
	case SOAP_TYPE___ns1__ModifyRules:
		soap_serialize___ns1__ModifyRules(soap, (const struct __ns1__ModifyRules *)ptr);
		break;
	case SOAP_TYPE___ns1__GetRules:
		soap_serialize___ns1__GetRules(soap, (const struct __ns1__GetRules *)ptr);
		break;
	case SOAP_TYPE___ns1__DeleteRules:
		soap_serialize___ns1__DeleteRules(soap, (const struct __ns1__DeleteRules *)ptr);
		break;
	case SOAP_TYPE___ns1__CreateRules:
		soap_serialize___ns1__CreateRules(soap, (const struct __ns1__CreateRules *)ptr);
		break;
	case SOAP_TYPE___ns1__GetSupportedRules:
		soap_serialize___ns1__GetSupportedRules(soap, (const struct __ns1__GetSupportedRules *)ptr);
		break;
	case SOAP_TYPE__wsse__Security:
		soap_serialize__wsse__Security(soap, (const struct _wsse__Security *)ptr);
		break;
	case SOAP_TYPE_ds__RSAKeyValueType:
		soap_serialize_ds__RSAKeyValueType(soap, (const struct ds__RSAKeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__DSAKeyValueType:
		soap_serialize_ds__DSAKeyValueType(soap, (const struct ds__DSAKeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__X509IssuerSerialType:
		soap_serialize_ds__X509IssuerSerialType(soap, (const struct ds__X509IssuerSerialType *)ptr);
		break;
	case SOAP_TYPE_ds__X509DataType:
		soap_serialize_ds__X509DataType(soap, (const struct ds__X509DataType *)ptr);
		break;
	case SOAP_TYPE_ds__RetrievalMethodType:
		soap_serialize_ds__RetrievalMethodType(soap, (const struct ds__RetrievalMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__KeyValueType:
		soap_serialize_ds__KeyValueType(soap, (const struct ds__KeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__DigestMethodType:
		soap_serialize_ds__DigestMethodType(soap, (const struct ds__DigestMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__TransformType:
		soap_serialize_ds__TransformType(soap, (const struct ds__TransformType *)ptr);
		break;
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		soap_serialize__c14n__InclusiveNamespaces(soap, (const struct _c14n__InclusiveNamespaces *)ptr);
		break;
	case SOAP_TYPE_ds__TransformsType:
		soap_serialize_ds__TransformsType(soap, (const struct ds__TransformsType *)ptr);
		break;
	case SOAP_TYPE_ds__ReferenceType:
		soap_serialize_ds__ReferenceType(soap, (const struct ds__ReferenceType *)ptr);
		break;
	case SOAP_TYPE_ds__SignatureMethodType:
		soap_serialize_ds__SignatureMethodType(soap, (const struct ds__SignatureMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		soap_serialize_ds__CanonicalizationMethodType(soap, (const struct ds__CanonicalizationMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__KeyInfoType:
		soap_serialize_ds__KeyInfoType(soap, (const struct ds__KeyInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__SignedInfoType:
		soap_serialize_ds__SignedInfoType(soap, (const struct ds__SignedInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__SignatureType:
		soap_serialize_ds__SignatureType(soap, (const struct ds__SignatureType *)ptr);
		break;
	case SOAP_TYPE__wsse__SecurityTokenReference:
		soap_serialize__wsse__SecurityTokenReference(soap, (const struct _wsse__SecurityTokenReference *)ptr);
		break;
	case SOAP_TYPE__wsse__KeyIdentifier:
		soap_serialize__wsse__KeyIdentifier(soap, (const struct _wsse__KeyIdentifier *)ptr);
		break;
	case SOAP_TYPE__wsse__Embedded:
		soap_serialize__wsse__Embedded(soap, (const struct _wsse__Embedded *)ptr);
		break;
	case SOAP_TYPE__wsse__Reference:
		soap_serialize__wsse__Reference(soap, (const struct _wsse__Reference *)ptr);
		break;
	case SOAP_TYPE__wsse__BinarySecurityToken:
		soap_serialize__wsse__BinarySecurityToken(soap, (const struct _wsse__BinarySecurityToken *)ptr);
		break;
	case SOAP_TYPE__wsse__Password:
		soap_serialize__wsse__Password(soap, (const struct _wsse__Password *)ptr);
		break;
	case SOAP_TYPE__wsse__UsernameToken:
		soap_serialize__wsse__UsernameToken(soap, (const struct _wsse__UsernameToken *)ptr);
		break;
	case SOAP_TYPE__wsu__Timestamp:
		soap_serialize__wsu__Timestamp(soap, (const struct _wsu__Timestamp *)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		soap_serialize__wsa5__ProblemAction(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		soap_serialize__wsa5__FaultTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__From:
		soap_serialize__wsa5__From(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		soap_serialize__wsa5__ReplyTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		soap_serialize__wsa5__RelatesTo(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE__wsa5__Metadata:
		soap_serialize__wsa5__Metadata(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		soap_serialize__wsa5__ReferenceParameters(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		soap_serialize__wsa5__EndpointReference(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		soap_serialize_wsa5__ProblemActionType(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		soap_serialize_wsa5__RelatesToType(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		soap_serialize_wsa5__MetadataType(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		soap_serialize_wsa5__ReferenceParametersType(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		soap_serialize_wsa5__EndpointReferenceType(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__xop__Include:
		soap_serialize__xop__Include(soap, (const struct _xop__Include *)ptr);
		break;
	case SOAP_TYPE_xsd__anyAttribute:
		soap_serialize_xsd__anyAttribute(soap, (const struct soap_dom_attribute *)ptr);
		break;
	case SOAP_TYPE_xsd__anyType:
		soap_serialize_xsd__anyType(soap, (const struct soap_dom_element *)ptr);
		break;
	case SOAP_TYPE_PointerTo_tan__ModifyAnalyticsModulesResponse:
		soap_serialize_PointerTo_tan__ModifyAnalyticsModulesResponse(soap, (_tan__ModifyAnalyticsModulesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tan__ModifyAnalyticsModules:
		soap_serialize_PointerTo_tan__ModifyAnalyticsModules(soap, (_tan__ModifyAnalyticsModules *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tan__GetAnalyticsModulesResponse:
		soap_serialize_PointerTo_tan__GetAnalyticsModulesResponse(soap, (_tan__GetAnalyticsModulesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tan__GetAnalyticsModules:
		soap_serialize_PointerTo_tan__GetAnalyticsModules(soap, (_tan__GetAnalyticsModules *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tan__DeleteAnalyticsModulesResponse:
		soap_serialize_PointerTo_tan__DeleteAnalyticsModulesResponse(soap, (_tan__DeleteAnalyticsModulesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tan__DeleteAnalyticsModules:
		soap_serialize_PointerTo_tan__DeleteAnalyticsModules(soap, (_tan__DeleteAnalyticsModules *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tan__CreateAnalyticsModulesResponse:
		soap_serialize_PointerTo_tan__CreateAnalyticsModulesResponse(soap, (_tan__CreateAnalyticsModulesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tan__CreateAnalyticsModules:
		soap_serialize_PointerTo_tan__CreateAnalyticsModules(soap, (_tan__CreateAnalyticsModules *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tan__GetSupportedAnalyticsModulesResponse:
		soap_serialize_PointerTo_tan__GetSupportedAnalyticsModulesResponse(soap, (_tan__GetSupportedAnalyticsModulesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tan__GetSupportedAnalyticsModules:
		soap_serialize_PointerTo_tan__GetSupportedAnalyticsModules(soap, (_tan__GetSupportedAnalyticsModules *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tan__ModifyRulesResponse:
		soap_serialize_PointerTo_tan__ModifyRulesResponse(soap, (_tan__ModifyRulesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tan__ModifyRules:
		soap_serialize_PointerTo_tan__ModifyRules(soap, (_tan__ModifyRules *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tan__GetRulesResponse:
		soap_serialize_PointerTo_tan__GetRulesResponse(soap, (_tan__GetRulesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tan__GetRules:
		soap_serialize_PointerTo_tan__GetRules(soap, (_tan__GetRules *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tan__DeleteRulesResponse:
		soap_serialize_PointerTo_tan__DeleteRulesResponse(soap, (_tan__DeleteRulesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tan__DeleteRules:
		soap_serialize_PointerTo_tan__DeleteRules(soap, (_tan__DeleteRules *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tan__CreateRulesResponse:
		soap_serialize_PointerTo_tan__CreateRulesResponse(soap, (_tan__CreateRulesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tan__CreateRules:
		soap_serialize_PointerTo_tan__CreateRules(soap, (_tan__CreateRules *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tan__GetSupportedRulesResponse:
		soap_serialize_PointerTo_tan__GetSupportedRulesResponse(soap, (_tan__GetSupportedRulesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tan__GetSupportedRules:
		soap_serialize_PointerTo_tan__GetSupportedRules(soap, (_tan__GetSupportedRules *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__NCName:
		soap_serialize_PointerToxsd__NCName(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wstop__TopicNamespaceType_Topic:
		soap_serialize_PointerTo_wstop__TopicNamespaceType_Topic(soap, (_wstop__TopicNamespaceType_Topic *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__ConcreteTopicExpression:
		soap_serialize_PointerTowstop__ConcreteTopicExpression(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__TopicType:
		soap_serialize_PointerTowstop__TopicType(soap, (wstop__TopicType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__QueryExpressionType:
		soap_serialize_PointerTowstop__QueryExpressionType(soap, (wstop__QueryExpressionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ObjectExtension:
		soap_serialize_PointerTott__ObjectExtension(soap, (tt__ObjectExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Behaviour:
		soap_serialize_PointerTott__Behaviour(soap, (tt__Behaviour *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Appearance:
		soap_serialize_PointerTott__Appearance(soap, (tt__Appearance *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZConfigurationExtension:
		soap_serialize_PointerTott__PTZConfigurationExtension(soap, (tt__PTZConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ZoomLimits:
		soap_serialize_PointerTott__ZoomLimits(soap, (tt__ZoomLimits *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PanTiltLimits:
		soap_serialize_PointerTott__PanTiltLimits(soap, (tt__PanTiltLimits *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZSpeed:
		soap_serialize_PointerTott__PTZSpeed(soap, (tt__PTZSpeed *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZNodeExtension:
		soap_serialize_PointerTott__PTZNodeExtension(soap, (tt__PTZNodeExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__RelayOutputSettings:
		soap_serialize_PointerTott__RelayOutputSettings(soap, (tt__RelayOutputSettings *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkInterfaceExtension:
		soap_serialize_PointerTott__NetworkInterfaceExtension(soap, (tt__NetworkInterfaceExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPv6NetworkInterface:
		soap_serialize_PointerTott__IPv6NetworkInterface(soap, (tt__IPv6NetworkInterface *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPv4NetworkInterface:
		soap_serialize_PointerTott__IPv4NetworkInterface(soap, (tt__IPv4NetworkInterface *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkInterfaceLink:
		soap_serialize_PointerTott__NetworkInterfaceLink(soap, (tt__NetworkInterfaceLink *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkInterfaceInfo:
		soap_serialize_PointerTott__NetworkInterfaceInfo(soap, (tt__NetworkInterfaceInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__EventSubscription:
		soap_serialize_PointerTott__EventSubscription(soap, (tt__EventSubscription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZFilter:
		soap_serialize_PointerTott__PTZFilter(soap, (tt__PTZFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__RuleEngineConfiguration:
		soap_serialize_PointerTott__RuleEngineConfiguration(soap, (tt__RuleEngineConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__AnalyticsEngineConfiguration:
		soap_serialize_PointerTott__AnalyticsEngineConfiguration(soap, (tt__AnalyticsEngineConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__MulticastConfiguration:
		soap_serialize_PointerTott__MulticastConfiguration(soap, (tt__MulticastConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__H264Configuration:
		soap_serialize_PointerTott__H264Configuration(soap, (tt__H264Configuration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Mpeg4Configuration:
		soap_serialize_PointerTott__Mpeg4Configuration(soap, (tt__Mpeg4Configuration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__VideoRateControl:
		soap_serialize_PointerTott__VideoRateControl(soap, (tt__VideoRateControl *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IntRectangle:
		soap_serialize_PointerTott__IntRectangle(soap, (tt__IntRectangle *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__VideoSourceExtension:
		soap_serialize_PointerTott__VideoSourceExtension(soap, (tt__VideoSourceExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImagingSettings:
		soap_serialize_PointerTott__ImagingSettings(soap, (tt__ImagingSettings *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__Documentation:
		soap_serialize_PointerTowstop__Documentation(soap, (wstop__Documentation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause:
		soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, (_wsrfbf__BaseFaultType_FaultCause *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_Description:
		soap_serialize_PointerTo_wsrfbf__BaseFaultType_Description(soap, (_wsrfbf__BaseFaultType_Description *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_xml__lang:
		soap_serialize_PointerTo_xml__lang(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode:
		soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, (_wsrfbf__BaseFaultType_ErrorCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		soap_serialize_PointerToxsd__nonNegativeInteger(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsnb__Subscribe_SubscriptionPolicy:
		soap_serialize_PointerTo_wsnb__Subscribe_SubscriptionPolicy(soap, (_wsnb__Subscribe_SubscriptionPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnb__AbsoluteOrRelativeTimeType:
		soap_serialize_PointerTowsnb__AbsoluteOrRelativeTimeType(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnb__SubscriptionPolicyType:
		soap_serialize_PointerTowsnb__SubscriptionPolicyType(soap, (wsnb__SubscriptionPolicyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstop__TopicSetType:
		soap_serialize_PointerTowstop__TopicSetType(soap, (wstop__TopicSetType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnb__TopicExpressionType:
		soap_serialize_PointerTowsnb__TopicExpressionType(soap, (wsnb__TopicExpressionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__EndpointReferenceType:
		soap_serialize_PointerTowsa5__EndpointReferenceType(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PropertyOperation:
		soap_serialize_PointerTott__PropertyOperation(soap, (enum tt__PropertyOperation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__MessageExtension:
		soap_serialize_PointerTott__MessageExtension(soap, (tt__MessageExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__tt__union_EventStream:
		soap_serialize_PointerTo__tt__union_EventStream(soap, (__tt__union_EventStream *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__EventStreamExtension:
		soap_serialize_PointerTott__EventStreamExtension(soap, (tt__EventStreamExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnb__NotificationMessageHolderType:
		soap_serialize_PointerTowsnb__NotificationMessageHolderType(soap, (wsnb__NotificationMessageHolderType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__tt__union_PTZStream:
		soap_serialize_PointerTo__tt__union_PTZStream(soap, (__tt__union_PTZStream *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZStreamExtension:
		soap_serialize_PointerTott__PTZStreamExtension(soap, (tt__PTZStreamExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__tt__union_VideoAnalyticsStream:
		soap_serialize_PointerTo__tt__union_VideoAnalyticsStream(soap, (__tt__union_VideoAnalyticsStream *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__VideoAnalyticsStreamExtension:
		soap_serialize_PointerTott__VideoAnalyticsStreamExtension(soap, (tt__VideoAnalyticsStreamExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Frame:
		soap_serialize_PointerTott__Frame(soap, (tt__Frame *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__tt__union_MetadataStream:
		soap_serialize_PointerTo__tt__union_MetadataStream(soap, (__tt__union_MetadataStream *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__MetadataStreamExtension:
		soap_serialize_PointerTott__MetadataStreamExtension(soap, (tt__MetadataStreamExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__EventStream:
		soap_serialize_PointerTott__EventStream(soap, (tt__EventStream *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZStream:
		soap_serialize_PointerTott__PTZStream(soap, (tt__PTZStream *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__VideoAnalyticsStream:
		soap_serialize_PointerTott__VideoAnalyticsStream(soap, (tt__VideoAnalyticsStream *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SupportedAnalyticsModulesExtension:
		soap_serialize_PointerTott__SupportedAnalyticsModulesExtension(soap, (tt__SupportedAnalyticsModulesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SupportedRulesExtension:
		soap_serialize_PointerTott__SupportedRulesExtension(soap, (tt__SupportedRulesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ConfigDescription:
		soap_serialize_PointerTott__ConfigDescription(soap, (tt__ConfigDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ConfigDescriptionExtension:
		soap_serialize_PointerTott__ConfigDescriptionExtension(soap, (tt__ConfigDescriptionExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tt__ConfigDescription_Messages:
		soap_serialize_PointerTo_tt__ConfigDescription_Messages(soap, (_tt__ConfigDescription_Messages *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ItemList:
		soap_serialize_PointerTott__ItemList(soap, (tt__ItemList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__RuleEngineConfigurationExtension:
		soap_serialize_PointerTott__RuleEngineConfigurationExtension(soap, (tt__RuleEngineConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__AnalyticsEngineConfigurationExtension:
		soap_serialize_PointerTott__AnalyticsEngineConfigurationExtension(soap, (tt__AnalyticsEngineConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ObjectTreeExtension:
		soap_serialize_PointerTott__ObjectTreeExtension(soap, (tt__ObjectTreeExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Merge:
		soap_serialize_PointerTott__Merge(soap, (tt__Merge *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Split:
		soap_serialize_PointerTott__Split(soap, (tt__Split *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Rename:
		soap_serialize_PointerTott__Rename(soap, (tt__Rename *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__BehaviourExtension:
		soap_serialize_PointerTott__BehaviourExtension(soap, (tt__BehaviourExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tt__Behaviour_Idle:
		soap_serialize_PointerTo_tt__Behaviour_Idle(soap, (_tt__Behaviour_Idle *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tt__Behaviour_Removed:
		soap_serialize_PointerTo_tt__Behaviour_Removed(soap, (_tt__Behaviour_Removed *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__integer:
		soap_serialize_PointerToxsd__integer(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ObjectId:
		soap_serialize_PointerTott__ObjectId(soap, (tt__ObjectId *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__FrameExtension:
		soap_serialize_PointerTott__FrameExtension(soap, (tt__FrameExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ObjectTree:
		soap_serialize_PointerTott__ObjectTree(soap, (tt__ObjectTree *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Object:
		soap_serialize_PointerTott__Object(soap, (tt__Object *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZStatus:
		soap_serialize_PointerTott__PTZStatus(soap, (tt__PTZStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__TransformationExtension:
		soap_serialize_PointerTott__TransformationExtension(soap, (tt__TransformationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ClassDescriptorExtension:
		soap_serialize_PointerTott__ClassDescriptorExtension(soap, (tt__ClassDescriptorExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tt__ClassDescriptor_ClassCandidate:
		soap_serialize_PointerTo_tt__ClassDescriptor_ClassCandidate(soap, (_tt__ClassDescriptor_ClassCandidate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ColorDescriptorExtension:
		soap_serialize_PointerTott__ColorDescriptorExtension(soap, (tt__ColorDescriptorExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tt__ColorDescriptor_ColorCluster:
		soap_serialize_PointerTo_tt__ColorDescriptor_ColorCluster(soap, (_tt__ColorDescriptor_ColorCluster *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ColorCovariance:
		soap_serialize_PointerTott__ColorCovariance(soap, (tt__ColorCovariance *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Color:
		soap_serialize_PointerTott__Color(soap, (tt__Color *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ShapeDescriptorExtension:
		soap_serialize_PointerTott__ShapeDescriptorExtension(soap, (tt__ShapeDescriptorExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Polygon:
		soap_serialize_PointerTott__Polygon(soap, (tt__Polygon *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__AppearanceExtension:
		soap_serialize_PointerTott__AppearanceExtension(soap, (tt__AppearanceExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ClassDescriptor:
		soap_serialize_PointerTott__ClassDescriptor(soap, (tt__ClassDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ColorDescriptor:
		soap_serialize_PointerTott__ColorDescriptor(soap, (tt__ColorDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ShapeDescriptor:
		soap_serialize_PointerTott__ShapeDescriptor(soap, (tt__ShapeDescriptor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Transformation:
		soap_serialize_PointerTott__Transformation(soap, (tt__Transformation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Vector:
		soap_serialize_PointerTott__Vector(soap, (tt__Vector *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ItemListDescriptionExtension:
		soap_serialize_PointerTott__ItemListDescriptionExtension(soap, (tt__ItemListDescriptionExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tt__ItemListDescription_ElementItemDescription:
		soap_serialize_PointerTo_tt__ItemListDescription_ElementItemDescription(soap, (_tt__ItemListDescription_ElementItemDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tt__ItemListDescription_SimpleItemDescription:
		soap_serialize_PointerTo_tt__ItemListDescription_SimpleItemDescription(soap, (_tt__ItemListDescription_SimpleItemDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__MessageDescriptionExtension:
		soap_serialize_PointerTott__MessageDescriptionExtension(soap, (tt__MessageDescriptionExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ItemListDescription:
		soap_serialize_PointerTott__ItemListDescription(soap, (tt__ItemListDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ItemListExtension:
		soap_serialize_PointerTott__ItemListExtension(soap, (tt__ItemListExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tt__ItemList_ElementItem:
		soap_serialize_PointerTo_tt__ItemList_ElementItem(soap, (_tt__ItemList_ElementItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tt__ItemList_SimpleItem:
		soap_serialize_PointerTo_tt__ItemList_SimpleItem(soap, (_tt__ItemList_SimpleItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__FocusOptions20Extension:
		soap_serialize_PointerTott__FocusOptions20Extension(soap, (tt__FocusOptions20Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__WhiteBalanceOptions20Extension:
		soap_serialize_PointerTott__WhiteBalanceOptions20Extension(soap, (tt__WhiteBalanceOptions20Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__FocusConfiguration20Extension:
		soap_serialize_PointerTott__FocusConfiguration20Extension(soap, (tt__FocusConfiguration20Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__WhiteBalance20Extension:
		soap_serialize_PointerTott__WhiteBalance20Extension(soap, (tt__WhiteBalance20Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__RelativeFocusOptions20:
		soap_serialize_PointerTott__RelativeFocusOptions20(soap, (tt__RelativeFocusOptions20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImagingOptions20Extension:
		soap_serialize_PointerTott__ImagingOptions20Extension(soap, (tt__ImagingOptions20Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__WhiteBalanceOptions20:
		soap_serialize_PointerTott__WhiteBalanceOptions20(soap, (tt__WhiteBalanceOptions20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__WideDynamicRangeOptions20:
		soap_serialize_PointerTott__WideDynamicRangeOptions20(soap, (tt__WideDynamicRangeOptions20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__FocusOptions20:
		soap_serialize_PointerTott__FocusOptions20(soap, (tt__FocusOptions20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ExposureOptions20:
		soap_serialize_PointerTott__ExposureOptions20(soap, (tt__ExposureOptions20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__BacklightCompensationOptions20:
		soap_serialize_PointerTott__BacklightCompensationOptions20(soap, (tt__BacklightCompensationOptions20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ExposurePriority:
		soap_serialize_PointerTott__ExposurePriority(soap, (enum tt__ExposurePriority *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImagingSettingsExtension20:
		soap_serialize_PointerTott__ImagingSettingsExtension20(soap, (tt__ImagingSettingsExtension20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__WhiteBalance20:
		soap_serialize_PointerTott__WhiteBalance20(soap, (tt__WhiteBalance20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__WideDynamicRange20:
		soap_serialize_PointerTott__WideDynamicRange20(soap, (tt__WideDynamicRange20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__FocusConfiguration20:
		soap_serialize_PointerTott__FocusConfiguration20(soap, (tt__FocusConfiguration20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Exposure20:
		soap_serialize_PointerTott__Exposure20(soap, (tt__Exposure20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__BacklightCompensation20:
		soap_serialize_PointerTott__BacklightCompensation20(soap, (tt__BacklightCompensation20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__FocusStatus20Extension:
		soap_serialize_PointerTott__FocusStatus20Extension(soap, (tt__FocusStatus20Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImagingStatus20Extension:
		soap_serialize_PointerTott__ImagingStatus20Extension(soap, (tt__ImagingStatus20Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__FocusStatus20:
		soap_serialize_PointerTott__FocusStatus20(soap, (tt__FocusStatus20 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ContinuousFocusOptions:
		soap_serialize_PointerTott__ContinuousFocusOptions(soap, (tt__ContinuousFocusOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__RelativeFocusOptions:
		soap_serialize_PointerTott__RelativeFocusOptions(soap, (tt__RelativeFocusOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__AbsoluteFocusOptions:
		soap_serialize_PointerTott__AbsoluteFocusOptions(soap, (tt__AbsoluteFocusOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ContinuousFocus:
		soap_serialize_PointerTott__ContinuousFocus(soap, (tt__ContinuousFocus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__RelativeFocus:
		soap_serialize_PointerTott__RelativeFocus(soap, (tt__RelativeFocus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__AbsoluteFocus:
		soap_serialize_PointerTott__AbsoluteFocus(soap, (tt__AbsoluteFocus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__WhiteBalanceOptions:
		soap_serialize_PointerTott__WhiteBalanceOptions(soap, (tt__WhiteBalanceOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__WideDynamicRangeOptions:
		soap_serialize_PointerTott__WideDynamicRangeOptions(soap, (tt__WideDynamicRangeOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__FocusOptions:
		soap_serialize_PointerTott__FocusOptions(soap, (tt__FocusOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ExposureOptions:
		soap_serialize_PointerTott__ExposureOptions(soap, (tt__ExposureOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__BacklightCompensationOptions:
		soap_serialize_PointerTott__BacklightCompensationOptions(soap, (tt__BacklightCompensationOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Rectangle:
		soap_serialize_PointerTott__Rectangle(soap, (tt__Rectangle *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImagingSettingsExtension:
		soap_serialize_PointerTott__ImagingSettingsExtension(soap, (tt__ImagingSettingsExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__WhiteBalance:
		soap_serialize_PointerTott__WhiteBalance(soap, (tt__WhiteBalance *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__WideDynamicRange:
		soap_serialize_PointerTott__WideDynamicRange(soap, (tt__WideDynamicRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IrCutFilterMode:
		soap_serialize_PointerTott__IrCutFilterMode(soap, (enum tt__IrCutFilterMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__FocusConfiguration:
		soap_serialize_PointerTott__FocusConfiguration(soap, (tt__FocusConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Exposure:
		soap_serialize_PointerTott__Exposure(soap, (tt__Exposure *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofloat:
		soap_serialize_PointerTofloat(soap, (float *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__BacklightCompensation:
		soap_serialize_PointerTott__BacklightCompensation(soap, (tt__BacklightCompensation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__FocusStatus:
		soap_serialize_PointerTott__FocusStatus(soap, (tt__FocusStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__MoveStatus:
		soap_serialize_PointerTott__MoveStatus(soap, (enum tt__MoveStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ReferenceToken:
		soap_serialize_PointerTott__ReferenceToken(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Name:
		soap_serialize_PointerTott__Name(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZMoveStatus:
		soap_serialize_PointerTott__PTZMoveStatus(soap, (tt__PTZMoveStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZVector:
		soap_serialize_PointerTott__PTZVector(soap, (tt__PTZVector *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Vector1D:
		soap_serialize_PointerTott__Vector1D(soap, (tt__Vector1D *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Vector2D:
		soap_serialize_PointerTott__Vector2D(soap, (tt__Vector2D *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyURI:
		soap_serialize_PointerToxsd__anyURI(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__FloatRange:
		soap_serialize_PointerTott__FloatRange(soap, (tt__FloatRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZSpacesExtension:
		soap_serialize_PointerTott__PTZSpacesExtension(soap, (tt__PTZSpacesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Space1DDescription:
		soap_serialize_PointerTott__Space1DDescription(soap, (tt__Space1DDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Space2DDescription:
		soap_serialize_PointerTott__Space2DDescription(soap, (tt__Space2DDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DurationRange:
		soap_serialize_PointerTott__DurationRange(soap, (tt__DurationRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZSpaces:
		soap_serialize_PointerTott__PTZSpaces(soap, (tt__PTZSpaces *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__BinaryData:
		soap_serialize_PointerTott__BinaryData(soap, (tt__BinaryData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__CertificateGenerationParametersExtension:
		soap_serialize_PointerTott__CertificateGenerationParametersExtension(soap, (tt__CertificateGenerationParametersExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__UserExtension:
		soap_serialize_PointerTott__UserExtension(soap, (tt__UserExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Date:
		soap_serialize_PointerTott__Date(soap, (tt__Date *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Time:
		soap_serialize_PointerTott__Time(soap, (tt__Time *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SystemDateTimeExtension:
		soap_serialize_PointerTott__SystemDateTimeExtension(soap, (tt__SystemDateTimeExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DateTime:
		soap_serialize_PointerTott__DateTime(soap, (tt__DateTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__TimeZone:
		soap_serialize_PointerTott__TimeZone(soap, (tt__TimeZone *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__AttachmentData:
		soap_serialize_PointerTott__AttachmentData(soap, (tt__AttachmentData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SystemCapabilitiesExtension:
		soap_serialize_PointerTott__SystemCapabilitiesExtension(soap, (tt__SystemCapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__OnvifVersion:
		soap_serialize_PointerTott__OnvifVersion(soap, (tt__OnvifVersion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SecurityCapabilitiesExtension:
		soap_serialize_PointerTott__SecurityCapabilitiesExtension(soap, (tt__SecurityCapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkCapabilitiesExtension:
		soap_serialize_PointerTott__NetworkCapabilitiesExtension(soap, (tt__NetworkCapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__RealTimeStreamingCapabilitiesExtension:
		soap_serialize_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, (tt__RealTimeStreamingCapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ProfileCapabilities:
		soap_serialize_PointerTott__ProfileCapabilities(soap, (tt__ProfileCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__MediaCapabilitiesExtension:
		soap_serialize_PointerTott__MediaCapabilitiesExtension(soap, (tt__MediaCapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__RealTimeStreamingCapabilities:
		soap_serialize_PointerTott__RealTimeStreamingCapabilities(soap, (tt__RealTimeStreamingCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IOCapabilitiesExtension:
		soap_serialize_PointerTott__IOCapabilitiesExtension(soap, (tt__IOCapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DeviceCapabilitiesExtension:
		soap_serialize_PointerTott__DeviceCapabilitiesExtension(soap, (tt__DeviceCapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SecurityCapabilities:
		soap_serialize_PointerTott__SecurityCapabilities(soap, (tt__SecurityCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IOCapabilities:
		soap_serialize_PointerTott__IOCapabilities(soap, (tt__IOCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SystemCapabilities:
		soap_serialize_PointerTott__SystemCapabilities(soap, (tt__SystemCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkCapabilities:
		soap_serialize_PointerTott__NetworkCapabilities(soap, (tt__NetworkCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__CapabilitiesExtension:
		soap_serialize_PointerTott__CapabilitiesExtension(soap, (tt__CapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZCapabilities:
		soap_serialize_PointerTott__PTZCapabilities(soap, (tt__PTZCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__MediaCapabilities:
		soap_serialize_PointerTott__MediaCapabilities(soap, (tt__MediaCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImagingCapabilities:
		soap_serialize_PointerTott__ImagingCapabilities(soap, (tt__ImagingCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__EventCapabilities:
		soap_serialize_PointerTott__EventCapabilities(soap, (tt__EventCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DeviceCapabilities:
		soap_serialize_PointerTott__DeviceCapabilities(soap, (tt__DeviceCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__AnalyticsCapabilities:
		soap_serialize_PointerTott__AnalyticsCapabilities(soap, (tt__AnalyticsCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPAddressFilterExtension:
		soap_serialize_PointerTott__IPAddressFilterExtension(soap, (tt__IPAddressFilterExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkZeroConfigurationExtension:
		soap_serialize_PointerTott__NetworkZeroConfigurationExtension(soap, (tt__NetworkZeroConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPv6DHCPConfiguration:
		soap_serialize_PointerTott__IPv6DHCPConfiguration(soap, (enum tt__IPv6DHCPConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkInterfaceSetConfigurationExtension:
		soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, (tt__NetworkInterfaceSetConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPv6NetworkInterfaceSetConfiguration:
		soap_serialize_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, (tt__IPv6NetworkInterfaceSetConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPv4NetworkInterfaceSetConfiguration:
		soap_serialize_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, (tt__IPv4NetworkInterfaceSetConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DynamicDNSInformationExtension:
		soap_serialize_PointerTott__DynamicDNSInformationExtension(soap, (tt__DynamicDNSInformationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__duration:
		soap_serialize_PointerToxsd__duration(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NTPInformationExtension:
		soap_serialize_PointerTott__NTPInformationExtension(soap, (tt__NTPInformationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkHost:
		soap_serialize_PointerTott__NetworkHost(soap, (tt__NetworkHost *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DNSInformationExtension:
		soap_serialize_PointerTott__DNSInformationExtension(soap, (tt__DNSInformationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__HostnameInformationExtension:
		soap_serialize_PointerTott__HostnameInformationExtension(soap, (tt__HostnameInformationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__token:
		soap_serialize_PointerToxsd__token(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkHostExtension:
		soap_serialize_PointerTott__NetworkHostExtension(soap, (tt__NetworkHostExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DNSName:
		soap_serialize_PointerTott__DNSName(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPv6Address:
		soap_serialize_PointerTott__IPv6Address(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPv4Address:
		soap_serialize_PointerTott__IPv4Address(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkProtocolExtension:
		soap_serialize_PointerTott__NetworkProtocolExtension(soap, (tt__NetworkProtocolExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPv6ConfigurationExtension:
		soap_serialize_PointerTott__IPv6ConfigurationExtension(soap, (tt__IPv6ConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PrefixedIPv6Address:
		soap_serialize_PointerTott__PrefixedIPv6Address(soap, (tt__PrefixedIPv6Address *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PrefixedIPv4Address:
		soap_serialize_PointerTott__PrefixedIPv4Address(soap, (tt__PrefixedIPv4Address *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPv4Configuration:
		soap_serialize_PointerTott__IPv4Configuration(soap, (tt__IPv4Configuration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPv6Configuration:
		soap_serialize_PointerTott__IPv6Configuration(soap, (tt__IPv6Configuration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkInterfaceConnectionSetting:
		soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, (tt__NetworkInterfaceConnectionSetting *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Transport:
		soap_serialize_PointerTott__Transport(soap, (tt__Transport *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPAddress:
		soap_serialize_PointerTott__IPAddress(soap, (tt__IPAddress *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZStatusFilterOptions:
		soap_serialize_PointerTott__PTZStatusFilterOptions(soap, (tt__PTZStatusFilterOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tt__EventSubscription_SubscriptionPolicy:
		soap_serialize_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, (_tt__EventSubscription_SubscriptionPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsnb__FilterType:
		soap_serialize_PointerTowsnb__FilterType(soap, (wsnb__FilterType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IntList:
		soap_serialize_PointerTott__IntList(soap, (tt__IntList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__AudioEncoderConfigurationOption:
		soap_serialize_PointerTott__AudioEncoderConfigurationOption(soap, (tt__AudioEncoderConfigurationOption *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__AudioSourceOptionsExtension:
		soap_serialize_PointerTott__AudioSourceOptionsExtension(soap, (tt__AudioSourceOptionsExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__VideoResolution:
		soap_serialize_PointerTott__VideoResolution(soap, (tt__VideoResolution *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__VideoEncoderOptionsExtension:
		soap_serialize_PointerTott__VideoEncoderOptionsExtension(soap, (tt__VideoEncoderOptionsExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__H264Options:
		soap_serialize_PointerTott__H264Options(soap, (tt__H264Options *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Mpeg4Options:
		soap_serialize_PointerTott__Mpeg4Options(soap, (tt__Mpeg4Options *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__JpegOptions:
		soap_serialize_PointerTott__JpegOptions(soap, (tt__JpegOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__VideoSourceConfigurationOptionsExtension:
		soap_serialize_PointerTott__VideoSourceConfigurationOptionsExtension(soap, (tt__VideoSourceConfigurationOptionsExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IntRectangleRange:
		soap_serialize_PointerTott__IntRectangleRange(soap, (tt__IntRectangleRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ProfileExtension:
		soap_serialize_PointerTott__ProfileExtension(soap, (tt__ProfileExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__MetadataConfiguration:
		soap_serialize_PointerTott__MetadataConfiguration(soap, (tt__MetadataConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZConfiguration:
		soap_serialize_PointerTott__PTZConfiguration(soap, (tt__PTZConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__VideoAnalyticsConfiguration:
		soap_serialize_PointerTott__VideoAnalyticsConfiguration(soap, (tt__VideoAnalyticsConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__AudioEncoderConfiguration:
		soap_serialize_PointerTott__AudioEncoderConfiguration(soap, (tt__AudioEncoderConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__VideoEncoderConfiguration:
		soap_serialize_PointerTott__VideoEncoderConfiguration(soap, (tt__VideoEncoderConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__AudioSourceConfiguration:
		soap_serialize_PointerTott__AudioSourceConfiguration(soap, (tt__AudioSourceConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__VideoSourceConfiguration:
		soap_serialize_PointerTott__VideoSourceConfiguration(soap, (tt__VideoSourceConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IntRange:
		soap_serialize_PointerTott__IntRange(soap, (tt__IntRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SupportedAnalyticsModules:
		soap_serialize_PointerTott__SupportedAnalyticsModules(soap, (tt__SupportedAnalyticsModules *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Config:
		soap_serialize_PointerTott__Config(soap, (tt__Config *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SupportedRules:
		soap_serialize_PointerTott__SupportedRules(soap, (tt__SupportedRules *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		soap_serialize_PointerTo_wsa5__FaultTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		soap_serialize_PointerTo_wsa5__ReplyTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__From:
		soap_serialize_PointerTo_wsa5__From(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		soap_serialize_PointerTo_wsa5__RelatesTo(soap, (struct wsa5__RelatesToType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Security:
		soap_serialize_PointerTo_wsse__Security(soap, (struct _wsse__Security *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignatureType:
		soap_serialize_PointerTods__SignatureType(soap, (struct ds__SignatureType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, (struct _wsse__BinarySecurityToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		soap_serialize_PointerTo_wsse__UsernameToken(soap, (struct _wsse__UsernameToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		soap_serialize_PointerTo_wsu__Timestamp(soap, (struct _wsu__Timestamp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		soap_serialize_PointerTods__X509IssuerSerialType(soap, (struct ds__X509IssuerSerialType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		soap_serialize_PointerTods__RSAKeyValueType(soap, (struct ds__RSAKeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		soap_serialize_PointerTods__DSAKeyValueType(soap, (struct ds__DSAKeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__TransformType:
		soap_serialize_PointerTods__TransformType(soap, (struct ds__TransformType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__DigestMethodType:
		soap_serialize_PointerTods__DigestMethodType(soap, (struct ds__DigestMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__TransformsType:
		soap_serialize_PointerTods__TransformsType(soap, (struct ds__TransformsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		soap_serialize_PointerToPointerTods__ReferenceType(soap, (struct ds__ReferenceType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__ReferenceType:
		soap_serialize_PointerTods__ReferenceType(soap, (struct ds__ReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		soap_serialize_PointerTods__SignatureMethodType(soap, (struct ds__SignatureMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		soap_serialize_PointerTods__CanonicalizationMethodType(soap, (struct ds__CanonicalizationMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, (struct _wsse__SecurityTokenReference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__X509DataType:
		soap_serialize_PointerTods__X509DataType(soap, (struct ds__X509DataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		soap_serialize_PointerTods__RetrievalMethodType(soap, (struct ds__RetrievalMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__KeyValueType:
		soap_serialize_PointerTods__KeyValueType(soap, (struct ds__KeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, (struct _c14n__InclusiveNamespaces *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__KeyInfoType:
		soap_serialize_PointerTods__KeyInfoType(soap, (struct ds__KeyInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignedInfoType:
		soap_serialize_PointerTods__SignedInfoType(soap, (struct ds__SignedInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		soap_serialize_PointerTo_wsse__Embedded(soap, (struct _wsse__Embedded *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		soap_serialize_PointerTo_wsse__KeyIdentifier(soap, (struct _wsse__KeyIdentifier *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Reference:
		soap_serialize_PointerTo_wsse__Reference(soap, (struct _wsse__Reference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Password:
		soap_serialize_PointerTo_wsse__Password(soap, (struct _wsse__Password *const*)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemIRI:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__wsa5__Action:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__wsa5__To:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__wsa5__MessageID:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		soap_serialize_PointerTowsa5__MetadataType(soap, (struct wsa5__MetadataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		soap_serialize_PointerTowsa5__ReferenceParametersType(soap, (struct wsa5__ReferenceParametersType *const*)ptr);
		break;
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE__xop__Include:
		return (void*)soap_instantiate__xop__Include(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return (void*)soap_instantiate_wsa5__EndpointReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return (void*)soap_instantiate_wsa5__ReferenceParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__MetadataType:
		return (void*)soap_instantiate_wsa5__MetadataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__ProblemActionType:
		return (void*)soap_instantiate_wsa5__ProblemActionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__RelatesToType:
		return (void*)soap_instantiate_wsa5__RelatesToType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsu__Timestamp:
		return (void*)soap_instantiate__wsu__Timestamp(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__UsernameToken:
		return (void*)soap_instantiate__wsse__UsernameToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__BinarySecurityToken:
		return (void*)soap_instantiate__wsse__BinarySecurityToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Reference:
		return (void*)soap_instantiate__wsse__Reference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Embedded:
		return (void*)soap_instantiate__wsse__Embedded(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__KeyIdentifier:
		return (void*)soap_instantiate__wsse__KeyIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__SecurityTokenReference:
		return (void*)soap_instantiate__wsse__SecurityTokenReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__SignatureType:
		return (void*)soap_instantiate_ds__SignatureType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		return (void*)soap_instantiate__c14n__InclusiveNamespaces(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__TransformType:
		return (void*)soap_instantiate_ds__TransformType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__KeyInfoType:
		return (void*)soap_instantiate_ds__KeyInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__SignedInfoType:
		return (void*)soap_instantiate_ds__SignedInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return (void*)soap_instantiate_ds__CanonicalizationMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__SignatureMethodType:
		return (void*)soap_instantiate_ds__SignatureMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__ReferenceType:
		return (void*)soap_instantiate_ds__ReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__TransformsType:
		return (void*)soap_instantiate_ds__TransformsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__DigestMethodType:
		return (void*)soap_instantiate_ds__DigestMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__KeyValueType:
		return (void*)soap_instantiate_ds__KeyValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__RetrievalMethodType:
		return (void*)soap_instantiate_ds__RetrievalMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__X509DataType:
		return (void*)soap_instantiate_ds__X509DataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return (void*)soap_instantiate_ds__X509IssuerSerialType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__DSAKeyValueType:
		return (void*)soap_instantiate_ds__DSAKeyValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__RSAKeyValueType:
		return (void*)soap_instantiate_ds__RSAKeyValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Security:
		return (void*)soap_instantiate__wsse__Security(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Password:
		return (void*)soap_instantiate__wsse__Password(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tan__GetSupportedRules:
		return (void*)soap_instantiate__tan__GetSupportedRules(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tan__GetSupportedRulesResponse:
		return (void*)soap_instantiate__tan__GetSupportedRulesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tan__CreateRules:
		return (void*)soap_instantiate__tan__CreateRules(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tan__CreateRulesResponse:
		return (void*)soap_instantiate__tan__CreateRulesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tan__DeleteRules:
		return (void*)soap_instantiate__tan__DeleteRules(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tan__DeleteRulesResponse:
		return (void*)soap_instantiate__tan__DeleteRulesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tan__ModifyRules:
		return (void*)soap_instantiate__tan__ModifyRules(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tan__ModifyRulesResponse:
		return (void*)soap_instantiate__tan__ModifyRulesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tan__GetRules:
		return (void*)soap_instantiate__tan__GetRules(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tan__GetRulesResponse:
		return (void*)soap_instantiate__tan__GetRulesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tan__GetSupportedAnalyticsModules:
		return (void*)soap_instantiate__tan__GetSupportedAnalyticsModules(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse:
		return (void*)soap_instantiate__tan__GetSupportedAnalyticsModulesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tan__CreateAnalyticsModules:
		return (void*)soap_instantiate__tan__CreateAnalyticsModules(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tan__CreateAnalyticsModulesResponse:
		return (void*)soap_instantiate__tan__CreateAnalyticsModulesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tan__DeleteAnalyticsModules:
		return (void*)soap_instantiate__tan__DeleteAnalyticsModules(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tan__DeleteAnalyticsModulesResponse:
		return (void*)soap_instantiate__tan__DeleteAnalyticsModulesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tan__ModifyAnalyticsModules:
		return (void*)soap_instantiate__tan__ModifyAnalyticsModules(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tan__ModifyAnalyticsModulesResponse:
		return (void*)soap_instantiate__tan__ModifyAnalyticsModulesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tan__GetAnalyticsModules:
		return (void*)soap_instantiate__tan__GetAnalyticsModules(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tan__GetAnalyticsModulesResponse:
		return (void*)soap_instantiate__tan__GetAnalyticsModulesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DeviceEntity:
		return (void*)soap_instantiate_tt__DeviceEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IntRectangle:
		return (void*)soap_instantiate_tt__IntRectangle(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IntRectangleRange:
		return (void*)soap_instantiate_tt__IntRectangleRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IntRange:
		return (void*)soap_instantiate_tt__IntRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__FloatRange:
		return (void*)soap_instantiate_tt__FloatRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DurationRange:
		return (void*)soap_instantiate_tt__DurationRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IntList:
		return (void*)soap_instantiate_tt__IntList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__VideoSourceExtension:
		return (void*)soap_instantiate_tt__VideoSourceExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Profile:
		return (void*)soap_instantiate_tt__Profile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ProfileExtension:
		return (void*)soap_instantiate_tt__ProfileExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ConfigurationEntity:
		return (void*)soap_instantiate_tt__ConfigurationEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__VideoSourceConfigurationOptions:
		return (void*)soap_instantiate_tt__VideoSourceConfigurationOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension:
		return (void*)soap_instantiate_tt__VideoSourceConfigurationOptionsExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__VideoResolution:
		return (void*)soap_instantiate_tt__VideoResolution(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__VideoRateControl:
		return (void*)soap_instantiate_tt__VideoRateControl(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Mpeg4Configuration:
		return (void*)soap_instantiate_tt__Mpeg4Configuration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__H264Configuration:
		return (void*)soap_instantiate_tt__H264Configuration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__VideoEncoderConfigurationOptions:
		return (void*)soap_instantiate_tt__VideoEncoderConfigurationOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__VideoEncoderOptionsExtension:
		return (void*)soap_instantiate_tt__VideoEncoderOptionsExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__JpegOptions:
		return (void*)soap_instantiate_tt__JpegOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Mpeg4Options:
		return (void*)soap_instantiate_tt__Mpeg4Options(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__H264Options:
		return (void*)soap_instantiate_tt__H264Options(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AudioSourceConfigurationOptions:
		return (void*)soap_instantiate_tt__AudioSourceConfigurationOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AudioSourceOptionsExtension:
		return (void*)soap_instantiate_tt__AudioSourceOptionsExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AudioEncoderConfigurationOptions:
		return (void*)soap_instantiate_tt__AudioEncoderConfigurationOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AudioEncoderConfigurationOption:
		return (void*)soap_instantiate_tt__AudioEncoderConfigurationOption(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZFilter:
		return (void*)soap_instantiate_tt__PTZFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy:
		return (void*)soap_instantiate__tt__EventSubscription_SubscriptionPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__EventSubscription:
		return (void*)soap_instantiate_tt__EventSubscription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__MetadataConfigurationOptions:
		return (void*)soap_instantiate_tt__MetadataConfigurationOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZStatusFilterOptions:
		return (void*)soap_instantiate_tt__PTZStatusFilterOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__MulticastConfiguration:
		return (void*)soap_instantiate_tt__MulticastConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__StreamSetup:
		return (void*)soap_instantiate_tt__StreamSetup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Transport:
		return (void*)soap_instantiate_tt__Transport(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__MediaUri:
		return (void*)soap_instantiate_tt__MediaUri(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Scope:
		return (void*)soap_instantiate_tt__Scope(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkInterfaceExtension:
		return (void*)soap_instantiate_tt__NetworkInterfaceExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkInterfaceLink:
		return (void*)soap_instantiate_tt__NetworkInterfaceLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkInterfaceConnectionSetting:
		return (void*)soap_instantiate_tt__NetworkInterfaceConnectionSetting(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkInterfaceInfo:
		return (void*)soap_instantiate_tt__NetworkInterfaceInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPv6NetworkInterface:
		return (void*)soap_instantiate_tt__IPv6NetworkInterface(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPv4NetworkInterface:
		return (void*)soap_instantiate_tt__IPv4NetworkInterface(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPv4Configuration:
		return (void*)soap_instantiate_tt__IPv4Configuration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPv6Configuration:
		return (void*)soap_instantiate_tt__IPv6Configuration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPv6ConfigurationExtension:
		return (void*)soap_instantiate_tt__IPv6ConfigurationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkProtocol:
		return (void*)soap_instantiate_tt__NetworkProtocol(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkProtocolExtension:
		return (void*)soap_instantiate_tt__NetworkProtocolExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkHost:
		return (void*)soap_instantiate_tt__NetworkHost(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkHostExtension:
		return (void*)soap_instantiate_tt__NetworkHostExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPAddress:
		return (void*)soap_instantiate_tt__IPAddress(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PrefixedIPv4Address:
		return (void*)soap_instantiate_tt__PrefixedIPv4Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PrefixedIPv6Address:
		return (void*)soap_instantiate_tt__PrefixedIPv6Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__HostnameInformation:
		return (void*)soap_instantiate_tt__HostnameInformation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__HostnameInformationExtension:
		return (void*)soap_instantiate_tt__HostnameInformationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DNSInformation:
		return (void*)soap_instantiate_tt__DNSInformation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DNSInformationExtension:
		return (void*)soap_instantiate_tt__DNSInformationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NTPInformation:
		return (void*)soap_instantiate_tt__NTPInformation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NTPInformationExtension:
		return (void*)soap_instantiate_tt__NTPInformationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DynamicDNSInformation:
		return (void*)soap_instantiate_tt__DynamicDNSInformation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DynamicDNSInformationExtension:
		return (void*)soap_instantiate_tt__DynamicDNSInformationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkInterfaceSetConfiguration:
		return (void*)soap_instantiate_tt__NetworkInterfaceSetConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension:
		return (void*)soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration:
		return (void*)soap_instantiate_tt__IPv6NetworkInterfaceSetConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration:
		return (void*)soap_instantiate_tt__IPv4NetworkInterfaceSetConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkGateway:
		return (void*)soap_instantiate_tt__NetworkGateway(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkZeroConfiguration:
		return (void*)soap_instantiate_tt__NetworkZeroConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkZeroConfigurationExtension:
		return (void*)soap_instantiate_tt__NetworkZeroConfigurationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPAddressFilter:
		return (void*)soap_instantiate_tt__IPAddressFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPAddressFilterExtension:
		return (void*)soap_instantiate_tt__IPAddressFilterExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Capabilities:
		return (void*)soap_instantiate_tt__Capabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__CapabilitiesExtension:
		return (void*)soap_instantiate_tt__CapabilitiesExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AnalyticsCapabilities:
		return (void*)soap_instantiate_tt__AnalyticsCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DeviceCapabilities:
		return (void*)soap_instantiate_tt__DeviceCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DeviceCapabilitiesExtension:
		return (void*)soap_instantiate_tt__DeviceCapabilitiesExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__EventCapabilities:
		return (void*)soap_instantiate_tt__EventCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IOCapabilities:
		return (void*)soap_instantiate_tt__IOCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IOCapabilitiesExtension:
		return (void*)soap_instantiate_tt__IOCapabilitiesExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__MediaCapabilities:
		return (void*)soap_instantiate_tt__MediaCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__MediaCapabilitiesExtension:
		return (void*)soap_instantiate_tt__MediaCapabilitiesExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__RealTimeStreamingCapabilities:
		return (void*)soap_instantiate_tt__RealTimeStreamingCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension:
		return (void*)soap_instantiate_tt__RealTimeStreamingCapabilitiesExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ProfileCapabilities:
		return (void*)soap_instantiate_tt__ProfileCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkCapabilities:
		return (void*)soap_instantiate_tt__NetworkCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkCapabilitiesExtension:
		return (void*)soap_instantiate_tt__NetworkCapabilitiesExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SecurityCapabilities:
		return (void*)soap_instantiate_tt__SecurityCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SecurityCapabilitiesExtension:
		return (void*)soap_instantiate_tt__SecurityCapabilitiesExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__StorageCapabilities:
		return (void*)soap_instantiate_tt__StorageCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SystemCapabilities:
		return (void*)soap_instantiate_tt__SystemCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SystemCapabilitiesExtension:
		return (void*)soap_instantiate_tt__SystemCapabilitiesExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__OnvifVersion:
		return (void*)soap_instantiate_tt__OnvifVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingCapabilities:
		return (void*)soap_instantiate_tt__ImagingCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZCapabilities:
		return (void*)soap_instantiate_tt__PTZCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SystemLog:
		return (void*)soap_instantiate_tt__SystemLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SupportInformation:
		return (void*)soap_instantiate_tt__SupportInformation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__BinaryData:
		return (void*)soap_instantiate_tt__BinaryData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AttachmentData:
		return (void*)soap_instantiate_tt__AttachmentData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__BackupFile:
		return (void*)soap_instantiate_tt__BackupFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SystemDateTime:
		return (void*)soap_instantiate_tt__SystemDateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SystemDateTimeExtension:
		return (void*)soap_instantiate_tt__SystemDateTimeExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DateTime:
		return (void*)soap_instantiate_tt__DateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Date:
		return (void*)soap_instantiate_tt__Date(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Time:
		return (void*)soap_instantiate_tt__Time(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__TimeZone:
		return (void*)soap_instantiate_tt__TimeZone(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__User:
		return (void*)soap_instantiate_tt__User(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__UserExtension:
		return (void*)soap_instantiate_tt__UserExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__CertificateGenerationParameters:
		return (void*)soap_instantiate_tt__CertificateGenerationParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__CertificateGenerationParametersExtension:
		return (void*)soap_instantiate_tt__CertificateGenerationParametersExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Certificate:
		return (void*)soap_instantiate_tt__Certificate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__CertificateStatus:
		return (void*)soap_instantiate_tt__CertificateStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__RelayOutputSettings:
		return (void*)soap_instantiate_tt__RelayOutputSettings(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZNodeExtension:
		return (void*)soap_instantiate_tt__PTZNodeExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZConfigurationExtension:
		return (void*)soap_instantiate_tt__PTZConfigurationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZConfigurationOptions:
		return (void*)soap_instantiate_tt__PTZConfigurationOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PanTiltLimits:
		return (void*)soap_instantiate_tt__PanTiltLimits(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ZoomLimits:
		return (void*)soap_instantiate_tt__ZoomLimits(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZSpaces:
		return (void*)soap_instantiate_tt__PTZSpaces(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZSpacesExtension:
		return (void*)soap_instantiate_tt__PTZSpacesExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Space2DDescription:
		return (void*)soap_instantiate_tt__Space2DDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Space1DDescription:
		return (void*)soap_instantiate_tt__Space1DDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Vector2D:
		return (void*)soap_instantiate_tt__Vector2D(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Vector1D:
		return (void*)soap_instantiate_tt__Vector1D(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZVector:
		return (void*)soap_instantiate_tt__PTZVector(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZSpeed:
		return (void*)soap_instantiate_tt__PTZSpeed(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZStatus:
		return (void*)soap_instantiate_tt__PTZStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZPreset:
		return (void*)soap_instantiate_tt__PTZPreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZMoveStatus:
		return (void*)soap_instantiate_tt__PTZMoveStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingStatus:
		return (void*)soap_instantiate_tt__ImagingStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__FocusStatus:
		return (void*)soap_instantiate_tt__FocusStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__FocusConfiguration:
		return (void*)soap_instantiate_tt__FocusConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingSettings:
		return (void*)soap_instantiate_tt__ImagingSettings(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingSettingsExtension:
		return (void*)soap_instantiate_tt__ImagingSettingsExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Exposure:
		return (void*)soap_instantiate_tt__Exposure(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__WideDynamicRange:
		return (void*)soap_instantiate_tt__WideDynamicRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__BacklightCompensation:
		return (void*)soap_instantiate_tt__BacklightCompensation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingOptions:
		return (void*)soap_instantiate_tt__ImagingOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__WideDynamicRangeOptions:
		return (void*)soap_instantiate_tt__WideDynamicRangeOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__BacklightCompensationOptions:
		return (void*)soap_instantiate_tt__BacklightCompensationOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__FocusOptions:
		return (void*)soap_instantiate_tt__FocusOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ExposureOptions:
		return (void*)soap_instantiate_tt__ExposureOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__WhiteBalanceOptions:
		return (void*)soap_instantiate_tt__WhiteBalanceOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__FocusMove:
		return (void*)soap_instantiate_tt__FocusMove(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AbsoluteFocus:
		return (void*)soap_instantiate_tt__AbsoluteFocus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__RelativeFocus:
		return (void*)soap_instantiate_tt__RelativeFocus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ContinuousFocus:
		return (void*)soap_instantiate_tt__ContinuousFocus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__MoveOptions:
		return (void*)soap_instantiate_tt__MoveOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AbsoluteFocusOptions:
		return (void*)soap_instantiate_tt__AbsoluteFocusOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__RelativeFocusOptions:
		return (void*)soap_instantiate_tt__RelativeFocusOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ContinuousFocusOptions:
		return (void*)soap_instantiate_tt__ContinuousFocusOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__WhiteBalance:
		return (void*)soap_instantiate_tt__WhiteBalance(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingStatus20:
		return (void*)soap_instantiate_tt__ImagingStatus20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingStatus20Extension:
		return (void*)soap_instantiate_tt__ImagingStatus20Extension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__FocusStatus20:
		return (void*)soap_instantiate_tt__FocusStatus20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__FocusStatus20Extension:
		return (void*)soap_instantiate_tt__FocusStatus20Extension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingSettings20:
		return (void*)soap_instantiate_tt__ImagingSettings20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingSettingsExtension20:
		return (void*)soap_instantiate_tt__ImagingSettingsExtension20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__WideDynamicRange20:
		return (void*)soap_instantiate_tt__WideDynamicRange20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__BacklightCompensation20:
		return (void*)soap_instantiate_tt__BacklightCompensation20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Exposure20:
		return (void*)soap_instantiate_tt__Exposure20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingOptions20:
		return (void*)soap_instantiate_tt__ImagingOptions20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingOptions20Extension:
		return (void*)soap_instantiate_tt__ImagingOptions20Extension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__WideDynamicRangeOptions20:
		return (void*)soap_instantiate_tt__WideDynamicRangeOptions20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__BacklightCompensationOptions20:
		return (void*)soap_instantiate_tt__BacklightCompensationOptions20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ExposureOptions20:
		return (void*)soap_instantiate_tt__ExposureOptions20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__MoveOptions20:
		return (void*)soap_instantiate_tt__MoveOptions20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__RelativeFocusOptions20:
		return (void*)soap_instantiate_tt__RelativeFocusOptions20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__WhiteBalance20:
		return (void*)soap_instantiate_tt__WhiteBalance20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__WhiteBalance20Extension:
		return (void*)soap_instantiate_tt__WhiteBalance20Extension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__FocusConfiguration20:
		return (void*)soap_instantiate_tt__FocusConfiguration20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__FocusConfiguration20Extension:
		return (void*)soap_instantiate_tt__FocusConfiguration20Extension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__WhiteBalanceOptions20:
		return (void*)soap_instantiate_tt__WhiteBalanceOptions20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__WhiteBalanceOptions20Extension:
		return (void*)soap_instantiate_tt__WhiteBalanceOptions20Extension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__FocusOptions20:
		return (void*)soap_instantiate_tt__FocusOptions20(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__FocusOptions20Extension:
		return (void*)soap_instantiate_tt__FocusOptions20Extension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__MessageExtension:
		return (void*)soap_instantiate_tt__MessageExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tt__ItemList_SimpleItem:
		return (void*)soap_instantiate__tt__ItemList_SimpleItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tt__ItemList_ElementItem:
		return (void*)soap_instantiate__tt__ItemList_ElementItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ItemList:
		return (void*)soap_instantiate_tt__ItemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ItemListExtension:
		return (void*)soap_instantiate_tt__ItemListExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__MessageDescription:
		return (void*)soap_instantiate_tt__MessageDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__MessageDescriptionExtension:
		return (void*)soap_instantiate_tt__MessageDescriptionExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription:
		return (void*)soap_instantiate__tt__ItemListDescription_SimpleItemDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tt__ItemListDescription_ElementItemDescription:
		return (void*)soap_instantiate__tt__ItemListDescription_ElementItemDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ItemListDescription:
		return (void*)soap_instantiate_tt__ItemListDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ItemListDescriptionExtension:
		return (void*)soap_instantiate_tt__ItemListDescriptionExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Vector:
		return (void*)soap_instantiate_tt__Vector(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Rectangle:
		return (void*)soap_instantiate_tt__Rectangle(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Polygon:
		return (void*)soap_instantiate_tt__Polygon(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Polyline:
		return (void*)soap_instantiate_tt__Polyline(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Color:
		return (void*)soap_instantiate_tt__Color(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ColorCovariance:
		return (void*)soap_instantiate_tt__ColorCovariance(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Appearance:
		return (void*)soap_instantiate_tt__Appearance(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AppearanceExtension:
		return (void*)soap_instantiate_tt__AppearanceExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ShapeDescriptor:
		return (void*)soap_instantiate_tt__ShapeDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ShapeDescriptorExtension:
		return (void*)soap_instantiate_tt__ShapeDescriptorExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tt__ColorDescriptor_ColorCluster:
		return (void*)soap_instantiate__tt__ColorDescriptor_ColorCluster(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ColorDescriptor:
		return (void*)soap_instantiate_tt__ColorDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ColorDescriptorExtension:
		return (void*)soap_instantiate_tt__ColorDescriptorExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tt__ClassDescriptor_ClassCandidate:
		return (void*)soap_instantiate__tt__ClassDescriptor_ClassCandidate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ClassDescriptor:
		return (void*)soap_instantiate_tt__ClassDescriptor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ClassDescriptorExtension:
		return (void*)soap_instantiate_tt__ClassDescriptorExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ObjectExtension:
		return (void*)soap_instantiate_tt__ObjectExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Transformation:
		return (void*)soap_instantiate_tt__Transformation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__TransformationExtension:
		return (void*)soap_instantiate_tt__TransformationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Frame:
		return (void*)soap_instantiate_tt__Frame(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__FrameExtension:
		return (void*)soap_instantiate_tt__FrameExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Merge:
		return (void*)soap_instantiate_tt__Merge(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Split:
		return (void*)soap_instantiate_tt__Split(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Rename:
		return (void*)soap_instantiate_tt__Rename(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ObjectId:
		return (void*)soap_instantiate_tt__ObjectId(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tt__Behaviour_Removed:
		return (void*)soap_instantiate__tt__Behaviour_Removed(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tt__Behaviour_Idle:
		return (void*)soap_instantiate__tt__Behaviour_Idle(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Behaviour:
		return (void*)soap_instantiate_tt__Behaviour(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__BehaviourExtension:
		return (void*)soap_instantiate_tt__BehaviourExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ObjectTree:
		return (void*)soap_instantiate_tt__ObjectTree(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ObjectTreeExtension:
		return (void*)soap_instantiate_tt__ObjectTreeExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AnalyticsEngineConfiguration:
		return (void*)soap_instantiate_tt__AnalyticsEngineConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension:
		return (void*)soap_instantiate_tt__AnalyticsEngineConfigurationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__RuleEngineConfiguration:
		return (void*)soap_instantiate_tt__RuleEngineConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__RuleEngineConfigurationExtension:
		return (void*)soap_instantiate_tt__RuleEngineConfigurationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Config:
		return (void*)soap_instantiate_tt__Config(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tt__ConfigDescription_Messages:
		return (void*)soap_instantiate__tt__ConfigDescription_Messages(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ConfigDescription:
		return (void*)soap_instantiate_tt__ConfigDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ConfigDescriptionExtension:
		return (void*)soap_instantiate_tt__ConfigDescriptionExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SupportedRules:
		return (void*)soap_instantiate_tt__SupportedRules(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SupportedRulesExtension:
		return (void*)soap_instantiate_tt__SupportedRulesExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SupportedAnalyticsModules:
		return (void*)soap_instantiate_tt__SupportedAnalyticsModules(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SupportedAnalyticsModulesExtension:
		return (void*)soap_instantiate_tt__SupportedAnalyticsModulesExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tt__union_MetadataStream:
		return (void*)soap_instantiate___tt__union_MetadataStream(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__MetadataStream:
		return (void*)soap_instantiate_tt__MetadataStream(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__MetadataStreamExtension:
		return (void*)soap_instantiate_tt__MetadataStreamExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tt__union_VideoAnalyticsStream:
		return (void*)soap_instantiate___tt__union_VideoAnalyticsStream(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__VideoAnalyticsStream:
		return (void*)soap_instantiate_tt__VideoAnalyticsStream(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__VideoAnalyticsStreamExtension:
		return (void*)soap_instantiate_tt__VideoAnalyticsStreamExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tt__union_PTZStream:
		return (void*)soap_instantiate___tt__union_PTZStream(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZStream:
		return (void*)soap_instantiate_tt__PTZStream(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZStreamExtension:
		return (void*)soap_instantiate_tt__PTZStreamExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tt__union_EventStream:
		return (void*)soap_instantiate___tt__union_EventStream(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__EventStream:
		return (void*)soap_instantiate_tt__EventStream(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__EventStreamExtension:
		return (void*)soap_instantiate_tt__EventStreamExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tt__Message:
		return (void*)soap_instantiate__tt__Message(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__QueryExpressionType:
		return (void*)soap_instantiate_wsnb__QueryExpressionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__TopicExpressionType:
		return (void*)soap_instantiate_wsnb__TopicExpressionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__FilterType:
		return (void*)soap_instantiate_wsnb__FilterType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__SubscriptionPolicyType:
		return (void*)soap_instantiate_wsnb__SubscriptionPolicyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__NotificationMessageHolderType_Message:
		return (void*)soap_instantiate__wsnb__NotificationMessageHolderType_Message(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__NotificationMessageHolderType:
		return (void*)soap_instantiate_wsnb__NotificationMessageHolderType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__NotificationProducerRP:
		return (void*)soap_instantiate__wsnb__NotificationProducerRP(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__SubscriptionManagerRP:
		return (void*)soap_instantiate__wsnb__SubscriptionManagerRP(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__Notify:
		return (void*)soap_instantiate__wsnb__Notify(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__UseRaw:
		return (void*)soap_instantiate__wsnb__UseRaw(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__Subscribe_SubscriptionPolicy:
		return (void*)soap_instantiate__wsnb__Subscribe_SubscriptionPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__Subscribe:
		return (void*)soap_instantiate__wsnb__Subscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__SubscribeResponse:
		return (void*)soap_instantiate__wsnb__SubscribeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__GetCurrentMessage:
		return (void*)soap_instantiate__wsnb__GetCurrentMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__GetCurrentMessageResponse:
		return (void*)soap_instantiate__wsnb__GetCurrentMessageResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__GetMessages:
		return (void*)soap_instantiate__wsnb__GetMessages(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__GetMessagesResponse:
		return (void*)soap_instantiate__wsnb__GetMessagesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__DestroyPullPoint:
		return (void*)soap_instantiate__wsnb__DestroyPullPoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__DestroyPullPointResponse:
		return (void*)soap_instantiate__wsnb__DestroyPullPointResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__CreatePullPoint:
		return (void*)soap_instantiate__wsnb__CreatePullPoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__CreatePullPointResponse:
		return (void*)soap_instantiate__wsnb__CreatePullPointResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__Renew:
		return (void*)soap_instantiate__wsnb__Renew(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__RenewResponse:
		return (void*)soap_instantiate__wsnb__RenewResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__Unsubscribe:
		return (void*)soap_instantiate__wsnb__Unsubscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__UnsubscribeResponse:
		return (void*)soap_instantiate__wsnb__UnsubscribeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__PauseSubscription:
		return (void*)soap_instantiate__wsnb__PauseSubscription(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__PauseSubscriptionResponse:
		return (void*)soap_instantiate__wsnb__PauseSubscriptionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__ResumeSubscription:
		return (void*)soap_instantiate__wsnb__ResumeSubscription(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsnb__ResumeSubscriptionResponse:
		return (void*)soap_instantiate__wsnb__ResumeSubscriptionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode:
		return (void*)soap_instantiate__wsrfbf__BaseFaultType_ErrorCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrfbf__BaseFaultType_Description:
		return (void*)soap_instantiate__wsrfbf__BaseFaultType_Description(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause:
		return (void*)soap_instantiate__wsrfbf__BaseFaultType_FaultCause(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		return (void*)soap_instantiate_wsrfbf__BaseFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__Documentation:
		return (void*)soap_instantiate_wstop__Documentation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		return (void*)soap_instantiate_wstop__ExtensibleDocumented(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__QueryExpressionType:
		return (void*)soap_instantiate_wstop__QueryExpressionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__VideoSource:
		return (void*)soap_instantiate_tt__VideoSource(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AudioSource:
		return (void*)soap_instantiate_tt__AudioSource(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__VideoSourceConfiguration:
		return (void*)soap_instantiate_tt__VideoSourceConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__VideoEncoderConfiguration:
		return (void*)soap_instantiate_tt__VideoEncoderConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AudioSourceConfiguration:
		return (void*)soap_instantiate_tt__AudioSourceConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AudioEncoderConfiguration:
		return (void*)soap_instantiate_tt__AudioEncoderConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__VideoAnalyticsConfiguration:
		return (void*)soap_instantiate_tt__VideoAnalyticsConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__MetadataConfiguration:
		return (void*)soap_instantiate_tt__MetadataConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkInterface:
		return (void*)soap_instantiate_tt__NetworkInterface(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__RelayOutput:
		return (void*)soap_instantiate_tt__RelayOutput(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZNode:
		return (void*)soap_instantiate_tt__PTZNode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZConfiguration:
		return (void*)soap_instantiate_tt__PTZConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Object:
		return (void*)soap_instantiate_tt__Object(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__SubscribeCreationFailedFaultType:
		return (void*)soap_instantiate_wsnb__SubscribeCreationFailedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__InvalidFilterFaultType:
		return (void*)soap_instantiate_wsnb__InvalidFilterFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__TopicExpressionDialectUnknownFaultType:
		return (void*)soap_instantiate_wsnb__TopicExpressionDialectUnknownFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__InvalidTopicExpressionFaultType:
		return (void*)soap_instantiate_wsnb__InvalidTopicExpressionFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__TopicNotSupportedFaultType:
		return (void*)soap_instantiate_wsnb__TopicNotSupportedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__MultipleTopicsSpecifiedFaultType:
		return (void*)soap_instantiate_wsnb__MultipleTopicsSpecifiedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__InvalidProducerPropertiesExpressionFaultType:
		return (void*)soap_instantiate_wsnb__InvalidProducerPropertiesExpressionFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__InvalidMessageContentExpressionFaultType:
		return (void*)soap_instantiate_wsnb__InvalidMessageContentExpressionFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__UnrecognizedPolicyRequestFaultType:
		return (void*)soap_instantiate_wsnb__UnrecognizedPolicyRequestFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__UnsupportedPolicyRequestFaultType:
		return (void*)soap_instantiate_wsnb__UnsupportedPolicyRequestFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__NotifyMessageNotSupportedFaultType:
		return (void*)soap_instantiate_wsnb__NotifyMessageNotSupportedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__UnacceptableInitialTerminationTimeFaultType:
		return (void*)soap_instantiate_wsnb__UnacceptableInitialTerminationTimeFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__NoCurrentMessageOnTopicFaultType:
		return (void*)soap_instantiate_wsnb__NoCurrentMessageOnTopicFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__UnableToGetMessagesFaultType:
		return (void*)soap_instantiate_wsnb__UnableToGetMessagesFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__UnableToDestroyPullPointFaultType:
		return (void*)soap_instantiate_wsnb__UnableToDestroyPullPointFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__UnableToCreatePullPointFaultType:
		return (void*)soap_instantiate_wsnb__UnableToCreatePullPointFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__UnacceptableTerminationTimeFaultType:
		return (void*)soap_instantiate_wsnb__UnacceptableTerminationTimeFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__UnableToDestroySubscriptionFaultType:
		return (void*)soap_instantiate_wsnb__UnableToDestroySubscriptionFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__PauseFailedFaultType:
		return (void*)soap_instantiate_wsnb__PauseFailedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__ResumeFailedFaultType:
		return (void*)soap_instantiate_wsnb__ResumeFailedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wstop__TopicNamespaceType_Topic:
		return (void*)soap_instantiate__wstop__TopicNamespaceType_Topic(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__TopicNamespaceType:
		return (void*)soap_instantiate_wstop__TopicNamespaceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__TopicType:
		return (void*)soap_instantiate_wstop__TopicType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__TopicSetType:
		return (void*)soap_instantiate_wstop__TopicSetType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetSupportedRules:
		return (void*)soap_instantiate___ns1__GetSupportedRules(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CreateRules:
		return (void*)soap_instantiate___ns1__CreateRules(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DeleteRules:
		return (void*)soap_instantiate___ns1__DeleteRules(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetRules:
		return (void*)soap_instantiate___ns1__GetRules(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ModifyRules:
		return (void*)soap_instantiate___ns1__ModifyRules(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetSupportedAnalyticsModules:
		return (void*)soap_instantiate___ns2__GetSupportedAnalyticsModules(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__CreateAnalyticsModules:
		return (void*)soap_instantiate___ns2__CreateAnalyticsModules(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__DeleteAnalyticsModules:
		return (void*)soap_instantiate___ns2__DeleteAnalyticsModules(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetAnalyticsModules:
		return (void*)soap_instantiate___ns2__GetAnalyticsModules(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__ModifyAnalyticsModules:
		return (void*)soap_instantiate___ns2__ModifyAnalyticsModules(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyAttribute:
		return (void*)soap_instantiate_xsd__anyAttribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__EndpointReference:
		return (void*)soap_instantiate__wsa5__EndpointReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ReferenceParameters:
		return (void*)soap_instantiate__wsa5__ReferenceParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__Metadata:
		return (void*)soap_instantiate__wsa5__Metadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__RelatesTo:
		return (void*)soap_instantiate__wsa5__RelatesTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ReplyTo:
		return (void*)soap_instantiate__wsa5__ReplyTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__From:
		return (void*)soap_instantiate__wsa5__From(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__FaultTo:
		return (void*)soap_instantiate__wsa5__FaultTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ProblemAction:
		return (void*)soap_instantiate__wsa5__ProblemAction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__NCName:
		return (void*)soap_instantiate_xsd__NCName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__QName:
		return (void*)soap_instantiate_xsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anySimpleType:
		return (void*)soap_instantiate_xsd__anySimpleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__integer:
		return (void*)soap_instantiate_xsd__integer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return (void*)soap_instantiate_xsd__nonNegativeInteger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__token:
		return (void*)soap_instantiate_xsd__token(soap, -1, type, arrayType, n);
	case SOAP_TYPE__xml__lang:
		return (void*)soap_instantiate__xml__lang(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsnb__AbsoluteOrRelativeTimeType:
		return (void*)soap_instantiate_wsnb__AbsoluteOrRelativeTimeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ReferenceToken:
		return (void*)soap_instantiate_tt__ReferenceToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Name:
		return (void*)soap_instantiate_tt__Name(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPv4Address:
		return (void*)soap_instantiate_tt__IPv4Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPv6Address:
		return (void*)soap_instantiate_tt__IPv6Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__HwAddress:
		return (void*)soap_instantiate_tt__HwAddress(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DNSName:
		return (void*)soap_instantiate_tt__DNSName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Domain:
		return (void*)soap_instantiate_tt__Domain(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AuxiliaryData:
		return (void*)soap_instantiate_tt__AuxiliaryData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__TopicNamespaceLocation:
		return (void*)soap_instantiate_tt__TopicNamespaceLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__FullTopicExpression:
		return (void*)soap_instantiate_wstop__FullTopicExpression(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
		return (void*)soap_instantiate_wstop__ConcreteTopicExpression(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wstop__SimpleTopicExpression:
		return (void*)soap_instantiate_wstop__SimpleTopicExpression(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTowstop__TopicType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData:
		return (void*)soap_instantiate_std__vectorTemplateOftt__AuxiliaryData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsnb__NotificationMessageHolderType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTowsnb__NotificationMessageHolderType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsnb__TopicExpressionType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTowsnb__TopicExpressionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__ConfigDescription:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__ConfigDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyURI:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Merge:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__Merge(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Split:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__Split(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Rename:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__Rename(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__ObjectId:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__ObjectId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Object:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__Object(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Polygon:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__Polygon(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__Vector(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode:
		return (void*)soap_instantiate_std__vectorTemplateOftt__BacklightCompensationMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode:
		return (void*)soap_instantiate_std__vectorTemplateOftt__WhiteBalanceMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority:
		return (void*)soap_instantiate_std__vectorTemplateOftt__ExposurePriority(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__ExposureMode:
		return (void*)soap_instantiate_std__vectorTemplateOftt__ExposureMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode:
		return (void*)soap_instantiate_std__vectorTemplateOftt__AutoFocusMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode:
		return (void*)soap_instantiate_std__vectorTemplateOftt__WideDynamicMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode:
		return (void*)soap_instantiate_std__vectorTemplateOftt__IrCutFilterMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Space1DDescription:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__Space1DDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Space2DDescription:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__Space2DDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__OnvifVersion:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__OnvifVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__IPv6Address:
		return (void*)soap_instantiate_std__vectorTemplateOftt__IPv6Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__IPv4Address:
		return (void*)soap_instantiate_std__vectorTemplateOftt__IPv4Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkHost:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__NetworkHost(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__IPAddress:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__IPAddress(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__token:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__token(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv6Address:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv4Address:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__H264Profile:
		return (void*)soap_instantiate_std__vectorTemplateOftt__H264Profile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__Mpeg4Profile:
		return (void*)soap_instantiate_std__vectorTemplateOftt__Mpeg4Profile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoResolution:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__VideoResolution(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken:
		return (void*)soap_instantiate_std__vectorTemplateOftt__ReferenceToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyType:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfint:
		return (void*)soap_instantiate_std__vectorTemplateOfint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Config:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__Config(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE__xop__Include:
		if (p->size < 0)
			SOAP_DELETE((struct _xop__Include*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _xop__Include*)p->ptr);
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__EndpointReferenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__EndpointReferenceType*)p->ptr);
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__ReferenceParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__ReferenceParametersType*)p->ptr);
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__MetadataType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__MetadataType*)p->ptr);
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__ProblemActionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__ProblemActionType*)p->ptr);
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__RelatesToType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__RelatesToType*)p->ptr);
		break;
	case SOAP_TYPE__wsu__Timestamp:
		if (p->size < 0)
			SOAP_DELETE((struct _wsu__Timestamp*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsu__Timestamp*)p->ptr);
		break;
	case SOAP_TYPE__wsse__UsernameToken:
		if (p->size < 0)
			SOAP_DELETE((struct _wsse__UsernameToken*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsse__UsernameToken*)p->ptr);
		break;
	case SOAP_TYPE__wsse__BinarySecurityToken:
		if (p->size < 0)
			SOAP_DELETE((struct _wsse__BinarySecurityToken*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsse__BinarySecurityToken*)p->ptr);
		break;
	case SOAP_TYPE__wsse__Reference:
		if (p->size < 0)
			SOAP_DELETE((struct _wsse__Reference*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsse__Reference*)p->ptr);
		break;
	case SOAP_TYPE__wsse__Embedded:
		if (p->size < 0)
			SOAP_DELETE((struct _wsse__Embedded*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsse__Embedded*)p->ptr);
		break;
	case SOAP_TYPE__wsse__KeyIdentifier:
		if (p->size < 0)
			SOAP_DELETE((struct _wsse__KeyIdentifier*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsse__KeyIdentifier*)p->ptr);
		break;
	case SOAP_TYPE__wsse__SecurityTokenReference:
		if (p->size < 0)
			SOAP_DELETE((struct _wsse__SecurityTokenReference*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsse__SecurityTokenReference*)p->ptr);
		break;
	case SOAP_TYPE_ds__SignatureType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__SignatureType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__SignatureType*)p->ptr);
		break;
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		if (p->size < 0)
			SOAP_DELETE((struct _c14n__InclusiveNamespaces*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _c14n__InclusiveNamespaces*)p->ptr);
		break;
	case SOAP_TYPE_ds__TransformType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__TransformType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__TransformType*)p->ptr);
		break;
	case SOAP_TYPE_ds__KeyInfoType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__KeyInfoType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__KeyInfoType*)p->ptr);
		break;
	case SOAP_TYPE_ds__SignedInfoType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__SignedInfoType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__SignedInfoType*)p->ptr);
		break;
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__CanonicalizationMethodType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__CanonicalizationMethodType*)p->ptr);
		break;
	case SOAP_TYPE_ds__SignatureMethodType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__SignatureMethodType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__SignatureMethodType*)p->ptr);
		break;
	case SOAP_TYPE_ds__ReferenceType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__ReferenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__ReferenceType*)p->ptr);
		break;
	case SOAP_TYPE_ds__TransformsType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__TransformsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__TransformsType*)p->ptr);
		break;
	case SOAP_TYPE_ds__DigestMethodType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__DigestMethodType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__DigestMethodType*)p->ptr);
		break;
	case SOAP_TYPE_ds__KeyValueType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__KeyValueType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__KeyValueType*)p->ptr);
		break;
	case SOAP_TYPE_ds__RetrievalMethodType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__RetrievalMethodType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__RetrievalMethodType*)p->ptr);
		break;
	case SOAP_TYPE_ds__X509DataType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__X509DataType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__X509DataType*)p->ptr);
		break;
	case SOAP_TYPE_ds__X509IssuerSerialType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__X509IssuerSerialType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__X509IssuerSerialType*)p->ptr);
		break;
	case SOAP_TYPE_ds__DSAKeyValueType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__DSAKeyValueType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__DSAKeyValueType*)p->ptr);
		break;
	case SOAP_TYPE_ds__RSAKeyValueType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__RSAKeyValueType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__RSAKeyValueType*)p->ptr);
		break;
	case SOAP_TYPE__wsse__Security:
		if (p->size < 0)
			SOAP_DELETE((struct _wsse__Security*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsse__Security*)p->ptr);
		break;
	case SOAP_TYPE__wsse__Password:
		if (p->size < 0)
			SOAP_DELETE((struct _wsse__Password*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsse__Password*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			SOAP_DELETE((xsd__base64Binary*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__base64Binary*)p->ptr);
		break;
	case SOAP_TYPE__tan__GetSupportedRules:
		if (p->size < 0)
			SOAP_DELETE((_tan__GetSupportedRules*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tan__GetSupportedRules*)p->ptr);
		break;
	case SOAP_TYPE__tan__GetSupportedRulesResponse:
		if (p->size < 0)
			SOAP_DELETE((_tan__GetSupportedRulesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tan__GetSupportedRulesResponse*)p->ptr);
		break;
	case SOAP_TYPE__tan__CreateRules:
		if (p->size < 0)
			SOAP_DELETE((_tan__CreateRules*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tan__CreateRules*)p->ptr);
		break;
	case SOAP_TYPE__tan__CreateRulesResponse:
		if (p->size < 0)
			SOAP_DELETE((_tan__CreateRulesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tan__CreateRulesResponse*)p->ptr);
		break;
	case SOAP_TYPE__tan__DeleteRules:
		if (p->size < 0)
			SOAP_DELETE((_tan__DeleteRules*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tan__DeleteRules*)p->ptr);
		break;
	case SOAP_TYPE__tan__DeleteRulesResponse:
		if (p->size < 0)
			SOAP_DELETE((_tan__DeleteRulesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tan__DeleteRulesResponse*)p->ptr);
		break;
	case SOAP_TYPE__tan__ModifyRules:
		if (p->size < 0)
			SOAP_DELETE((_tan__ModifyRules*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tan__ModifyRules*)p->ptr);
		break;
	case SOAP_TYPE__tan__ModifyRulesResponse:
		if (p->size < 0)
			SOAP_DELETE((_tan__ModifyRulesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tan__ModifyRulesResponse*)p->ptr);
		break;
	case SOAP_TYPE__tan__GetRules:
		if (p->size < 0)
			SOAP_DELETE((_tan__GetRules*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tan__GetRules*)p->ptr);
		break;
	case SOAP_TYPE__tan__GetRulesResponse:
		if (p->size < 0)
			SOAP_DELETE((_tan__GetRulesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tan__GetRulesResponse*)p->ptr);
		break;
	case SOAP_TYPE__tan__GetSupportedAnalyticsModules:
		if (p->size < 0)
			SOAP_DELETE((_tan__GetSupportedAnalyticsModules*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tan__GetSupportedAnalyticsModules*)p->ptr);
		break;
	case SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse:
		if (p->size < 0)
			SOAP_DELETE((_tan__GetSupportedAnalyticsModulesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tan__GetSupportedAnalyticsModulesResponse*)p->ptr);
		break;
	case SOAP_TYPE__tan__CreateAnalyticsModules:
		if (p->size < 0)
			SOAP_DELETE((_tan__CreateAnalyticsModules*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tan__CreateAnalyticsModules*)p->ptr);
		break;
	case SOAP_TYPE__tan__CreateAnalyticsModulesResponse:
		if (p->size < 0)
			SOAP_DELETE((_tan__CreateAnalyticsModulesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tan__CreateAnalyticsModulesResponse*)p->ptr);
		break;
	case SOAP_TYPE__tan__DeleteAnalyticsModules:
		if (p->size < 0)
			SOAP_DELETE((_tan__DeleteAnalyticsModules*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tan__DeleteAnalyticsModules*)p->ptr);
		break;
	case SOAP_TYPE__tan__DeleteAnalyticsModulesResponse:
		if (p->size < 0)
			SOAP_DELETE((_tan__DeleteAnalyticsModulesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tan__DeleteAnalyticsModulesResponse*)p->ptr);
		break;
	case SOAP_TYPE__tan__ModifyAnalyticsModules:
		if (p->size < 0)
			SOAP_DELETE((_tan__ModifyAnalyticsModules*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tan__ModifyAnalyticsModules*)p->ptr);
		break;
	case SOAP_TYPE__tan__ModifyAnalyticsModulesResponse:
		if (p->size < 0)
			SOAP_DELETE((_tan__ModifyAnalyticsModulesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tan__ModifyAnalyticsModulesResponse*)p->ptr);
		break;
	case SOAP_TYPE__tan__GetAnalyticsModules:
		if (p->size < 0)
			SOAP_DELETE((_tan__GetAnalyticsModules*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tan__GetAnalyticsModules*)p->ptr);
		break;
	case SOAP_TYPE__tan__GetAnalyticsModulesResponse:
		if (p->size < 0)
			SOAP_DELETE((_tan__GetAnalyticsModulesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tan__GetAnalyticsModulesResponse*)p->ptr);
		break;
	case SOAP_TYPE_tt__DeviceEntity:
		if (p->size < 0)
			SOAP_DELETE((tt__DeviceEntity*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__DeviceEntity*)p->ptr);
		break;
	case SOAP_TYPE_tt__IntRectangle:
		if (p->size < 0)
			SOAP_DELETE((tt__IntRectangle*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__IntRectangle*)p->ptr);
		break;
	case SOAP_TYPE_tt__IntRectangleRange:
		if (p->size < 0)
			SOAP_DELETE((tt__IntRectangleRange*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__IntRectangleRange*)p->ptr);
		break;
	case SOAP_TYPE_tt__IntRange:
		if (p->size < 0)
			SOAP_DELETE((tt__IntRange*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__IntRange*)p->ptr);
		break;
	case SOAP_TYPE_tt__FloatRange:
		if (p->size < 0)
			SOAP_DELETE((tt__FloatRange*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__FloatRange*)p->ptr);
		break;
	case SOAP_TYPE_tt__DurationRange:
		if (p->size < 0)
			SOAP_DELETE((tt__DurationRange*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__DurationRange*)p->ptr);
		break;
	case SOAP_TYPE_tt__IntList:
		if (p->size < 0)
			SOAP_DELETE((tt__IntList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__IntList*)p->ptr);
		break;
	case SOAP_TYPE_tt__VideoSourceExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__VideoSourceExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__VideoSourceExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__Profile:
		if (p->size < 0)
			SOAP_DELETE((tt__Profile*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Profile*)p->ptr);
		break;
	case SOAP_TYPE_tt__ProfileExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__ProfileExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ProfileExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__ConfigurationEntity:
		if (p->size < 0)
			SOAP_DELETE((tt__ConfigurationEntity*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ConfigurationEntity*)p->ptr);
		break;
	case SOAP_TYPE_tt__VideoSourceConfigurationOptions:
		if (p->size < 0)
			SOAP_DELETE((tt__VideoSourceConfigurationOptions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__VideoSourceConfigurationOptions*)p->ptr);
		break;
	case SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__VideoSourceConfigurationOptionsExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__VideoSourceConfigurationOptionsExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__VideoResolution:
		if (p->size < 0)
			SOAP_DELETE((tt__VideoResolution*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__VideoResolution*)p->ptr);
		break;
	case SOAP_TYPE_tt__VideoRateControl:
		if (p->size < 0)
			SOAP_DELETE((tt__VideoRateControl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__VideoRateControl*)p->ptr);
		break;
	case SOAP_TYPE_tt__Mpeg4Configuration:
		if (p->size < 0)
			SOAP_DELETE((tt__Mpeg4Configuration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Mpeg4Configuration*)p->ptr);
		break;
	case SOAP_TYPE_tt__H264Configuration:
		if (p->size < 0)
			SOAP_DELETE((tt__H264Configuration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__H264Configuration*)p->ptr);
		break;
	case SOAP_TYPE_tt__VideoEncoderConfigurationOptions:
		if (p->size < 0)
			SOAP_DELETE((tt__VideoEncoderConfigurationOptions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__VideoEncoderConfigurationOptions*)p->ptr);
		break;
	case SOAP_TYPE_tt__VideoEncoderOptionsExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__VideoEncoderOptionsExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__VideoEncoderOptionsExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__JpegOptions:
		if (p->size < 0)
			SOAP_DELETE((tt__JpegOptions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__JpegOptions*)p->ptr);
		break;
	case SOAP_TYPE_tt__Mpeg4Options:
		if (p->size < 0)
			SOAP_DELETE((tt__Mpeg4Options*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Mpeg4Options*)p->ptr);
		break;
	case SOAP_TYPE_tt__H264Options:
		if (p->size < 0)
			SOAP_DELETE((tt__H264Options*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__H264Options*)p->ptr);
		break;
	case SOAP_TYPE_tt__AudioSourceConfigurationOptions:
		if (p->size < 0)
			SOAP_DELETE((tt__AudioSourceConfigurationOptions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__AudioSourceConfigurationOptions*)p->ptr);
		break;
	case SOAP_TYPE_tt__AudioSourceOptionsExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__AudioSourceOptionsExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__AudioSourceOptionsExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__AudioEncoderConfigurationOptions:
		if (p->size < 0)
			SOAP_DELETE((tt__AudioEncoderConfigurationOptions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__AudioEncoderConfigurationOptions*)p->ptr);
		break;
	case SOAP_TYPE_tt__AudioEncoderConfigurationOption:
		if (p->size < 0)
			SOAP_DELETE((tt__AudioEncoderConfigurationOption*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__AudioEncoderConfigurationOption*)p->ptr);
		break;
	case SOAP_TYPE_tt__PTZFilter:
		if (p->size < 0)
			SOAP_DELETE((tt__PTZFilter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__PTZFilter*)p->ptr);
		break;
	case SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy:
		if (p->size < 0)
			SOAP_DELETE((_tt__EventSubscription_SubscriptionPolicy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tt__EventSubscription_SubscriptionPolicy*)p->ptr);
		break;
	case SOAP_TYPE_tt__EventSubscription:
		if (p->size < 0)
			SOAP_DELETE((tt__EventSubscription*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__EventSubscription*)p->ptr);
		break;
	case SOAP_TYPE_tt__MetadataConfigurationOptions:
		if (p->size < 0)
			SOAP_DELETE((tt__MetadataConfigurationOptions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__MetadataConfigurationOptions*)p->ptr);
		break;
	case SOAP_TYPE_tt__PTZStatusFilterOptions:
		if (p->size < 0)
			SOAP_DELETE((tt__PTZStatusFilterOptions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__PTZStatusFilterOptions*)p->ptr);
		break;
	case SOAP_TYPE_tt__MulticastConfiguration:
		if (p->size < 0)
			SOAP_DELETE((tt__MulticastConfiguration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__MulticastConfiguration*)p->ptr);
		break;
	case SOAP_TYPE_tt__StreamSetup:
		if (p->size < 0)
			SOAP_DELETE((tt__StreamSetup*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__StreamSetup*)p->ptr);
		break;
	case SOAP_TYPE_tt__Transport:
		if (p->size < 0)
			SOAP_DELETE((tt__Transport*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Transport*)p->ptr);
		break;
	case SOAP_TYPE_tt__MediaUri:
		if (p->size < 0)
			SOAP_DELETE((tt__MediaUri*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__MediaUri*)p->ptr);
		break;
	case SOAP_TYPE_tt__Scope:
		if (p->size < 0)
			SOAP_DELETE((tt__Scope*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Scope*)p->ptr);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__NetworkInterfaceExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__NetworkInterfaceExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceLink:
		if (p->size < 0)
			SOAP_DELETE((tt__NetworkInterfaceLink*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__NetworkInterfaceLink*)p->ptr);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceConnectionSetting:
		if (p->size < 0)
			SOAP_DELETE((tt__NetworkInterfaceConnectionSetting*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__NetworkInterfaceConnectionSetting*)p->ptr);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceInfo:
		if (p->size < 0)
			SOAP_DELETE((tt__NetworkInterfaceInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__NetworkInterfaceInfo*)p->ptr);
		break;
	case SOAP_TYPE_tt__IPv6NetworkInterface:
		if (p->size < 0)
			SOAP_DELETE((tt__IPv6NetworkInterface*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__IPv6NetworkInterface*)p->ptr);
		break;
	case SOAP_TYPE_tt__IPv4NetworkInterface:
		if (p->size < 0)
			SOAP_DELETE((tt__IPv4NetworkInterface*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__IPv4NetworkInterface*)p->ptr);
		break;
	case SOAP_TYPE_tt__IPv4Configuration:
		if (p->size < 0)
			SOAP_DELETE((tt__IPv4Configuration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__IPv4Configuration*)p->ptr);
		break;
	case SOAP_TYPE_tt__IPv6Configuration:
		if (p->size < 0)
			SOAP_DELETE((tt__IPv6Configuration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__IPv6Configuration*)p->ptr);
		break;
	case SOAP_TYPE_tt__IPv6ConfigurationExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__IPv6ConfigurationExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__IPv6ConfigurationExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__NetworkProtocol:
		if (p->size < 0)
			SOAP_DELETE((tt__NetworkProtocol*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__NetworkProtocol*)p->ptr);
		break;
	case SOAP_TYPE_tt__NetworkProtocolExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__NetworkProtocolExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__NetworkProtocolExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__NetworkHost:
		if (p->size < 0)
			SOAP_DELETE((tt__NetworkHost*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__NetworkHost*)p->ptr);
		break;
	case SOAP_TYPE_tt__NetworkHostExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__NetworkHostExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__NetworkHostExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__IPAddress:
		if (p->size < 0)
			SOAP_DELETE((tt__IPAddress*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__IPAddress*)p->ptr);
		break;
	case SOAP_TYPE_tt__PrefixedIPv4Address:
		if (p->size < 0)
			SOAP_DELETE((tt__PrefixedIPv4Address*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__PrefixedIPv4Address*)p->ptr);
		break;
	case SOAP_TYPE_tt__PrefixedIPv6Address:
		if (p->size < 0)
			SOAP_DELETE((tt__PrefixedIPv6Address*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__PrefixedIPv6Address*)p->ptr);
		break;
	case SOAP_TYPE_tt__HostnameInformation:
		if (p->size < 0)
			SOAP_DELETE((tt__HostnameInformation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__HostnameInformation*)p->ptr);
		break;
	case SOAP_TYPE_tt__HostnameInformationExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__HostnameInformationExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__HostnameInformationExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__DNSInformation:
		if (p->size < 0)
			SOAP_DELETE((tt__DNSInformation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__DNSInformation*)p->ptr);
		break;
	case SOAP_TYPE_tt__DNSInformationExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__DNSInformationExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__DNSInformationExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__NTPInformation:
		if (p->size < 0)
			SOAP_DELETE((tt__NTPInformation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__NTPInformation*)p->ptr);
		break;
	case SOAP_TYPE_tt__NTPInformationExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__NTPInformationExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__NTPInformationExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__DynamicDNSInformation:
		if (p->size < 0)
			SOAP_DELETE((tt__DynamicDNSInformation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__DynamicDNSInformation*)p->ptr);
		break;
	case SOAP_TYPE_tt__DynamicDNSInformationExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__DynamicDNSInformationExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__DynamicDNSInformationExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceSetConfiguration:
		if (p->size < 0)
			SOAP_DELETE((tt__NetworkInterfaceSetConfiguration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__NetworkInterfaceSetConfiguration*)p->ptr);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__NetworkInterfaceSetConfigurationExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__NetworkInterfaceSetConfigurationExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration:
		if (p->size < 0)
			SOAP_DELETE((tt__IPv6NetworkInterfaceSetConfiguration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__IPv6NetworkInterfaceSetConfiguration*)p->ptr);
		break;
	case SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration:
		if (p->size < 0)
			SOAP_DELETE((tt__IPv4NetworkInterfaceSetConfiguration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__IPv4NetworkInterfaceSetConfiguration*)p->ptr);
		break;
	case SOAP_TYPE_tt__NetworkGateway:
		if (p->size < 0)
			SOAP_DELETE((tt__NetworkGateway*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__NetworkGateway*)p->ptr);
		break;
	case SOAP_TYPE_tt__NetworkZeroConfiguration:
		if (p->size < 0)
			SOAP_DELETE((tt__NetworkZeroConfiguration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__NetworkZeroConfiguration*)p->ptr);
		break;
	case SOAP_TYPE_tt__NetworkZeroConfigurationExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__NetworkZeroConfigurationExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__NetworkZeroConfigurationExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__IPAddressFilter:
		if (p->size < 0)
			SOAP_DELETE((tt__IPAddressFilter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__IPAddressFilter*)p->ptr);
		break;
	case SOAP_TYPE_tt__IPAddressFilterExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__IPAddressFilterExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__IPAddressFilterExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__Capabilities:
		if (p->size < 0)
			SOAP_DELETE((tt__Capabilities*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Capabilities*)p->ptr);
		break;
	case SOAP_TYPE_tt__CapabilitiesExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__CapabilitiesExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__CapabilitiesExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__AnalyticsCapabilities:
		if (p->size < 0)
			SOAP_DELETE((tt__AnalyticsCapabilities*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__AnalyticsCapabilities*)p->ptr);
		break;
	case SOAP_TYPE_tt__DeviceCapabilities:
		if (p->size < 0)
			SOAP_DELETE((tt__DeviceCapabilities*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__DeviceCapabilities*)p->ptr);
		break;
	case SOAP_TYPE_tt__DeviceCapabilitiesExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__DeviceCapabilitiesExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__DeviceCapabilitiesExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__EventCapabilities:
		if (p->size < 0)
			SOAP_DELETE((tt__EventCapabilities*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__EventCapabilities*)p->ptr);
		break;
	case SOAP_TYPE_tt__IOCapabilities:
		if (p->size < 0)
			SOAP_DELETE((tt__IOCapabilities*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__IOCapabilities*)p->ptr);
		break;
	case SOAP_TYPE_tt__IOCapabilitiesExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__IOCapabilitiesExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__IOCapabilitiesExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__MediaCapabilities:
		if (p->size < 0)
			SOAP_DELETE((tt__MediaCapabilities*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__MediaCapabilities*)p->ptr);
		break;
	case SOAP_TYPE_tt__MediaCapabilitiesExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__MediaCapabilitiesExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__MediaCapabilitiesExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__RealTimeStreamingCapabilities:
		if (p->size < 0)
			SOAP_DELETE((tt__RealTimeStreamingCapabilities*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__RealTimeStreamingCapabilities*)p->ptr);
		break;
	case SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__RealTimeStreamingCapabilitiesExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__RealTimeStreamingCapabilitiesExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__ProfileCapabilities:
		if (p->size < 0)
			SOAP_DELETE((tt__ProfileCapabilities*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ProfileCapabilities*)p->ptr);
		break;
	case SOAP_TYPE_tt__NetworkCapabilities:
		if (p->size < 0)
			SOAP_DELETE((tt__NetworkCapabilities*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__NetworkCapabilities*)p->ptr);
		break;
	case SOAP_TYPE_tt__NetworkCapabilitiesExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__NetworkCapabilitiesExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__NetworkCapabilitiesExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__SecurityCapabilities:
		if (p->size < 0)
			SOAP_DELETE((tt__SecurityCapabilities*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__SecurityCapabilities*)p->ptr);
		break;
	case SOAP_TYPE_tt__SecurityCapabilitiesExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__SecurityCapabilitiesExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__SecurityCapabilitiesExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__StorageCapabilities:
		if (p->size < 0)
			SOAP_DELETE((tt__StorageCapabilities*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__StorageCapabilities*)p->ptr);
		break;
	case SOAP_TYPE_tt__SystemCapabilities:
		if (p->size < 0)
			SOAP_DELETE((tt__SystemCapabilities*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__SystemCapabilities*)p->ptr);
		break;
	case SOAP_TYPE_tt__SystemCapabilitiesExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__SystemCapabilitiesExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__SystemCapabilitiesExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__OnvifVersion:
		if (p->size < 0)
			SOAP_DELETE((tt__OnvifVersion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__OnvifVersion*)p->ptr);
		break;
	case SOAP_TYPE_tt__ImagingCapabilities:
		if (p->size < 0)
			SOAP_DELETE((tt__ImagingCapabilities*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ImagingCapabilities*)p->ptr);
		break;
	case SOAP_TYPE_tt__PTZCapabilities:
		if (p->size < 0)
			SOAP_DELETE((tt__PTZCapabilities*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__PTZCapabilities*)p->ptr);
		break;
	case SOAP_TYPE_tt__SystemLog:
		if (p->size < 0)
			SOAP_DELETE((tt__SystemLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__SystemLog*)p->ptr);
		break;
	case SOAP_TYPE_tt__SupportInformation:
		if (p->size < 0)
			SOAP_DELETE((tt__SupportInformation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__SupportInformation*)p->ptr);
		break;
	case SOAP_TYPE_tt__BinaryData:
		if (p->size < 0)
			SOAP_DELETE((tt__BinaryData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__BinaryData*)p->ptr);
		break;
	case SOAP_TYPE_tt__AttachmentData:
		if (p->size < 0)
			SOAP_DELETE((tt__AttachmentData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__AttachmentData*)p->ptr);
		break;
	case SOAP_TYPE_tt__BackupFile:
		if (p->size < 0)
			SOAP_DELETE((tt__BackupFile*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__BackupFile*)p->ptr);
		break;
	case SOAP_TYPE_tt__SystemDateTime:
		if (p->size < 0)
			SOAP_DELETE((tt__SystemDateTime*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__SystemDateTime*)p->ptr);
		break;
	case SOAP_TYPE_tt__SystemDateTimeExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__SystemDateTimeExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__SystemDateTimeExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__DateTime:
		if (p->size < 0)
			SOAP_DELETE((tt__DateTime*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__DateTime*)p->ptr);
		break;
	case SOAP_TYPE_tt__Date:
		if (p->size < 0)
			SOAP_DELETE((tt__Date*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Date*)p->ptr);
		break;
	case SOAP_TYPE_tt__Time:
		if (p->size < 0)
			SOAP_DELETE((tt__Time*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Time*)p->ptr);
		break;
	case SOAP_TYPE_tt__TimeZone:
		if (p->size < 0)
			SOAP_DELETE((tt__TimeZone*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__TimeZone*)p->ptr);
		break;
	case SOAP_TYPE_tt__User:
		if (p->size < 0)
			SOAP_DELETE((tt__User*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__User*)p->ptr);
		break;
	case SOAP_TYPE_tt__UserExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__UserExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__UserExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__CertificateGenerationParameters:
		if (p->size < 0)
			SOAP_DELETE((tt__CertificateGenerationParameters*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__CertificateGenerationParameters*)p->ptr);
		break;
	case SOAP_TYPE_tt__CertificateGenerationParametersExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__CertificateGenerationParametersExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__CertificateGenerationParametersExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__Certificate:
		if (p->size < 0)
			SOAP_DELETE((tt__Certificate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Certificate*)p->ptr);
		break;
	case SOAP_TYPE_tt__CertificateStatus:
		if (p->size < 0)
			SOAP_DELETE((tt__CertificateStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__CertificateStatus*)p->ptr);
		break;
	case SOAP_TYPE_tt__RelayOutputSettings:
		if (p->size < 0)
			SOAP_DELETE((tt__RelayOutputSettings*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__RelayOutputSettings*)p->ptr);
		break;
	case SOAP_TYPE_tt__PTZNodeExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__PTZNodeExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__PTZNodeExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__PTZConfigurationExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__PTZConfigurationExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__PTZConfigurationExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__PTZConfigurationOptions:
		if (p->size < 0)
			SOAP_DELETE((tt__PTZConfigurationOptions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__PTZConfigurationOptions*)p->ptr);
		break;
	case SOAP_TYPE_tt__PanTiltLimits:
		if (p->size < 0)
			SOAP_DELETE((tt__PanTiltLimits*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__PanTiltLimits*)p->ptr);
		break;
	case SOAP_TYPE_tt__ZoomLimits:
		if (p->size < 0)
			SOAP_DELETE((tt__ZoomLimits*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ZoomLimits*)p->ptr);
		break;
	case SOAP_TYPE_tt__PTZSpaces:
		if (p->size < 0)
			SOAP_DELETE((tt__PTZSpaces*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__PTZSpaces*)p->ptr);
		break;
	case SOAP_TYPE_tt__PTZSpacesExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__PTZSpacesExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__PTZSpacesExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__Space2DDescription:
		if (p->size < 0)
			SOAP_DELETE((tt__Space2DDescription*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Space2DDescription*)p->ptr);
		break;
	case SOAP_TYPE_tt__Space1DDescription:
		if (p->size < 0)
			SOAP_DELETE((tt__Space1DDescription*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Space1DDescription*)p->ptr);
		break;
	case SOAP_TYPE_tt__Vector2D:
		if (p->size < 0)
			SOAP_DELETE((tt__Vector2D*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Vector2D*)p->ptr);
		break;
	case SOAP_TYPE_tt__Vector1D:
		if (p->size < 0)
			SOAP_DELETE((tt__Vector1D*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Vector1D*)p->ptr);
		break;
	case SOAP_TYPE_tt__PTZVector:
		if (p->size < 0)
			SOAP_DELETE((tt__PTZVector*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__PTZVector*)p->ptr);
		break;
	case SOAP_TYPE_tt__PTZSpeed:
		if (p->size < 0)
			SOAP_DELETE((tt__PTZSpeed*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__PTZSpeed*)p->ptr);
		break;
	case SOAP_TYPE_tt__PTZStatus:
		if (p->size < 0)
			SOAP_DELETE((tt__PTZStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__PTZStatus*)p->ptr);
		break;
	case SOAP_TYPE_tt__PTZPreset:
		if (p->size < 0)
			SOAP_DELETE((tt__PTZPreset*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__PTZPreset*)p->ptr);
		break;
	case SOAP_TYPE_tt__PTZMoveStatus:
		if (p->size < 0)
			SOAP_DELETE((tt__PTZMoveStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__PTZMoveStatus*)p->ptr);
		break;
	case SOAP_TYPE_tt__ImagingStatus:
		if (p->size < 0)
			SOAP_DELETE((tt__ImagingStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ImagingStatus*)p->ptr);
		break;
	case SOAP_TYPE_tt__FocusStatus:
		if (p->size < 0)
			SOAP_DELETE((tt__FocusStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__FocusStatus*)p->ptr);
		break;
	case SOAP_TYPE_tt__FocusConfiguration:
		if (p->size < 0)
			SOAP_DELETE((tt__FocusConfiguration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__FocusConfiguration*)p->ptr);
		break;
	case SOAP_TYPE_tt__ImagingSettings:
		if (p->size < 0)
			SOAP_DELETE((tt__ImagingSettings*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ImagingSettings*)p->ptr);
		break;
	case SOAP_TYPE_tt__ImagingSettingsExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__ImagingSettingsExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ImagingSettingsExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__Exposure:
		if (p->size < 0)
			SOAP_DELETE((tt__Exposure*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Exposure*)p->ptr);
		break;
	case SOAP_TYPE_tt__WideDynamicRange:
		if (p->size < 0)
			SOAP_DELETE((tt__WideDynamicRange*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__WideDynamicRange*)p->ptr);
		break;
	case SOAP_TYPE_tt__BacklightCompensation:
		if (p->size < 0)
			SOAP_DELETE((tt__BacklightCompensation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__BacklightCompensation*)p->ptr);
		break;
	case SOAP_TYPE_tt__ImagingOptions:
		if (p->size < 0)
			SOAP_DELETE((tt__ImagingOptions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ImagingOptions*)p->ptr);
		break;
	case SOAP_TYPE_tt__WideDynamicRangeOptions:
		if (p->size < 0)
			SOAP_DELETE((tt__WideDynamicRangeOptions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__WideDynamicRangeOptions*)p->ptr);
		break;
	case SOAP_TYPE_tt__BacklightCompensationOptions:
		if (p->size < 0)
			SOAP_DELETE((tt__BacklightCompensationOptions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__BacklightCompensationOptions*)p->ptr);
		break;
	case SOAP_TYPE_tt__FocusOptions:
		if (p->size < 0)
			SOAP_DELETE((tt__FocusOptions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__FocusOptions*)p->ptr);
		break;
	case SOAP_TYPE_tt__ExposureOptions:
		if (p->size < 0)
			SOAP_DELETE((tt__ExposureOptions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ExposureOptions*)p->ptr);
		break;
	case SOAP_TYPE_tt__WhiteBalanceOptions:
		if (p->size < 0)
			SOAP_DELETE((tt__WhiteBalanceOptions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__WhiteBalanceOptions*)p->ptr);
		break;
	case SOAP_TYPE_tt__FocusMove:
		if (p->size < 0)
			SOAP_DELETE((tt__FocusMove*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__FocusMove*)p->ptr);
		break;
	case SOAP_TYPE_tt__AbsoluteFocus:
		if (p->size < 0)
			SOAP_DELETE((tt__AbsoluteFocus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__AbsoluteFocus*)p->ptr);
		break;
	case SOAP_TYPE_tt__RelativeFocus:
		if (p->size < 0)
			SOAP_DELETE((tt__RelativeFocus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__RelativeFocus*)p->ptr);
		break;
	case SOAP_TYPE_tt__ContinuousFocus:
		if (p->size < 0)
			SOAP_DELETE((tt__ContinuousFocus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ContinuousFocus*)p->ptr);
		break;
	case SOAP_TYPE_tt__MoveOptions:
		if (p->size < 0)
			SOAP_DELETE((tt__MoveOptions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__MoveOptions*)p->ptr);
		break;
	case SOAP_TYPE_tt__AbsoluteFocusOptions:
		if (p->size < 0)
			SOAP_DELETE((tt__AbsoluteFocusOptions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__AbsoluteFocusOptions*)p->ptr);
		break;
	case SOAP_TYPE_tt__RelativeFocusOptions:
		if (p->size < 0)
			SOAP_DELETE((tt__RelativeFocusOptions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__RelativeFocusOptions*)p->ptr);
		break;
	case SOAP_TYPE_tt__ContinuousFocusOptions:
		if (p->size < 0)
			SOAP_DELETE((tt__ContinuousFocusOptions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ContinuousFocusOptions*)p->ptr);
		break;
	case SOAP_TYPE_tt__WhiteBalance:
		if (p->size < 0)
			SOAP_DELETE((tt__WhiteBalance*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__WhiteBalance*)p->ptr);
		break;
	case SOAP_TYPE_tt__ImagingStatus20:
		if (p->size < 0)
			SOAP_DELETE((tt__ImagingStatus20*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ImagingStatus20*)p->ptr);
		break;
	case SOAP_TYPE_tt__ImagingStatus20Extension:
		if (p->size < 0)
			SOAP_DELETE((tt__ImagingStatus20Extension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ImagingStatus20Extension*)p->ptr);
		break;
	case SOAP_TYPE_tt__FocusStatus20:
		if (p->size < 0)
			SOAP_DELETE((tt__FocusStatus20*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__FocusStatus20*)p->ptr);
		break;
	case SOAP_TYPE_tt__FocusStatus20Extension:
		if (p->size < 0)
			SOAP_DELETE((tt__FocusStatus20Extension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__FocusStatus20Extension*)p->ptr);
		break;
	case SOAP_TYPE_tt__ImagingSettings20:
		if (p->size < 0)
			SOAP_DELETE((tt__ImagingSettings20*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ImagingSettings20*)p->ptr);
		break;
	case SOAP_TYPE_tt__ImagingSettingsExtension20:
		if (p->size < 0)
			SOAP_DELETE((tt__ImagingSettingsExtension20*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ImagingSettingsExtension20*)p->ptr);
		break;
	case SOAP_TYPE_tt__WideDynamicRange20:
		if (p->size < 0)
			SOAP_DELETE((tt__WideDynamicRange20*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__WideDynamicRange20*)p->ptr);
		break;
	case SOAP_TYPE_tt__BacklightCompensation20:
		if (p->size < 0)
			SOAP_DELETE((tt__BacklightCompensation20*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__BacklightCompensation20*)p->ptr);
		break;
	case SOAP_TYPE_tt__Exposure20:
		if (p->size < 0)
			SOAP_DELETE((tt__Exposure20*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Exposure20*)p->ptr);
		break;
	case SOAP_TYPE_tt__ImagingOptions20:
		if (p->size < 0)
			SOAP_DELETE((tt__ImagingOptions20*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ImagingOptions20*)p->ptr);
		break;
	case SOAP_TYPE_tt__ImagingOptions20Extension:
		if (p->size < 0)
			SOAP_DELETE((tt__ImagingOptions20Extension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ImagingOptions20Extension*)p->ptr);
		break;
	case SOAP_TYPE_tt__WideDynamicRangeOptions20:
		if (p->size < 0)
			SOAP_DELETE((tt__WideDynamicRangeOptions20*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__WideDynamicRangeOptions20*)p->ptr);
		break;
	case SOAP_TYPE_tt__BacklightCompensationOptions20:
		if (p->size < 0)
			SOAP_DELETE((tt__BacklightCompensationOptions20*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__BacklightCompensationOptions20*)p->ptr);
		break;
	case SOAP_TYPE_tt__ExposureOptions20:
		if (p->size < 0)
			SOAP_DELETE((tt__ExposureOptions20*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ExposureOptions20*)p->ptr);
		break;
	case SOAP_TYPE_tt__MoveOptions20:
		if (p->size < 0)
			SOAP_DELETE((tt__MoveOptions20*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__MoveOptions20*)p->ptr);
		break;
	case SOAP_TYPE_tt__RelativeFocusOptions20:
		if (p->size < 0)
			SOAP_DELETE((tt__RelativeFocusOptions20*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__RelativeFocusOptions20*)p->ptr);
		break;
	case SOAP_TYPE_tt__WhiteBalance20:
		if (p->size < 0)
			SOAP_DELETE((tt__WhiteBalance20*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__WhiteBalance20*)p->ptr);
		break;
	case SOAP_TYPE_tt__WhiteBalance20Extension:
		if (p->size < 0)
			SOAP_DELETE((tt__WhiteBalance20Extension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__WhiteBalance20Extension*)p->ptr);
		break;
	case SOAP_TYPE_tt__FocusConfiguration20:
		if (p->size < 0)
			SOAP_DELETE((tt__FocusConfiguration20*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__FocusConfiguration20*)p->ptr);
		break;
	case SOAP_TYPE_tt__FocusConfiguration20Extension:
		if (p->size < 0)
			SOAP_DELETE((tt__FocusConfiguration20Extension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__FocusConfiguration20Extension*)p->ptr);
		break;
	case SOAP_TYPE_tt__WhiteBalanceOptions20:
		if (p->size < 0)
			SOAP_DELETE((tt__WhiteBalanceOptions20*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__WhiteBalanceOptions20*)p->ptr);
		break;
	case SOAP_TYPE_tt__WhiteBalanceOptions20Extension:
		if (p->size < 0)
			SOAP_DELETE((tt__WhiteBalanceOptions20Extension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__WhiteBalanceOptions20Extension*)p->ptr);
		break;
	case SOAP_TYPE_tt__FocusOptions20:
		if (p->size < 0)
			SOAP_DELETE((tt__FocusOptions20*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__FocusOptions20*)p->ptr);
		break;
	case SOAP_TYPE_tt__FocusOptions20Extension:
		if (p->size < 0)
			SOAP_DELETE((tt__FocusOptions20Extension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__FocusOptions20Extension*)p->ptr);
		break;
	case SOAP_TYPE_tt__MessageExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__MessageExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__MessageExtension*)p->ptr);
		break;
	case SOAP_TYPE__tt__ItemList_SimpleItem:
		if (p->size < 0)
			SOAP_DELETE((_tt__ItemList_SimpleItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tt__ItemList_SimpleItem*)p->ptr);
		break;
	case SOAP_TYPE__tt__ItemList_ElementItem:
		if (p->size < 0)
			SOAP_DELETE((_tt__ItemList_ElementItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tt__ItemList_ElementItem*)p->ptr);
		break;
	case SOAP_TYPE_tt__ItemList:
		if (p->size < 0)
			SOAP_DELETE((tt__ItemList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ItemList*)p->ptr);
		break;
	case SOAP_TYPE_tt__ItemListExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__ItemListExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ItemListExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__MessageDescription:
		if (p->size < 0)
			SOAP_DELETE((tt__MessageDescription*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__MessageDescription*)p->ptr);
		break;
	case SOAP_TYPE_tt__MessageDescriptionExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__MessageDescriptionExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__MessageDescriptionExtension*)p->ptr);
		break;
	case SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription:
		if (p->size < 0)
			SOAP_DELETE((_tt__ItemListDescription_SimpleItemDescription*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tt__ItemListDescription_SimpleItemDescription*)p->ptr);
		break;
	case SOAP_TYPE__tt__ItemListDescription_ElementItemDescription:
		if (p->size < 0)
			SOAP_DELETE((_tt__ItemListDescription_ElementItemDescription*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tt__ItemListDescription_ElementItemDescription*)p->ptr);
		break;
	case SOAP_TYPE_tt__ItemListDescription:
		if (p->size < 0)
			SOAP_DELETE((tt__ItemListDescription*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ItemListDescription*)p->ptr);
		break;
	case SOAP_TYPE_tt__ItemListDescriptionExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__ItemListDescriptionExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ItemListDescriptionExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__Vector:
		if (p->size < 0)
			SOAP_DELETE((tt__Vector*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Vector*)p->ptr);
		break;
	case SOAP_TYPE_tt__Rectangle:
		if (p->size < 0)
			SOAP_DELETE((tt__Rectangle*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Rectangle*)p->ptr);
		break;
	case SOAP_TYPE_tt__Polygon:
		if (p->size < 0)
			SOAP_DELETE((tt__Polygon*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Polygon*)p->ptr);
		break;
	case SOAP_TYPE_tt__Polyline:
		if (p->size < 0)
			SOAP_DELETE((tt__Polyline*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Polyline*)p->ptr);
		break;
	case SOAP_TYPE_tt__Color:
		if (p->size < 0)
			SOAP_DELETE((tt__Color*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Color*)p->ptr);
		break;
	case SOAP_TYPE_tt__ColorCovariance:
		if (p->size < 0)
			SOAP_DELETE((tt__ColorCovariance*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ColorCovariance*)p->ptr);
		break;
	case SOAP_TYPE_tt__Appearance:
		if (p->size < 0)
			SOAP_DELETE((tt__Appearance*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Appearance*)p->ptr);
		break;
	case SOAP_TYPE_tt__AppearanceExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__AppearanceExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__AppearanceExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__ShapeDescriptor:
		if (p->size < 0)
			SOAP_DELETE((tt__ShapeDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ShapeDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_tt__ShapeDescriptorExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__ShapeDescriptorExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ShapeDescriptorExtension*)p->ptr);
		break;
	case SOAP_TYPE__tt__ColorDescriptor_ColorCluster:
		if (p->size < 0)
			SOAP_DELETE((_tt__ColorDescriptor_ColorCluster*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tt__ColorDescriptor_ColorCluster*)p->ptr);
		break;
	case SOAP_TYPE_tt__ColorDescriptor:
		if (p->size < 0)
			SOAP_DELETE((tt__ColorDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ColorDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_tt__ColorDescriptorExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__ColorDescriptorExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ColorDescriptorExtension*)p->ptr);
		break;
	case SOAP_TYPE__tt__ClassDescriptor_ClassCandidate:
		if (p->size < 0)
			SOAP_DELETE((_tt__ClassDescriptor_ClassCandidate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tt__ClassDescriptor_ClassCandidate*)p->ptr);
		break;
	case SOAP_TYPE_tt__ClassDescriptor:
		if (p->size < 0)
			SOAP_DELETE((tt__ClassDescriptor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ClassDescriptor*)p->ptr);
		break;
	case SOAP_TYPE_tt__ClassDescriptorExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__ClassDescriptorExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ClassDescriptorExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__ObjectExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__ObjectExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ObjectExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__Transformation:
		if (p->size < 0)
			SOAP_DELETE((tt__Transformation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Transformation*)p->ptr);
		break;
	case SOAP_TYPE_tt__TransformationExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__TransformationExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__TransformationExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__Frame:
		if (p->size < 0)
			SOAP_DELETE((tt__Frame*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Frame*)p->ptr);
		break;
	case SOAP_TYPE_tt__FrameExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__FrameExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__FrameExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__Merge:
		if (p->size < 0)
			SOAP_DELETE((tt__Merge*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Merge*)p->ptr);
		break;
	case SOAP_TYPE_tt__Split:
		if (p->size < 0)
			SOAP_DELETE((tt__Split*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Split*)p->ptr);
		break;
	case SOAP_TYPE_tt__Rename:
		if (p->size < 0)
			SOAP_DELETE((tt__Rename*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Rename*)p->ptr);
		break;
	case SOAP_TYPE_tt__ObjectId:
		if (p->size < 0)
			SOAP_DELETE((tt__ObjectId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ObjectId*)p->ptr);
		break;
	case SOAP_TYPE__tt__Behaviour_Removed:
		if (p->size < 0)
			SOAP_DELETE((_tt__Behaviour_Removed*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tt__Behaviour_Removed*)p->ptr);
		break;
	case SOAP_TYPE__tt__Behaviour_Idle:
		if (p->size < 0)
			SOAP_DELETE((_tt__Behaviour_Idle*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tt__Behaviour_Idle*)p->ptr);
		break;
	case SOAP_TYPE_tt__Behaviour:
		if (p->size < 0)
			SOAP_DELETE((tt__Behaviour*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Behaviour*)p->ptr);
		break;
	case SOAP_TYPE_tt__BehaviourExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__BehaviourExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__BehaviourExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__ObjectTree:
		if (p->size < 0)
			SOAP_DELETE((tt__ObjectTree*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ObjectTree*)p->ptr);
		break;
	case SOAP_TYPE_tt__ObjectTreeExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__ObjectTreeExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ObjectTreeExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__AnalyticsEngineConfiguration:
		if (p->size < 0)
			SOAP_DELETE((tt__AnalyticsEngineConfiguration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__AnalyticsEngineConfiguration*)p->ptr);
		break;
	case SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__AnalyticsEngineConfigurationExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__AnalyticsEngineConfigurationExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__RuleEngineConfiguration:
		if (p->size < 0)
			SOAP_DELETE((tt__RuleEngineConfiguration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__RuleEngineConfiguration*)p->ptr);
		break;
	case SOAP_TYPE_tt__RuleEngineConfigurationExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__RuleEngineConfigurationExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__RuleEngineConfigurationExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__Config:
		if (p->size < 0)
			SOAP_DELETE((tt__Config*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Config*)p->ptr);
		break;
	case SOAP_TYPE__tt__ConfigDescription_Messages:
		if (p->size < 0)
			SOAP_DELETE((_tt__ConfigDescription_Messages*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tt__ConfigDescription_Messages*)p->ptr);
		break;
	case SOAP_TYPE_tt__ConfigDescription:
		if (p->size < 0)
			SOAP_DELETE((tt__ConfigDescription*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ConfigDescription*)p->ptr);
		break;
	case SOAP_TYPE_tt__ConfigDescriptionExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__ConfigDescriptionExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__ConfigDescriptionExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__SupportedRules:
		if (p->size < 0)
			SOAP_DELETE((tt__SupportedRules*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__SupportedRules*)p->ptr);
		break;
	case SOAP_TYPE_tt__SupportedRulesExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__SupportedRulesExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__SupportedRulesExtension*)p->ptr);
		break;
	case SOAP_TYPE_tt__SupportedAnalyticsModules:
		if (p->size < 0)
			SOAP_DELETE((tt__SupportedAnalyticsModules*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__SupportedAnalyticsModules*)p->ptr);
		break;
	case SOAP_TYPE_tt__SupportedAnalyticsModulesExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__SupportedAnalyticsModulesExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__SupportedAnalyticsModulesExtension*)p->ptr);
		break;
	case SOAP_TYPE___tt__union_MetadataStream:
		if (p->size < 0)
			SOAP_DELETE((__tt__union_MetadataStream*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__tt__union_MetadataStream*)p->ptr);
		break;
	case SOAP_TYPE_tt__MetadataStream:
		if (p->size < 0)
			SOAP_DELETE((tt__MetadataStream*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__MetadataStream*)p->ptr);
		break;
	case SOAP_TYPE_tt__MetadataStreamExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__MetadataStreamExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__MetadataStreamExtension*)p->ptr);
		break;
	case SOAP_TYPE___tt__union_VideoAnalyticsStream:
		if (p->size < 0)
			SOAP_DELETE((__tt__union_VideoAnalyticsStream*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__tt__union_VideoAnalyticsStream*)p->ptr);
		break;
	case SOAP_TYPE_tt__VideoAnalyticsStream:
		if (p->size < 0)
			SOAP_DELETE((tt__VideoAnalyticsStream*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__VideoAnalyticsStream*)p->ptr);
		break;
	case SOAP_TYPE_tt__VideoAnalyticsStreamExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__VideoAnalyticsStreamExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__VideoAnalyticsStreamExtension*)p->ptr);
		break;
	case SOAP_TYPE___tt__union_PTZStream:
		if (p->size < 0)
			SOAP_DELETE((__tt__union_PTZStream*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__tt__union_PTZStream*)p->ptr);
		break;
	case SOAP_TYPE_tt__PTZStream:
		if (p->size < 0)
			SOAP_DELETE((tt__PTZStream*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__PTZStream*)p->ptr);
		break;
	case SOAP_TYPE_tt__PTZStreamExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__PTZStreamExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__PTZStreamExtension*)p->ptr);
		break;
	case SOAP_TYPE___tt__union_EventStream:
		if (p->size < 0)
			SOAP_DELETE((__tt__union_EventStream*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__tt__union_EventStream*)p->ptr);
		break;
	case SOAP_TYPE_tt__EventStream:
		if (p->size < 0)
			SOAP_DELETE((tt__EventStream*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__EventStream*)p->ptr);
		break;
	case SOAP_TYPE_tt__EventStreamExtension:
		if (p->size < 0)
			SOAP_DELETE((tt__EventStreamExtension*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__EventStreamExtension*)p->ptr);
		break;
	case SOAP_TYPE__tt__Message:
		if (p->size < 0)
			SOAP_DELETE((_tt__Message*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_tt__Message*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__QueryExpressionType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__QueryExpressionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__QueryExpressionType*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__TopicExpressionType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__TopicExpressionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__TopicExpressionType*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__FilterType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__FilterType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__FilterType*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__SubscriptionPolicyType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__SubscriptionPolicyType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__SubscriptionPolicyType*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__NotificationMessageHolderType_Message:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__NotificationMessageHolderType_Message*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__NotificationMessageHolderType_Message*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__NotificationMessageHolderType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__NotificationMessageHolderType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__NotificationMessageHolderType*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__NotificationProducerRP:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__NotificationProducerRP*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__NotificationProducerRP*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__SubscriptionManagerRP:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__SubscriptionManagerRP*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__SubscriptionManagerRP*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__Notify:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__Notify*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__Notify*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__UseRaw:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__UseRaw*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__UseRaw*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__Subscribe_SubscriptionPolicy:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__Subscribe_SubscriptionPolicy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__Subscribe_SubscriptionPolicy*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__Subscribe:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__Subscribe*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__Subscribe*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__SubscribeResponse:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__SubscribeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__SubscribeResponse*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__GetCurrentMessage:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__GetCurrentMessage*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__GetCurrentMessage*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__GetCurrentMessageResponse:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__GetCurrentMessageResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__GetCurrentMessageResponse*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__GetMessages:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__GetMessages*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__GetMessages*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__GetMessagesResponse:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__GetMessagesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__GetMessagesResponse*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__DestroyPullPoint:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__DestroyPullPoint*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__DestroyPullPoint*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__DestroyPullPointResponse:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__DestroyPullPointResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__DestroyPullPointResponse*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__CreatePullPoint:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__CreatePullPoint*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__CreatePullPoint*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__CreatePullPointResponse:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__CreatePullPointResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__CreatePullPointResponse*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__Renew:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__Renew*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__Renew*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__RenewResponse:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__RenewResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__RenewResponse*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__Unsubscribe:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__Unsubscribe*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__Unsubscribe*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__UnsubscribeResponse:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__UnsubscribeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__UnsubscribeResponse*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__PauseSubscription:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__PauseSubscription*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__PauseSubscription*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__PauseSubscriptionResponse:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__PauseSubscriptionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__PauseSubscriptionResponse*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__ResumeSubscription:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__ResumeSubscription*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__ResumeSubscription*)p->ptr);
		break;
	case SOAP_TYPE__wsnb__ResumeSubscriptionResponse:
		if (p->size < 0)
			SOAP_DELETE((_wsnb__ResumeSubscriptionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsnb__ResumeSubscriptionResponse*)p->ptr);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode:
		if (p->size < 0)
			SOAP_DELETE((_wsrfbf__BaseFaultType_ErrorCode*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsrfbf__BaseFaultType_ErrorCode*)p->ptr);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_Description:
		if (p->size < 0)
			SOAP_DELETE((_wsrfbf__BaseFaultType_Description*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsrfbf__BaseFaultType_Description*)p->ptr);
		break;
	case SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause:
		if (p->size < 0)
			SOAP_DELETE((_wsrfbf__BaseFaultType_FaultCause*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wsrfbf__BaseFaultType_FaultCause*)p->ptr);
		break;
	case SOAP_TYPE_wsrfbf__BaseFaultType:
		if (p->size < 0)
			SOAP_DELETE((wsrfbf__BaseFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsrfbf__BaseFaultType*)p->ptr);
		break;
	case SOAP_TYPE_wstop__Documentation:
		if (p->size < 0)
			SOAP_DELETE((wstop__Documentation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wstop__Documentation*)p->ptr);
		break;
	case SOAP_TYPE_wstop__ExtensibleDocumented:
		if (p->size < 0)
			SOAP_DELETE((wstop__ExtensibleDocumented*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wstop__ExtensibleDocumented*)p->ptr);
		break;
	case SOAP_TYPE_wstop__QueryExpressionType:
		if (p->size < 0)
			SOAP_DELETE((wstop__QueryExpressionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wstop__QueryExpressionType*)p->ptr);
		break;
	case SOAP_TYPE_tt__VideoSource:
		if (p->size < 0)
			SOAP_DELETE((tt__VideoSource*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__VideoSource*)p->ptr);
		break;
	case SOAP_TYPE_tt__AudioSource:
		if (p->size < 0)
			SOAP_DELETE((tt__AudioSource*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__AudioSource*)p->ptr);
		break;
	case SOAP_TYPE_tt__VideoSourceConfiguration:
		if (p->size < 0)
			SOAP_DELETE((tt__VideoSourceConfiguration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__VideoSourceConfiguration*)p->ptr);
		break;
	case SOAP_TYPE_tt__VideoEncoderConfiguration:
		if (p->size < 0)
			SOAP_DELETE((tt__VideoEncoderConfiguration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__VideoEncoderConfiguration*)p->ptr);
		break;
	case SOAP_TYPE_tt__AudioSourceConfiguration:
		if (p->size < 0)
			SOAP_DELETE((tt__AudioSourceConfiguration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__AudioSourceConfiguration*)p->ptr);
		break;
	case SOAP_TYPE_tt__AudioEncoderConfiguration:
		if (p->size < 0)
			SOAP_DELETE((tt__AudioEncoderConfiguration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__AudioEncoderConfiguration*)p->ptr);
		break;
	case SOAP_TYPE_tt__VideoAnalyticsConfiguration:
		if (p->size < 0)
			SOAP_DELETE((tt__VideoAnalyticsConfiguration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__VideoAnalyticsConfiguration*)p->ptr);
		break;
	case SOAP_TYPE_tt__MetadataConfiguration:
		if (p->size < 0)
			SOAP_DELETE((tt__MetadataConfiguration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__MetadataConfiguration*)p->ptr);
		break;
	case SOAP_TYPE_tt__NetworkInterface:
		if (p->size < 0)
			SOAP_DELETE((tt__NetworkInterface*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__NetworkInterface*)p->ptr);
		break;
	case SOAP_TYPE_tt__RelayOutput:
		if (p->size < 0)
			SOAP_DELETE((tt__RelayOutput*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__RelayOutput*)p->ptr);
		break;
	case SOAP_TYPE_tt__PTZNode:
		if (p->size < 0)
			SOAP_DELETE((tt__PTZNode*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__PTZNode*)p->ptr);
		break;
	case SOAP_TYPE_tt__PTZConfiguration:
		if (p->size < 0)
			SOAP_DELETE((tt__PTZConfiguration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__PTZConfiguration*)p->ptr);
		break;
	case SOAP_TYPE_tt__Object:
		if (p->size < 0)
			SOAP_DELETE((tt__Object*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tt__Object*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__SubscribeCreationFailedFaultType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__SubscribeCreationFailedFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__SubscribeCreationFailedFaultType*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__InvalidFilterFaultType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__InvalidFilterFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__InvalidFilterFaultType*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__TopicExpressionDialectUnknownFaultType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__TopicExpressionDialectUnknownFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__TopicExpressionDialectUnknownFaultType*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__InvalidTopicExpressionFaultType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__InvalidTopicExpressionFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__InvalidTopicExpressionFaultType*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__TopicNotSupportedFaultType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__TopicNotSupportedFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__TopicNotSupportedFaultType*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__MultipleTopicsSpecifiedFaultType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__MultipleTopicsSpecifiedFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__MultipleTopicsSpecifiedFaultType*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__InvalidProducerPropertiesExpressionFaultType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__InvalidProducerPropertiesExpressionFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__InvalidProducerPropertiesExpressionFaultType*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__InvalidMessageContentExpressionFaultType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__InvalidMessageContentExpressionFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__InvalidMessageContentExpressionFaultType*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__UnrecognizedPolicyRequestFaultType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__UnrecognizedPolicyRequestFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__UnrecognizedPolicyRequestFaultType*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__UnsupportedPolicyRequestFaultType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__UnsupportedPolicyRequestFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__UnsupportedPolicyRequestFaultType*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__NotifyMessageNotSupportedFaultType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__NotifyMessageNotSupportedFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__NotifyMessageNotSupportedFaultType*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__UnacceptableInitialTerminationTimeFaultType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__UnacceptableInitialTerminationTimeFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__UnacceptableInitialTerminationTimeFaultType*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__NoCurrentMessageOnTopicFaultType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__NoCurrentMessageOnTopicFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__NoCurrentMessageOnTopicFaultType*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__UnableToGetMessagesFaultType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__UnableToGetMessagesFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__UnableToGetMessagesFaultType*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__UnableToDestroyPullPointFaultType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__UnableToDestroyPullPointFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__UnableToDestroyPullPointFaultType*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__UnableToCreatePullPointFaultType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__UnableToCreatePullPointFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__UnableToCreatePullPointFaultType*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__UnacceptableTerminationTimeFaultType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__UnacceptableTerminationTimeFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__UnacceptableTerminationTimeFaultType*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__UnableToDestroySubscriptionFaultType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__UnableToDestroySubscriptionFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__UnableToDestroySubscriptionFaultType*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__PauseFailedFaultType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__PauseFailedFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__PauseFailedFaultType*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__ResumeFailedFaultType:
		if (p->size < 0)
			SOAP_DELETE((wsnb__ResumeFailedFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wsnb__ResumeFailedFaultType*)p->ptr);
		break;
	case SOAP_TYPE__wstop__TopicNamespaceType_Topic:
		if (p->size < 0)
			SOAP_DELETE((_wstop__TopicNamespaceType_Topic*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_wstop__TopicNamespaceType_Topic*)p->ptr);
		break;
	case SOAP_TYPE_wstop__TopicNamespaceType:
		if (p->size < 0)
			SOAP_DELETE((wstop__TopicNamespaceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wstop__TopicNamespaceType*)p->ptr);
		break;
	case SOAP_TYPE_wstop__TopicType:
		if (p->size < 0)
			SOAP_DELETE((wstop__TopicType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wstop__TopicType*)p->ptr);
		break;
	case SOAP_TYPE_wstop__TopicSetType:
		if (p->size < 0)
			SOAP_DELETE((wstop__TopicSetType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((wstop__TopicSetType*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetSupportedRules:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetSupportedRules*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetSupportedRules*)p->ptr);
		break;
	case SOAP_TYPE___ns1__CreateRules:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__CreateRules*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__CreateRules*)p->ptr);
		break;
	case SOAP_TYPE___ns1__DeleteRules:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__DeleteRules*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__DeleteRules*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetRules:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetRules*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetRules*)p->ptr);
		break;
	case SOAP_TYPE___ns1__ModifyRules:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__ModifyRules*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__ModifyRules*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetSupportedAnalyticsModules:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__GetSupportedAnalyticsModules*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__GetSupportedAnalyticsModules*)p->ptr);
		break;
	case SOAP_TYPE___ns2__CreateAnalyticsModules:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__CreateAnalyticsModules*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__CreateAnalyticsModules*)p->ptr);
		break;
	case SOAP_TYPE___ns2__DeleteAnalyticsModules:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__DeleteAnalyticsModules*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__DeleteAnalyticsModules*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetAnalyticsModules:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__GetAnalyticsModules*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__GetAnalyticsModules*)p->ptr);
		break;
	case SOAP_TYPE___ns2__ModifyAnalyticsModules:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__ModifyAnalyticsModules*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__ModifyAnalyticsModules*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
	case SOAP_TYPE_xsd__anyType:
		if (p->size < 0)
			SOAP_DELETE((struct soap_dom_element*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct soap_dom_element*)p->ptr);
		break;
	case SOAP_TYPE_xsd__anyAttribute:
		if (p->size < 0)
			SOAP_DELETE((struct soap_dom_attribute*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct soap_dom_attribute*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__EndpointReferenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__EndpointReferenceType*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__ReferenceParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__ReferenceParametersType*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__Metadata:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__MetadataType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__MetadataType*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__RelatesToType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__RelatesToType*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__EndpointReferenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__EndpointReferenceType*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__From:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__EndpointReferenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__EndpointReferenceType*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__EndpointReferenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__EndpointReferenceType*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__ProblemActionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__ProblemActionType*)p->ptr);
		break;
	case SOAP_TYPE_xsd__NCName:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__QName:
		if (p->size < 0)
			SOAP_DELETE((xsd__QName*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__QName*)p->ptr);
		break;
	case SOAP_TYPE_xsd__anySimpleType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__integer:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__token:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE__xml__lang:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_wsnb__AbsoluteOrRelativeTimeType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_tt__ReferenceToken:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_tt__Name:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_tt__IPv4Address:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_tt__IPv6Address:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_tt__HwAddress:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_tt__DNSName:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_tt__Domain:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_tt__AuxiliaryData:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_tt__TopicNamespaceLocation:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_wstop__FullTopicExpression:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_wstop__ConcreteTopicExpression:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_wstop__SimpleTopicExpression:
		if (p->size < 0)
			SOAP_DELETE((xsd__QName*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__QName*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<wstop__TopicType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<wstop__TopicType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		if (p->size < 0)
			SOAP_DELETE((std::vector<xsd__QName >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<xsd__QName >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsnb__NotificationMessageHolderType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<wsnb__NotificationMessageHolderType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<wsnb__NotificationMessageHolderType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsnb__TopicExpressionType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<wsnb__TopicExpressionType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<wsnb__TopicExpressionType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__ConfigDescription:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tt__ConfigDescription * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tt__ConfigDescription * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Merge:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tt__Merge * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tt__Merge * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Split:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tt__Split * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tt__Split * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Rename:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tt__Rename * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tt__Rename * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__ObjectId:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tt__ObjectId * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tt__ObjectId * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Object:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tt__Object * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tt__Object * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Polygon:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tt__Polygon * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tt__Polygon * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tt__Vector * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tt__Vector * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode:
		if (p->size < 0)
			SOAP_DELETE((std::vector<enum tt__BacklightCompensationMode >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<enum tt__BacklightCompensationMode >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode:
		if (p->size < 0)
			SOAP_DELETE((std::vector<enum tt__WhiteBalanceMode >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<enum tt__WhiteBalanceMode >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority:
		if (p->size < 0)
			SOAP_DELETE((std::vector<enum tt__ExposurePriority >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<enum tt__ExposurePriority >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__ExposureMode:
		if (p->size < 0)
			SOAP_DELETE((std::vector<enum tt__ExposureMode >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<enum tt__ExposureMode >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode:
		if (p->size < 0)
			SOAP_DELETE((std::vector<enum tt__AutoFocusMode >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<enum tt__AutoFocusMode >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode:
		if (p->size < 0)
			SOAP_DELETE((std::vector<enum tt__WideDynamicMode >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<enum tt__WideDynamicMode >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode:
		if (p->size < 0)
			SOAP_DELETE((std::vector<enum tt__IrCutFilterMode >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<enum tt__IrCutFilterMode >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Space1DDescription:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tt__Space1DDescription * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tt__Space1DDescription * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Space2DDescription:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tt__Space2DDescription * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tt__Space2DDescription * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__OnvifVersion:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tt__OnvifVersion * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tt__OnvifVersion * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__IPv6Address:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__IPv4Address:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkHost:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tt__NetworkHost * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tt__NetworkHost * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__IPAddress:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tt__IPAddress * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tt__IPAddress * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__token:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv6Address:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tt__PrefixedIPv6Address * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tt__PrefixedIPv6Address * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv4Address:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tt__PrefixedIPv4Address * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tt__PrefixedIPv4Address * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tt__AudioEncoderConfigurationOption * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tt__AudioEncoderConfigurationOption * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__H264Profile:
		if (p->size < 0)
			SOAP_DELETE((std::vector<enum tt__H264Profile >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<enum tt__H264Profile >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__Mpeg4Profile:
		if (p->size < 0)
			SOAP_DELETE((std::vector<enum tt__Mpeg4Profile >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<enum tt__Mpeg4Profile >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoResolution:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tt__VideoResolution * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tt__VideoResolution * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<struct soap_dom_element >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<struct soap_dom_element >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		if (p->size < 0)
			SOAP_DELETE((std::vector<int >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<int >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Config:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tt__Config * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tt__Config * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<wstop__TopicType * >*)p)[len] = *(wstop__TopicType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<xsd__QName >*)p)[len] = *(xsd__QName *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsnb__NotificationMessageHolderType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<wsnb__NotificationMessageHolderType * >*)p)[len] = *(wsnb__NotificationMessageHolderType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTowsnb__TopicExpressionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<wsnb__TopicExpressionType * >*)p)[len] = *(wsnb__TopicExpressionType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__ConfigDescription:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tt__ConfigDescription * >*)p)[len] = *(tt__ConfigDescription **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyURI:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Merge:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tt__Merge * >*)p)[len] = *(tt__Merge **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Split:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tt__Split * >*)p)[len] = *(tt__Split **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Rename:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tt__Rename * >*)p)[len] = *(tt__Rename **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__ObjectId:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tt__ObjectId * >*)p)[len] = *(tt__ObjectId **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Object:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tt__Object * >*)p)[len] = *(tt__Object **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Polygon:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tt__Polygon * >*)p)[len] = *(tt__Polygon **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tt__Vector * >*)p)[len] = *(tt__Vector **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum tt__BacklightCompensationMode >*)p)[len] = *(enum tt__BacklightCompensationMode *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum tt__WhiteBalanceMode >*)p)[len] = *(enum tt__WhiteBalanceMode *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum tt__ExposurePriority >*)p)[len] = *(enum tt__ExposurePriority *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__ExposureMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum tt__ExposureMode >*)p)[len] = *(enum tt__ExposureMode *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum tt__AutoFocusMode >*)p)[len] = *(enum tt__AutoFocusMode *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum tt__WideDynamicMode >*)p)[len] = *(enum tt__WideDynamicMode *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum tt__IrCutFilterMode >*)p)[len] = *(enum tt__IrCutFilterMode *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Space1DDescription:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tt__Space1DDescription * >*)p)[len] = *(tt__Space1DDescription **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Space2DDescription:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tt__Space2DDescription * >*)p)[len] = *(tt__Space2DDescription **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__OnvifVersion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tt__OnvifVersion * >*)p)[len] = *(tt__OnvifVersion **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__IPv6Address:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__IPv4Address:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkHost:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tt__NetworkHost * >*)p)[len] = *(tt__NetworkHost **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__IPAddress:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tt__IPAddress * >*)p)[len] = *(tt__IPAddress **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__token:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv6Address:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tt__PrefixedIPv6Address * >*)p)[len] = *(tt__PrefixedIPv6Address **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv4Address:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tt__PrefixedIPv4Address * >*)p)[len] = *(tt__PrefixedIPv4Address **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tt__AudioEncoderConfigurationOption * >*)p)[len] = *(tt__AudioEncoderConfigurationOption **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__H264Profile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum tt__H264Profile >*)p)[len] = *(enum tt__H264Profile *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__Mpeg4Profile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum tt__Mpeg4Profile >*)p)[len] = *(enum tt__Mpeg4Profile *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoResolution:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tt__VideoResolution * >*)p)[len] = *(tt__VideoResolution **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<struct soap_dom_element >*)p)[len] = *(struct soap_dom_element *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<int >*)p)[len] = *(int *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Config:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tt__Config * >*)p)[len] = *(tt__Config **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IANA_IfTypes(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_tt__IANA_IfTypes);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_tt__IANA_IfTypes(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_tt__IANA_IfTypes);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IANA_IfTypes(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IANA_IfTypes);
	if (soap_out_tt__IANA_IfTypes(soap, tag?tag:"tt:IANA-IfTypes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_tt__IANA_IfTypes(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IANA_IfTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__duration);
	if (soap_out_xsd__duration(soap, tag?tag:"xsd:duration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{	float *p;
	p = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag?tag:"float", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLONG64(struct soap *soap, ULONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLONG64
	*a = SOAP_DEFAULT_unsignedLONG64;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_unsignedLONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{	ULONG64 *p;
	p = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_unsignedLONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLONG64);
	if (soap_out_unsignedLONG64(soap, tag?tag:"unsignedLong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_unsignedLONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ClassType(struct soap *soap, enum tt__ClassType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__ClassType
	*a = SOAP_DEFAULT_tt__ClassType;
#else
	*a = (enum tt__ClassType)0;
#endif
}

static const struct soap_code_map soap_codes_tt__ClassType[] =
{	{ (long)tt__ClassType__Animal, "Animal" },
	{ (long)tt__ClassType__Face, "Face" },
	{ (long)tt__ClassType__Human, "Human" },
	{ (long)tt__ClassType__Vehical, "Vehical" },
	{ (long)tt__ClassType__Other, "Other" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ClassType2s(struct soap *soap, enum tt__ClassType n)
{	const char *s = soap_code_str(soap_codes_tt__ClassType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ClassType(struct soap *soap, const char *tag, int id, const enum tt__ClassType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ClassType), type) || soap_send(soap, soap_tt__ClassType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ClassType(struct soap *soap, const char *s, enum tt__ClassType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ClassType, s);
	if (map)
		*a = (enum tt__ClassType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ClassType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ClassType * SOAP_FMAC4 soap_in_tt__ClassType(struct soap *soap, const char *tag, enum tt__ClassType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ClassType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ClassType, sizeof(enum tt__ClassType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__ClassType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__ClassType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ClassType, 0, sizeof(enum tt__ClassType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ClassType(struct soap *soap, const enum tt__ClassType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ClassType);
	if (soap_out_tt__ClassType(soap, tag?tag:"tt:ClassType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ClassType * SOAP_FMAC4 soap_get_tt__ClassType(struct soap *soap, enum tt__ClassType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ClassType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Direction(struct soap *soap, enum tt__Direction *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__Direction
	*a = SOAP_DEFAULT_tt__Direction;
#else
	*a = (enum tt__Direction)0;
#endif
}

static const struct soap_code_map soap_codes_tt__Direction[] =
{	{ (long)tt__Direction__Left, "Left" },
	{ (long)tt__Direction__Right, "Right" },
	{ (long)tt__Direction__Any, "Any" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Direction2s(struct soap *soap, enum tt__Direction n)
{	const char *s = soap_code_str(soap_codes_tt__Direction, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Direction(struct soap *soap, const char *tag, int id, const enum tt__Direction *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Direction), type) || soap_send(soap, soap_tt__Direction2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Direction(struct soap *soap, const char *s, enum tt__Direction *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Direction, s);
	if (map)
		*a = (enum tt__Direction)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Direction)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Direction * SOAP_FMAC4 soap_in_tt__Direction(struct soap *soap, const char *tag, enum tt__Direction *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Direction *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Direction, sizeof(enum tt__Direction), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__Direction(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__Direction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Direction, 0, sizeof(enum tt__Direction), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Direction(struct soap *soap, const enum tt__Direction *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Direction);
	if (soap_out_tt__Direction(soap, tag?tag:"tt:Direction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Direction * SOAP_FMAC4 soap_get_tt__Direction(struct soap *soap, enum tt__Direction *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Direction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PropertyOperation(struct soap *soap, enum tt__PropertyOperation *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__PropertyOperation
	*a = SOAP_DEFAULT_tt__PropertyOperation;
#else
	*a = (enum tt__PropertyOperation)0;
#endif
}

static const struct soap_code_map soap_codes_tt__PropertyOperation[] =
{	{ (long)tt__PropertyOperation__Initialized, "Initialized" },
	{ (long)tt__PropertyOperation__Deleted, "Deleted" },
	{ (long)tt__PropertyOperation__Changed, "Changed" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__PropertyOperation2s(struct soap *soap, enum tt__PropertyOperation n)
{	const char *s = soap_code_str(soap_codes_tt__PropertyOperation, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PropertyOperation(struct soap *soap, const char *tag, int id, const enum tt__PropertyOperation *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PropertyOperation), type) || soap_send(soap, soap_tt__PropertyOperation2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__PropertyOperation(struct soap *soap, const char *s, enum tt__PropertyOperation *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__PropertyOperation, s);
	if (map)
		*a = (enum tt__PropertyOperation)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__PropertyOperation)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__PropertyOperation * SOAP_FMAC4 soap_in_tt__PropertyOperation(struct soap *soap, const char *tag, enum tt__PropertyOperation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__PropertyOperation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PropertyOperation, sizeof(enum tt__PropertyOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__PropertyOperation(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__PropertyOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PropertyOperation, 0, sizeof(enum tt__PropertyOperation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PropertyOperation(struct soap *soap, const enum tt__PropertyOperation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PropertyOperation);
	if (soap_out_tt__PropertyOperation(soap, tag?tag:"tt:PropertyOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__PropertyOperation * SOAP_FMAC4 soap_get_tt__PropertyOperation(struct soap *soap, enum tt__PropertyOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PropertyOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__IrCutFilterMode
	*a = SOAP_DEFAULT_tt__IrCutFilterMode;
#else
	*a = (enum tt__IrCutFilterMode)0;
#endif
}

static const struct soap_code_map soap_codes_tt__IrCutFilterMode[] =
{	{ (long)tt__IrCutFilterMode__ON, "ON" },
	{ (long)tt__IrCutFilterMode__OFF, "OFF" },
	{ (long)tt__IrCutFilterMode__AUTO, "AUTO" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IrCutFilterMode2s(struct soap *soap, enum tt__IrCutFilterMode n)
{	const char *s = soap_code_str(soap_codes_tt__IrCutFilterMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterMode(struct soap *soap, const char *tag, int id, const enum tt__IrCutFilterMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IrCutFilterMode), type) || soap_send(soap, soap_tt__IrCutFilterMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IrCutFilterMode(struct soap *soap, const char *s, enum tt__IrCutFilterMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__IrCutFilterMode, s);
	if (map)
		*a = (enum tt__IrCutFilterMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__IrCutFilterMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IrCutFilterMode * SOAP_FMAC4 soap_in_tt__IrCutFilterMode(struct soap *soap, const char *tag, enum tt__IrCutFilterMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__IrCutFilterMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterMode, sizeof(enum tt__IrCutFilterMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__IrCutFilterMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__IrCutFilterMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterMode, 0, sizeof(enum tt__IrCutFilterMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IrCutFilterMode(struct soap *soap, const enum tt__IrCutFilterMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IrCutFilterMode);
	if (soap_out_tt__IrCutFilterMode(soap, tag?tag:"tt:IrCutFilterMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IrCutFilterMode * SOAP_FMAC4 soap_get_tt__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WhiteBalanceMode(struct soap *soap, enum tt__WhiteBalanceMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__WhiteBalanceMode
	*a = SOAP_DEFAULT_tt__WhiteBalanceMode;
#else
	*a = (enum tt__WhiteBalanceMode)0;
#endif
}

static const struct soap_code_map soap_codes_tt__WhiteBalanceMode[] =
{	{ (long)tt__WhiteBalanceMode__AUTO, "AUTO" },
	{ (long)tt__WhiteBalanceMode__MANUAL, "MANUAL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__WhiteBalanceMode2s(struct soap *soap, enum tt__WhiteBalanceMode n)
{	const char *s = soap_code_str(soap_codes_tt__WhiteBalanceMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceMode(struct soap *soap, const char *tag, int id, const enum tt__WhiteBalanceMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalanceMode), type) || soap_send(soap, soap_tt__WhiteBalanceMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__WhiteBalanceMode(struct soap *soap, const char *s, enum tt__WhiteBalanceMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__WhiteBalanceMode, s);
	if (map)
		*a = (enum tt__WhiteBalanceMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__WhiteBalanceMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__WhiteBalanceMode * SOAP_FMAC4 soap_in_tt__WhiteBalanceMode(struct soap *soap, const char *tag, enum tt__WhiteBalanceMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__WhiteBalanceMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceMode, sizeof(enum tt__WhiteBalanceMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__WhiteBalanceMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__WhiteBalanceMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceMode, 0, sizeof(enum tt__WhiteBalanceMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WhiteBalanceMode(struct soap *soap, const enum tt__WhiteBalanceMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__WhiteBalanceMode);
	if (soap_out_tt__WhiteBalanceMode(soap, tag?tag:"tt:WhiteBalanceMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__WhiteBalanceMode * SOAP_FMAC4 soap_get_tt__WhiteBalanceMode(struct soap *soap, enum tt__WhiteBalanceMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Enabled(struct soap *soap, enum tt__Enabled *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__Enabled
	*a = SOAP_DEFAULT_tt__Enabled;
#else
	*a = (enum tt__Enabled)0;
#endif
}

static const struct soap_code_map soap_codes_tt__Enabled[] =
{	{ (long)tt__Enabled__ENABLED, "ENABLED" },
	{ (long)tt__Enabled__DISABLED, "DISABLED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Enabled2s(struct soap *soap, enum tt__Enabled n)
{	const char *s = soap_code_str(soap_codes_tt__Enabled, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Enabled(struct soap *soap, const char *tag, int id, const enum tt__Enabled *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Enabled), type) || soap_send(soap, soap_tt__Enabled2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Enabled(struct soap *soap, const char *s, enum tt__Enabled *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Enabled, s);
	if (map)
		*a = (enum tt__Enabled)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Enabled)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Enabled * SOAP_FMAC4 soap_in_tt__Enabled(struct soap *soap, const char *tag, enum tt__Enabled *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Enabled *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Enabled, sizeof(enum tt__Enabled), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__Enabled(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__Enabled *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Enabled, 0, sizeof(enum tt__Enabled), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Enabled(struct soap *soap, const enum tt__Enabled *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Enabled);
	if (soap_out_tt__Enabled(soap, tag?tag:"tt:Enabled", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Enabled * SOAP_FMAC4 soap_get_tt__Enabled(struct soap *soap, enum tt__Enabled *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Enabled(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ExposureMode(struct soap *soap, enum tt__ExposureMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__ExposureMode
	*a = SOAP_DEFAULT_tt__ExposureMode;
#else
	*a = (enum tt__ExposureMode)0;
#endif
}

static const struct soap_code_map soap_codes_tt__ExposureMode[] =
{	{ (long)tt__ExposureMode__AUTO, "AUTO" },
	{ (long)tt__ExposureMode__MANUAL, "MANUAL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ExposureMode2s(struct soap *soap, enum tt__ExposureMode n)
{	const char *s = soap_code_str(soap_codes_tt__ExposureMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposureMode(struct soap *soap, const char *tag, int id, const enum tt__ExposureMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ExposureMode), type) || soap_send(soap, soap_tt__ExposureMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ExposureMode(struct soap *soap, const char *s, enum tt__ExposureMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ExposureMode, s);
	if (map)
		*a = (enum tt__ExposureMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ExposureMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ExposureMode * SOAP_FMAC4 soap_in_tt__ExposureMode(struct soap *soap, const char *tag, enum tt__ExposureMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ExposureMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposureMode, sizeof(enum tt__ExposureMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__ExposureMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__ExposureMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposureMode, 0, sizeof(enum tt__ExposureMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ExposureMode(struct soap *soap, const enum tt__ExposureMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ExposureMode);
	if (soap_out_tt__ExposureMode(soap, tag?tag:"tt:ExposureMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ExposureMode * SOAP_FMAC4 soap_get_tt__ExposureMode(struct soap *soap, enum tt__ExposureMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposureMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ExposurePriority(struct soap *soap, enum tt__ExposurePriority *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__ExposurePriority
	*a = SOAP_DEFAULT_tt__ExposurePriority;
#else
	*a = (enum tt__ExposurePriority)0;
#endif
}

static const struct soap_code_map soap_codes_tt__ExposurePriority[] =
{	{ (long)tt__ExposurePriority__LowNoise, "LowNoise" },
	{ (long)tt__ExposurePriority__FrameRate, "FrameRate" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ExposurePriority2s(struct soap *soap, enum tt__ExposurePriority n)
{	const char *s = soap_code_str(soap_codes_tt__ExposurePriority, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposurePriority(struct soap *soap, const char *tag, int id, const enum tt__ExposurePriority *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ExposurePriority), type) || soap_send(soap, soap_tt__ExposurePriority2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ExposurePriority(struct soap *soap, const char *s, enum tt__ExposurePriority *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ExposurePriority, s);
	if (map)
		*a = (enum tt__ExposurePriority)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ExposurePriority)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ExposurePriority * SOAP_FMAC4 soap_in_tt__ExposurePriority(struct soap *soap, const char *tag, enum tt__ExposurePriority *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ExposurePriority *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposurePriority, sizeof(enum tt__ExposurePriority), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__ExposurePriority(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__ExposurePriority *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposurePriority, 0, sizeof(enum tt__ExposurePriority), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ExposurePriority(struct soap *soap, const enum tt__ExposurePriority *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ExposurePriority);
	if (soap_out_tt__ExposurePriority(soap, tag?tag:"tt:ExposurePriority", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ExposurePriority * SOAP_FMAC4 soap_get_tt__ExposurePriority(struct soap *soap, enum tt__ExposurePriority *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposurePriority(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__BacklightCompensationMode(struct soap *soap, enum tt__BacklightCompensationMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__BacklightCompensationMode
	*a = SOAP_DEFAULT_tt__BacklightCompensationMode;
#else
	*a = (enum tt__BacklightCompensationMode)0;
#endif
}

static const struct soap_code_map soap_codes_tt__BacklightCompensationMode[] =
{	{ (long)tt__BacklightCompensationMode__OFF, "OFF" },
	{ (long)tt__BacklightCompensationMode__ON, "ON" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__BacklightCompensationMode2s(struct soap *soap, enum tt__BacklightCompensationMode n)
{	const char *s = soap_code_str(soap_codes_tt__BacklightCompensationMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensationMode(struct soap *soap, const char *tag, int id, const enum tt__BacklightCompensationMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensationMode), type) || soap_send(soap, soap_tt__BacklightCompensationMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__BacklightCompensationMode(struct soap *soap, const char *s, enum tt__BacklightCompensationMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__BacklightCompensationMode, s);
	if (map)
		*a = (enum tt__BacklightCompensationMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__BacklightCompensationMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__BacklightCompensationMode * SOAP_FMAC4 soap_in_tt__BacklightCompensationMode(struct soap *soap, const char *tag, enum tt__BacklightCompensationMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__BacklightCompensationMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensationMode, sizeof(enum tt__BacklightCompensationMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__BacklightCompensationMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__BacklightCompensationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensationMode, 0, sizeof(enum tt__BacklightCompensationMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BacklightCompensationMode(struct soap *soap, const enum tt__BacklightCompensationMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__BacklightCompensationMode);
	if (soap_out_tt__BacklightCompensationMode(soap, tag?tag:"tt:BacklightCompensationMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__BacklightCompensationMode * SOAP_FMAC4 soap_get_tt__BacklightCompensationMode(struct soap *soap, enum tt__BacklightCompensationMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WideDynamicMode(struct soap *soap, enum tt__WideDynamicMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__WideDynamicMode
	*a = SOAP_DEFAULT_tt__WideDynamicMode;
#else
	*a = (enum tt__WideDynamicMode)0;
#endif
}

static const struct soap_code_map soap_codes_tt__WideDynamicMode[] =
{	{ (long)tt__WideDynamicMode__OFF, "OFF" },
	{ (long)tt__WideDynamicMode__ON, "ON" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__WideDynamicMode2s(struct soap *soap, enum tt__WideDynamicMode n)
{	const char *s = soap_code_str(soap_codes_tt__WideDynamicMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicMode(struct soap *soap, const char *tag, int id, const enum tt__WideDynamicMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicMode), type) || soap_send(soap, soap_tt__WideDynamicMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__WideDynamicMode(struct soap *soap, const char *s, enum tt__WideDynamicMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__WideDynamicMode, s);
	if (map)
		*a = (enum tt__WideDynamicMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__WideDynamicMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__WideDynamicMode * SOAP_FMAC4 soap_in_tt__WideDynamicMode(struct soap *soap, const char *tag, enum tt__WideDynamicMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__WideDynamicMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicMode, sizeof(enum tt__WideDynamicMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__WideDynamicMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__WideDynamicMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicMode, 0, sizeof(enum tt__WideDynamicMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WideDynamicMode(struct soap *soap, const enum tt__WideDynamicMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__WideDynamicMode);
	if (soap_out_tt__WideDynamicMode(soap, tag?tag:"tt:WideDynamicMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__WideDynamicMode * SOAP_FMAC4 soap_get_tt__WideDynamicMode(struct soap *soap, enum tt__WideDynamicMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AutoFocusMode(struct soap *soap, enum tt__AutoFocusMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__AutoFocusMode
	*a = SOAP_DEFAULT_tt__AutoFocusMode;
#else
	*a = (enum tt__AutoFocusMode)0;
#endif
}

static const struct soap_code_map soap_codes_tt__AutoFocusMode[] =
{	{ (long)tt__AutoFocusMode__AUTO, "AUTO" },
	{ (long)tt__AutoFocusMode__MANUAL, "MANUAL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__AutoFocusMode2s(struct soap *soap, enum tt__AutoFocusMode n)
{	const char *s = soap_code_str(soap_codes_tt__AutoFocusMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AutoFocusMode(struct soap *soap, const char *tag, int id, const enum tt__AutoFocusMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AutoFocusMode), type) || soap_send(soap, soap_tt__AutoFocusMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__AutoFocusMode(struct soap *soap, const char *s, enum tt__AutoFocusMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__AutoFocusMode, s);
	if (map)
		*a = (enum tt__AutoFocusMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__AutoFocusMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__AutoFocusMode * SOAP_FMAC4 soap_in_tt__AutoFocusMode(struct soap *soap, const char *tag, enum tt__AutoFocusMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__AutoFocusMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AutoFocusMode, sizeof(enum tt__AutoFocusMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__AutoFocusMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__AutoFocusMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AutoFocusMode, 0, sizeof(enum tt__AutoFocusMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AutoFocusMode(struct soap *soap, const enum tt__AutoFocusMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AutoFocusMode);
	if (soap_out_tt__AutoFocusMode(soap, tag?tag:"tt:AutoFocusMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__AutoFocusMode * SOAP_FMAC4 soap_get_tt__AutoFocusMode(struct soap *soap, enum tt__AutoFocusMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AutoFocusMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MoveStatus(struct soap *soap, enum tt__MoveStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__MoveStatus
	*a = SOAP_DEFAULT_tt__MoveStatus;
#else
	*a = (enum tt__MoveStatus)0;
#endif
}

static const struct soap_code_map soap_codes_tt__MoveStatus[] =
{	{ (long)tt__MoveStatus__IDLE, "IDLE" },
	{ (long)tt__MoveStatus__MOVING, "MOVING" },
	{ (long)tt__MoveStatus__UNKNOWN, "UNKNOWN" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__MoveStatus2s(struct soap *soap, enum tt__MoveStatus n)
{	const char *s = soap_code_str(soap_codes_tt__MoveStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MoveStatus(struct soap *soap, const char *tag, int id, const enum tt__MoveStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MoveStatus), type) || soap_send(soap, soap_tt__MoveStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__MoveStatus(struct soap *soap, const char *s, enum tt__MoveStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__MoveStatus, s);
	if (map)
		*a = (enum tt__MoveStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__MoveStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__MoveStatus * SOAP_FMAC4 soap_in_tt__MoveStatus(struct soap *soap, const char *tag, enum tt__MoveStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__MoveStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MoveStatus, sizeof(enum tt__MoveStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__MoveStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__MoveStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MoveStatus, 0, sizeof(enum tt__MoveStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MoveStatus(struct soap *soap, const enum tt__MoveStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MoveStatus);
	if (soap_out_tt__MoveStatus(soap, tag?tag:"tt:MoveStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__MoveStatus * SOAP_FMAC4 soap_get_tt__MoveStatus(struct soap *soap, enum tt__MoveStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RelayMode(struct soap *soap, enum tt__RelayMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__RelayMode
	*a = SOAP_DEFAULT_tt__RelayMode;
#else
	*a = (enum tt__RelayMode)0;
#endif
}

static const struct soap_code_map soap_codes_tt__RelayMode[] =
{	{ (long)tt__RelayMode__Monostable, "Monostable" },
	{ (long)tt__RelayMode__Bistable, "Bistable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__RelayMode2s(struct soap *soap, enum tt__RelayMode n)
{	const char *s = soap_code_str(soap_codes_tt__RelayMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayMode(struct soap *soap, const char *tag, int id, const enum tt__RelayMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayMode), type) || soap_send(soap, soap_tt__RelayMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__RelayMode(struct soap *soap, const char *s, enum tt__RelayMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__RelayMode, s);
	if (map)
		*a = (enum tt__RelayMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__RelayMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__RelayMode * SOAP_FMAC4 soap_in_tt__RelayMode(struct soap *soap, const char *tag, enum tt__RelayMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__RelayMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayMode, sizeof(enum tt__RelayMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__RelayMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__RelayMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayMode, 0, sizeof(enum tt__RelayMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayMode(struct soap *soap, const enum tt__RelayMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RelayMode);
	if (soap_out_tt__RelayMode(soap, tag?tag:"tt:RelayMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RelayMode * SOAP_FMAC4 soap_get_tt__RelayMode(struct soap *soap, enum tt__RelayMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RelayIdleState(struct soap *soap, enum tt__RelayIdleState *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__RelayIdleState
	*a = SOAP_DEFAULT_tt__RelayIdleState;
#else
	*a = (enum tt__RelayIdleState)0;
#endif
}

static const struct soap_code_map soap_codes_tt__RelayIdleState[] =
{	{ (long)tt__RelayIdleState__closed, "closed" },
	{ (long)tt__RelayIdleState__open, "open" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__RelayIdleState2s(struct soap *soap, enum tt__RelayIdleState n)
{	const char *s = soap_code_str(soap_codes_tt__RelayIdleState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayIdleState(struct soap *soap, const char *tag, int id, const enum tt__RelayIdleState *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayIdleState), type) || soap_send(soap, soap_tt__RelayIdleState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__RelayIdleState(struct soap *soap, const char *s, enum tt__RelayIdleState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__RelayIdleState, s);
	if (map)
		*a = (enum tt__RelayIdleState)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__RelayIdleState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__RelayIdleState * SOAP_FMAC4 soap_in_tt__RelayIdleState(struct soap *soap, const char *tag, enum tt__RelayIdleState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__RelayIdleState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayIdleState, sizeof(enum tt__RelayIdleState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__RelayIdleState(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__RelayIdleState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayIdleState, 0, sizeof(enum tt__RelayIdleState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayIdleState(struct soap *soap, const enum tt__RelayIdleState *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RelayIdleState);
	if (soap_out_tt__RelayIdleState(soap, tag?tag:"tt:RelayIdleState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RelayIdleState * SOAP_FMAC4 soap_get_tt__RelayIdleState(struct soap *soap, enum tt__RelayIdleState *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayIdleState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RelayLogicalState(struct soap *soap, enum tt__RelayLogicalState *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__RelayLogicalState
	*a = SOAP_DEFAULT_tt__RelayLogicalState;
#else
	*a = (enum tt__RelayLogicalState)0;
#endif
}

static const struct soap_code_map soap_codes_tt__RelayLogicalState[] =
{	{ (long)tt__RelayLogicalState__active, "active" },
	{ (long)tt__RelayLogicalState__inactive, "inactive" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__RelayLogicalState2s(struct soap *soap, enum tt__RelayLogicalState n)
{	const char *s = soap_code_str(soap_codes_tt__RelayLogicalState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayLogicalState(struct soap *soap, const char *tag, int id, const enum tt__RelayLogicalState *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayLogicalState), type) || soap_send(soap, soap_tt__RelayLogicalState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__RelayLogicalState(struct soap *soap, const char *s, enum tt__RelayLogicalState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__RelayLogicalState, s);
	if (map)
		*a = (enum tt__RelayLogicalState)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__RelayLogicalState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__RelayLogicalState * SOAP_FMAC4 soap_in_tt__RelayLogicalState(struct soap *soap, const char *tag, enum tt__RelayLogicalState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__RelayLogicalState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayLogicalState, sizeof(enum tt__RelayLogicalState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__RelayLogicalState(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__RelayLogicalState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayLogicalState, 0, sizeof(enum tt__RelayLogicalState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayLogicalState(struct soap *soap, const enum tt__RelayLogicalState *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RelayLogicalState);
	if (soap_out_tt__RelayLogicalState(soap, tag?tag:"tt:RelayLogicalState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RelayLogicalState * SOAP_FMAC4 soap_get_tt__RelayLogicalState(struct soap *soap, enum tt__RelayLogicalState *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayLogicalState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__UserLevel(struct soap *soap, enum tt__UserLevel *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__UserLevel
	*a = SOAP_DEFAULT_tt__UserLevel;
#else
	*a = (enum tt__UserLevel)0;
#endif
}

static const struct soap_code_map soap_codes_tt__UserLevel[] =
{	{ (long)tt__UserLevel__Administrator, "Administrator" },
	{ (long)tt__UserLevel__Operator, "Operator" },
	{ (long)tt__UserLevel__User, "User" },
	{ (long)tt__UserLevel__Anonymous, "Anonymous" },
	{ (long)tt__UserLevel__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__UserLevel2s(struct soap *soap, enum tt__UserLevel n)
{	const char *s = soap_code_str(soap_codes_tt__UserLevel, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__UserLevel(struct soap *soap, const char *tag, int id, const enum tt__UserLevel *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__UserLevel), type) || soap_send(soap, soap_tt__UserLevel2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__UserLevel(struct soap *soap, const char *s, enum tt__UserLevel *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__UserLevel, s);
	if (map)
		*a = (enum tt__UserLevel)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__UserLevel)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__UserLevel * SOAP_FMAC4 soap_in_tt__UserLevel(struct soap *soap, const char *tag, enum tt__UserLevel *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__UserLevel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__UserLevel, sizeof(enum tt__UserLevel), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__UserLevel(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__UserLevel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__UserLevel, 0, sizeof(enum tt__UserLevel), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__UserLevel(struct soap *soap, const enum tt__UserLevel *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__UserLevel);
	if (soap_out_tt__UserLevel(soap, tag?tag:"tt:UserLevel", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__UserLevel * SOAP_FMAC4 soap_get_tt__UserLevel(struct soap *soap, enum tt__UserLevel *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__UserLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SetDateTimeType(struct soap *soap, enum tt__SetDateTimeType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__SetDateTimeType
	*a = SOAP_DEFAULT_tt__SetDateTimeType;
#else
	*a = (enum tt__SetDateTimeType)0;
#endif
}

static const struct soap_code_map soap_codes_tt__SetDateTimeType[] =
{	{ (long)tt__SetDateTimeType__Manual, "Manual" },
	{ (long)tt__SetDateTimeType__NTP, "NTP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__SetDateTimeType2s(struct soap *soap, enum tt__SetDateTimeType n)
{	const char *s = soap_code_str(soap_codes_tt__SetDateTimeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SetDateTimeType(struct soap *soap, const char *tag, int id, const enum tt__SetDateTimeType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SetDateTimeType), type) || soap_send(soap, soap_tt__SetDateTimeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__SetDateTimeType(struct soap *soap, const char *s, enum tt__SetDateTimeType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__SetDateTimeType, s);
	if (map)
		*a = (enum tt__SetDateTimeType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__SetDateTimeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__SetDateTimeType * SOAP_FMAC4 soap_in_tt__SetDateTimeType(struct soap *soap, const char *tag, enum tt__SetDateTimeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__SetDateTimeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SetDateTimeType, sizeof(enum tt__SetDateTimeType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__SetDateTimeType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__SetDateTimeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SetDateTimeType, 0, sizeof(enum tt__SetDateTimeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SetDateTimeType(struct soap *soap, const enum tt__SetDateTimeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SetDateTimeType);
	if (soap_out_tt__SetDateTimeType(soap, tag?tag:"tt:SetDateTimeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__SetDateTimeType * SOAP_FMAC4 soap_get_tt__SetDateTimeType(struct soap *soap, enum tt__SetDateTimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SetDateTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FactoryDefaultType(struct soap *soap, enum tt__FactoryDefaultType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__FactoryDefaultType
	*a = SOAP_DEFAULT_tt__FactoryDefaultType;
#else
	*a = (enum tt__FactoryDefaultType)0;
#endif
}

static const struct soap_code_map soap_codes_tt__FactoryDefaultType[] =
{	{ (long)tt__FactoryDefaultType__Hard, "Hard" },
	{ (long)tt__FactoryDefaultType__Soft, "Soft" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__FactoryDefaultType2s(struct soap *soap, enum tt__FactoryDefaultType n)
{	const char *s = soap_code_str(soap_codes_tt__FactoryDefaultType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FactoryDefaultType(struct soap *soap, const char *tag, int id, const enum tt__FactoryDefaultType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FactoryDefaultType), type) || soap_send(soap, soap_tt__FactoryDefaultType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__FactoryDefaultType(struct soap *soap, const char *s, enum tt__FactoryDefaultType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__FactoryDefaultType, s);
	if (map)
		*a = (enum tt__FactoryDefaultType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__FactoryDefaultType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__FactoryDefaultType * SOAP_FMAC4 soap_in_tt__FactoryDefaultType(struct soap *soap, const char *tag, enum tt__FactoryDefaultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__FactoryDefaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FactoryDefaultType, sizeof(enum tt__FactoryDefaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__FactoryDefaultType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__FactoryDefaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FactoryDefaultType, 0, sizeof(enum tt__FactoryDefaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FactoryDefaultType(struct soap *soap, const enum tt__FactoryDefaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FactoryDefaultType);
	if (soap_out_tt__FactoryDefaultType(soap, tag?tag:"tt:FactoryDefaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__FactoryDefaultType * SOAP_FMAC4 soap_get_tt__FactoryDefaultType(struct soap *soap, enum tt__FactoryDefaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FactoryDefaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemLogType(struct soap *soap, enum tt__SystemLogType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__SystemLogType
	*a = SOAP_DEFAULT_tt__SystemLogType;
#else
	*a = (enum tt__SystemLogType)0;
#endif
}

static const struct soap_code_map soap_codes_tt__SystemLogType[] =
{	{ (long)tt__SystemLogType__System, "System" },
	{ (long)tt__SystemLogType__Access, "Access" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__SystemLogType2s(struct soap *soap, enum tt__SystemLogType n)
{	const char *s = soap_code_str(soap_codes_tt__SystemLogType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLogType(struct soap *soap, const char *tag, int id, const enum tt__SystemLogType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLogType), type) || soap_send(soap, soap_tt__SystemLogType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__SystemLogType(struct soap *soap, const char *s, enum tt__SystemLogType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__SystemLogType, s);
	if (map)
		*a = (enum tt__SystemLogType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__SystemLogType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__SystemLogType * SOAP_FMAC4 soap_in_tt__SystemLogType(struct soap *soap, const char *tag, enum tt__SystemLogType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__SystemLogType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLogType, sizeof(enum tt__SystemLogType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__SystemLogType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__SystemLogType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLogType, 0, sizeof(enum tt__SystemLogType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemLogType(struct soap *soap, const enum tt__SystemLogType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SystemLogType);
	if (soap_out_tt__SystemLogType(soap, tag?tag:"tt:SystemLogType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__SystemLogType * SOAP_FMAC4 soap_get_tt__SystemLogType(struct soap *soap, enum tt__SystemLogType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLogType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CapabilityCategory(struct soap *soap, enum tt__CapabilityCategory *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__CapabilityCategory
	*a = SOAP_DEFAULT_tt__CapabilityCategory;
#else
	*a = (enum tt__CapabilityCategory)0;
#endif
}

static const struct soap_code_map soap_codes_tt__CapabilityCategory[] =
{	{ (long)tt__CapabilityCategory__All, "All" },
	{ (long)tt__CapabilityCategory__Analytics, "Analytics" },
	{ (long)tt__CapabilityCategory__Device, "Device" },
	{ (long)tt__CapabilityCategory__Events, "Events" },
	{ (long)tt__CapabilityCategory__Imaging, "Imaging" },
	{ (long)tt__CapabilityCategory__Media, "Media" },
	{ (long)tt__CapabilityCategory__PTZ, "PTZ" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__CapabilityCategory2s(struct soap *soap, enum tt__CapabilityCategory n)
{	const char *s = soap_code_str(soap_codes_tt__CapabilityCategory, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CapabilityCategory(struct soap *soap, const char *tag, int id, const enum tt__CapabilityCategory *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CapabilityCategory), type) || soap_send(soap, soap_tt__CapabilityCategory2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__CapabilityCategory(struct soap *soap, const char *s, enum tt__CapabilityCategory *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__CapabilityCategory, s);
	if (map)
		*a = (enum tt__CapabilityCategory)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__CapabilityCategory)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__CapabilityCategory * SOAP_FMAC4 soap_in_tt__CapabilityCategory(struct soap *soap, const char *tag, enum tt__CapabilityCategory *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__CapabilityCategory *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilityCategory, sizeof(enum tt__CapabilityCategory), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__CapabilityCategory(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__CapabilityCategory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CapabilityCategory, 0, sizeof(enum tt__CapabilityCategory), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CapabilityCategory(struct soap *soap, const enum tt__CapabilityCategory *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__CapabilityCategory);
	if (soap_out_tt__CapabilityCategory(soap, tag?tag:"tt:CapabilityCategory", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__CapabilityCategory * SOAP_FMAC4 soap_get_tt__CapabilityCategory(struct soap *soap, enum tt__CapabilityCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CapabilityCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DynamicDNSType(struct soap *soap, enum tt__DynamicDNSType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__DynamicDNSType
	*a = SOAP_DEFAULT_tt__DynamicDNSType;
#else
	*a = (enum tt__DynamicDNSType)0;
#endif
}

static const struct soap_code_map soap_codes_tt__DynamicDNSType[] =
{	{ (long)tt__DynamicDNSType__NoUpdate, "NoUpdate" },
	{ (long)tt__DynamicDNSType__ClientUpdates, "ClientUpdates" },
	{ (long)tt__DynamicDNSType__ServerUpdates, "ServerUpdates" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__DynamicDNSType2s(struct soap *soap, enum tt__DynamicDNSType n)
{	const char *s = soap_code_str(soap_codes_tt__DynamicDNSType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DynamicDNSType(struct soap *soap, const char *tag, int id, const enum tt__DynamicDNSType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DynamicDNSType), type) || soap_send(soap, soap_tt__DynamicDNSType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__DynamicDNSType(struct soap *soap, const char *s, enum tt__DynamicDNSType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__DynamicDNSType, s);
	if (map)
		*a = (enum tt__DynamicDNSType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__DynamicDNSType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__DynamicDNSType * SOAP_FMAC4 soap_in_tt__DynamicDNSType(struct soap *soap, const char *tag, enum tt__DynamicDNSType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__DynamicDNSType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSType, sizeof(enum tt__DynamicDNSType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__DynamicDNSType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__DynamicDNSType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DynamicDNSType, 0, sizeof(enum tt__DynamicDNSType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DynamicDNSType(struct soap *soap, const enum tt__DynamicDNSType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DynamicDNSType);
	if (soap_out_tt__DynamicDNSType(soap, tag?tag:"tt:DynamicDNSType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__DynamicDNSType * SOAP_FMAC4 soap_get_tt__DynamicDNSType(struct soap *soap, enum tt__DynamicDNSType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DynamicDNSType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPAddressFilterType(struct soap *soap, enum tt__IPAddressFilterType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__IPAddressFilterType
	*a = SOAP_DEFAULT_tt__IPAddressFilterType;
#else
	*a = (enum tt__IPAddressFilterType)0;
#endif
}

static const struct soap_code_map soap_codes_tt__IPAddressFilterType[] =
{	{ (long)tt__IPAddressFilterType__Allow, "Allow" },
	{ (long)tt__IPAddressFilterType__Deny, "Deny" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IPAddressFilterType2s(struct soap *soap, enum tt__IPAddressFilterType n)
{	const char *s = soap_code_str(soap_codes_tt__IPAddressFilterType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddressFilterType(struct soap *soap, const char *tag, int id, const enum tt__IPAddressFilterType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddressFilterType), type) || soap_send(soap, soap_tt__IPAddressFilterType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IPAddressFilterType(struct soap *soap, const char *s, enum tt__IPAddressFilterType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__IPAddressFilterType, s);
	if (map)
		*a = (enum tt__IPAddressFilterType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__IPAddressFilterType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IPAddressFilterType * SOAP_FMAC4 soap_in_tt__IPAddressFilterType(struct soap *soap, const char *tag, enum tt__IPAddressFilterType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__IPAddressFilterType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilterType, sizeof(enum tt__IPAddressFilterType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__IPAddressFilterType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__IPAddressFilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddressFilterType, 0, sizeof(enum tt__IPAddressFilterType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPAddressFilterType(struct soap *soap, const enum tt__IPAddressFilterType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPAddressFilterType);
	if (soap_out_tt__IPAddressFilterType(soap, tag?tag:"tt:IPAddressFilterType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPAddressFilterType * SOAP_FMAC4 soap_get_tt__IPAddressFilterType(struct soap *soap, enum tt__IPAddressFilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddressFilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPType(struct soap *soap, enum tt__IPType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__IPType
	*a = SOAP_DEFAULT_tt__IPType;
#else
	*a = (enum tt__IPType)0;
#endif
}

static const struct soap_code_map soap_codes_tt__IPType[] =
{	{ (long)tt__IPType__IPv4, "IPv4" },
	{ (long)tt__IPType__IPv6, "IPv6" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IPType2s(struct soap *soap, enum tt__IPType n)
{	const char *s = soap_code_str(soap_codes_tt__IPType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPType(struct soap *soap, const char *tag, int id, const enum tt__IPType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPType), type) || soap_send(soap, soap_tt__IPType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IPType(struct soap *soap, const char *s, enum tt__IPType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__IPType, s);
	if (map)
		*a = (enum tt__IPType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__IPType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IPType * SOAP_FMAC4 soap_in_tt__IPType(struct soap *soap, const char *tag, enum tt__IPType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__IPType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPType, sizeof(enum tt__IPType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__IPType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__IPType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPType, 0, sizeof(enum tt__IPType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPType(struct soap *soap, const enum tt__IPType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPType);
	if (soap_out_tt__IPType(soap, tag?tag:"tt:IPType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPType * SOAP_FMAC4 soap_get_tt__IPType(struct soap *soap, enum tt__IPType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkHostType(struct soap *soap, enum tt__NetworkHostType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__NetworkHostType
	*a = SOAP_DEFAULT_tt__NetworkHostType;
#else
	*a = (enum tt__NetworkHostType)0;
#endif
}

static const struct soap_code_map soap_codes_tt__NetworkHostType[] =
{	{ (long)tt__NetworkHostType__IPv4, "IPv4" },
	{ (long)tt__NetworkHostType__IPv6, "IPv6" },
	{ (long)tt__NetworkHostType__DNS, "DNS" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__NetworkHostType2s(struct soap *soap, enum tt__NetworkHostType n)
{	const char *s = soap_code_str(soap_codes_tt__NetworkHostType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkHostType(struct soap *soap, const char *tag, int id, const enum tt__NetworkHostType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkHostType), type) || soap_send(soap, soap_tt__NetworkHostType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__NetworkHostType(struct soap *soap, const char *s, enum tt__NetworkHostType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__NetworkHostType, s);
	if (map)
		*a = (enum tt__NetworkHostType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__NetworkHostType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__NetworkHostType * SOAP_FMAC4 soap_in_tt__NetworkHostType(struct soap *soap, const char *tag, enum tt__NetworkHostType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__NetworkHostType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHostType, sizeof(enum tt__NetworkHostType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__NetworkHostType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__NetworkHostType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHostType, 0, sizeof(enum tt__NetworkHostType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkHostType(struct soap *soap, const enum tt__NetworkHostType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkHostType);
	if (soap_out_tt__NetworkHostType(soap, tag?tag:"tt:NetworkHostType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__NetworkHostType * SOAP_FMAC4 soap_get_tt__NetworkHostType(struct soap *soap, enum tt__NetworkHostType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkHostType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkProtocolType(struct soap *soap, enum tt__NetworkProtocolType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__NetworkProtocolType
	*a = SOAP_DEFAULT_tt__NetworkProtocolType;
#else
	*a = (enum tt__NetworkProtocolType)0;
#endif
}

static const struct soap_code_map soap_codes_tt__NetworkProtocolType[] =
{	{ (long)tt__NetworkProtocolType__HTTP, "HTTP" },
	{ (long)tt__NetworkProtocolType__HTTPS, "HTTPS" },
	{ (long)tt__NetworkProtocolType__RTSP, "RTSP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__NetworkProtocolType2s(struct soap *soap, enum tt__NetworkProtocolType n)
{	const char *s = soap_code_str(soap_codes_tt__NetworkProtocolType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkProtocolType(struct soap *soap, const char *tag, int id, const enum tt__NetworkProtocolType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkProtocolType), type) || soap_send(soap, soap_tt__NetworkProtocolType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__NetworkProtocolType(struct soap *soap, const char *s, enum tt__NetworkProtocolType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__NetworkProtocolType, s);
	if (map)
		*a = (enum tt__NetworkProtocolType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__NetworkProtocolType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__NetworkProtocolType * SOAP_FMAC4 soap_in_tt__NetworkProtocolType(struct soap *soap, const char *tag, enum tt__NetworkProtocolType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__NetworkProtocolType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocolType, sizeof(enum tt__NetworkProtocolType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__NetworkProtocolType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__NetworkProtocolType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkProtocolType, 0, sizeof(enum tt__NetworkProtocolType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkProtocolType(struct soap *soap, const enum tt__NetworkProtocolType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkProtocolType);
	if (soap_out_tt__NetworkProtocolType(soap, tag?tag:"tt:NetworkProtocolType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__NetworkProtocolType * SOAP_FMAC4 soap_get_tt__NetworkProtocolType(struct soap *soap, enum tt__NetworkProtocolType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkProtocolType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__IPv6DHCPConfiguration
	*a = SOAP_DEFAULT_tt__IPv6DHCPConfiguration;
#else
	*a = (enum tt__IPv6DHCPConfiguration)0;
#endif
}

static const struct soap_code_map soap_codes_tt__IPv6DHCPConfiguration[] =
{	{ (long)tt__IPv6DHCPConfiguration__Auto, "Auto" },
	{ (long)tt__IPv6DHCPConfiguration__Stateful, "Stateful" },
	{ (long)tt__IPv6DHCPConfiguration__Stateless, "Stateless" },
	{ (long)tt__IPv6DHCPConfiguration__Off, "Off" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IPv6DHCPConfiguration2s(struct soap *soap, enum tt__IPv6DHCPConfiguration n)
{	const char *s = soap_code_str(soap_codes_tt__IPv6DHCPConfiguration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6DHCPConfiguration(struct soap *soap, const char *tag, int id, const enum tt__IPv6DHCPConfiguration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6DHCPConfiguration), type) || soap_send(soap, soap_tt__IPv6DHCPConfiguration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IPv6DHCPConfiguration(struct soap *soap, const char *s, enum tt__IPv6DHCPConfiguration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__IPv6DHCPConfiguration, s);
	if (map)
		*a = (enum tt__IPv6DHCPConfiguration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__IPv6DHCPConfiguration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration * SOAP_FMAC4 soap_in_tt__IPv6DHCPConfiguration(struct soap *soap, const char *tag, enum tt__IPv6DHCPConfiguration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__IPv6DHCPConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6DHCPConfiguration, sizeof(enum tt__IPv6DHCPConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__IPv6DHCPConfiguration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__IPv6DHCPConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6DHCPConfiguration, 0, sizeof(enum tt__IPv6DHCPConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv6DHCPConfiguration(struct soap *soap, const enum tt__IPv6DHCPConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPv6DHCPConfiguration);
	if (soap_out_tt__IPv6DHCPConfiguration(soap, tag?tag:"tt:IPv6DHCPConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration * SOAP_FMAC4 soap_get_tt__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6DHCPConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Duplex(struct soap *soap, enum tt__Duplex *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__Duplex
	*a = SOAP_DEFAULT_tt__Duplex;
#else
	*a = (enum tt__Duplex)0;
#endif
}

static const struct soap_code_map soap_codes_tt__Duplex[] =
{	{ (long)tt__Duplex__Full, "Full" },
	{ (long)tt__Duplex__Half, "Half" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Duplex2s(struct soap *soap, enum tt__Duplex n)
{	const char *s = soap_code_str(soap_codes_tt__Duplex, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Duplex(struct soap *soap, const char *tag, int id, const enum tt__Duplex *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Duplex), type) || soap_send(soap, soap_tt__Duplex2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Duplex(struct soap *soap, const char *s, enum tt__Duplex *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Duplex, s);
	if (map)
		*a = (enum tt__Duplex)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Duplex)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Duplex * SOAP_FMAC4 soap_in_tt__Duplex(struct soap *soap, const char *tag, enum tt__Duplex *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Duplex *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Duplex, sizeof(enum tt__Duplex), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__Duplex(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__Duplex *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Duplex, 0, sizeof(enum tt__Duplex), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Duplex(struct soap *soap, const enum tt__Duplex *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Duplex);
	if (soap_out_tt__Duplex(soap, tag?tag:"tt:Duplex", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Duplex * SOAP_FMAC4 soap_get_tt__Duplex(struct soap *soap, enum tt__Duplex *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Duplex(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DiscoveryMode(struct soap *soap, enum tt__DiscoveryMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__DiscoveryMode
	*a = SOAP_DEFAULT_tt__DiscoveryMode;
#else
	*a = (enum tt__DiscoveryMode)0;
#endif
}

static const struct soap_code_map soap_codes_tt__DiscoveryMode[] =
{	{ (long)tt__DiscoveryMode__Discoverable, "Discoverable" },
	{ (long)tt__DiscoveryMode__NonDiscoverable, "NonDiscoverable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__DiscoveryMode2s(struct soap *soap, enum tt__DiscoveryMode n)
{	const char *s = soap_code_str(soap_codes_tt__DiscoveryMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DiscoveryMode(struct soap *soap, const char *tag, int id, const enum tt__DiscoveryMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DiscoveryMode), type) || soap_send(soap, soap_tt__DiscoveryMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__DiscoveryMode(struct soap *soap, const char *s, enum tt__DiscoveryMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__DiscoveryMode, s);
	if (map)
		*a = (enum tt__DiscoveryMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__DiscoveryMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__DiscoveryMode * SOAP_FMAC4 soap_in_tt__DiscoveryMode(struct soap *soap, const char *tag, enum tt__DiscoveryMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__DiscoveryMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DiscoveryMode, sizeof(enum tt__DiscoveryMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__DiscoveryMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__DiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DiscoveryMode, 0, sizeof(enum tt__DiscoveryMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DiscoveryMode(struct soap *soap, const enum tt__DiscoveryMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DiscoveryMode);
	if (soap_out_tt__DiscoveryMode(soap, tag?tag:"tt:DiscoveryMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__DiscoveryMode * SOAP_FMAC4 soap_get_tt__DiscoveryMode(struct soap *soap, enum tt__DiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ScopeDefinition(struct soap *soap, enum tt__ScopeDefinition *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__ScopeDefinition
	*a = SOAP_DEFAULT_tt__ScopeDefinition;
#else
	*a = (enum tt__ScopeDefinition)0;
#endif
}

static const struct soap_code_map soap_codes_tt__ScopeDefinition[] =
{	{ (long)tt__ScopeDefinition__Fixed, "Fixed" },
	{ (long)tt__ScopeDefinition__Configurable, "Configurable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ScopeDefinition2s(struct soap *soap, enum tt__ScopeDefinition n)
{	const char *s = soap_code_str(soap_codes_tt__ScopeDefinition, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ScopeDefinition(struct soap *soap, const char *tag, int id, const enum tt__ScopeDefinition *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ScopeDefinition), type) || soap_send(soap, soap_tt__ScopeDefinition2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ScopeDefinition(struct soap *soap, const char *s, enum tt__ScopeDefinition *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ScopeDefinition, s);
	if (map)
		*a = (enum tt__ScopeDefinition)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ScopeDefinition)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ScopeDefinition * SOAP_FMAC4 soap_in_tt__ScopeDefinition(struct soap *soap, const char *tag, enum tt__ScopeDefinition *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ScopeDefinition *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ScopeDefinition, sizeof(enum tt__ScopeDefinition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__ScopeDefinition(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__ScopeDefinition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ScopeDefinition, 0, sizeof(enum tt__ScopeDefinition), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ScopeDefinition(struct soap *soap, const enum tt__ScopeDefinition *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ScopeDefinition);
	if (soap_out_tt__ScopeDefinition(soap, tag?tag:"tt:ScopeDefinition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ScopeDefinition * SOAP_FMAC4 soap_get_tt__ScopeDefinition(struct soap *soap, enum tt__ScopeDefinition *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ScopeDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TransportProtocol(struct soap *soap, enum tt__TransportProtocol *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__TransportProtocol
	*a = SOAP_DEFAULT_tt__TransportProtocol;
#else
	*a = (enum tt__TransportProtocol)0;
#endif
}

static const struct soap_code_map soap_codes_tt__TransportProtocol[] =
{	{ (long)tt__TransportProtocol__UDP, "UDP" },
	{ (long)tt__TransportProtocol__TCP, "TCP" },
	{ (long)tt__TransportProtocol__RTSP, "RTSP" },
	{ (long)tt__TransportProtocol__HTTP, "HTTP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__TransportProtocol2s(struct soap *soap, enum tt__TransportProtocol n)
{	const char *s = soap_code_str(soap_codes_tt__TransportProtocol, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TransportProtocol(struct soap *soap, const char *tag, int id, const enum tt__TransportProtocol *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TransportProtocol), type) || soap_send(soap, soap_tt__TransportProtocol2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__TransportProtocol(struct soap *soap, const char *s, enum tt__TransportProtocol *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__TransportProtocol, s);
	if (map)
		*a = (enum tt__TransportProtocol)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__TransportProtocol)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__TransportProtocol * SOAP_FMAC4 soap_in_tt__TransportProtocol(struct soap *soap, const char *tag, enum tt__TransportProtocol *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__TransportProtocol *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TransportProtocol, sizeof(enum tt__TransportProtocol), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__TransportProtocol(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__TransportProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TransportProtocol, 0, sizeof(enum tt__TransportProtocol), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TransportProtocol(struct soap *soap, const enum tt__TransportProtocol *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__TransportProtocol);
	if (soap_out_tt__TransportProtocol(soap, tag?tag:"tt:TransportProtocol", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__TransportProtocol * SOAP_FMAC4 soap_get_tt__TransportProtocol(struct soap *soap, enum tt__TransportProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TransportProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__StreamType(struct soap *soap, enum tt__StreamType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__StreamType
	*a = SOAP_DEFAULT_tt__StreamType;
#else
	*a = (enum tt__StreamType)0;
#endif
}

static const struct soap_code_map soap_codes_tt__StreamType[] =
{	{ (long)tt__StreamType__RTP_Unicast, "RTP-Unicast" },
	{ (long)tt__StreamType__RTP_Multicast, "RTP-Multicast" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__StreamType2s(struct soap *soap, enum tt__StreamType n)
{	const char *s = soap_code_str(soap_codes_tt__StreamType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StreamType(struct soap *soap, const char *tag, int id, const enum tt__StreamType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__StreamType), type) || soap_send(soap, soap_tt__StreamType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__StreamType(struct soap *soap, const char *s, enum tt__StreamType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__StreamType, s);
	if (map)
		*a = (enum tt__StreamType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__StreamType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__StreamType * SOAP_FMAC4 soap_in_tt__StreamType(struct soap *soap, const char *tag, enum tt__StreamType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__StreamType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StreamType, sizeof(enum tt__StreamType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__StreamType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__StreamType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__StreamType, 0, sizeof(enum tt__StreamType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StreamType(struct soap *soap, const enum tt__StreamType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__StreamType);
	if (soap_out_tt__StreamType(soap, tag?tag:"tt:StreamType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__StreamType * SOAP_FMAC4 soap_get_tt__StreamType(struct soap *soap, enum tt__StreamType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StreamType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioEncoding(struct soap *soap, enum tt__AudioEncoding *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__AudioEncoding
	*a = SOAP_DEFAULT_tt__AudioEncoding;
#else
	*a = (enum tt__AudioEncoding)0;
#endif
}

static const struct soap_code_map soap_codes_tt__AudioEncoding[] =
{	{ (long)tt__AudioEncoding__G711, "G711" },
	{ (long)tt__AudioEncoding__G726, "G726" },
	{ (long)tt__AudioEncoding__AAC, "AAC" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__AudioEncoding2s(struct soap *soap, enum tt__AudioEncoding n)
{	const char *s = soap_code_str(soap_codes_tt__AudioEncoding, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoding(struct soap *soap, const char *tag, int id, const enum tt__AudioEncoding *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoding), type) || soap_send(soap, soap_tt__AudioEncoding2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__AudioEncoding(struct soap *soap, const char *s, enum tt__AudioEncoding *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__AudioEncoding, s);
	if (map)
		*a = (enum tt__AudioEncoding)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__AudioEncoding)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__AudioEncoding * SOAP_FMAC4 soap_in_tt__AudioEncoding(struct soap *soap, const char *tag, enum tt__AudioEncoding *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__AudioEncoding *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoding, sizeof(enum tt__AudioEncoding), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__AudioEncoding(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__AudioEncoding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoding, 0, sizeof(enum tt__AudioEncoding), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioEncoding(struct soap *soap, const enum tt__AudioEncoding *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AudioEncoding);
	if (soap_out_tt__AudioEncoding(soap, tag?tag:"tt:AudioEncoding", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__AudioEncoding * SOAP_FMAC4 soap_get_tt__AudioEncoding(struct soap *soap, enum tt__AudioEncoding *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__H264Profile(struct soap *soap, enum tt__H264Profile *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__H264Profile
	*a = SOAP_DEFAULT_tt__H264Profile;
#else
	*a = (enum tt__H264Profile)0;
#endif
}

static const struct soap_code_map soap_codes_tt__H264Profile[] =
{	{ (long)tt__H264Profile__Baseline, "Baseline" },
	{ (long)tt__H264Profile__Main, "Main" },
	{ (long)tt__H264Profile__Extended, "Extended" },
	{ (long)tt__H264Profile__High, "High" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__H264Profile2s(struct soap *soap, enum tt__H264Profile n)
{	const char *s = soap_code_str(soap_codes_tt__H264Profile, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Profile(struct soap *soap, const char *tag, int id, const enum tt__H264Profile *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Profile), type) || soap_send(soap, soap_tt__H264Profile2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__H264Profile(struct soap *soap, const char *s, enum tt__H264Profile *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__H264Profile, s);
	if (map)
		*a = (enum tt__H264Profile)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__H264Profile)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__H264Profile * SOAP_FMAC4 soap_in_tt__H264Profile(struct soap *soap, const char *tag, enum tt__H264Profile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__H264Profile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Profile, sizeof(enum tt__H264Profile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__H264Profile(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__H264Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Profile, 0, sizeof(enum tt__H264Profile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__H264Profile(struct soap *soap, const enum tt__H264Profile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__H264Profile);
	if (soap_out_tt__H264Profile(soap, tag?tag:"tt:H264Profile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__H264Profile * SOAP_FMAC4 soap_get_tt__H264Profile(struct soap *soap, enum tt__H264Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__Mpeg4Profile
	*a = SOAP_DEFAULT_tt__Mpeg4Profile;
#else
	*a = (enum tt__Mpeg4Profile)0;
#endif
}

static const struct soap_code_map soap_codes_tt__Mpeg4Profile[] =
{	{ (long)tt__Mpeg4Profile__SP, "SP" },
	{ (long)tt__Mpeg4Profile__ASP, "ASP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Mpeg4Profile2s(struct soap *soap, enum tt__Mpeg4Profile n)
{	const char *s = soap_code_str(soap_codes_tt__Mpeg4Profile, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Profile(struct soap *soap, const char *tag, int id, const enum tt__Mpeg4Profile *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Profile), type) || soap_send(soap, soap_tt__Mpeg4Profile2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Mpeg4Profile(struct soap *soap, const char *s, enum tt__Mpeg4Profile *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Mpeg4Profile, s);
	if (map)
		*a = (enum tt__Mpeg4Profile)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Mpeg4Profile)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Mpeg4Profile * SOAP_FMAC4 soap_in_tt__Mpeg4Profile(struct soap *soap, const char *tag, enum tt__Mpeg4Profile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Mpeg4Profile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Profile, sizeof(enum tt__Mpeg4Profile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__Mpeg4Profile(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__Mpeg4Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Profile, 0, sizeof(enum tt__Mpeg4Profile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Mpeg4Profile(struct soap *soap, const enum tt__Mpeg4Profile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Mpeg4Profile);
	if (soap_out_tt__Mpeg4Profile(soap, tag?tag:"tt:Mpeg4Profile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Mpeg4Profile * SOAP_FMAC4 soap_get_tt__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoEncoding(struct soap *soap, enum tt__VideoEncoding *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__VideoEncoding
	*a = SOAP_DEFAULT_tt__VideoEncoding;
#else
	*a = (enum tt__VideoEncoding)0;
#endif
}

static const struct soap_code_map soap_codes_tt__VideoEncoding[] =
{	{ (long)tt__VideoEncoding__JPEG, "JPEG" },
	{ (long)tt__VideoEncoding__MPEG4, "MPEG4" },
	{ (long)tt__VideoEncoding__H264, "H264" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__VideoEncoding2s(struct soap *soap, enum tt__VideoEncoding n)
{	const char *s = soap_code_str(soap_codes_tt__VideoEncoding, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoding(struct soap *soap, const char *tag, int id, const enum tt__VideoEncoding *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoding), type) || soap_send(soap, soap_tt__VideoEncoding2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__VideoEncoding(struct soap *soap, const char *s, enum tt__VideoEncoding *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__VideoEncoding, s);
	if (map)
		*a = (enum tt__VideoEncoding)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__VideoEncoding)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__VideoEncoding * SOAP_FMAC4 soap_in_tt__VideoEncoding(struct soap *soap, const char *tag, enum tt__VideoEncoding *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__VideoEncoding *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoding, sizeof(enum tt__VideoEncoding), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2tt__VideoEncoding(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__VideoEncoding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoding, 0, sizeof(enum tt__VideoEncoding), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoding(struct soap *soap, const enum tt__VideoEncoding *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoEncoding);
	if (soap_out_tt__VideoEncoding(soap, tag?tag:"tt:VideoEncoding", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__VideoEncoding * SOAP_FMAC4 soap_get_tt__VideoEncoding(struct soap *soap, enum tt__VideoEncoding *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsse__FaultcodeEnum
	*a = SOAP_DEFAULT_wsse__FaultcodeEnum;
#else
	*a = (enum wsse__FaultcodeEnum)0;
#endif
}

static const struct soap_code_map soap_codes_wsse__FaultcodeEnum[] =
{	{ (long)wsse__UnsupportedSecurityToken, "wsse:UnsupportedSecurityToken" },
	{ (long)wsse__UnsupportedAlgorithm, "wsse:UnsupportedAlgorithm" },
	{ (long)wsse__InvalidSecurity, "wsse:InvalidSecurity" },
	{ (long)wsse__InvalidSecurityToken, "wsse:InvalidSecurityToken" },
	{ (long)wsse__FailedAuthentication, "wsse:FailedAuthentication" },
	{ (long)wsse__FailedCheck, "wsse:FailedCheck" },
	{ (long)wsse__SecurityTokenUnavailable, "wsse:SecurityTokenUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsse__FaultcodeEnum2s(struct soap *soap, enum wsse__FaultcodeEnum n)
{	const char *s = soap_code_str(soap_codes_wsse__FaultcodeEnum, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsse__FaultcodeEnum(struct soap *soap, const char *tag, int id, const enum wsse__FaultcodeEnum *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsse__FaultcodeEnum), type) || soap_send(soap, soap_wsse__FaultcodeEnum2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsse__FaultcodeEnum(struct soap *soap, const char *s, enum wsse__FaultcodeEnum *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, -1, -1);
	map = soap_code(soap_codes_wsse__FaultcodeEnum, t);
	if (map)
		*a = (enum wsse__FaultcodeEnum)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsse__FaultcodeEnum)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_in_wsse__FaultcodeEnum(struct soap *soap, const char *tag, enum wsse__FaultcodeEnum *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsse__FaultcodeEnum *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsse__FaultcodeEnum(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsse__FaultcodeEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsse__FaultcodeEnum, 0, sizeof(enum wsse__FaultcodeEnum), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsse__FaultcodeEnum(struct soap *soap, const enum wsse__FaultcodeEnum *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsse__FaultcodeEnum);
	if (soap_out_wsse__FaultcodeEnum(soap, tag?tag:"wsse:FaultcodeEnum", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_get_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsse__FaultcodeEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsu__tTimestampFault
	*a = SOAP_DEFAULT_wsu__tTimestampFault;
#else
	*a = (enum wsu__tTimestampFault)0;
#endif
}

static const struct soap_code_map soap_codes_wsu__tTimestampFault[] =
{	{ (long)wsu__MessageExpired, "wsu:MessageExpired" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsu__tTimestampFault2s(struct soap *soap, enum wsu__tTimestampFault n)
{	const char *s = soap_code_str(soap_codes_wsu__tTimestampFault, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsu__tTimestampFault(struct soap *soap, const char *tag, int id, const enum wsu__tTimestampFault *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsu__tTimestampFault), type) || soap_send(soap, soap_wsu__tTimestampFault2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsu__tTimestampFault(struct soap *soap, const char *s, enum wsu__tTimestampFault *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, -1, -1);
	map = soap_code(soap_codes_wsu__tTimestampFault, t);
	if (map)
		*a = (enum wsu__tTimestampFault)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsu__tTimestampFault)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_in_wsu__tTimestampFault(struct soap *soap, const char *tag, enum wsu__tTimestampFault *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsu__tTimestampFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsu__tTimestampFault(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsu__tTimestampFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsu__tTimestampFault, 0, sizeof(enum wsu__tTimestampFault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsu__tTimestampFault(struct soap *soap, const enum wsu__tTimestampFault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsu__tTimestampFault);
	if (soap_out_wsu__tTimestampFault(soap, tag?tag:"wsu:tTimestampFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_get_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsu__tTimestampFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__wsa5__IsReferenceParameter
	*a = SOAP_DEFAULT__wsa5__IsReferenceParameter;
#else
	*a = (enum _wsa5__IsReferenceParameter)0;
#endif
}

static const struct soap_code_map soap_codes__wsa5__IsReferenceParameter[] =
{	{ (long)wsa5__false, "wsa5:false" },
	{ (long)wsa5__true, "wsa5:true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__wsa5__IsReferenceParameter2s(struct soap *soap, enum _wsa5__IsReferenceParameter n)
{	const char *s = soap_code_str(soap_codes__wsa5__IsReferenceParameter, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, int id, const enum _wsa5__IsReferenceParameter *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa5__IsReferenceParameter), type) || soap_send(soap, soap__wsa5__IsReferenceParameter2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_wsa5__IsReferenceParameter(struct soap *soap, const char *s, enum _wsa5__IsReferenceParameter *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, -1, -1);
	map = soap_code(soap_codes__wsa5__IsReferenceParameter, t);
	if (map)
		*a = (enum _wsa5__IsReferenceParameter)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _wsa5__IsReferenceParameter)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_in__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _wsa5__IsReferenceParameter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_wsa5__IsReferenceParameter(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _wsa5__IsReferenceParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa5__IsReferenceParameter, 0, sizeof(enum _wsa5__IsReferenceParameter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__IsReferenceParameter(struct soap *soap, const enum _wsa5__IsReferenceParameter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa5__IsReferenceParameter);
	if (soap_out__wsa5__IsReferenceParameter(soap, tag?tag:"wsa5:IsReferenceParameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_get__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa5__IsReferenceParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsa5__FaultCodesType
	*a = SOAP_DEFAULT_wsa5__FaultCodesType;
#else
	*a = (enum wsa5__FaultCodesType)0;
#endif
}

static const struct soap_code_map soap_codes_wsa5__FaultCodesType[] =
{	{ (long)wsa5__InvalidAddressingHeader, "wsa5:InvalidAddressingHeader" },
	{ (long)wsa5__InvalidAddress, "wsa5:InvalidAddress" },
	{ (long)wsa5__InvalidEPR, "wsa5:InvalidEPR" },
	{ (long)wsa5__InvalidCardinality, "wsa5:InvalidCardinality" },
	{ (long)wsa5__MissingAddressInEPR, "wsa5:MissingAddressInEPR" },
	{ (long)wsa5__DuplicateMessageID, "wsa5:DuplicateMessageID" },
	{ (long)wsa5__ActionMismatch, "wsa5:ActionMismatch" },
	{ (long)wsa5__MessageAddressingHeaderRequired, "wsa5:MessageAddressingHeaderRequired" },
	{ (long)wsa5__DestinationUnreachable, "wsa5:DestinationUnreachable" },
	{ (long)wsa5__ActionNotSupported, "wsa5:ActionNotSupported" },
	{ (long)wsa5__EndpointUnavailable, "wsa5:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__FaultCodesType2s(struct soap *soap, enum wsa5__FaultCodesType n)
{	const char *s = soap_code_str(soap_codes_wsa5__FaultCodesType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesType(struct soap *soap, const char *tag, int id, const enum wsa5__FaultCodesType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__FaultCodesType), type) || soap_send(soap, soap_wsa5__FaultCodesType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__FaultCodesType(struct soap *soap, const char *s, enum wsa5__FaultCodesType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, -1, -1);
	map = soap_code(soap_codes_wsa5__FaultCodesType, t);
	if (map)
		*a = (enum wsa5__FaultCodesType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 10)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__FaultCodesType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_in_wsa5__FaultCodesType(struct soap *soap, const char *tag, enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__FaultCodesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsa5__FaultCodesType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsa5__FaultCodesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__FaultCodesType, 0, sizeof(enum wsa5__FaultCodesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesType(struct soap *soap, const enum wsa5__FaultCodesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__FaultCodesType);
	if (soap_out_wsa5__FaultCodesType(soap, tag?tag:"wsa5:FaultCodesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_get_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsa5__RelationshipType
	*a = SOAP_DEFAULT_wsa5__RelationshipType;
#else
	*a = (enum wsa5__RelationshipType)0;
#endif
}

static const struct soap_code_map soap_codes_wsa5__RelationshipType[] =
{	{ (long)http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply, "http://www.w3.org/2005/08/addressing/reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__RelationshipType2s(struct soap *soap, enum wsa5__RelationshipType n)
{	const char *s = soap_code_str(soap_codes_wsa5__RelationshipType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipType(struct soap *soap, const char *tag, int id, const enum wsa5__RelationshipType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__RelationshipType), type) || soap_send(soap, soap_wsa5__RelationshipType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__RelationshipType(struct soap *soap, const char *s, enum wsa5__RelationshipType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_wsa5__RelationshipType, s);
	if (map)
		*a = (enum wsa5__RelationshipType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__RelationshipType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_in_wsa5__RelationshipType(struct soap *soap, const char *tag, enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__RelationshipType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsa5__RelationshipType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsa5__RelationshipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__RelationshipType, 0, sizeof(enum wsa5__RelationshipType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipType(struct soap *soap, const enum wsa5__RelationshipType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__RelationshipType);
	if (soap_out_wsa5__RelationshipType(soap, tag?tag:"wsa5:RelationshipType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_get_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _wstop__TopicNamespaceType_Topic::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_wstop__TopicNamespaceType_Topic::documentation = NULL;
	soap_default_xsd__anyAttribute(soap, &this->_wstop__TopicNamespaceType_Topic::__anyAttribute);
	this->_wstop__TopicNamespaceType_Topic::MessagePattern = NULL;
	soap_default_std__vectorTemplateOfPointerTowstop__TopicType(soap, &this->_wstop__TopicNamespaceType_Topic::Topic);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wstop__TopicNamespaceType_Topic::__any);
	soap_default_xsd__NCName(soap, &this->_wstop__TopicNamespaceType_Topic::name);
	this->_wstop__TopicNamespaceType_Topic::messageTypes = NULL;
	this->_wstop__TopicNamespaceType_Topic::final = (bool)0;
	this->_wstop__TopicNamespaceType_Topic::parent = NULL;
}

void _wstop__TopicNamespaceType_Topic::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTowstop__Documentation(soap, &this->_wstop__TopicNamespaceType_Topic::documentation);
	soap_serialize_PointerTowstop__QueryExpressionType(soap, &this->_wstop__TopicNamespaceType_Topic::MessagePattern);
	soap_serialize_std__vectorTemplateOfPointerTowstop__TopicType(soap, &this->_wstop__TopicNamespaceType_Topic::Topic);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wstop__TopicNamespaceType_Topic::__any);
}

int _wstop__TopicNamespaceType_Topic::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wstop__TopicNamespaceType_Topic(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, int id, const _wstop__TopicNamespaceType_Topic *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_wstop__TopicNamespaceType_Topic*)a)->__anyAttribute, ""))
		return soap->error;
	if (!((_wstop__TopicNamespaceType_Topic*)a)->name.empty())
		soap_set_attr(soap, "name", ((_wstop__TopicNamespaceType_Topic*)a)->name.c_str(), 1);
	if (((_wstop__TopicNamespaceType_Topic*)a)->messageTypes)
		soap_set_attr(soap, "messageTypes", ((_wstop__TopicNamespaceType_Topic*)a)->messageTypes->c_str(), 1);
	soap_set_attr(soap, "final", soap_bool2s(soap, ((_wstop__TopicNamespaceType_Topic*)a)->final), 1);
	if (((_wstop__TopicNamespaceType_Topic*)a)->parent)
		soap_set_attr(soap, "parent", ((_wstop__TopicNamespaceType_Topic*)a)->parent->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wstop__TopicNamespaceType_Topic), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &(a->_wstop__TopicNamespaceType_Topic::documentation), ""))
		return soap->error;
	if (soap_out_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", -1, &(a->_wstop__TopicNamespaceType_Topic::MessagePattern), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowstop__TopicType(soap, "wstop:Topic", -1, &(a->_wstop__TopicNamespaceType_Topic::Topic), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_wstop__TopicNamespaceType_Topic::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wstop__TopicNamespaceType_Topic::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wstop__TopicNamespaceType_Topic(soap, tag, this, type);
}

SOAP_FMAC3 _wstop__TopicNamespaceType_Topic * SOAP_FMAC4 soap_in__wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, _wstop__TopicNamespaceType_Topic *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wstop__TopicNamespaceType_Topic *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wstop__TopicNamespaceType_Topic, sizeof(_wstop__TopicNamespaceType_Topic), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wstop__TopicNamespaceType_Topic)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wstop__TopicNamespaceType_Topic *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_wstop__TopicNamespaceType_Topic*)a)->__anyAttribute, "xsd:anyAttribute");
	{	const char *t = soap_attr_value(soap, "name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_wstop__TopicNamespaceType_Topic*)a)->name.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "messageTypes", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((_wstop__TopicNamespaceType_Topic*)a)->messageTypes = soap_new_std__string(soap, -1);
				((_wstop__TopicNamespaceType_Topic*)a)->messageTypes->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "final", 0), &((_wstop__TopicNamespaceType_Topic*)a)->final))
		return NULL;
	{	const char *t = soap_attr_value(soap, "parent", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((_wstop__TopicNamespaceType_Topic*)a)->parent = soap_new_std__string(soap, -1);
				((_wstop__TopicNamespaceType_Topic*)a)->parent->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_documentation1 = 1;
	size_t soap_flag_MessagePattern1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &(a->_wstop__TopicNamespaceType_Topic::documentation), "wstop:Documentation"))
				{	soap_flag_documentation1--;
					continue;
				}
			if (soap_flag_MessagePattern1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", &(a->_wstop__TopicNamespaceType_Topic::MessagePattern), "wstop:QueryExpressionType"))
				{	soap_flag_MessagePattern1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTowstop__TopicType(soap, "wstop:Topic", &(a->_wstop__TopicNamespaceType_Topic::Topic), "wstop:TopicType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_wstop__TopicNamespaceType_Topic::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wstop__TopicNamespaceType_Topic *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wstop__TopicNamespaceType_Topic, 0, sizeof(_wstop__TopicNamespaceType_Topic), 0, soap_copy__wstop__TopicNamespaceType_Topic);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _wstop__TopicNamespaceType_Topic::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wstop__TopicNamespaceType_Topic);
	if (this->soap_out(soap, tag?tag:"wstop:TopicNamespaceType-Topic", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wstop__TopicNamespaceType_Topic::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wstop__TopicNamespaceType_Topic(soap, this, tag, type);
}

SOAP_FMAC3 _wstop__TopicNamespaceType_Topic * SOAP_FMAC4 soap_get__wstop__TopicNamespaceType_Topic(struct soap *soap, _wstop__TopicNamespaceType_Topic *p, const char *tag, const char *type)
{
	if ((p = soap_in__wstop__TopicNamespaceType_Topic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wstop__TopicNamespaceType_Topic * SOAP_FMAC2 soap_instantiate__wstop__TopicNamespaceType_Topic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wstop__TopicNamespaceType_Topic(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wstop__TopicNamespaceType_Topic, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wstop__TopicNamespaceType_Topic);
		if (size)
			*size = sizeof(_wstop__TopicNamespaceType_Topic);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wstop__TopicNamespaceType_Topic[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wstop__TopicNamespaceType_Topic);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wstop__TopicNamespaceType_Topic*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wstop__TopicNamespaceType_Topic(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wstop__TopicNamespaceType_Topic %p -> %p\n", q, p));
	*(_wstop__TopicNamespaceType_Topic*)p = *(_wstop__TopicNamespaceType_Topic*)q;
}

void _wsrfbf__BaseFaultType_FaultCause::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &this->_wsrfbf__BaseFaultType_FaultCause::__any);
}

void _wsrfbf__BaseFaultType_FaultCause::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &this->_wsrfbf__BaseFaultType_FaultCause::__any);
}

int _wsrfbf__BaseFaultType_FaultCause::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsrfbf__BaseFaultType_FaultCause(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, int id, const _wsrfbf__BaseFaultType_FaultCause *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &(a->_wsrfbf__BaseFaultType_FaultCause::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsrfbf__BaseFaultType_FaultCause::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsrfbf__BaseFaultType_FaultCause(soap, tag, this, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC4 soap_in__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_FaultCause *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsrfbf__BaseFaultType_FaultCause *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(_wsrfbf__BaseFaultType_FaultCause), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsrfbf__BaseFaultType_FaultCause *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___any1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &(a->_wsrfbf__BaseFaultType_FaultCause::__any), "xsd:anyType"))
				{	soap_flag___any1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsrfbf__BaseFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, 0, sizeof(_wsrfbf__BaseFaultType_FaultCause), 0, soap_copy__wsrfbf__BaseFaultType_FaultCause);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _wsrfbf__BaseFaultType_FaultCause::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause);
	if (this->soap_out(soap, tag?tag:"wsrfbf:BaseFaultType-FaultCause", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsrfbf__BaseFaultType_FaultCause::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsrfbf__BaseFaultType_FaultCause(soap, this, tag, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC4 soap_get__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfbf__BaseFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsrfbf__BaseFaultType_FaultCause(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsrfbf__BaseFaultType_FaultCause);
		if (size)
			*size = sizeof(_wsrfbf__BaseFaultType_FaultCause);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsrfbf__BaseFaultType_FaultCause[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsrfbf__BaseFaultType_FaultCause);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsrfbf__BaseFaultType_FaultCause*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsrfbf__BaseFaultType_FaultCause %p -> %p\n", q, p));
	*(_wsrfbf__BaseFaultType_FaultCause*)p = *(_wsrfbf__BaseFaultType_FaultCause*)q;
}

void _wsrfbf__BaseFaultType_Description::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_wsrfbf__BaseFaultType_Description::__item);
	this->_wsrfbf__BaseFaultType_Description::xml__lang = NULL;
}

void _wsrfbf__BaseFaultType_Description::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_wsrfbf__BaseFaultType_Description::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_wsrfbf__BaseFaultType_Description::__item);
}

int _wsrfbf__BaseFaultType_Description::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsrfbf__BaseFaultType_Description(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, int id, const _wsrfbf__BaseFaultType_Description *a, const char *type)
{
	if (((_wsrfbf__BaseFaultType_Description*)a)->xml__lang)
		soap_set_attr(soap, "xml:lang", ((_wsrfbf__BaseFaultType_Description*)a)->xml__lang->c_str(), 1);
	return soap_out_std__string(soap, tag, id, &a->_wsrfbf__BaseFaultType_Description::__item, "");
}

void *_wsrfbf__BaseFaultType_Description::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsrfbf__BaseFaultType_Description(soap, tag, this, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_Description * SOAP_FMAC4 soap_in__wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_Description *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (_wsrfbf__BaseFaultType_Description *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfbf__BaseFaultType_Description, sizeof(_wsrfbf__BaseFaultType_Description), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsrfbf__BaseFaultType_Description)
			return (_wsrfbf__BaseFaultType_Description *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "xml:lang", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((_wsrfbf__BaseFaultType_Description*)a)->xml__lang = soap_new_std__string(soap, -1);
				((_wsrfbf__BaseFaultType_Description*)a)->xml__lang->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__string(soap, tag, &(a->_wsrfbf__BaseFaultType_Description::__item), ""))
		return NULL;
	return a;
}

int _wsrfbf__BaseFaultType_Description::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
	if (this->soap_out(soap, tag?tag:"wsrfbf:BaseFaultType-Description", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsrfbf__BaseFaultType_Description::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsrfbf__BaseFaultType_Description(soap, this, tag, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_Description * SOAP_FMAC4 soap_get__wsrfbf__BaseFaultType_Description(struct soap *soap, _wsrfbf__BaseFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfbf__BaseFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsrfbf__BaseFaultType_Description * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_Description(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsrfbf__BaseFaultType_Description(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsrfbf__BaseFaultType_Description, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsrfbf__BaseFaultType_Description);
		if (size)
			*size = sizeof(_wsrfbf__BaseFaultType_Description);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsrfbf__BaseFaultType_Description[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsrfbf__BaseFaultType_Description);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsrfbf__BaseFaultType_Description*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsrfbf__BaseFaultType_Description(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsrfbf__BaseFaultType_Description %p -> %p\n", q, p));
	*(_wsrfbf__BaseFaultType_Description*)p = *(_wsrfbf__BaseFaultType_Description*)q;
}

void _wsrfbf__BaseFaultType_ErrorCode::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &this->_wsrfbf__BaseFaultType_ErrorCode::dialect);
}

void _wsrfbf__BaseFaultType_ErrorCode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
}

int _wsrfbf__BaseFaultType_ErrorCode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsrfbf__BaseFaultType_ErrorCode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const _wsrfbf__BaseFaultType_ErrorCode *a, const char *type)
{
	if (!((_wsrfbf__BaseFaultType_ErrorCode*)a)->dialect.empty())
		soap_set_attr(soap, "dialect", ((_wsrfbf__BaseFaultType_ErrorCode*)a)->dialect.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsrfbf__BaseFaultType_ErrorCode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsrfbf__BaseFaultType_ErrorCode(soap, tag, this, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_ErrorCode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsrfbf__BaseFaultType_ErrorCode *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(_wsrfbf__BaseFaultType_ErrorCode), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsrfbf__BaseFaultType_ErrorCode *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "dialect", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_wsrfbf__BaseFaultType_ErrorCode*)a)->dialect.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsrfbf__BaseFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, 0, sizeof(_wsrfbf__BaseFaultType_ErrorCode), 0, soap_copy__wsrfbf__BaseFaultType_ErrorCode);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _wsrfbf__BaseFaultType_ErrorCode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode);
	if (this->soap_out(soap, tag?tag:"wsrfbf:BaseFaultType-ErrorCode", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsrfbf__BaseFaultType_ErrorCode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsrfbf__BaseFaultType_ErrorCode(soap, this, tag, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfbf__BaseFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsrfbf__BaseFaultType_ErrorCode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsrfbf__BaseFaultType_ErrorCode);
		if (size)
			*size = sizeof(_wsrfbf__BaseFaultType_ErrorCode);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsrfbf__BaseFaultType_ErrorCode[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsrfbf__BaseFaultType_ErrorCode);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsrfbf__BaseFaultType_ErrorCode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsrfbf__BaseFaultType_ErrorCode %p -> %p\n", q, p));
	*(_wsrfbf__BaseFaultType_ErrorCode*)p = *(_wsrfbf__BaseFaultType_ErrorCode*)q;
}

void _wsnb__Subscribe_SubscriptionPolicy::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__Subscribe_SubscriptionPolicy::__any);
}

void _wsnb__Subscribe_SubscriptionPolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__Subscribe_SubscriptionPolicy::__any);
}

int _wsnb__Subscribe_SubscriptionPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__Subscribe_SubscriptionPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, const _wsnb__Subscribe_SubscriptionPolicy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__Subscribe_SubscriptionPolicy), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_wsnb__Subscribe_SubscriptionPolicy::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnb__Subscribe_SubscriptionPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__Subscribe_SubscriptionPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_in__wsnb__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, _wsnb__Subscribe_SubscriptionPolicy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__Subscribe_SubscriptionPolicy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__Subscribe_SubscriptionPolicy, sizeof(_wsnb__Subscribe_SubscriptionPolicy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__Subscribe_SubscriptionPolicy)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__Subscribe_SubscriptionPolicy *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_wsnb__Subscribe_SubscriptionPolicy::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__Subscribe_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__Subscribe_SubscriptionPolicy, 0, sizeof(_wsnb__Subscribe_SubscriptionPolicy), 0, soap_copy__wsnb__Subscribe_SubscriptionPolicy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _wsnb__Subscribe_SubscriptionPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__Subscribe_SubscriptionPolicy);
	if (this->soap_out(soap, tag?tag:"wsnb:Subscribe-SubscriptionPolicy", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__Subscribe_SubscriptionPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__Subscribe_SubscriptionPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_get__wsnb__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnb__Subscribe_SubscriptionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__Subscribe_SubscriptionPolicy * SOAP_FMAC2 soap_instantiate__wsnb__Subscribe_SubscriptionPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__Subscribe_SubscriptionPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__Subscribe_SubscriptionPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__Subscribe_SubscriptionPolicy);
		if (size)
			*size = sizeof(_wsnb__Subscribe_SubscriptionPolicy);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__Subscribe_SubscriptionPolicy[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__Subscribe_SubscriptionPolicy);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__Subscribe_SubscriptionPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__Subscribe_SubscriptionPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__Subscribe_SubscriptionPolicy %p -> %p\n", q, p));
	*(_wsnb__Subscribe_SubscriptionPolicy*)p = *(_wsnb__Subscribe_SubscriptionPolicy*)q;
}

void _wsnb__NotificationMessageHolderType_Message::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &this->_wsnb__NotificationMessageHolderType_Message::__any);
}

void _wsnb__NotificationMessageHolderType_Message::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &this->_wsnb__NotificationMessageHolderType_Message::__any);
}

int _wsnb__NotificationMessageHolderType_Message::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__NotificationMessageHolderType_Message(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__NotificationMessageHolderType_Message(struct soap *soap, const char *tag, int id, const _wsnb__NotificationMessageHolderType_Message *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__NotificationMessageHolderType_Message), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &(a->_wsnb__NotificationMessageHolderType_Message::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_wsnb__NotificationMessageHolderType_Message::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__NotificationMessageHolderType_Message(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_in__wsnb__NotificationMessageHolderType_Message(struct soap *soap, const char *tag, _wsnb__NotificationMessageHolderType_Message *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__NotificationMessageHolderType_Message *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__NotificationMessageHolderType_Message, sizeof(_wsnb__NotificationMessageHolderType_Message), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__NotificationMessageHolderType_Message)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__NotificationMessageHolderType_Message *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___any1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &(a->_wsnb__NotificationMessageHolderType_Message::__any), "xsd:anyType"))
				{	soap_flag___any1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__NotificationMessageHolderType_Message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__NotificationMessageHolderType_Message, 0, sizeof(_wsnb__NotificationMessageHolderType_Message), 0, soap_copy__wsnb__NotificationMessageHolderType_Message);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _wsnb__NotificationMessageHolderType_Message::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__NotificationMessageHolderType_Message);
	if (this->soap_out(soap, tag?tag:"wsnb:NotificationMessageHolderType-Message", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__NotificationMessageHolderType_Message::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__NotificationMessageHolderType_Message(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_get__wsnb__NotificationMessageHolderType_Message(struct soap *soap, _wsnb__NotificationMessageHolderType_Message *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__NotificationMessageHolderType_Message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__NotificationMessageHolderType_Message * SOAP_FMAC2 soap_instantiate__wsnb__NotificationMessageHolderType_Message(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__NotificationMessageHolderType_Message(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__NotificationMessageHolderType_Message, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__NotificationMessageHolderType_Message);
		if (size)
			*size = sizeof(_wsnb__NotificationMessageHolderType_Message);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__NotificationMessageHolderType_Message[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__NotificationMessageHolderType_Message);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__NotificationMessageHolderType_Message*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__NotificationMessageHolderType_Message(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__NotificationMessageHolderType_Message %p -> %p\n", q, p));
	*(_wsnb__NotificationMessageHolderType_Message*)p = *(_wsnb__NotificationMessageHolderType_Message*)q;
}

void __tt__union_EventStream::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__tt__union_EventStream::__union_EventStream = 0;
}

void __tt__union_EventStream::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__tt__union_EventStream(soap, this->__tt__union_EventStream::__union_EventStream, &this->__tt__union_EventStream::union_EventStream);
}

int __tt__union_EventStream::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___tt__union_EventStream(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tt__union_EventStream(struct soap *soap, const char *tag, int id, const __tt__union_EventStream *a, const char *type)
{
	if (soap_out__tt__union_EventStream(soap, a->__tt__union_EventStream::__union_EventStream, &a->__tt__union_EventStream::union_EventStream))
		return soap->error;
	return SOAP_OK;
}

void *__tt__union_EventStream::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___tt__union_EventStream(soap, tag, this, type);
}

SOAP_FMAC3 __tt__union_EventStream * SOAP_FMAC4 soap_in___tt__union_EventStream(struct soap *soap, const char *tag, __tt__union_EventStream *a, const char *type)
{
	a = (__tt__union_EventStream *)soap_class_id_enter(soap, "", a, SOAP_TYPE___tt__union_EventStream, sizeof(__tt__union_EventStream), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	a->soap_default(soap);
		if (!soap_in__tt__union_EventStream(soap, &a->__union_EventStream, &a->union_EventStream))
			return NULL;
	return a;
}

int __tt__union_EventStream::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-tt:union-EventStream", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__tt__union_EventStream::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___tt__union_EventStream(soap, this, tag, type);
}

SOAP_FMAC3 __tt__union_EventStream * SOAP_FMAC4 soap_get___tt__union_EventStream(struct soap *soap, __tt__union_EventStream *p, const char *tag, const char *type)
{
	if ((p = soap_in___tt__union_EventStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __tt__union_EventStream * SOAP_FMAC2 soap_instantiate___tt__union_EventStream(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tt__union_EventStream(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tt__union_EventStream, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__tt__union_EventStream);
		if (size)
			*size = sizeof(__tt__union_EventStream);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(__tt__union_EventStream[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(__tt__union_EventStream);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (__tt__union_EventStream*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tt__union_EventStream(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __tt__union_EventStream %p -> %p\n", q, p));
	*(__tt__union_EventStream*)p = *(__tt__union_EventStream*)q;
}

void __tt__union_PTZStream::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__tt__union_PTZStream::__union_PTZStream = 0;
}

void __tt__union_PTZStream::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__tt__union_PTZStream(soap, this->__tt__union_PTZStream::__union_PTZStream, &this->__tt__union_PTZStream::union_PTZStream);
}

int __tt__union_PTZStream::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___tt__union_PTZStream(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tt__union_PTZStream(struct soap *soap, const char *tag, int id, const __tt__union_PTZStream *a, const char *type)
{
	if (soap_out__tt__union_PTZStream(soap, a->__tt__union_PTZStream::__union_PTZStream, &a->__tt__union_PTZStream::union_PTZStream))
		return soap->error;
	return SOAP_OK;
}

void *__tt__union_PTZStream::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___tt__union_PTZStream(soap, tag, this, type);
}

SOAP_FMAC3 __tt__union_PTZStream * SOAP_FMAC4 soap_in___tt__union_PTZStream(struct soap *soap, const char *tag, __tt__union_PTZStream *a, const char *type)
{
	a = (__tt__union_PTZStream *)soap_class_id_enter(soap, "", a, SOAP_TYPE___tt__union_PTZStream, sizeof(__tt__union_PTZStream), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	a->soap_default(soap);
		if (!soap_in__tt__union_PTZStream(soap, &a->__union_PTZStream, &a->union_PTZStream))
			return NULL;
	return a;
}

int __tt__union_PTZStream::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-tt:union-PTZStream", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__tt__union_PTZStream::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___tt__union_PTZStream(soap, this, tag, type);
}

SOAP_FMAC3 __tt__union_PTZStream * SOAP_FMAC4 soap_get___tt__union_PTZStream(struct soap *soap, __tt__union_PTZStream *p, const char *tag, const char *type)
{
	if ((p = soap_in___tt__union_PTZStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __tt__union_PTZStream * SOAP_FMAC2 soap_instantiate___tt__union_PTZStream(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tt__union_PTZStream(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tt__union_PTZStream, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__tt__union_PTZStream);
		if (size)
			*size = sizeof(__tt__union_PTZStream);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(__tt__union_PTZStream[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(__tt__union_PTZStream);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (__tt__union_PTZStream*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tt__union_PTZStream(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __tt__union_PTZStream %p -> %p\n", q, p));
	*(__tt__union_PTZStream*)p = *(__tt__union_PTZStream*)q;
}

void __tt__union_VideoAnalyticsStream::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__tt__union_VideoAnalyticsStream::__union_VideoAnalyticsStream = 0;
}

void __tt__union_VideoAnalyticsStream::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__tt__union_VideoAnalyticsStream(soap, this->__tt__union_VideoAnalyticsStream::__union_VideoAnalyticsStream, &this->__tt__union_VideoAnalyticsStream::union_VideoAnalyticsStream);
}

int __tt__union_VideoAnalyticsStream::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___tt__union_VideoAnalyticsStream(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tt__union_VideoAnalyticsStream(struct soap *soap, const char *tag, int id, const __tt__union_VideoAnalyticsStream *a, const char *type)
{
	if (soap_out__tt__union_VideoAnalyticsStream(soap, a->__tt__union_VideoAnalyticsStream::__union_VideoAnalyticsStream, &a->__tt__union_VideoAnalyticsStream::union_VideoAnalyticsStream))
		return soap->error;
	return SOAP_OK;
}

void *__tt__union_VideoAnalyticsStream::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___tt__union_VideoAnalyticsStream(soap, tag, this, type);
}

SOAP_FMAC3 __tt__union_VideoAnalyticsStream * SOAP_FMAC4 soap_in___tt__union_VideoAnalyticsStream(struct soap *soap, const char *tag, __tt__union_VideoAnalyticsStream *a, const char *type)
{
	a = (__tt__union_VideoAnalyticsStream *)soap_class_id_enter(soap, "", a, SOAP_TYPE___tt__union_VideoAnalyticsStream, sizeof(__tt__union_VideoAnalyticsStream), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	a->soap_default(soap);
		if (!soap_in__tt__union_VideoAnalyticsStream(soap, &a->__union_VideoAnalyticsStream, &a->union_VideoAnalyticsStream))
			return NULL;
	return a;
}

int __tt__union_VideoAnalyticsStream::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-tt:union-VideoAnalyticsStream", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__tt__union_VideoAnalyticsStream::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___tt__union_VideoAnalyticsStream(soap, this, tag, type);
}

SOAP_FMAC3 __tt__union_VideoAnalyticsStream * SOAP_FMAC4 soap_get___tt__union_VideoAnalyticsStream(struct soap *soap, __tt__union_VideoAnalyticsStream *p, const char *tag, const char *type)
{
	if ((p = soap_in___tt__union_VideoAnalyticsStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __tt__union_VideoAnalyticsStream * SOAP_FMAC2 soap_instantiate___tt__union_VideoAnalyticsStream(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tt__union_VideoAnalyticsStream(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tt__union_VideoAnalyticsStream, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__tt__union_VideoAnalyticsStream);
		if (size)
			*size = sizeof(__tt__union_VideoAnalyticsStream);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(__tt__union_VideoAnalyticsStream[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(__tt__union_VideoAnalyticsStream);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (__tt__union_VideoAnalyticsStream*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tt__union_VideoAnalyticsStream(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __tt__union_VideoAnalyticsStream %p -> %p\n", q, p));
	*(__tt__union_VideoAnalyticsStream*)p = *(__tt__union_VideoAnalyticsStream*)q;
}

void __tt__union_MetadataStream::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__tt__union_MetadataStream::__union_MetadataStream = 0;
}

void __tt__union_MetadataStream::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__tt__union_MetadataStream(soap, this->__tt__union_MetadataStream::__union_MetadataStream, &this->__tt__union_MetadataStream::union_MetadataStream);
}

int __tt__union_MetadataStream::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___tt__union_MetadataStream(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tt__union_MetadataStream(struct soap *soap, const char *tag, int id, const __tt__union_MetadataStream *a, const char *type)
{
	if (soap_out__tt__union_MetadataStream(soap, a->__tt__union_MetadataStream::__union_MetadataStream, &a->__tt__union_MetadataStream::union_MetadataStream))
		return soap->error;
	return SOAP_OK;
}

void *__tt__union_MetadataStream::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___tt__union_MetadataStream(soap, tag, this, type);
}

SOAP_FMAC3 __tt__union_MetadataStream * SOAP_FMAC4 soap_in___tt__union_MetadataStream(struct soap *soap, const char *tag, __tt__union_MetadataStream *a, const char *type)
{
	a = (__tt__union_MetadataStream *)soap_class_id_enter(soap, "", a, SOAP_TYPE___tt__union_MetadataStream, sizeof(__tt__union_MetadataStream), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	a->soap_default(soap);
		if (!soap_in__tt__union_MetadataStream(soap, &a->__union_MetadataStream, &a->union_MetadataStream))
			return NULL;
	return a;
}

int __tt__union_MetadataStream::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-tt:union-MetadataStream", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__tt__union_MetadataStream::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___tt__union_MetadataStream(soap, this, tag, type);
}

SOAP_FMAC3 __tt__union_MetadataStream * SOAP_FMAC4 soap_get___tt__union_MetadataStream(struct soap *soap, __tt__union_MetadataStream *p, const char *tag, const char *type)
{
	if ((p = soap_in___tt__union_MetadataStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __tt__union_MetadataStream * SOAP_FMAC2 soap_instantiate___tt__union_MetadataStream(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tt__union_MetadataStream(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tt__union_MetadataStream, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__tt__union_MetadataStream);
		if (size)
			*size = sizeof(__tt__union_MetadataStream);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(__tt__union_MetadataStream[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(__tt__union_MetadataStream);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (__tt__union_MetadataStream*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tt__union_MetadataStream(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __tt__union_MetadataStream %p -> %p\n", q, p));
	*(__tt__union_MetadataStream*)p = *(__tt__union_MetadataStream*)q;
}

void _tt__ConfigDescription_Messages::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_tt__ConfigDescription_Messages::Source = NULL;
	this->_tt__ConfigDescription_Messages::Key = NULL;
	this->_tt__ConfigDescription_Messages::Data = NULL;
	this->_tt__ConfigDescription_Messages::Extension = NULL;
	this->_tt__ConfigDescription_Messages::IsProperty = NULL;
	soap_default_xsd__anyAttribute(soap, &this->_tt__ConfigDescription_Messages::__anyAttribute);
	soap_default_std__string(soap, &this->_tt__ConfigDescription_Messages::ParentTopic);
}

void _tt__ConfigDescription_Messages::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ItemListDescription(soap, &this->_tt__ConfigDescription_Messages::Source);
	soap_serialize_PointerTott__ItemListDescription(soap, &this->_tt__ConfigDescription_Messages::Key);
	soap_serialize_PointerTott__ItemListDescription(soap, &this->_tt__ConfigDescription_Messages::Data);
	soap_serialize_PointerTott__MessageDescriptionExtension(soap, &this->_tt__ConfigDescription_Messages::Extension);
	soap_embedded(soap, &this->_tt__ConfigDescription_Messages::ParentTopic, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_tt__ConfigDescription_Messages::ParentTopic);
}

int _tt__ConfigDescription_Messages::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tt__ConfigDescription_Messages(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ConfigDescription_Messages(struct soap *soap, const char *tag, int id, const _tt__ConfigDescription_Messages *a, const char *type)
{
	if (((_tt__ConfigDescription_Messages*)a)->IsProperty)
		soap_set_attr(soap, "IsProperty", soap_bool2s(soap, *((_tt__ConfigDescription_Messages*)a)->IsProperty), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_tt__ConfigDescription_Messages*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ConfigDescription_Messages), type))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Source", -1, &(a->_tt__ConfigDescription_Messages::Source), ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Key", -1, &(a->_tt__ConfigDescription_Messages::Key), ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Data", -1, &(a->_tt__ConfigDescription_Messages::Data), ""))
		return soap->error;
	if (soap_out_PointerTott__MessageDescriptionExtension(soap, "tt:Extension", -1, &(a->_tt__ConfigDescription_Messages::Extension), ""))
		return soap->error;
	if (soap_out_std__string(soap, "tt:ParentTopic", -1, &(a->_tt__ConfigDescription_Messages::ParentTopic), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tt__ConfigDescription_Messages::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tt__ConfigDescription_Messages(soap, tag, this, type);
}

SOAP_FMAC3 _tt__ConfigDescription_Messages * SOAP_FMAC4 soap_in__tt__ConfigDescription_Messages(struct soap *soap, const char *tag, _tt__ConfigDescription_Messages *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tt__ConfigDescription_Messages *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ConfigDescription_Messages, sizeof(_tt__ConfigDescription_Messages), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tt__ConfigDescription_Messages)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tt__ConfigDescription_Messages *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "IsProperty", 0);
		if (t)
		{
			if (!(((_tt__ConfigDescription_Messages*)a)->IsProperty = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((_tt__ConfigDescription_Messages*)a)->IsProperty))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_tt__ConfigDescription_Messages*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Source1 = 1;
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_Data1 = 1;
	size_t soap_flag_Extension1 = 1;
	size_t soap_flag_ParentTopic1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescription(soap, "tt:Source", &(a->_tt__ConfigDescription_Messages::Source), "tt:ItemListDescription"))
				{	soap_flag_Source1--;
					continue;
				}
			if (soap_flag_Key1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescription(soap, "tt:Key", &(a->_tt__ConfigDescription_Messages::Key), "tt:ItemListDescription"))
				{	soap_flag_Key1--;
					continue;
				}
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescription(soap, "tt:Data", &(a->_tt__ConfigDescription_Messages::Data), "tt:ItemListDescription"))
				{	soap_flag_Data1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MessageDescriptionExtension(soap, "tt:Extension", &(a->_tt__ConfigDescription_Messages::Extension), "tt:MessageDescriptionExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			if (soap_flag_ParentTopic1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tt:ParentTopic", &(a->_tt__ConfigDescription_Messages::ParentTopic), "xsd:string"))
				{	soap_flag_ParentTopic1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tt__ConfigDescription_Messages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ConfigDescription_Messages, 0, sizeof(_tt__ConfigDescription_Messages), 0, soap_copy__tt__ConfigDescription_Messages);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ParentTopic1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tt__ConfigDescription_Messages::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tt__ConfigDescription_Messages);
	if (this->soap_out(soap, tag?tag:"tt:ConfigDescription-Messages", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tt__ConfigDescription_Messages::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tt__ConfigDescription_Messages(soap, this, tag, type);
}

SOAP_FMAC3 _tt__ConfigDescription_Messages * SOAP_FMAC4 soap_get__tt__ConfigDescription_Messages(struct soap *soap, _tt__ConfigDescription_Messages *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ConfigDescription_Messages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tt__ConfigDescription_Messages * SOAP_FMAC2 soap_instantiate__tt__ConfigDescription_Messages(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tt__ConfigDescription_Messages(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tt__ConfigDescription_Messages, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tt__ConfigDescription_Messages);
		if (size)
			*size = sizeof(_tt__ConfigDescription_Messages);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tt__ConfigDescription_Messages[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tt__ConfigDescription_Messages);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tt__ConfigDescription_Messages*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tt__ConfigDescription_Messages(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tt__ConfigDescription_Messages %p -> %p\n", q, p));
	*(_tt__ConfigDescription_Messages*)p = *(_tt__ConfigDescription_Messages*)q;
}

void _tt__Behaviour_Idle::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_tt__Behaviour_Idle::__any);
}

void _tt__Behaviour_Idle::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_tt__Behaviour_Idle::__any);
}

int _tt__Behaviour_Idle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tt__Behaviour_Idle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__Behaviour_Idle(struct soap *soap, const char *tag, int id, const _tt__Behaviour_Idle *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__Behaviour_Idle), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_tt__Behaviour_Idle::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tt__Behaviour_Idle::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tt__Behaviour_Idle(soap, tag, this, type);
}

SOAP_FMAC3 _tt__Behaviour_Idle * SOAP_FMAC4 soap_in__tt__Behaviour_Idle(struct soap *soap, const char *tag, _tt__Behaviour_Idle *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tt__Behaviour_Idle *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tt__Behaviour_Idle, sizeof(_tt__Behaviour_Idle), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tt__Behaviour_Idle)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tt__Behaviour_Idle *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_tt__Behaviour_Idle::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tt__Behaviour_Idle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__Behaviour_Idle, 0, sizeof(_tt__Behaviour_Idle), 0, soap_copy__tt__Behaviour_Idle);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tt__Behaviour_Idle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tt__Behaviour_Idle);
	if (this->soap_out(soap, tag?tag:"tt:Behaviour-Idle", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tt__Behaviour_Idle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tt__Behaviour_Idle(soap, this, tag, type);
}

SOAP_FMAC3 _tt__Behaviour_Idle * SOAP_FMAC4 soap_get__tt__Behaviour_Idle(struct soap *soap, _tt__Behaviour_Idle *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__Behaviour_Idle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tt__Behaviour_Idle * SOAP_FMAC2 soap_instantiate__tt__Behaviour_Idle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tt__Behaviour_Idle(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tt__Behaviour_Idle, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tt__Behaviour_Idle);
		if (size)
			*size = sizeof(_tt__Behaviour_Idle);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tt__Behaviour_Idle[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tt__Behaviour_Idle);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tt__Behaviour_Idle*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tt__Behaviour_Idle(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tt__Behaviour_Idle %p -> %p\n", q, p));
	*(_tt__Behaviour_Idle*)p = *(_tt__Behaviour_Idle*)q;
}

void _tt__Behaviour_Removed::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_tt__Behaviour_Removed::__any);
}

void _tt__Behaviour_Removed::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_tt__Behaviour_Removed::__any);
}

int _tt__Behaviour_Removed::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tt__Behaviour_Removed(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__Behaviour_Removed(struct soap *soap, const char *tag, int id, const _tt__Behaviour_Removed *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__Behaviour_Removed), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_tt__Behaviour_Removed::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tt__Behaviour_Removed::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tt__Behaviour_Removed(soap, tag, this, type);
}

SOAP_FMAC3 _tt__Behaviour_Removed * SOAP_FMAC4 soap_in__tt__Behaviour_Removed(struct soap *soap, const char *tag, _tt__Behaviour_Removed *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tt__Behaviour_Removed *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tt__Behaviour_Removed, sizeof(_tt__Behaviour_Removed), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tt__Behaviour_Removed)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tt__Behaviour_Removed *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_tt__Behaviour_Removed::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tt__Behaviour_Removed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__Behaviour_Removed, 0, sizeof(_tt__Behaviour_Removed), 0, soap_copy__tt__Behaviour_Removed);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tt__Behaviour_Removed::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tt__Behaviour_Removed);
	if (this->soap_out(soap, tag?tag:"tt:Behaviour-Removed", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tt__Behaviour_Removed::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tt__Behaviour_Removed(soap, this, tag, type);
}

SOAP_FMAC3 _tt__Behaviour_Removed * SOAP_FMAC4 soap_get__tt__Behaviour_Removed(struct soap *soap, _tt__Behaviour_Removed *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__Behaviour_Removed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tt__Behaviour_Removed * SOAP_FMAC2 soap_instantiate__tt__Behaviour_Removed(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tt__Behaviour_Removed(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tt__Behaviour_Removed, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tt__Behaviour_Removed);
		if (size)
			*size = sizeof(_tt__Behaviour_Removed);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tt__Behaviour_Removed[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tt__Behaviour_Removed);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tt__Behaviour_Removed*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tt__Behaviour_Removed(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tt__Behaviour_Removed %p -> %p\n", q, p));
	*(_tt__Behaviour_Removed*)p = *(_tt__Behaviour_Removed*)q;
}

void _tt__ClassDescriptor_ClassCandidate::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_tt__ClassType(soap, &this->_tt__ClassDescriptor_ClassCandidate::Type);
	soap_default_float(soap, &this->_tt__ClassDescriptor_ClassCandidate::Likelihood);
}

void _tt__ClassDescriptor_ClassCandidate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_tt__ClassDescriptor_ClassCandidate::Likelihood, SOAP_TYPE_float);
}

int _tt__ClassDescriptor_ClassCandidate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tt__ClassDescriptor_ClassCandidate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ClassDescriptor_ClassCandidate(struct soap *soap, const char *tag, int id, const _tt__ClassDescriptor_ClassCandidate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate), type))
		return soap->error;
	if (soap_out_tt__ClassType(soap, "tt:Type", -1, &(a->_tt__ClassDescriptor_ClassCandidate::Type), ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Likelihood", -1, &(a->_tt__ClassDescriptor_ClassCandidate::Likelihood), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tt__ClassDescriptor_ClassCandidate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tt__ClassDescriptor_ClassCandidate(soap, tag, this, type);
}

SOAP_FMAC3 _tt__ClassDescriptor_ClassCandidate * SOAP_FMAC4 soap_in__tt__ClassDescriptor_ClassCandidate(struct soap *soap, const char *tag, _tt__ClassDescriptor_ClassCandidate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tt__ClassDescriptor_ClassCandidate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate, sizeof(_tt__ClassDescriptor_ClassCandidate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tt__ClassDescriptor_ClassCandidate)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tt__ClassDescriptor_ClassCandidate *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Likelihood1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__ClassType(soap, "tt:Type", &(a->_tt__ClassDescriptor_ClassCandidate::Type), "tt:ClassType"))
				{	soap_flag_Type1--;
					continue;
				}
			if (soap_flag_Likelihood1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Likelihood", &(a->_tt__ClassDescriptor_ClassCandidate::Likelihood), "xsd:float"))
				{	soap_flag_Likelihood1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tt__ClassDescriptor_ClassCandidate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate, 0, sizeof(_tt__ClassDescriptor_ClassCandidate), 0, soap_copy__tt__ClassDescriptor_ClassCandidate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0 || soap_flag_Likelihood1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tt__ClassDescriptor_ClassCandidate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate);
	if (this->soap_out(soap, tag?tag:"tt:ClassDescriptor-ClassCandidate", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tt__ClassDescriptor_ClassCandidate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tt__ClassDescriptor_ClassCandidate(soap, this, tag, type);
}

SOAP_FMAC3 _tt__ClassDescriptor_ClassCandidate * SOAP_FMAC4 soap_get__tt__ClassDescriptor_ClassCandidate(struct soap *soap, _tt__ClassDescriptor_ClassCandidate *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ClassDescriptor_ClassCandidate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tt__ClassDescriptor_ClassCandidate * SOAP_FMAC2 soap_instantiate__tt__ClassDescriptor_ClassCandidate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tt__ClassDescriptor_ClassCandidate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tt__ClassDescriptor_ClassCandidate);
		if (size)
			*size = sizeof(_tt__ClassDescriptor_ClassCandidate);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tt__ClassDescriptor_ClassCandidate[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tt__ClassDescriptor_ClassCandidate);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tt__ClassDescriptor_ClassCandidate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tt__ClassDescriptor_ClassCandidate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tt__ClassDescriptor_ClassCandidate %p -> %p\n", q, p));
	*(_tt__ClassDescriptor_ClassCandidate*)p = *(_tt__ClassDescriptor_ClassCandidate*)q;
}

void _tt__ColorDescriptor_ColorCluster::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_tt__ColorDescriptor_ColorCluster::Color = NULL;
	this->_tt__ColorDescriptor_ColorCluster::Weight = NULL;
	this->_tt__ColorDescriptor_ColorCluster::Covariance = NULL;
}

void _tt__ColorDescriptor_ColorCluster::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Color(soap, &this->_tt__ColorDescriptor_ColorCluster::Color);
	soap_serialize_PointerTofloat(soap, &this->_tt__ColorDescriptor_ColorCluster::Weight);
	soap_serialize_PointerTott__ColorCovariance(soap, &this->_tt__ColorDescriptor_ColorCluster::Covariance);
}

int _tt__ColorDescriptor_ColorCluster::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tt__ColorDescriptor_ColorCluster(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, int id, const _tt__ColorDescriptor_ColorCluster *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ColorDescriptor_ColorCluster), type))
		return soap->error;
	if (a->_tt__ColorDescriptor_ColorCluster::Color)
	{	if (soap_out_PointerTott__Color(soap, "tt:Color", -1, &a->_tt__ColorDescriptor_ColorCluster::Color, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Color"))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Weight", -1, &(a->_tt__ColorDescriptor_ColorCluster::Weight), ""))
		return soap->error;
	if (soap_out_PointerTott__ColorCovariance(soap, "tt:Covariance", -1, &(a->_tt__ColorDescriptor_ColorCluster::Covariance), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tt__ColorDescriptor_ColorCluster::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tt__ColorDescriptor_ColorCluster(soap, tag, this, type);
}

SOAP_FMAC3 _tt__ColorDescriptor_ColorCluster * SOAP_FMAC4 soap_in__tt__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, _tt__ColorDescriptor_ColorCluster *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tt__ColorDescriptor_ColorCluster *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ColorDescriptor_ColorCluster, sizeof(_tt__ColorDescriptor_ColorCluster), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tt__ColorDescriptor_ColorCluster)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tt__ColorDescriptor_ColorCluster *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Color1 = 1;
	size_t soap_flag_Weight1 = 1;
	size_t soap_flag_Covariance1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Color1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Color(soap, "tt:Color", &(a->_tt__ColorDescriptor_ColorCluster::Color), "tt:Color"))
				{	soap_flag_Color1--;
					continue;
				}
			if (soap_flag_Weight1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Weight", &(a->_tt__ColorDescriptor_ColorCluster::Weight), "xsd:float"))
				{	soap_flag_Weight1--;
					continue;
				}
			if (soap_flag_Covariance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ColorCovariance(soap, "tt:Covariance", &(a->_tt__ColorDescriptor_ColorCluster::Covariance), "tt:ColorCovariance"))
				{	soap_flag_Covariance1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tt__ColorDescriptor_ColorCluster *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ColorDescriptor_ColorCluster, 0, sizeof(_tt__ColorDescriptor_ColorCluster), 0, soap_copy__tt__ColorDescriptor_ColorCluster);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Color1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tt__ColorDescriptor_ColorCluster::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tt__ColorDescriptor_ColorCluster);
	if (this->soap_out(soap, tag?tag:"tt:ColorDescriptor-ColorCluster", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tt__ColorDescriptor_ColorCluster::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tt__ColorDescriptor_ColorCluster(soap, this, tag, type);
}

SOAP_FMAC3 _tt__ColorDescriptor_ColorCluster * SOAP_FMAC4 soap_get__tt__ColorDescriptor_ColorCluster(struct soap *soap, _tt__ColorDescriptor_ColorCluster *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ColorDescriptor_ColorCluster(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tt__ColorDescriptor_ColorCluster * SOAP_FMAC2 soap_instantiate__tt__ColorDescriptor_ColorCluster(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tt__ColorDescriptor_ColorCluster(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tt__ColorDescriptor_ColorCluster, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tt__ColorDescriptor_ColorCluster);
		if (size)
			*size = sizeof(_tt__ColorDescriptor_ColorCluster);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tt__ColorDescriptor_ColorCluster[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tt__ColorDescriptor_ColorCluster);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tt__ColorDescriptor_ColorCluster*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tt__ColorDescriptor_ColorCluster(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tt__ColorDescriptor_ColorCluster %p -> %p\n", q, p));
	*(_tt__ColorDescriptor_ColorCluster*)p = *(_tt__ColorDescriptor_ColorCluster*)q;
}

void _tt__ItemListDescription_ElementItemDescription::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_tt__ItemListDescription_ElementItemDescription::Name);
	soap_default_xsd__QName(soap, &this->_tt__ItemListDescription_ElementItemDescription::Type);
}

void _tt__ItemListDescription_ElementItemDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
}

int _tt__ItemListDescription_ElementItemDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tt__ItemListDescription_ElementItemDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, int id, const _tt__ItemListDescription_ElementItemDescription *a, const char *type)
{
	if (!((_tt__ItemListDescription_ElementItemDescription*)a)->Name.empty())
		soap_set_attr(soap, "Name", ((_tt__ItemListDescription_ElementItemDescription*)a)->Name.c_str(), 1);
	if (!((_tt__ItemListDescription_ElementItemDescription*)a)->Type.empty())
		soap_set_attr(soap, "Type", soap_QName2s(soap, ((_tt__ItemListDescription_ElementItemDescription*)a)->Type.c_str()), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tt__ItemListDescription_ElementItemDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tt__ItemListDescription_ElementItemDescription(soap, tag, this, type);
}

SOAP_FMAC3 _tt__ItemListDescription_ElementItemDescription * SOAP_FMAC4 soap_in__tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, _tt__ItemListDescription_ElementItemDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tt__ItemListDescription_ElementItemDescription *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, sizeof(_tt__ItemListDescription_ElementItemDescription), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tt__ItemListDescription_ElementItemDescription)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tt__ItemListDescription_ElementItemDescription *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_tt__ItemListDescription_ElementItemDescription*)a)->Name.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Type", 1);
		if (t)
		{	char *s;
			if (soap_s2QName(soap, t, &s, -1, -1))
				return NULL;
			((_tt__ItemListDescription_ElementItemDescription*)a)->Type.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tt__ItemListDescription_ElementItemDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, 0, sizeof(_tt__ItemListDescription_ElementItemDescription), 0, soap_copy__tt__ItemListDescription_ElementItemDescription);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tt__ItemListDescription_ElementItemDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription);
	if (this->soap_out(soap, tag?tag:"tt:ItemListDescription-ElementItemDescription", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tt__ItemListDescription_ElementItemDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tt__ItemListDescription_ElementItemDescription(soap, this, tag, type);
}

SOAP_FMAC3 _tt__ItemListDescription_ElementItemDescription * SOAP_FMAC4 soap_get__tt__ItemListDescription_ElementItemDescription(struct soap *soap, _tt__ItemListDescription_ElementItemDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemListDescription_ElementItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tt__ItemListDescription_ElementItemDescription * SOAP_FMAC2 soap_instantiate__tt__ItemListDescription_ElementItemDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tt__ItemListDescription_ElementItemDescription(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tt__ItemListDescription_ElementItemDescription);
		if (size)
			*size = sizeof(_tt__ItemListDescription_ElementItemDescription);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tt__ItemListDescription_ElementItemDescription[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tt__ItemListDescription_ElementItemDescription);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tt__ItemListDescription_ElementItemDescription*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tt__ItemListDescription_ElementItemDescription(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tt__ItemListDescription_ElementItemDescription %p -> %p\n", q, p));
	*(_tt__ItemListDescription_ElementItemDescription*)p = *(_tt__ItemListDescription_ElementItemDescription*)q;
}

void _tt__ItemListDescription_SimpleItemDescription::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_tt__ItemListDescription_SimpleItemDescription::Name);
	soap_default_xsd__QName(soap, &this->_tt__ItemListDescription_SimpleItemDescription::Type);
}

void _tt__ItemListDescription_SimpleItemDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
}

int _tt__ItemListDescription_SimpleItemDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tt__ItemListDescription_SimpleItemDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, int id, const _tt__ItemListDescription_SimpleItemDescription *a, const char *type)
{
	if (!((_tt__ItemListDescription_SimpleItemDescription*)a)->Name.empty())
		soap_set_attr(soap, "Name", ((_tt__ItemListDescription_SimpleItemDescription*)a)->Name.c_str(), 1);
	if (!((_tt__ItemListDescription_SimpleItemDescription*)a)->Type.empty())
		soap_set_attr(soap, "Type", soap_QName2s(soap, ((_tt__ItemListDescription_SimpleItemDescription*)a)->Type.c_str()), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tt__ItemListDescription_SimpleItemDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tt__ItemListDescription_SimpleItemDescription(soap, tag, this, type);
}

SOAP_FMAC3 _tt__ItemListDescription_SimpleItemDescription * SOAP_FMAC4 soap_in__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, _tt__ItemListDescription_SimpleItemDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tt__ItemListDescription_SimpleItemDescription *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, sizeof(_tt__ItemListDescription_SimpleItemDescription), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tt__ItemListDescription_SimpleItemDescription *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_tt__ItemListDescription_SimpleItemDescription*)a)->Name.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Type", 1);
		if (t)
		{	char *s;
			if (soap_s2QName(soap, t, &s, -1, -1))
				return NULL;
			((_tt__ItemListDescription_SimpleItemDescription*)a)->Type.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tt__ItemListDescription_SimpleItemDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, 0, sizeof(_tt__ItemListDescription_SimpleItemDescription), 0, soap_copy__tt__ItemListDescription_SimpleItemDescription);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tt__ItemListDescription_SimpleItemDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription);
	if (this->soap_out(soap, tag?tag:"tt:ItemListDescription-SimpleItemDescription", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tt__ItemListDescription_SimpleItemDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tt__ItemListDescription_SimpleItemDescription(soap, this, tag, type);
}

SOAP_FMAC3 _tt__ItemListDescription_SimpleItemDescription * SOAP_FMAC4 soap_get__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, _tt__ItemListDescription_SimpleItemDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemListDescription_SimpleItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tt__ItemListDescription_SimpleItemDescription * SOAP_FMAC2 soap_instantiate__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tt__ItemListDescription_SimpleItemDescription(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tt__ItemListDescription_SimpleItemDescription);
		if (size)
			*size = sizeof(_tt__ItemListDescription_SimpleItemDescription);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tt__ItemListDescription_SimpleItemDescription[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tt__ItemListDescription_SimpleItemDescription);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tt__ItemListDescription_SimpleItemDescription*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tt__ItemListDescription_SimpleItemDescription %p -> %p\n", q, p));
	*(_tt__ItemListDescription_SimpleItemDescription*)p = *(_tt__ItemListDescription_SimpleItemDescription*)q;
}

void _tt__ItemList_ElementItem::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &this->_tt__ItemList_ElementItem::__any);
	soap_default_std__string(soap, &this->_tt__ItemList_ElementItem::Name);
}

void _tt__ItemList_ElementItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &this->_tt__ItemList_ElementItem::__any);
}

int _tt__ItemList_ElementItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tt__ItemList_ElementItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemList_ElementItem(struct soap *soap, const char *tag, int id, const _tt__ItemList_ElementItem *a, const char *type)
{
	if (!((_tt__ItemList_ElementItem*)a)->Name.empty())
		soap_set_attr(soap, "Name", ((_tt__ItemList_ElementItem*)a)->Name.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemList_ElementItem), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &(a->_tt__ItemList_ElementItem::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tt__ItemList_ElementItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tt__ItemList_ElementItem(soap, tag, this, type);
}

SOAP_FMAC3 _tt__ItemList_ElementItem * SOAP_FMAC4 soap_in__tt__ItemList_ElementItem(struct soap *soap, const char *tag, _tt__ItemList_ElementItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tt__ItemList_ElementItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemList_ElementItem, sizeof(_tt__ItemList_ElementItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tt__ItemList_ElementItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tt__ItemList_ElementItem *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_tt__ItemList_ElementItem*)a)->Name.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag___any1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &(a->_tt__ItemList_ElementItem::__any), "xsd:anyType"))
				{	soap_flag___any1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tt__ItemList_ElementItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemList_ElementItem, 0, sizeof(_tt__ItemList_ElementItem), 0, soap_copy__tt__ItemList_ElementItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tt__ItemList_ElementItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tt__ItemList_ElementItem);
	if (this->soap_out(soap, tag?tag:"tt:ItemList-ElementItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tt__ItemList_ElementItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tt__ItemList_ElementItem(soap, this, tag, type);
}

SOAP_FMAC3 _tt__ItemList_ElementItem * SOAP_FMAC4 soap_get__tt__ItemList_ElementItem(struct soap *soap, _tt__ItemList_ElementItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemList_ElementItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tt__ItemList_ElementItem * SOAP_FMAC2 soap_instantiate__tt__ItemList_ElementItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tt__ItemList_ElementItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tt__ItemList_ElementItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tt__ItemList_ElementItem);
		if (size)
			*size = sizeof(_tt__ItemList_ElementItem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tt__ItemList_ElementItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tt__ItemList_ElementItem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tt__ItemList_ElementItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tt__ItemList_ElementItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tt__ItemList_ElementItem %p -> %p\n", q, p));
	*(_tt__ItemList_ElementItem*)p = *(_tt__ItemList_ElementItem*)q;
}

void _tt__ItemList_SimpleItem::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_tt__ItemList_SimpleItem::Name);
	soap_default_xsd__anySimpleType(soap, &this->_tt__ItemList_SimpleItem::Value);
}

void _tt__ItemList_SimpleItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
}

int _tt__ItemList_SimpleItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tt__ItemList_SimpleItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemList_SimpleItem(struct soap *soap, const char *tag, int id, const _tt__ItemList_SimpleItem *a, const char *type)
{
	if (!((_tt__ItemList_SimpleItem*)a)->Name.empty())
		soap_set_attr(soap, "Name", ((_tt__ItemList_SimpleItem*)a)->Name.c_str(), 1);
	if (!((_tt__ItemList_SimpleItem*)a)->Value.empty())
		soap_set_attr(soap, "Value", ((_tt__ItemList_SimpleItem*)a)->Value.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemList_SimpleItem), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tt__ItemList_SimpleItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tt__ItemList_SimpleItem(soap, tag, this, type);
}

SOAP_FMAC3 _tt__ItemList_SimpleItem * SOAP_FMAC4 soap_in__tt__ItemList_SimpleItem(struct soap *soap, const char *tag, _tt__ItemList_SimpleItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tt__ItemList_SimpleItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemList_SimpleItem, sizeof(_tt__ItemList_SimpleItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tt__ItemList_SimpleItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tt__ItemList_SimpleItem *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_tt__ItemList_SimpleItem*)a)->Name.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Value", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_tt__ItemList_SimpleItem*)a)->Value.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tt__ItemList_SimpleItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemList_SimpleItem, 0, sizeof(_tt__ItemList_SimpleItem), 0, soap_copy__tt__ItemList_SimpleItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tt__ItemList_SimpleItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tt__ItemList_SimpleItem);
	if (this->soap_out(soap, tag?tag:"tt:ItemList-SimpleItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tt__ItemList_SimpleItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tt__ItemList_SimpleItem(soap, this, tag, type);
}

SOAP_FMAC3 _tt__ItemList_SimpleItem * SOAP_FMAC4 soap_get__tt__ItemList_SimpleItem(struct soap *soap, _tt__ItemList_SimpleItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemList_SimpleItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tt__ItemList_SimpleItem * SOAP_FMAC2 soap_instantiate__tt__ItemList_SimpleItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tt__ItemList_SimpleItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tt__ItemList_SimpleItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tt__ItemList_SimpleItem);
		if (size)
			*size = sizeof(_tt__ItemList_SimpleItem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tt__ItemList_SimpleItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tt__ItemList_SimpleItem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tt__ItemList_SimpleItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tt__ItemList_SimpleItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tt__ItemList_SimpleItem %p -> %p\n", q, p));
	*(_tt__ItemList_SimpleItem*)p = *(_tt__ItemList_SimpleItem*)q;
}

void _tt__EventSubscription_SubscriptionPolicy::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_tt__EventSubscription_SubscriptionPolicy::__any);
}

void _tt__EventSubscription_SubscriptionPolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_tt__EventSubscription_SubscriptionPolicy::__any);
}

int _tt__EventSubscription_SubscriptionPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tt__EventSubscription_SubscriptionPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, int id, const _tt__EventSubscription_SubscriptionPolicy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_tt__EventSubscription_SubscriptionPolicy::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tt__EventSubscription_SubscriptionPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tt__EventSubscription_SubscriptionPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _tt__EventSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_in__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, _tt__EventSubscription_SubscriptionPolicy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tt__EventSubscription_SubscriptionPolicy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, sizeof(_tt__EventSubscription_SubscriptionPolicy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tt__EventSubscription_SubscriptionPolicy *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_tt__EventSubscription_SubscriptionPolicy::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tt__EventSubscription_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, 0, sizeof(_tt__EventSubscription_SubscriptionPolicy), 0, soap_copy__tt__EventSubscription_SubscriptionPolicy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tt__EventSubscription_SubscriptionPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy);
	if (this->soap_out(soap, tag?tag:"tt:EventSubscription-SubscriptionPolicy", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tt__EventSubscription_SubscriptionPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tt__EventSubscription_SubscriptionPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _tt__EventSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_get__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, _tt__EventSubscription_SubscriptionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__EventSubscription_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tt__EventSubscription_SubscriptionPolicy * SOAP_FMAC2 soap_instantiate__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tt__EventSubscription_SubscriptionPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tt__EventSubscription_SubscriptionPolicy);
		if (size)
			*size = sizeof(_tt__EventSubscription_SubscriptionPolicy);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tt__EventSubscription_SubscriptionPolicy[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tt__EventSubscription_SubscriptionPolicy);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tt__EventSubscription_SubscriptionPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tt__EventSubscription_SubscriptionPolicy %p -> %p\n", q, p));
	*(_tt__EventSubscription_SubscriptionPolicy*)p = *(_tt__EventSubscription_SubscriptionPolicy*)q;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__SimpleTopicExpression(struct soap *soap, const char *tag, int id, const xsd__QName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__SimpleTopicExpression), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_wstop__SimpleTopicExpression(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_wstop__SimpleTopicExpression, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 2, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_wstop__SimpleTopicExpression, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_wstop__SimpleTopicExpression, 0, sizeof(std::string), 0, soap_copy_wstop__SimpleTopicExpression);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__SimpleTopicExpression(struct soap *soap, const xsd__QName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wstop__SimpleTopicExpression);
	if (soap_out_wstop__SimpleTopicExpression(soap, tag?tag:"wstop:SimpleTopicExpression", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__QName * SOAP_FMAC4 soap_get_wstop__SimpleTopicExpression(struct soap *soap, xsd__QName *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__SimpleTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__ConcreteTopicExpression(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_wstop__ConcreteTopicExpression), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_wstop__ConcreteTopicExpression(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_wstop__ConcreteTopicExpression, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_wstop__ConcreteTopicExpression, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_wstop__ConcreteTopicExpression, 0, sizeof(std::string), 0, soap_copy_wstop__ConcreteTopicExpression);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__ConcreteTopicExpression(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wstop__ConcreteTopicExpression);
	if (soap_out_wstop__ConcreteTopicExpression(soap, tag?tag:"wstop:ConcreteTopicExpression", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_wstop__ConcreteTopicExpression(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__ConcreteTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__FullTopicExpression(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_wstop__FullTopicExpression), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_wstop__FullTopicExpression(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_wstop__FullTopicExpression, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_wstop__FullTopicExpression, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_wstop__FullTopicExpression, 0, sizeof(std::string), 0, soap_copy_wstop__FullTopicExpression);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__FullTopicExpression(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wstop__FullTopicExpression);
	if (soap_out_wstop__FullTopicExpression(soap, tag?tag:"wstop:FullTopicExpression", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_wstop__FullTopicExpression(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__FullTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TopicNamespaceLocation(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__TopicNamespaceLocation), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__TopicNamespaceLocation(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_tt__TopicNamespaceLocation, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_tt__TopicNamespaceLocation, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_tt__TopicNamespaceLocation, 0, sizeof(std::string), 0, soap_copy_tt__TopicNamespaceLocation);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TopicNamespaceLocation(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__TopicNamespaceLocation);
	if (soap_out_tt__TopicNamespaceLocation(soap, tag?tag:"tt:TopicNamespaceLocation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__TopicNamespaceLocation(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TopicNamespaceLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AuxiliaryData(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__AuxiliaryData), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__AuxiliaryData(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_tt__AuxiliaryData, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, 128)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_tt__AuxiliaryData, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_tt__AuxiliaryData, 0, sizeof(std::string), 0, soap_copy_tt__AuxiliaryData);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AuxiliaryData(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AuxiliaryData);
	if (soap_out_tt__AuxiliaryData(soap, tag?tag:"tt:AuxiliaryData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__AuxiliaryData(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AuxiliaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Domain(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__Domain), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__Domain(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_tt__Domain, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_tt__Domain, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_tt__Domain, 0, sizeof(std::string), 0, soap_copy_tt__Domain);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Domain(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Domain);
	if (soap_out_tt__Domain(soap, tag?tag:"tt:Domain", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__Domain(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Domain(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DNSName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__DNSName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__DNSName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_tt__DNSName, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_tt__DNSName, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_tt__DNSName, 0, sizeof(std::string), 0, soap_copy_tt__DNSName);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DNSName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DNSName);
	if (soap_out_tt__DNSName(soap, tag?tag:"tt:DNSName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__DNSName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DNSName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__HwAddress(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__HwAddress), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__HwAddress(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_tt__HwAddress, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_tt__HwAddress, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_tt__HwAddress, 0, sizeof(std::string), 0, soap_copy_tt__HwAddress);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__HwAddress(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__HwAddress);
	if (soap_out_tt__HwAddress(soap, tag?tag:"tt:HwAddress", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__HwAddress(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__HwAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6Address(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__IPv6Address), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__IPv6Address(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_tt__IPv6Address, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_tt__IPv6Address, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_tt__IPv6Address, 0, sizeof(std::string), 0, soap_copy_tt__IPv6Address);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv6Address(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPv6Address);
	if (soap_out_tt__IPv6Address(soap, tag?tag:"tt:IPv6Address", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__IPv6Address(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4Address(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__IPv4Address), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__IPv4Address(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_tt__IPv4Address, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_tt__IPv4Address, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_tt__IPv4Address, 0, sizeof(std::string), 0, soap_copy_tt__IPv4Address);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv4Address(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPv4Address);
	if (soap_out_tt__IPv4Address(soap, tag?tag:"tt:IPv4Address", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__IPv4Address(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Name(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__Name), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__Name(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_tt__Name, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, 64)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_tt__Name, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_tt__Name, 0, sizeof(std::string), 0, soap_copy_tt__Name);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Name(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Name);
	if (soap_out_tt__Name(soap, tag?tag:"tt:Name", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__Name(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Name(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReferenceToken(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__ReferenceToken), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__ReferenceToken(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_tt__ReferenceToken, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, 64)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_tt__ReferenceToken, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_tt__ReferenceToken, 0, sizeof(std::string), 0, soap_copy_tt__ReferenceToken);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReferenceToken(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ReferenceToken);
	if (soap_out_tt__ReferenceToken(soap, tag?tag:"tt:ReferenceToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__ReferenceToken(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReferenceToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_wsnb__AbsoluteOrRelativeTimeType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_wsnb__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_wsnb__AbsoluteOrRelativeTimeType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_wsnb__AbsoluteOrRelativeTimeType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_wsnb__AbsoluteOrRelativeTimeType, 0, sizeof(std::string), 0, soap_copy_wsnb__AbsoluteOrRelativeTimeType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnb__AbsoluteOrRelativeTimeType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsnb__AbsoluteOrRelativeTimeType);
	if (soap_out_wsnb__AbsoluteOrRelativeTimeType(soap, tag?tag:"wsnb:AbsoluteOrRelativeTimeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_wsnb__AbsoluteOrRelativeTimeType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__AbsoluteOrRelativeTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wstop__TopicSetType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wstop__TopicSetType::__any);
	this->wstop__ExtensibleDocumented::documentation = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wstop__ExtensibleDocumented::__anyAttribute);
	/* transient soap skipped */
}

void wstop__TopicSetType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wstop__TopicSetType::__any);
	soap_serialize_PointerTowstop__Documentation(soap, &this->wstop__ExtensibleDocumented::documentation);
	/* transient soap skipped */
}

int wstop__TopicSetType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__TopicSetType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicSetType(struct soap *soap, const char *tag, int id, const wstop__TopicSetType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wstop__ExtensibleDocumented*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicSetType), "wstop:TopicSetType"))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &(a->wstop__ExtensibleDocumented::documentation), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wstop__TopicSetType::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wstop__TopicSetType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wstop__TopicSetType(soap, tag, this, type);
}

SOAP_FMAC3 wstop__TopicSetType * SOAP_FMAC4 soap_in_wstop__TopicSetType(struct soap *soap, const char *tag, wstop__TopicSetType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__TopicSetType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicSetType, sizeof(wstop__TopicSetType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wstop__TopicSetType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wstop__TopicSetType *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wstop__ExtensibleDocumented*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_documentation2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &(a->wstop__ExtensibleDocumented::documentation), "wstop:Documentation"))
				{	soap_flag_documentation2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wstop__TopicSetType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__TopicSetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicSetType, 0, sizeof(wstop__TopicSetType), 0, soap_copy_wstop__TopicSetType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int wstop__TopicSetType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wstop__TopicSetType);
	if (this->soap_out(soap, tag?tag:"wstop:TopicSetType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__TopicSetType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__TopicSetType(soap, this, tag, type);
}

SOAP_FMAC3 wstop__TopicSetType * SOAP_FMAC4 soap_get_wstop__TopicSetType(struct soap *soap, wstop__TopicSetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wstop__TopicSetType * SOAP_FMAC2 soap_instantiate_wstop__TopicSetType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wstop__TopicSetType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wstop__TopicSetType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wstop__TopicSetType);
		if (size)
			*size = sizeof(wstop__TopicSetType);
		((wstop__TopicSetType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wstop__TopicSetType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wstop__TopicSetType);
		for (int i = 0; i < n; i++)
			((wstop__TopicSetType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wstop__TopicSetType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wstop__TopicSetType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wstop__TopicSetType %p -> %p\n", q, p));
	*(wstop__TopicSetType*)p = *(wstop__TopicSetType*)q;
}

void wstop__TopicType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wstop__TopicType::MessagePattern = NULL;
	soap_default_std__vectorTemplateOfPointerTowstop__TopicType(soap, &this->wstop__TopicType::Topic);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wstop__TopicType::__any);
	soap_default_xsd__NCName(soap, &this->wstop__TopicType::name);
	this->wstop__TopicType::messageTypes = NULL;
	this->wstop__TopicType::final = (bool)0;
	this->wstop__ExtensibleDocumented::documentation = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wstop__ExtensibleDocumented::__anyAttribute);
	/* transient soap skipped */
}

void wstop__TopicType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTowstop__QueryExpressionType(soap, &this->wstop__TopicType::MessagePattern);
	soap_serialize_std__vectorTemplateOfPointerTowstop__TopicType(soap, &this->wstop__TopicType::Topic);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wstop__TopicType::__any);
	soap_serialize_PointerTowstop__Documentation(soap, &this->wstop__ExtensibleDocumented::documentation);
	/* transient soap skipped */
}

int wstop__TopicType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__TopicType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicType(struct soap *soap, const char *tag, int id, const wstop__TopicType *a, const char *type)
{
	if (!((wstop__TopicType*)a)->name.empty())
		soap_set_attr(soap, "name", ((wstop__TopicType*)a)->name.c_str(), 1);
	if (((wstop__TopicType*)a)->messageTypes)
		soap_set_attr(soap, "messageTypes", ((wstop__TopicType*)a)->messageTypes->c_str(), 1);
	soap_set_attr(soap, "final", soap_bool2s(soap, ((wstop__TopicType*)a)->final), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wstop__ExtensibleDocumented*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicType), "wstop:TopicType"))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &(a->wstop__ExtensibleDocumented::documentation), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", -1, &(a->wstop__TopicType::MessagePattern), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowstop__TopicType(soap, "wstop:Topic", -1, &(a->wstop__TopicType::Topic), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wstop__TopicType::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wstop__TopicType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wstop__TopicType(soap, tag, this, type);
}

SOAP_FMAC3 wstop__TopicType * SOAP_FMAC4 soap_in_wstop__TopicType(struct soap *soap, const char *tag, wstop__TopicType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__TopicType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicType, sizeof(wstop__TopicType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wstop__TopicType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wstop__TopicType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((wstop__TopicType*)a)->name.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "messageTypes", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((wstop__TopicType*)a)->messageTypes = soap_new_std__string(soap, -1);
				((wstop__TopicType*)a)->messageTypes->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "final", 0), &((wstop__TopicType*)a)->final))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wstop__ExtensibleDocumented*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_documentation2 = 1;
	size_t soap_flag_MessagePattern1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &(a->wstop__ExtensibleDocumented::documentation), "wstop:Documentation"))
				{	soap_flag_documentation2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_MessagePattern1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", &(a->wstop__TopicType::MessagePattern), "wstop:QueryExpressionType"))
				{	soap_flag_MessagePattern1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTowstop__TopicType(soap, "wstop:Topic", &(a->wstop__TopicType::Topic), "wstop:TopicType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wstop__TopicType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__TopicType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicType, 0, sizeof(wstop__TopicType), 0, soap_copy_wstop__TopicType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int wstop__TopicType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wstop__TopicType);
	if (this->soap_out(soap, tag?tag:"wstop:TopicType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__TopicType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__TopicType(soap, this, tag, type);
}

SOAP_FMAC3 wstop__TopicType * SOAP_FMAC4 soap_get_wstop__TopicType(struct soap *soap, wstop__TopicType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wstop__TopicType * SOAP_FMAC2 soap_instantiate_wstop__TopicType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wstop__TopicType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wstop__TopicType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wstop__TopicType);
		if (size)
			*size = sizeof(wstop__TopicType);
		((wstop__TopicType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wstop__TopicType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wstop__TopicType);
		for (int i = 0; i < n; i++)
			((wstop__TopicType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wstop__TopicType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wstop__TopicType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wstop__TopicType %p -> %p\n", q, p));
	*(wstop__TopicType*)p = *(wstop__TopicType*)q;
}

void wstop__TopicNamespaceType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wstop__TopicNamespaceType::__sizeTopic = 0;
	this->wstop__TopicNamespaceType::Topic = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wstop__TopicNamespaceType::__any);
	this->wstop__TopicNamespaceType::name = NULL;
	soap_default_xsd__anyURI(soap, &this->wstop__TopicNamespaceType::targetNamespace);
	this->wstop__TopicNamespaceType::final = (bool)0;
	this->wstop__ExtensibleDocumented::documentation = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wstop__ExtensibleDocumented::__anyAttribute);
	/* transient soap skipped */
}

void wstop__TopicNamespaceType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->wstop__TopicNamespaceType::Topic)
	{	int i;
		for (i = 0; i < this->wstop__TopicNamespaceType::__sizeTopic; i++)
		{
			soap_embedded(soap, this->wstop__TopicNamespaceType::Topic + i, SOAP_TYPE__wstop__TopicNamespaceType_Topic);
			this->wstop__TopicNamespaceType::Topic[i].soap_serialize(soap);
		}
	}
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wstop__TopicNamespaceType::__any);
	soap_serialize_PointerTowstop__Documentation(soap, &this->wstop__ExtensibleDocumented::documentation);
	/* transient soap skipped */
}

int wstop__TopicNamespaceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__TopicNamespaceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicNamespaceType(struct soap *soap, const char *tag, int id, const wstop__TopicNamespaceType *a, const char *type)
{
	if (((wstop__TopicNamespaceType*)a)->name)
		soap_set_attr(soap, "name", ((wstop__TopicNamespaceType*)a)->name->c_str(), 1);
	if (!((wstop__TopicNamespaceType*)a)->targetNamespace.empty())
		soap_set_attr(soap, "targetNamespace", ((wstop__TopicNamespaceType*)a)->targetNamespace.c_str(), 1);
	soap_set_attr(soap, "final", soap_bool2s(soap, ((wstop__TopicNamespaceType*)a)->final), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wstop__ExtensibleDocumented*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicNamespaceType), "wstop:TopicNamespaceType"))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &(a->wstop__ExtensibleDocumented::documentation), ""))
		return soap->error;
	/* transient soap skipped */
	if (a->wstop__TopicNamespaceType::Topic)
	{	int i;
		for (i = 0; i < a->wstop__TopicNamespaceType::__sizeTopic; i++)
			if (a->wstop__TopicNamespaceType::Topic[i].soap_out(soap, "wstop:Topic", -1, ""))
				return soap->error;
	}
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wstop__TopicNamespaceType::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wstop__TopicNamespaceType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wstop__TopicNamespaceType(soap, tag, this, type);
}

SOAP_FMAC3 wstop__TopicNamespaceType * SOAP_FMAC4 soap_in_wstop__TopicNamespaceType(struct soap *soap, const char *tag, wstop__TopicNamespaceType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__TopicNamespaceType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicNamespaceType, sizeof(wstop__TopicNamespaceType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wstop__TopicNamespaceType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wstop__TopicNamespaceType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((wstop__TopicNamespaceType*)a)->name = soap_new_std__string(soap, -1);
				((wstop__TopicNamespaceType*)a)->name->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "targetNamespace", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((wstop__TopicNamespaceType*)a)->targetNamespace.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "final", 0), &((wstop__TopicNamespaceType*)a)->final))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wstop__ExtensibleDocumented*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_documentation2 = 1;
	struct soap_blist *soap_blist_Topic1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &(a->wstop__ExtensibleDocumented::documentation), "wstop:Documentation"))
				{	soap_flag_documentation2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wstop:Topic", 1, NULL))
			{	if (a->wstop__TopicNamespaceType::Topic == NULL)
				{	if (soap_blist_Topic1 == NULL)
						soap_blist_Topic1 = soap_new_block(soap);
					a->wstop__TopicNamespaceType::Topic = (_wstop__TopicNamespaceType_Topic *)soap_push_block(soap, soap_blist_Topic1, sizeof(_wstop__TopicNamespaceType_Topic));
					if (a->wstop__TopicNamespaceType::Topic == NULL)
						return NULL;
					_wstop__TopicNamespaceType_Topic p;
					memcpy(a->wstop__TopicNamespaceType::Topic, &p, sizeof(_wstop__TopicNamespaceType_Topic)); // a bit rough but portable
					a->wstop__TopicNamespaceType::Topic->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__wstop__TopicNamespaceType_Topic(soap, "wstop:Topic", a->wstop__TopicNamespaceType::Topic, ""))
				{	a->wstop__TopicNamespaceType::__sizeTopic++;
					a->wstop__TopicNamespaceType::Topic = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wstop__TopicNamespaceType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wstop__TopicNamespaceType::Topic)
			soap_pop_block(soap, soap_blist_Topic1);
		if (a->wstop__TopicNamespaceType::__sizeTopic)
			a->wstop__TopicNamespaceType::Topic = (_wstop__TopicNamespaceType_Topic *)soap_save_block(soap, soap_blist_Topic1, NULL, 1);
		else
		{	a->wstop__TopicNamespaceType::Topic = NULL;
			if (soap_blist_Topic1)
				soap_end_block(soap, soap_blist_Topic1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__TopicNamespaceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicNamespaceType, 0, sizeof(wstop__TopicNamespaceType), 0, soap_copy_wstop__TopicNamespaceType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int wstop__TopicNamespaceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wstop__TopicNamespaceType);
	if (this->soap_out(soap, tag?tag:"wstop:TopicNamespaceType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__TopicNamespaceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__TopicNamespaceType(soap, this, tag, type);
}

SOAP_FMAC3 wstop__TopicNamespaceType * SOAP_FMAC4 soap_get_wstop__TopicNamespaceType(struct soap *soap, wstop__TopicNamespaceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicNamespaceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wstop__TopicNamespaceType * SOAP_FMAC2 soap_instantiate_wstop__TopicNamespaceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wstop__TopicNamespaceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wstop__TopicNamespaceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wstop__TopicNamespaceType);
		if (size)
			*size = sizeof(wstop__TopicNamespaceType);
		((wstop__TopicNamespaceType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wstop__TopicNamespaceType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wstop__TopicNamespaceType);
		for (int i = 0; i < n; i++)
			((wstop__TopicNamespaceType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wstop__TopicNamespaceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wstop__TopicNamespaceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wstop__TopicNamespaceType %p -> %p\n", q, p));
	*(wstop__TopicNamespaceType*)p = *(wstop__TopicNamespaceType*)q;
}

void wstop__QueryExpressionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyType(soap, &this->wstop__QueryExpressionType::__any);
	soap_default_xsd__anyURI(soap, &this->wstop__QueryExpressionType::Dialect);
	soap_default_xsd__anyType(soap, &this->wstop__QueryExpressionType::__mixed);
	/* transient soap skipped */
}

void wstop__QueryExpressionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &this->wstop__QueryExpressionType::__any);
	soap_serialize_xsd__anyType(soap, &this->wstop__QueryExpressionType::__mixed);
	/* transient soap skipped */
}

int wstop__QueryExpressionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__QueryExpressionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__QueryExpressionType(struct soap *soap, const char *tag, int id, const wstop__QueryExpressionType *a, const char *type)
{
	if (!((wstop__QueryExpressionType*)a)->Dialect.empty())
		soap_set_attr(soap, "Dialect", ((wstop__QueryExpressionType*)a)->Dialect.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__QueryExpressionType), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &(a->wstop__QueryExpressionType::__any), ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &(a->wstop__QueryExpressionType::__mixed), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wstop__QueryExpressionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wstop__QueryExpressionType(soap, tag, this, type);
}

SOAP_FMAC3 wstop__QueryExpressionType * SOAP_FMAC4 soap_in_wstop__QueryExpressionType(struct soap *soap, const char *tag, wstop__QueryExpressionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__QueryExpressionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__QueryExpressionType, sizeof(wstop__QueryExpressionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wstop__QueryExpressionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wstop__QueryExpressionType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Dialect", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((wstop__QueryExpressionType*)a)->Dialect.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag___any1 = 1;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag___any1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &(a->wstop__QueryExpressionType::__any), "xsd:anyType"))
				{	soap_flag___any1--;
					continue;
				}
			if (soap_flag___mixed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &(a->wstop__QueryExpressionType::__mixed), "xsd:anyType"))
				{	soap_flag___mixed1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__QueryExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__QueryExpressionType, 0, sizeof(wstop__QueryExpressionType), 0, soap_copy_wstop__QueryExpressionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int wstop__QueryExpressionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wstop__QueryExpressionType);
	if (this->soap_out(soap, tag?tag:"wstop:QueryExpressionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__QueryExpressionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__QueryExpressionType(soap, this, tag, type);
}

SOAP_FMAC3 wstop__QueryExpressionType * SOAP_FMAC4 soap_get_wstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wstop__QueryExpressionType * SOAP_FMAC2 soap_instantiate_wstop__QueryExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wstop__QueryExpressionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wstop__QueryExpressionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wstop__QueryExpressionType);
		if (size)
			*size = sizeof(wstop__QueryExpressionType);
		((wstop__QueryExpressionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wstop__QueryExpressionType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wstop__QueryExpressionType);
		for (int i = 0; i < n; i++)
			((wstop__QueryExpressionType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wstop__QueryExpressionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wstop__QueryExpressionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wstop__QueryExpressionType %p -> %p\n", q, p));
	*(wstop__QueryExpressionType*)p = *(wstop__QueryExpressionType*)q;
}

void wstop__ExtensibleDocumented::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wstop__ExtensibleDocumented::documentation = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wstop__ExtensibleDocumented::__anyAttribute);
	/* transient soap skipped */
}

void wstop__ExtensibleDocumented::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTowstop__Documentation(soap, &this->wstop__ExtensibleDocumented::documentation);
	/* transient soap skipped */
}

int wstop__ExtensibleDocumented::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__ExtensibleDocumented(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__ExtensibleDocumented(struct soap *soap, const char *tag, int id, const wstop__ExtensibleDocumented *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wstop__ExtensibleDocumented*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__ExtensibleDocumented), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &(a->wstop__ExtensibleDocumented::documentation), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wstop__ExtensibleDocumented::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wstop__ExtensibleDocumented(soap, tag, this, type);
}

SOAP_FMAC3 wstop__ExtensibleDocumented * SOAP_FMAC4 soap_in_wstop__ExtensibleDocumented(struct soap *soap, const char *tag, wstop__ExtensibleDocumented *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__ExtensibleDocumented *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__ExtensibleDocumented, sizeof(wstop__ExtensibleDocumented), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wstop__ExtensibleDocumented)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wstop__ExtensibleDocumented *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wstop__ExtensibleDocumented*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_documentation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &(a->wstop__ExtensibleDocumented::documentation), "wstop:Documentation"))
				{	soap_flag_documentation1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__ExtensibleDocumented *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__ExtensibleDocumented, 0, sizeof(wstop__ExtensibleDocumented), 0, soap_copy_wstop__ExtensibleDocumented);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int wstop__ExtensibleDocumented::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wstop__ExtensibleDocumented);
	if (this->soap_out(soap, tag?tag:"wstop:ExtensibleDocumented", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__ExtensibleDocumented::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__ExtensibleDocumented(soap, this, tag, type);
}

SOAP_FMAC3 wstop__ExtensibleDocumented * SOAP_FMAC4 soap_get_wstop__ExtensibleDocumented(struct soap *soap, wstop__ExtensibleDocumented *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__ExtensibleDocumented(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wstop__ExtensibleDocumented * SOAP_FMAC2 soap_instantiate_wstop__ExtensibleDocumented(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wstop__ExtensibleDocumented(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wstop__ExtensibleDocumented, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "wstop:TopicNamespaceType"))
	{	cp->type = SOAP_TYPE_wstop__TopicNamespaceType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wstop__TopicNamespaceType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wstop__TopicNamespaceType);
			((wstop__TopicNamespaceType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wstop__TopicNamespaceType[n]);
			if (size)
				*size = n * sizeof(wstop__TopicNamespaceType);
			for (int i = 0; i < n; i++)
				((wstop__TopicNamespaceType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wstop__TopicNamespaceType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "wstop:TopicType"))
	{	cp->type = SOAP_TYPE_wstop__TopicType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wstop__TopicType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wstop__TopicType);
			((wstop__TopicType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wstop__TopicType[n]);
			if (size)
				*size = n * sizeof(wstop__TopicType);
			for (int i = 0; i < n; i++)
				((wstop__TopicType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wstop__TopicType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "wstop:TopicSetType"))
	{	cp->type = SOAP_TYPE_wstop__TopicSetType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wstop__TopicSetType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wstop__TopicSetType);
			((wstop__TopicSetType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wstop__TopicSetType[n]);
			if (size)
				*size = n * sizeof(wstop__TopicSetType);
			for (int i = 0; i < n; i++)
				((wstop__TopicSetType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wstop__TopicSetType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wstop__ExtensibleDocumented);
		if (size)
			*size = sizeof(wstop__ExtensibleDocumented);
		((wstop__ExtensibleDocumented*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wstop__ExtensibleDocumented[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wstop__ExtensibleDocumented);
		for (int i = 0; i < n; i++)
			((wstop__ExtensibleDocumented*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wstop__ExtensibleDocumented*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wstop__ExtensibleDocumented(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wstop__ExtensibleDocumented %p -> %p\n", q, p));
	*(wstop__ExtensibleDocumented*)p = *(wstop__ExtensibleDocumented*)q;
}

void wstop__Documentation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wstop__Documentation::__any);
	soap_default_xsd__anyType(soap, &this->wstop__Documentation::__mixed);
	/* transient soap skipped */
}

void wstop__Documentation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wstop__Documentation::__any);
	soap_serialize_xsd__anyType(soap, &this->wstop__Documentation::__mixed);
	/* transient soap skipped */
}

int wstop__Documentation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wstop__Documentation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__Documentation(struct soap *soap, const char *tag, int id, const wstop__Documentation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__Documentation), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wstop__Documentation::__any), ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &(a->wstop__Documentation::__mixed), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wstop__Documentation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wstop__Documentation(soap, tag, this, type);
}

SOAP_FMAC3 wstop__Documentation * SOAP_FMAC4 soap_in_wstop__Documentation(struct soap *soap, const char *tag, wstop__Documentation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wstop__Documentation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__Documentation, sizeof(wstop__Documentation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wstop__Documentation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wstop__Documentation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___mixed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wstop__Documentation::__any), "xsd:anyType"))
					continue;
			if (soap_flag___mixed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &(a->wstop__Documentation::__mixed), "xsd:anyType"))
				{	soap_flag___mixed1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wstop__Documentation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__Documentation, 0, sizeof(wstop__Documentation), 0, soap_copy_wstop__Documentation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int wstop__Documentation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wstop__Documentation);
	if (this->soap_out(soap, tag?tag:"wstop:Documentation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wstop__Documentation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wstop__Documentation(soap, this, tag, type);
}

SOAP_FMAC3 wstop__Documentation * SOAP_FMAC4 soap_get_wstop__Documentation(struct soap *soap, wstop__Documentation *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__Documentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wstop__Documentation * SOAP_FMAC2 soap_instantiate_wstop__Documentation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wstop__Documentation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wstop__Documentation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wstop__Documentation);
		if (size)
			*size = sizeof(wstop__Documentation);
		((wstop__Documentation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wstop__Documentation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wstop__Documentation);
		for (int i = 0; i < n; i++)
			((wstop__Documentation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wstop__Documentation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wstop__Documentation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wstop__Documentation %p -> %p\n", q, p));
	*(wstop__Documentation*)p = *(wstop__Documentation*)q;
}

void wsrfbf__BaseFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_time(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	this->wsrfbf__BaseFaultType::__sizeDescription = 0;
	this->wsrfbf__BaseFaultType::Description = NULL;
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsrfbf__BaseFaultType::__anyAttribute);
	/* transient soap skipped */
}

void wsrfbf__BaseFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	if (this->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->wsrfbf__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->wsrfbf__BaseFaultType::Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			this->wsrfbf__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int wsrfbf__BaseFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsrfbf__BaseFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrfbf__BaseFaultType(struct soap *soap, const char *tag, int id, const wsrfbf__BaseFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrfbf__BaseFaultType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsrfbf__BaseFaultType::__any), ""))
		return soap->error;
	if (soap_out_time(soap, "wsrfbf:Timestamp", -1, &(a->wsrfbf__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &(a->wsrfbf__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->wsrfbf__BaseFaultType::__sizeDescription; i++)
			if (a->wsrfbf__BaseFaultType::Description[i].soap_out(soap, "wsrfbf:Description", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &(a->wsrfbf__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wsrfbf__BaseFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsrfbf__BaseFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsrfbf__BaseFaultType * SOAP_FMAC4 soap_in_wsrfbf__BaseFaultType(struct soap *soap, const char *tag, wsrfbf__BaseFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsrfbf__BaseFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsrfbf__BaseFaultType, sizeof(wsrfbf__BaseFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsrfbf__BaseFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsrfbf__BaseFaultType *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_Originator1 = 1;
	size_t soap_flag_ErrorCode1 = 1;
	struct soap_blist *soap_blist_Description1 = NULL;
	size_t soap_flag_FaultCause1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsrfbf:Timestamp", &(a->wsrfbf__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			if (soap_flag_Originator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &(a->wsrfbf__BaseFaultType::Originator), "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator1--;
					continue;
				}
			if (soap_flag_ErrorCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__BaseFaultType::Description == NULL)
				{	if (soap_blist_Description1 == NULL)
						soap_blist_Description1 = soap_new_block(soap);
					a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_push_block(soap, soap_blist_Description1, sizeof(_wsrfbf__BaseFaultType_Description));
					if (a->wsrfbf__BaseFaultType::Description == NULL)
						return NULL;
					_wsrfbf__BaseFaultType_Description p;
					memcpy(a->wsrfbf__BaseFaultType::Description, &p, sizeof(_wsrfbf__BaseFaultType_Description)); // a bit rough but portable
					a->wsrfbf__BaseFaultType::Description->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__BaseFaultType::Description, ""))
				{	a->wsrfbf__BaseFaultType::__sizeDescription++;
					a->wsrfbf__BaseFaultType::Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &(a->wsrfbf__BaseFaultType::FaultCause), ""))
				{	soap_flag_FaultCause1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsrfbf__BaseFaultType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__BaseFaultType::Description)
			soap_pop_block(soap, soap_blist_Description1);
		if (a->wsrfbf__BaseFaultType::__sizeDescription)
			a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description1, NULL, 1);
		else
		{	a->wsrfbf__BaseFaultType::Description = NULL;
			if (soap_blist_Description1)
				soap_end_block(soap, soap_blist_Description1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsrfbf__BaseFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrfbf__BaseFaultType, 0, sizeof(wsrfbf__BaseFaultType), 0, soap_copy_wsrfbf__BaseFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int wsrfbf__BaseFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsrfbf__BaseFaultType);
	if (this->soap_out(soap, tag?tag:"wsrfbf:BaseFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsrfbf__BaseFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsrfbf__BaseFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsrfbf__BaseFaultType * SOAP_FMAC4 soap_get_wsrfbf__BaseFaultType(struct soap *soap, wsrfbf__BaseFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrfbf__BaseFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsrfbf__BaseFaultType * SOAP_FMAC2 soap_instantiate_wsrfbf__BaseFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrfbf__BaseFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsrfbf__BaseFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "wsnb:SubscribeCreationFailedFaultType"))
	{	cp->type = SOAP_TYPE_wsnb__SubscribeCreationFailedFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wsnb__SubscribeCreationFailedFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wsnb__SubscribeCreationFailedFaultType);
			((wsnb__SubscribeCreationFailedFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wsnb__SubscribeCreationFailedFaultType[n]);
			if (size)
				*size = n * sizeof(wsnb__SubscribeCreationFailedFaultType);
			for (int i = 0; i < n; i++)
				((wsnb__SubscribeCreationFailedFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wsnb__SubscribeCreationFailedFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "wsnb:InvalidFilterFaultType"))
	{	cp->type = SOAP_TYPE_wsnb__InvalidFilterFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wsnb__InvalidFilterFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wsnb__InvalidFilterFaultType);
			((wsnb__InvalidFilterFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wsnb__InvalidFilterFaultType[n]);
			if (size)
				*size = n * sizeof(wsnb__InvalidFilterFaultType);
			for (int i = 0; i < n; i++)
				((wsnb__InvalidFilterFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wsnb__InvalidFilterFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "wsnb:TopicExpressionDialectUnknownFaultType"))
	{	cp->type = SOAP_TYPE_wsnb__TopicExpressionDialectUnknownFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wsnb__TopicExpressionDialectUnknownFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wsnb__TopicExpressionDialectUnknownFaultType);
			((wsnb__TopicExpressionDialectUnknownFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wsnb__TopicExpressionDialectUnknownFaultType[n]);
			if (size)
				*size = n * sizeof(wsnb__TopicExpressionDialectUnknownFaultType);
			for (int i = 0; i < n; i++)
				((wsnb__TopicExpressionDialectUnknownFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wsnb__TopicExpressionDialectUnknownFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "wsnb:InvalidTopicExpressionFaultType"))
	{	cp->type = SOAP_TYPE_wsnb__InvalidTopicExpressionFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wsnb__InvalidTopicExpressionFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wsnb__InvalidTopicExpressionFaultType);
			((wsnb__InvalidTopicExpressionFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wsnb__InvalidTopicExpressionFaultType[n]);
			if (size)
				*size = n * sizeof(wsnb__InvalidTopicExpressionFaultType);
			for (int i = 0; i < n; i++)
				((wsnb__InvalidTopicExpressionFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wsnb__InvalidTopicExpressionFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "wsnb:TopicNotSupportedFaultType"))
	{	cp->type = SOAP_TYPE_wsnb__TopicNotSupportedFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wsnb__TopicNotSupportedFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wsnb__TopicNotSupportedFaultType);
			((wsnb__TopicNotSupportedFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wsnb__TopicNotSupportedFaultType[n]);
			if (size)
				*size = n * sizeof(wsnb__TopicNotSupportedFaultType);
			for (int i = 0; i < n; i++)
				((wsnb__TopicNotSupportedFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wsnb__TopicNotSupportedFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "wsnb:MultipleTopicsSpecifiedFaultType"))
	{	cp->type = SOAP_TYPE_wsnb__MultipleTopicsSpecifiedFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wsnb__MultipleTopicsSpecifiedFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wsnb__MultipleTopicsSpecifiedFaultType);
			((wsnb__MultipleTopicsSpecifiedFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wsnb__MultipleTopicsSpecifiedFaultType[n]);
			if (size)
				*size = n * sizeof(wsnb__MultipleTopicsSpecifiedFaultType);
			for (int i = 0; i < n; i++)
				((wsnb__MultipleTopicsSpecifiedFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wsnb__MultipleTopicsSpecifiedFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "wsnb:InvalidProducerPropertiesExpressionFaultType"))
	{	cp->type = SOAP_TYPE_wsnb__InvalidProducerPropertiesExpressionFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wsnb__InvalidProducerPropertiesExpressionFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wsnb__InvalidProducerPropertiesExpressionFaultType);
			((wsnb__InvalidProducerPropertiesExpressionFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wsnb__InvalidProducerPropertiesExpressionFaultType[n]);
			if (size)
				*size = n * sizeof(wsnb__InvalidProducerPropertiesExpressionFaultType);
			for (int i = 0; i < n; i++)
				((wsnb__InvalidProducerPropertiesExpressionFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wsnb__InvalidProducerPropertiesExpressionFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "wsnb:InvalidMessageContentExpressionFaultType"))
	{	cp->type = SOAP_TYPE_wsnb__InvalidMessageContentExpressionFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wsnb__InvalidMessageContentExpressionFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wsnb__InvalidMessageContentExpressionFaultType);
			((wsnb__InvalidMessageContentExpressionFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wsnb__InvalidMessageContentExpressionFaultType[n]);
			if (size)
				*size = n * sizeof(wsnb__InvalidMessageContentExpressionFaultType);
			for (int i = 0; i < n; i++)
				((wsnb__InvalidMessageContentExpressionFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wsnb__InvalidMessageContentExpressionFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "wsnb:UnrecognizedPolicyRequestFaultType"))
	{	cp->type = SOAP_TYPE_wsnb__UnrecognizedPolicyRequestFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wsnb__UnrecognizedPolicyRequestFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wsnb__UnrecognizedPolicyRequestFaultType);
			((wsnb__UnrecognizedPolicyRequestFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wsnb__UnrecognizedPolicyRequestFaultType[n]);
			if (size)
				*size = n * sizeof(wsnb__UnrecognizedPolicyRequestFaultType);
			for (int i = 0; i < n; i++)
				((wsnb__UnrecognizedPolicyRequestFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wsnb__UnrecognizedPolicyRequestFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "wsnb:UnsupportedPolicyRequestFaultType"))
	{	cp->type = SOAP_TYPE_wsnb__UnsupportedPolicyRequestFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wsnb__UnsupportedPolicyRequestFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wsnb__UnsupportedPolicyRequestFaultType);
			((wsnb__UnsupportedPolicyRequestFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wsnb__UnsupportedPolicyRequestFaultType[n]);
			if (size)
				*size = n * sizeof(wsnb__UnsupportedPolicyRequestFaultType);
			for (int i = 0; i < n; i++)
				((wsnb__UnsupportedPolicyRequestFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wsnb__UnsupportedPolicyRequestFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "wsnb:NotifyMessageNotSupportedFaultType"))
	{	cp->type = SOAP_TYPE_wsnb__NotifyMessageNotSupportedFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wsnb__NotifyMessageNotSupportedFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wsnb__NotifyMessageNotSupportedFaultType);
			((wsnb__NotifyMessageNotSupportedFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wsnb__NotifyMessageNotSupportedFaultType[n]);
			if (size)
				*size = n * sizeof(wsnb__NotifyMessageNotSupportedFaultType);
			for (int i = 0; i < n; i++)
				((wsnb__NotifyMessageNotSupportedFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wsnb__NotifyMessageNotSupportedFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "wsnb:UnacceptableInitialTerminationTimeFaultType"))
	{	cp->type = SOAP_TYPE_wsnb__UnacceptableInitialTerminationTimeFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wsnb__UnacceptableInitialTerminationTimeFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wsnb__UnacceptableInitialTerminationTimeFaultType);
			((wsnb__UnacceptableInitialTerminationTimeFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wsnb__UnacceptableInitialTerminationTimeFaultType[n]);
			if (size)
				*size = n * sizeof(wsnb__UnacceptableInitialTerminationTimeFaultType);
			for (int i = 0; i < n; i++)
				((wsnb__UnacceptableInitialTerminationTimeFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wsnb__UnacceptableInitialTerminationTimeFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "wsnb:NoCurrentMessageOnTopicFaultType"))
	{	cp->type = SOAP_TYPE_wsnb__NoCurrentMessageOnTopicFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wsnb__NoCurrentMessageOnTopicFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wsnb__NoCurrentMessageOnTopicFaultType);
			((wsnb__NoCurrentMessageOnTopicFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wsnb__NoCurrentMessageOnTopicFaultType[n]);
			if (size)
				*size = n * sizeof(wsnb__NoCurrentMessageOnTopicFaultType);
			for (int i = 0; i < n; i++)
				((wsnb__NoCurrentMessageOnTopicFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wsnb__NoCurrentMessageOnTopicFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "wsnb:UnableToGetMessagesFaultType"))
	{	cp->type = SOAP_TYPE_wsnb__UnableToGetMessagesFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wsnb__UnableToGetMessagesFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wsnb__UnableToGetMessagesFaultType);
			((wsnb__UnableToGetMessagesFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wsnb__UnableToGetMessagesFaultType[n]);
			if (size)
				*size = n * sizeof(wsnb__UnableToGetMessagesFaultType);
			for (int i = 0; i < n; i++)
				((wsnb__UnableToGetMessagesFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wsnb__UnableToGetMessagesFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "wsnb:UnableToDestroyPullPointFaultType"))
	{	cp->type = SOAP_TYPE_wsnb__UnableToDestroyPullPointFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wsnb__UnableToDestroyPullPointFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wsnb__UnableToDestroyPullPointFaultType);
			((wsnb__UnableToDestroyPullPointFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wsnb__UnableToDestroyPullPointFaultType[n]);
			if (size)
				*size = n * sizeof(wsnb__UnableToDestroyPullPointFaultType);
			for (int i = 0; i < n; i++)
				((wsnb__UnableToDestroyPullPointFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wsnb__UnableToDestroyPullPointFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "wsnb:UnableToCreatePullPointFaultType"))
	{	cp->type = SOAP_TYPE_wsnb__UnableToCreatePullPointFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wsnb__UnableToCreatePullPointFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wsnb__UnableToCreatePullPointFaultType);
			((wsnb__UnableToCreatePullPointFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wsnb__UnableToCreatePullPointFaultType[n]);
			if (size)
				*size = n * sizeof(wsnb__UnableToCreatePullPointFaultType);
			for (int i = 0; i < n; i++)
				((wsnb__UnableToCreatePullPointFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wsnb__UnableToCreatePullPointFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "wsnb:UnacceptableTerminationTimeFaultType"))
	{	cp->type = SOAP_TYPE_wsnb__UnacceptableTerminationTimeFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wsnb__UnacceptableTerminationTimeFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wsnb__UnacceptableTerminationTimeFaultType);
			((wsnb__UnacceptableTerminationTimeFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wsnb__UnacceptableTerminationTimeFaultType[n]);
			if (size)
				*size = n * sizeof(wsnb__UnacceptableTerminationTimeFaultType);
			for (int i = 0; i < n; i++)
				((wsnb__UnacceptableTerminationTimeFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wsnb__UnacceptableTerminationTimeFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "wsnb:UnableToDestroySubscriptionFaultType"))
	{	cp->type = SOAP_TYPE_wsnb__UnableToDestroySubscriptionFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wsnb__UnableToDestroySubscriptionFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wsnb__UnableToDestroySubscriptionFaultType);
			((wsnb__UnableToDestroySubscriptionFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wsnb__UnableToDestroySubscriptionFaultType[n]);
			if (size)
				*size = n * sizeof(wsnb__UnableToDestroySubscriptionFaultType);
			for (int i = 0; i < n; i++)
				((wsnb__UnableToDestroySubscriptionFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wsnb__UnableToDestroySubscriptionFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "wsnb:PauseFailedFaultType"))
	{	cp->type = SOAP_TYPE_wsnb__PauseFailedFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wsnb__PauseFailedFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wsnb__PauseFailedFaultType);
			((wsnb__PauseFailedFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wsnb__PauseFailedFaultType[n]);
			if (size)
				*size = n * sizeof(wsnb__PauseFailedFaultType);
			for (int i = 0; i < n; i++)
				((wsnb__PauseFailedFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wsnb__PauseFailedFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "wsnb:ResumeFailedFaultType"))
	{	cp->type = SOAP_TYPE_wsnb__ResumeFailedFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(wsnb__ResumeFailedFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(wsnb__ResumeFailedFaultType);
			((wsnb__ResumeFailedFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(wsnb__ResumeFailedFaultType[n]);
			if (size)
				*size = n * sizeof(wsnb__ResumeFailedFaultType);
			for (int i = 0; i < n; i++)
				((wsnb__ResumeFailedFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (wsnb__ResumeFailedFaultType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsrfbf__BaseFaultType);
		if (size)
			*size = sizeof(wsrfbf__BaseFaultType);
		((wsrfbf__BaseFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsrfbf__BaseFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsrfbf__BaseFaultType);
		for (int i = 0; i < n; i++)
			((wsrfbf__BaseFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsrfbf__BaseFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsrfbf__BaseFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsrfbf__BaseFaultType %p -> %p\n", q, p));
	*(wsrfbf__BaseFaultType*)p = *(wsrfbf__BaseFaultType*)q;
}

void _wsnb__ResumeSubscriptionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__ResumeSubscriptionResponse::__any);
	/* transient soap skipped */
}

void _wsnb__ResumeSubscriptionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__ResumeSubscriptionResponse::__any);
	/* transient soap skipped */
}

int _wsnb__ResumeSubscriptionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__ResumeSubscriptionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__ResumeSubscriptionResponse(struct soap *soap, const char *tag, int id, const _wsnb__ResumeSubscriptionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__ResumeSubscriptionResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_wsnb__ResumeSubscriptionResponse::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_wsnb__ResumeSubscriptionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__ResumeSubscriptionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__ResumeSubscriptionResponse * SOAP_FMAC4 soap_in__wsnb__ResumeSubscriptionResponse(struct soap *soap, const char *tag, _wsnb__ResumeSubscriptionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__ResumeSubscriptionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__ResumeSubscriptionResponse, sizeof(_wsnb__ResumeSubscriptionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__ResumeSubscriptionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__ResumeSubscriptionResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_wsnb__ResumeSubscriptionResponse::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__ResumeSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__ResumeSubscriptionResponse, 0, sizeof(_wsnb__ResumeSubscriptionResponse), 0, soap_copy__wsnb__ResumeSubscriptionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _wsnb__ResumeSubscriptionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__ResumeSubscriptionResponse);
	if (this->soap_out(soap, tag?tag:"wsnb:ResumeSubscriptionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__ResumeSubscriptionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__ResumeSubscriptionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__ResumeSubscriptionResponse * SOAP_FMAC4 soap_get__wsnb__ResumeSubscriptionResponse(struct soap *soap, _wsnb__ResumeSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__ResumeSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__ResumeSubscriptionResponse * SOAP_FMAC2 soap_instantiate__wsnb__ResumeSubscriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__ResumeSubscriptionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__ResumeSubscriptionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__ResumeSubscriptionResponse);
		if (size)
			*size = sizeof(_wsnb__ResumeSubscriptionResponse);
		((_wsnb__ResumeSubscriptionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__ResumeSubscriptionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__ResumeSubscriptionResponse);
		for (int i = 0; i < n; i++)
			((_wsnb__ResumeSubscriptionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__ResumeSubscriptionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__ResumeSubscriptionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__ResumeSubscriptionResponse %p -> %p\n", q, p));
	*(_wsnb__ResumeSubscriptionResponse*)p = *(_wsnb__ResumeSubscriptionResponse*)q;
}

void _wsnb__ResumeSubscription::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__ResumeSubscription::__any);
	/* transient soap skipped */
}

void _wsnb__ResumeSubscription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__ResumeSubscription::__any);
	/* transient soap skipped */
}

int _wsnb__ResumeSubscription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__ResumeSubscription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__ResumeSubscription(struct soap *soap, const char *tag, int id, const _wsnb__ResumeSubscription *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__ResumeSubscription), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_wsnb__ResumeSubscription::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_wsnb__ResumeSubscription::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__ResumeSubscription(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__ResumeSubscription * SOAP_FMAC4 soap_in__wsnb__ResumeSubscription(struct soap *soap, const char *tag, _wsnb__ResumeSubscription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__ResumeSubscription *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__ResumeSubscription, sizeof(_wsnb__ResumeSubscription), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__ResumeSubscription)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__ResumeSubscription *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_wsnb__ResumeSubscription::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__ResumeSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__ResumeSubscription, 0, sizeof(_wsnb__ResumeSubscription), 0, soap_copy__wsnb__ResumeSubscription);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _wsnb__ResumeSubscription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__ResumeSubscription);
	if (this->soap_out(soap, tag?tag:"wsnb:ResumeSubscription", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__ResumeSubscription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__ResumeSubscription(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__ResumeSubscription * SOAP_FMAC4 soap_get__wsnb__ResumeSubscription(struct soap *soap, _wsnb__ResumeSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__ResumeSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__ResumeSubscription * SOAP_FMAC2 soap_instantiate__wsnb__ResumeSubscription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__ResumeSubscription(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__ResumeSubscription, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__ResumeSubscription);
		if (size)
			*size = sizeof(_wsnb__ResumeSubscription);
		((_wsnb__ResumeSubscription*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__ResumeSubscription[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__ResumeSubscription);
		for (int i = 0; i < n; i++)
			((_wsnb__ResumeSubscription*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__ResumeSubscription*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__ResumeSubscription(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__ResumeSubscription %p -> %p\n", q, p));
	*(_wsnb__ResumeSubscription*)p = *(_wsnb__ResumeSubscription*)q;
}

void _wsnb__PauseSubscriptionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__PauseSubscriptionResponse::__any);
	/* transient soap skipped */
}

void _wsnb__PauseSubscriptionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__PauseSubscriptionResponse::__any);
	/* transient soap skipped */
}

int _wsnb__PauseSubscriptionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__PauseSubscriptionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__PauseSubscriptionResponse(struct soap *soap, const char *tag, int id, const _wsnb__PauseSubscriptionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__PauseSubscriptionResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_wsnb__PauseSubscriptionResponse::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_wsnb__PauseSubscriptionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__PauseSubscriptionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__PauseSubscriptionResponse * SOAP_FMAC4 soap_in__wsnb__PauseSubscriptionResponse(struct soap *soap, const char *tag, _wsnb__PauseSubscriptionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__PauseSubscriptionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__PauseSubscriptionResponse, sizeof(_wsnb__PauseSubscriptionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__PauseSubscriptionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__PauseSubscriptionResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_wsnb__PauseSubscriptionResponse::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__PauseSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__PauseSubscriptionResponse, 0, sizeof(_wsnb__PauseSubscriptionResponse), 0, soap_copy__wsnb__PauseSubscriptionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _wsnb__PauseSubscriptionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__PauseSubscriptionResponse);
	if (this->soap_out(soap, tag?tag:"wsnb:PauseSubscriptionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__PauseSubscriptionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__PauseSubscriptionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__PauseSubscriptionResponse * SOAP_FMAC4 soap_get__wsnb__PauseSubscriptionResponse(struct soap *soap, _wsnb__PauseSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__PauseSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__PauseSubscriptionResponse * SOAP_FMAC2 soap_instantiate__wsnb__PauseSubscriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__PauseSubscriptionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__PauseSubscriptionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__PauseSubscriptionResponse);
		if (size)
			*size = sizeof(_wsnb__PauseSubscriptionResponse);
		((_wsnb__PauseSubscriptionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__PauseSubscriptionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__PauseSubscriptionResponse);
		for (int i = 0; i < n; i++)
			((_wsnb__PauseSubscriptionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__PauseSubscriptionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__PauseSubscriptionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__PauseSubscriptionResponse %p -> %p\n", q, p));
	*(_wsnb__PauseSubscriptionResponse*)p = *(_wsnb__PauseSubscriptionResponse*)q;
}

void _wsnb__PauseSubscription::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__PauseSubscription::__any);
	/* transient soap skipped */
}

void _wsnb__PauseSubscription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__PauseSubscription::__any);
	/* transient soap skipped */
}

int _wsnb__PauseSubscription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__PauseSubscription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__PauseSubscription(struct soap *soap, const char *tag, int id, const _wsnb__PauseSubscription *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__PauseSubscription), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_wsnb__PauseSubscription::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_wsnb__PauseSubscription::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__PauseSubscription(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__PauseSubscription * SOAP_FMAC4 soap_in__wsnb__PauseSubscription(struct soap *soap, const char *tag, _wsnb__PauseSubscription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__PauseSubscription *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__PauseSubscription, sizeof(_wsnb__PauseSubscription), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__PauseSubscription)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__PauseSubscription *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_wsnb__PauseSubscription::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__PauseSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__PauseSubscription, 0, sizeof(_wsnb__PauseSubscription), 0, soap_copy__wsnb__PauseSubscription);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _wsnb__PauseSubscription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__PauseSubscription);
	if (this->soap_out(soap, tag?tag:"wsnb:PauseSubscription", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__PauseSubscription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__PauseSubscription(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__PauseSubscription * SOAP_FMAC4 soap_get__wsnb__PauseSubscription(struct soap *soap, _wsnb__PauseSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__PauseSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__PauseSubscription * SOAP_FMAC2 soap_instantiate__wsnb__PauseSubscription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__PauseSubscription(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__PauseSubscription, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__PauseSubscription);
		if (size)
			*size = sizeof(_wsnb__PauseSubscription);
		((_wsnb__PauseSubscription*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__PauseSubscription[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__PauseSubscription);
		for (int i = 0; i < n; i++)
			((_wsnb__PauseSubscription*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__PauseSubscription*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__PauseSubscription(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__PauseSubscription %p -> %p\n", q, p));
	*(_wsnb__PauseSubscription*)p = *(_wsnb__PauseSubscription*)q;
}

void _wsnb__UnsubscribeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__UnsubscribeResponse::__any);
	/* transient soap skipped */
}

void _wsnb__UnsubscribeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__UnsubscribeResponse::__any);
	/* transient soap skipped */
}

int _wsnb__UnsubscribeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__UnsubscribeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__UnsubscribeResponse(struct soap *soap, const char *tag, int id, const _wsnb__UnsubscribeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__UnsubscribeResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_wsnb__UnsubscribeResponse::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_wsnb__UnsubscribeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__UnsubscribeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__UnsubscribeResponse * SOAP_FMAC4 soap_in__wsnb__UnsubscribeResponse(struct soap *soap, const char *tag, _wsnb__UnsubscribeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__UnsubscribeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__UnsubscribeResponse, sizeof(_wsnb__UnsubscribeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__UnsubscribeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__UnsubscribeResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_wsnb__UnsubscribeResponse::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__UnsubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__UnsubscribeResponse, 0, sizeof(_wsnb__UnsubscribeResponse), 0, soap_copy__wsnb__UnsubscribeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _wsnb__UnsubscribeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__UnsubscribeResponse);
	if (this->soap_out(soap, tag?tag:"wsnb:UnsubscribeResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__UnsubscribeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__UnsubscribeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__UnsubscribeResponse * SOAP_FMAC4 soap_get__wsnb__UnsubscribeResponse(struct soap *soap, _wsnb__UnsubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__UnsubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__UnsubscribeResponse * SOAP_FMAC2 soap_instantiate__wsnb__UnsubscribeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__UnsubscribeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__UnsubscribeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__UnsubscribeResponse);
		if (size)
			*size = sizeof(_wsnb__UnsubscribeResponse);
		((_wsnb__UnsubscribeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__UnsubscribeResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__UnsubscribeResponse);
		for (int i = 0; i < n; i++)
			((_wsnb__UnsubscribeResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__UnsubscribeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__UnsubscribeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__UnsubscribeResponse %p -> %p\n", q, p));
	*(_wsnb__UnsubscribeResponse*)p = *(_wsnb__UnsubscribeResponse*)q;
}

void _wsnb__Unsubscribe::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__Unsubscribe::__any);
	/* transient soap skipped */
}

void _wsnb__Unsubscribe::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__Unsubscribe::__any);
	/* transient soap skipped */
}

int _wsnb__Unsubscribe::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__Unsubscribe(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__Unsubscribe(struct soap *soap, const char *tag, int id, const _wsnb__Unsubscribe *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__Unsubscribe), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_wsnb__Unsubscribe::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_wsnb__Unsubscribe::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__Unsubscribe(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__Unsubscribe * SOAP_FMAC4 soap_in__wsnb__Unsubscribe(struct soap *soap, const char *tag, _wsnb__Unsubscribe *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__Unsubscribe *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__Unsubscribe, sizeof(_wsnb__Unsubscribe), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__Unsubscribe)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__Unsubscribe *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_wsnb__Unsubscribe::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__Unsubscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__Unsubscribe, 0, sizeof(_wsnb__Unsubscribe), 0, soap_copy__wsnb__Unsubscribe);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _wsnb__Unsubscribe::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__Unsubscribe);
	if (this->soap_out(soap, tag?tag:"wsnb:Unsubscribe", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__Unsubscribe::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__Unsubscribe(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__Unsubscribe * SOAP_FMAC4 soap_get__wsnb__Unsubscribe(struct soap *soap, _wsnb__Unsubscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__Unsubscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__Unsubscribe * SOAP_FMAC2 soap_instantiate__wsnb__Unsubscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__Unsubscribe(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__Unsubscribe, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__Unsubscribe);
		if (size)
			*size = sizeof(_wsnb__Unsubscribe);
		((_wsnb__Unsubscribe*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__Unsubscribe[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__Unsubscribe);
		for (int i = 0; i < n; i++)
			((_wsnb__Unsubscribe*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__Unsubscribe*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__Unsubscribe(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__Unsubscribe %p -> %p\n", q, p));
	*(_wsnb__Unsubscribe*)p = *(_wsnb__Unsubscribe*)q;
}

void _wsnb__RenewResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->_wsnb__RenewResponse::TerminationTime);
	this->_wsnb__RenewResponse::CurrentTime = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__RenewResponse::__any);
	/* transient soap skipped */
}

void _wsnb__RenewResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_wsnb__RenewResponse::TerminationTime, SOAP_TYPE_time);
	soap_serialize_PointerTotime(soap, &this->_wsnb__RenewResponse::CurrentTime);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__RenewResponse::__any);
	/* transient soap skipped */
}

int _wsnb__RenewResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__RenewResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__RenewResponse(struct soap *soap, const char *tag, int id, const _wsnb__RenewResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__RenewResponse), type))
		return soap->error;
	if (soap_out_time(soap, "wsnb:TerminationTime", -1, &(a->_wsnb__RenewResponse::TerminationTime), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "wsnb:CurrentTime", -1, &(a->_wsnb__RenewResponse::CurrentTime), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_wsnb__RenewResponse::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_wsnb__RenewResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__RenewResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__RenewResponse * SOAP_FMAC4 soap_in__wsnb__RenewResponse(struct soap *soap, const char *tag, _wsnb__RenewResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__RenewResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__RenewResponse, sizeof(_wsnb__RenewResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__RenewResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__RenewResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TerminationTime1 = 1;
	size_t soap_flag_CurrentTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TerminationTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsnb:TerminationTime", &(a->_wsnb__RenewResponse::TerminationTime), "xsd:dateTime"))
				{	soap_flag_TerminationTime1--;
					continue;
				}
			if (soap_flag_CurrentTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "wsnb:CurrentTime", &(a->_wsnb__RenewResponse::CurrentTime), "xsd:dateTime"))
				{	soap_flag_CurrentTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_wsnb__RenewResponse::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__RenewResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__RenewResponse, 0, sizeof(_wsnb__RenewResponse), 0, soap_copy__wsnb__RenewResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _wsnb__RenewResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__RenewResponse);
	if (this->soap_out(soap, tag?tag:"wsnb:RenewResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__RenewResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__RenewResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__RenewResponse * SOAP_FMAC4 soap_get__wsnb__RenewResponse(struct soap *soap, _wsnb__RenewResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__RenewResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__RenewResponse * SOAP_FMAC2 soap_instantiate__wsnb__RenewResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__RenewResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__RenewResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__RenewResponse);
		if (size)
			*size = sizeof(_wsnb__RenewResponse);
		((_wsnb__RenewResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__RenewResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__RenewResponse);
		for (int i = 0; i < n; i++)
			((_wsnb__RenewResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__RenewResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__RenewResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__RenewResponse %p -> %p\n", q, p));
	*(_wsnb__RenewResponse*)p = *(_wsnb__RenewResponse*)q;
}

void _wsnb__Renew::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_wsnb__Renew::TerminationTime = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__Renew::__any);
	/* transient soap skipped */
}

void _wsnb__Renew::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTowsnb__AbsoluteOrRelativeTimeType(soap, &this->_wsnb__Renew::TerminationTime);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__Renew::__any);
	/* transient soap skipped */
}

int _wsnb__Renew::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__Renew(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__Renew(struct soap *soap, const char *tag, int id, const _wsnb__Renew *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__Renew), type))
		return soap->error;
	if (a->_wsnb__Renew::TerminationTime)
	{	if (soap_out_PointerTowsnb__AbsoluteOrRelativeTimeType(soap, "wsnb:TerminationTime", -1, &a->_wsnb__Renew::TerminationTime, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wsnb:TerminationTime"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_wsnb__Renew::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_wsnb__Renew::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__Renew(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__Renew * SOAP_FMAC4 soap_in__wsnb__Renew(struct soap *soap, const char *tag, _wsnb__Renew *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__Renew *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__Renew, sizeof(_wsnb__Renew), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__Renew)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__Renew *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TerminationTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TerminationTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTowsnb__AbsoluteOrRelativeTimeType(soap, "wsnb:TerminationTime", &(a->_wsnb__Renew::TerminationTime), "wsnb:AbsoluteOrRelativeTimeType"))
				{	soap_flag_TerminationTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_wsnb__Renew::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__Renew *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__Renew, 0, sizeof(_wsnb__Renew), 0, soap_copy__wsnb__Renew);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _wsnb__Renew::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__Renew);
	if (this->soap_out(soap, tag?tag:"wsnb:Renew", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__Renew::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__Renew(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__Renew * SOAP_FMAC4 soap_get__wsnb__Renew(struct soap *soap, _wsnb__Renew *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__Renew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__Renew * SOAP_FMAC2 soap_instantiate__wsnb__Renew(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__Renew(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__Renew, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__Renew);
		if (size)
			*size = sizeof(_wsnb__Renew);
		((_wsnb__Renew*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__Renew[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__Renew);
		for (int i = 0; i < n; i++)
			((_wsnb__Renew*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__Renew*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__Renew(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__Renew %p -> %p\n", q, p));
	*(_wsnb__Renew*)p = *(_wsnb__Renew*)q;
}

void _wsnb__CreatePullPointResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_wsa5__EndpointReferenceType(soap, &this->_wsnb__CreatePullPointResponse::PullPoint);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__CreatePullPointResponse::__any);
	soap_default_xsd__anyAttribute(soap, &this->_wsnb__CreatePullPointResponse::__anyAttribute);
	/* transient soap skipped */
}

void _wsnb__CreatePullPointResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_wsnb__CreatePullPointResponse::PullPoint, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &this->_wsnb__CreatePullPointResponse::PullPoint);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__CreatePullPointResponse::__any);
	/* transient soap skipped */
}

int _wsnb__CreatePullPointResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__CreatePullPointResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__CreatePullPointResponse(struct soap *soap, const char *tag, int id, const _wsnb__CreatePullPointResponse *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_wsnb__CreatePullPointResponse*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__CreatePullPointResponse), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnb:PullPoint", -1, &(a->_wsnb__CreatePullPointResponse::PullPoint), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_wsnb__CreatePullPointResponse::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_wsnb__CreatePullPointResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__CreatePullPointResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__CreatePullPointResponse * SOAP_FMAC4 soap_in__wsnb__CreatePullPointResponse(struct soap *soap, const char *tag, _wsnb__CreatePullPointResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__CreatePullPointResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__CreatePullPointResponse, sizeof(_wsnb__CreatePullPointResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__CreatePullPointResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__CreatePullPointResponse *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_wsnb__CreatePullPointResponse*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_PullPoint1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PullPoint1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsa5__EndpointReferenceType(soap, "wsnb:PullPoint", &(a->_wsnb__CreatePullPointResponse::PullPoint), "wsa5:EndpointReferenceType"))
				{	soap_flag_PullPoint1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_wsnb__CreatePullPointResponse::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__CreatePullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__CreatePullPointResponse, 0, sizeof(_wsnb__CreatePullPointResponse), 0, soap_copy__wsnb__CreatePullPointResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PullPoint1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _wsnb__CreatePullPointResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__CreatePullPointResponse);
	if (this->soap_out(soap, tag?tag:"wsnb:CreatePullPointResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__CreatePullPointResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__CreatePullPointResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__CreatePullPointResponse * SOAP_FMAC4 soap_get__wsnb__CreatePullPointResponse(struct soap *soap, _wsnb__CreatePullPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__CreatePullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__CreatePullPointResponse * SOAP_FMAC2 soap_instantiate__wsnb__CreatePullPointResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__CreatePullPointResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__CreatePullPointResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__CreatePullPointResponse);
		if (size)
			*size = sizeof(_wsnb__CreatePullPointResponse);
		((_wsnb__CreatePullPointResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__CreatePullPointResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__CreatePullPointResponse);
		for (int i = 0; i < n; i++)
			((_wsnb__CreatePullPointResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__CreatePullPointResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__CreatePullPointResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__CreatePullPointResponse %p -> %p\n", q, p));
	*(_wsnb__CreatePullPointResponse*)p = *(_wsnb__CreatePullPointResponse*)q;
}

void _wsnb__CreatePullPoint::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__CreatePullPoint::__any);
	soap_default_xsd__anyAttribute(soap, &this->_wsnb__CreatePullPoint::__anyAttribute);
	/* transient soap skipped */
}

void _wsnb__CreatePullPoint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__CreatePullPoint::__any);
	/* transient soap skipped */
}

int _wsnb__CreatePullPoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__CreatePullPoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__CreatePullPoint(struct soap *soap, const char *tag, int id, const _wsnb__CreatePullPoint *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_wsnb__CreatePullPoint*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__CreatePullPoint), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_wsnb__CreatePullPoint::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_wsnb__CreatePullPoint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__CreatePullPoint(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__CreatePullPoint * SOAP_FMAC4 soap_in__wsnb__CreatePullPoint(struct soap *soap, const char *tag, _wsnb__CreatePullPoint *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__CreatePullPoint *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__CreatePullPoint, sizeof(_wsnb__CreatePullPoint), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__CreatePullPoint)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__CreatePullPoint *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_wsnb__CreatePullPoint*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_wsnb__CreatePullPoint::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__CreatePullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__CreatePullPoint, 0, sizeof(_wsnb__CreatePullPoint), 0, soap_copy__wsnb__CreatePullPoint);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _wsnb__CreatePullPoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__CreatePullPoint);
	if (this->soap_out(soap, tag?tag:"wsnb:CreatePullPoint", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__CreatePullPoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__CreatePullPoint(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__CreatePullPoint * SOAP_FMAC4 soap_get__wsnb__CreatePullPoint(struct soap *soap, _wsnb__CreatePullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__CreatePullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__CreatePullPoint * SOAP_FMAC2 soap_instantiate__wsnb__CreatePullPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__CreatePullPoint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__CreatePullPoint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__CreatePullPoint);
		if (size)
			*size = sizeof(_wsnb__CreatePullPoint);
		((_wsnb__CreatePullPoint*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__CreatePullPoint[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__CreatePullPoint);
		for (int i = 0; i < n; i++)
			((_wsnb__CreatePullPoint*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__CreatePullPoint*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__CreatePullPoint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__CreatePullPoint %p -> %p\n", q, p));
	*(_wsnb__CreatePullPoint*)p = *(_wsnb__CreatePullPoint*)q;
}

void _wsnb__DestroyPullPointResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__DestroyPullPointResponse::__any);
	soap_default_xsd__anyAttribute(soap, &this->_wsnb__DestroyPullPointResponse::__anyAttribute);
	/* transient soap skipped */
}

void _wsnb__DestroyPullPointResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__DestroyPullPointResponse::__any);
	/* transient soap skipped */
}

int _wsnb__DestroyPullPointResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__DestroyPullPointResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__DestroyPullPointResponse(struct soap *soap, const char *tag, int id, const _wsnb__DestroyPullPointResponse *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_wsnb__DestroyPullPointResponse*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__DestroyPullPointResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_wsnb__DestroyPullPointResponse::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_wsnb__DestroyPullPointResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__DestroyPullPointResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__DestroyPullPointResponse * SOAP_FMAC4 soap_in__wsnb__DestroyPullPointResponse(struct soap *soap, const char *tag, _wsnb__DestroyPullPointResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__DestroyPullPointResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__DestroyPullPointResponse, sizeof(_wsnb__DestroyPullPointResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__DestroyPullPointResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__DestroyPullPointResponse *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_wsnb__DestroyPullPointResponse*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_wsnb__DestroyPullPointResponse::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__DestroyPullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__DestroyPullPointResponse, 0, sizeof(_wsnb__DestroyPullPointResponse), 0, soap_copy__wsnb__DestroyPullPointResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _wsnb__DestroyPullPointResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__DestroyPullPointResponse);
	if (this->soap_out(soap, tag?tag:"wsnb:DestroyPullPointResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__DestroyPullPointResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__DestroyPullPointResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__DestroyPullPointResponse * SOAP_FMAC4 soap_get__wsnb__DestroyPullPointResponse(struct soap *soap, _wsnb__DestroyPullPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__DestroyPullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__DestroyPullPointResponse * SOAP_FMAC2 soap_instantiate__wsnb__DestroyPullPointResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__DestroyPullPointResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__DestroyPullPointResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__DestroyPullPointResponse);
		if (size)
			*size = sizeof(_wsnb__DestroyPullPointResponse);
		((_wsnb__DestroyPullPointResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__DestroyPullPointResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__DestroyPullPointResponse);
		for (int i = 0; i < n; i++)
			((_wsnb__DestroyPullPointResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__DestroyPullPointResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__DestroyPullPointResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__DestroyPullPointResponse %p -> %p\n", q, p));
	*(_wsnb__DestroyPullPointResponse*)p = *(_wsnb__DestroyPullPointResponse*)q;
}

void _wsnb__DestroyPullPoint::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__DestroyPullPoint::__any);
	soap_default_xsd__anyAttribute(soap, &this->_wsnb__DestroyPullPoint::__anyAttribute);
	/* transient soap skipped */
}

void _wsnb__DestroyPullPoint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__DestroyPullPoint::__any);
	/* transient soap skipped */
}

int _wsnb__DestroyPullPoint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__DestroyPullPoint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__DestroyPullPoint(struct soap *soap, const char *tag, int id, const _wsnb__DestroyPullPoint *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_wsnb__DestroyPullPoint*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__DestroyPullPoint), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_wsnb__DestroyPullPoint::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_wsnb__DestroyPullPoint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__DestroyPullPoint(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__DestroyPullPoint * SOAP_FMAC4 soap_in__wsnb__DestroyPullPoint(struct soap *soap, const char *tag, _wsnb__DestroyPullPoint *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__DestroyPullPoint *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__DestroyPullPoint, sizeof(_wsnb__DestroyPullPoint), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__DestroyPullPoint)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__DestroyPullPoint *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_wsnb__DestroyPullPoint*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_wsnb__DestroyPullPoint::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__DestroyPullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__DestroyPullPoint, 0, sizeof(_wsnb__DestroyPullPoint), 0, soap_copy__wsnb__DestroyPullPoint);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _wsnb__DestroyPullPoint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__DestroyPullPoint);
	if (this->soap_out(soap, tag?tag:"wsnb:DestroyPullPoint", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__DestroyPullPoint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__DestroyPullPoint(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__DestroyPullPoint * SOAP_FMAC4 soap_get__wsnb__DestroyPullPoint(struct soap *soap, _wsnb__DestroyPullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__DestroyPullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__DestroyPullPoint * SOAP_FMAC2 soap_instantiate__wsnb__DestroyPullPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__DestroyPullPoint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__DestroyPullPoint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__DestroyPullPoint);
		if (size)
			*size = sizeof(_wsnb__DestroyPullPoint);
		((_wsnb__DestroyPullPoint*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__DestroyPullPoint[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__DestroyPullPoint);
		for (int i = 0; i < n; i++)
			((_wsnb__DestroyPullPoint*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__DestroyPullPoint*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__DestroyPullPoint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__DestroyPullPoint %p -> %p\n", q, p));
	*(_wsnb__DestroyPullPoint*)p = *(_wsnb__DestroyPullPoint*)q;
}

void _wsnb__GetMessagesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTowsnb__NotificationMessageHolderType(soap, &this->_wsnb__GetMessagesResponse::NotificationMessage);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__GetMessagesResponse::__any);
	soap_default_xsd__anyAttribute(soap, &this->_wsnb__GetMessagesResponse::__anyAttribute);
	/* transient soap skipped */
}

void _wsnb__GetMessagesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTowsnb__NotificationMessageHolderType(soap, &this->_wsnb__GetMessagesResponse::NotificationMessage);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__GetMessagesResponse::__any);
	/* transient soap skipped */
}

int _wsnb__GetMessagesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__GetMessagesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__GetMessagesResponse(struct soap *soap, const char *tag, int id, const _wsnb__GetMessagesResponse *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_wsnb__GetMessagesResponse*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__GetMessagesResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowsnb__NotificationMessageHolderType(soap, "wsnb:NotificationMessage", -1, &(a->_wsnb__GetMessagesResponse::NotificationMessage), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_wsnb__GetMessagesResponse::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_wsnb__GetMessagesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__GetMessagesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__GetMessagesResponse * SOAP_FMAC4 soap_in__wsnb__GetMessagesResponse(struct soap *soap, const char *tag, _wsnb__GetMessagesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__GetMessagesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__GetMessagesResponse, sizeof(_wsnb__GetMessagesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__GetMessagesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__GetMessagesResponse *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_wsnb__GetMessagesResponse*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTowsnb__NotificationMessageHolderType(soap, "wsnb:NotificationMessage", &(a->_wsnb__GetMessagesResponse::NotificationMessage), "wsnb:NotificationMessageHolderType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_wsnb__GetMessagesResponse::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__GetMessagesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__GetMessagesResponse, 0, sizeof(_wsnb__GetMessagesResponse), 0, soap_copy__wsnb__GetMessagesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _wsnb__GetMessagesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__GetMessagesResponse);
	if (this->soap_out(soap, tag?tag:"wsnb:GetMessagesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__GetMessagesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__GetMessagesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__GetMessagesResponse * SOAP_FMAC4 soap_get__wsnb__GetMessagesResponse(struct soap *soap, _wsnb__GetMessagesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__GetMessagesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__GetMessagesResponse * SOAP_FMAC2 soap_instantiate__wsnb__GetMessagesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__GetMessagesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__GetMessagesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__GetMessagesResponse);
		if (size)
			*size = sizeof(_wsnb__GetMessagesResponse);
		((_wsnb__GetMessagesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__GetMessagesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__GetMessagesResponse);
		for (int i = 0; i < n; i++)
			((_wsnb__GetMessagesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__GetMessagesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__GetMessagesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__GetMessagesResponse %p -> %p\n", q, p));
	*(_wsnb__GetMessagesResponse*)p = *(_wsnb__GetMessagesResponse*)q;
}

void _wsnb__GetMessages::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_wsnb__GetMessages::MaximumNumber = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__GetMessages::__any);
	soap_default_xsd__anyAttribute(soap, &this->_wsnb__GetMessages::__anyAttribute);
	/* transient soap skipped */
}

void _wsnb__GetMessages::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->_wsnb__GetMessages::MaximumNumber);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__GetMessages::__any);
	/* transient soap skipped */
}

int _wsnb__GetMessages::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__GetMessages(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__GetMessages(struct soap *soap, const char *tag, int id, const _wsnb__GetMessages *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_wsnb__GetMessages*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__GetMessages), type))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "wsnb:MaximumNumber", -1, &(a->_wsnb__GetMessages::MaximumNumber), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_wsnb__GetMessages::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_wsnb__GetMessages::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__GetMessages(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__GetMessages * SOAP_FMAC4 soap_in__wsnb__GetMessages(struct soap *soap, const char *tag, _wsnb__GetMessages *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__GetMessages *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__GetMessages, sizeof(_wsnb__GetMessages), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__GetMessages)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__GetMessages *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_wsnb__GetMessages*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_MaximumNumber1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__nonNegativeInteger(soap, "wsnb:MaximumNumber", &(a->_wsnb__GetMessages::MaximumNumber), "xsd:nonNegativeInteger"))
				{	soap_flag_MaximumNumber1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_wsnb__GetMessages::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__GetMessages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__GetMessages, 0, sizeof(_wsnb__GetMessages), 0, soap_copy__wsnb__GetMessages);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _wsnb__GetMessages::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__GetMessages);
	if (this->soap_out(soap, tag?tag:"wsnb:GetMessages", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__GetMessages::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__GetMessages(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__GetMessages * SOAP_FMAC4 soap_get__wsnb__GetMessages(struct soap *soap, _wsnb__GetMessages *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__GetMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__GetMessages * SOAP_FMAC2 soap_instantiate__wsnb__GetMessages(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__GetMessages(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__GetMessages, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__GetMessages);
		if (size)
			*size = sizeof(_wsnb__GetMessages);
		((_wsnb__GetMessages*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__GetMessages[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__GetMessages);
		for (int i = 0; i < n; i++)
			((_wsnb__GetMessages*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__GetMessages*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__GetMessages(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__GetMessages %p -> %p\n", q, p));
	*(_wsnb__GetMessages*)p = *(_wsnb__GetMessages*)q;
}

void _wsnb__GetCurrentMessageResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__GetCurrentMessageResponse::__any);
	/* transient soap skipped */
}

void _wsnb__GetCurrentMessageResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__GetCurrentMessageResponse::__any);
	/* transient soap skipped */
}

int _wsnb__GetCurrentMessageResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__GetCurrentMessageResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__GetCurrentMessageResponse(struct soap *soap, const char *tag, int id, const _wsnb__GetCurrentMessageResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__GetCurrentMessageResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_wsnb__GetCurrentMessageResponse::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_wsnb__GetCurrentMessageResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__GetCurrentMessageResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__GetCurrentMessageResponse * SOAP_FMAC4 soap_in__wsnb__GetCurrentMessageResponse(struct soap *soap, const char *tag, _wsnb__GetCurrentMessageResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__GetCurrentMessageResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__GetCurrentMessageResponse, sizeof(_wsnb__GetCurrentMessageResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__GetCurrentMessageResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__GetCurrentMessageResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_wsnb__GetCurrentMessageResponse::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__GetCurrentMessageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__GetCurrentMessageResponse, 0, sizeof(_wsnb__GetCurrentMessageResponse), 0, soap_copy__wsnb__GetCurrentMessageResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _wsnb__GetCurrentMessageResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__GetCurrentMessageResponse);
	if (this->soap_out(soap, tag?tag:"wsnb:GetCurrentMessageResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__GetCurrentMessageResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__GetCurrentMessageResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__GetCurrentMessageResponse * SOAP_FMAC4 soap_get__wsnb__GetCurrentMessageResponse(struct soap *soap, _wsnb__GetCurrentMessageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__GetCurrentMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__GetCurrentMessageResponse * SOAP_FMAC2 soap_instantiate__wsnb__GetCurrentMessageResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__GetCurrentMessageResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__GetCurrentMessageResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__GetCurrentMessageResponse);
		if (size)
			*size = sizeof(_wsnb__GetCurrentMessageResponse);
		((_wsnb__GetCurrentMessageResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__GetCurrentMessageResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__GetCurrentMessageResponse);
		for (int i = 0; i < n; i++)
			((_wsnb__GetCurrentMessageResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__GetCurrentMessageResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__GetCurrentMessageResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__GetCurrentMessageResponse %p -> %p\n", q, p));
	*(_wsnb__GetCurrentMessageResponse*)p = *(_wsnb__GetCurrentMessageResponse*)q;
}

void _wsnb__GetCurrentMessage::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_wsnb__GetCurrentMessage::Topic = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__GetCurrentMessage::__any);
	/* transient soap skipped */
}

void _wsnb__GetCurrentMessage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTowsnb__TopicExpressionType(soap, &this->_wsnb__GetCurrentMessage::Topic);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__GetCurrentMessage::__any);
	/* transient soap skipped */
}

int _wsnb__GetCurrentMessage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__GetCurrentMessage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__GetCurrentMessage(struct soap *soap, const char *tag, int id, const _wsnb__GetCurrentMessage *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__GetCurrentMessage), type))
		return soap->error;
	if (a->_wsnb__GetCurrentMessage::Topic)
	{	if (soap_out_PointerTowsnb__TopicExpressionType(soap, "wsnb:Topic", -1, &a->_wsnb__GetCurrentMessage::Topic, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wsnb:Topic"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_wsnb__GetCurrentMessage::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_wsnb__GetCurrentMessage::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__GetCurrentMessage(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__GetCurrentMessage * SOAP_FMAC4 soap_in__wsnb__GetCurrentMessage(struct soap *soap, const char *tag, _wsnb__GetCurrentMessage *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__GetCurrentMessage *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__GetCurrentMessage, sizeof(_wsnb__GetCurrentMessage), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__GetCurrentMessage)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__GetCurrentMessage *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Topic1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Topic1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnb__TopicExpressionType(soap, "wsnb:Topic", &(a->_wsnb__GetCurrentMessage::Topic), "wsnb:TopicExpressionType"))
				{	soap_flag_Topic1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_wsnb__GetCurrentMessage::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__GetCurrentMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__GetCurrentMessage, 0, sizeof(_wsnb__GetCurrentMessage), 0, soap_copy__wsnb__GetCurrentMessage);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Topic1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _wsnb__GetCurrentMessage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__GetCurrentMessage);
	if (this->soap_out(soap, tag?tag:"wsnb:GetCurrentMessage", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__GetCurrentMessage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__GetCurrentMessage(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__GetCurrentMessage * SOAP_FMAC4 soap_get__wsnb__GetCurrentMessage(struct soap *soap, _wsnb__GetCurrentMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__GetCurrentMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__GetCurrentMessage * SOAP_FMAC2 soap_instantiate__wsnb__GetCurrentMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__GetCurrentMessage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__GetCurrentMessage, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__GetCurrentMessage);
		if (size)
			*size = sizeof(_wsnb__GetCurrentMessage);
		((_wsnb__GetCurrentMessage*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__GetCurrentMessage[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__GetCurrentMessage);
		for (int i = 0; i < n; i++)
			((_wsnb__GetCurrentMessage*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__GetCurrentMessage*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__GetCurrentMessage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__GetCurrentMessage %p -> %p\n", q, p));
	*(_wsnb__GetCurrentMessage*)p = *(_wsnb__GetCurrentMessage*)q;
}

void _wsnb__SubscribeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_wsa5__EndpointReferenceType(soap, &this->_wsnb__SubscribeResponse::SubscriptionReference);
	this->_wsnb__SubscribeResponse::CurrentTime = NULL;
	this->_wsnb__SubscribeResponse::TerminationTime = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__SubscribeResponse::__any);
	/* transient soap skipped */
}

void _wsnb__SubscribeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_wsnb__SubscribeResponse::SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &this->_wsnb__SubscribeResponse::SubscriptionReference);
	soap_serialize_PointerTotime(soap, &this->_wsnb__SubscribeResponse::CurrentTime);
	soap_serialize_PointerTotime(soap, &this->_wsnb__SubscribeResponse::TerminationTime);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__SubscribeResponse::__any);
	/* transient soap skipped */
}

int _wsnb__SubscribeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__SubscribeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__SubscribeResponse(struct soap *soap, const char *tag, int id, const _wsnb__SubscribeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__SubscribeResponse), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnb:SubscriptionReference", -1, &(a->_wsnb__SubscribeResponse::SubscriptionReference), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "wsnb:CurrentTime", -1, &(a->_wsnb__SubscribeResponse::CurrentTime), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "wsnb:TerminationTime", -1, &(a->_wsnb__SubscribeResponse::TerminationTime), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_wsnb__SubscribeResponse::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_wsnb__SubscribeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__SubscribeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__SubscribeResponse * SOAP_FMAC4 soap_in__wsnb__SubscribeResponse(struct soap *soap, const char *tag, _wsnb__SubscribeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__SubscribeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__SubscribeResponse, sizeof(_wsnb__SubscribeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__SubscribeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__SubscribeResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SubscriptionReference1 = 1;
	size_t soap_flag_CurrentTime1 = 1;
	size_t soap_flag_TerminationTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsa5__EndpointReferenceType(soap, "wsnb:SubscriptionReference", &(a->_wsnb__SubscribeResponse::SubscriptionReference), "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference1--;
					continue;
				}
			if (soap_flag_CurrentTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "wsnb:CurrentTime", &(a->_wsnb__SubscribeResponse::CurrentTime), "xsd:dateTime"))
				{	soap_flag_CurrentTime1--;
					continue;
				}
			if (soap_flag_TerminationTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "wsnb:TerminationTime", &(a->_wsnb__SubscribeResponse::TerminationTime), "xsd:dateTime"))
				{	soap_flag_TerminationTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_wsnb__SubscribeResponse::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__SubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__SubscribeResponse, 0, sizeof(_wsnb__SubscribeResponse), 0, soap_copy__wsnb__SubscribeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _wsnb__SubscribeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__SubscribeResponse);
	if (this->soap_out(soap, tag?tag:"wsnb:SubscribeResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__SubscribeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__SubscribeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__SubscribeResponse * SOAP_FMAC4 soap_get__wsnb__SubscribeResponse(struct soap *soap, _wsnb__SubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__SubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__SubscribeResponse * SOAP_FMAC2 soap_instantiate__wsnb__SubscribeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__SubscribeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__SubscribeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__SubscribeResponse);
		if (size)
			*size = sizeof(_wsnb__SubscribeResponse);
		((_wsnb__SubscribeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__SubscribeResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__SubscribeResponse);
		for (int i = 0; i < n; i++)
			((_wsnb__SubscribeResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__SubscribeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__SubscribeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__SubscribeResponse %p -> %p\n", q, p));
	*(_wsnb__SubscribeResponse*)p = *(_wsnb__SubscribeResponse*)q;
}

void _wsnb__Subscribe::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_wsa5__EndpointReferenceType(soap, &this->_wsnb__Subscribe::ConsumerReference);
	this->_wsnb__Subscribe::Filter = NULL;
	this->_wsnb__Subscribe::InitialTerminationTime = NULL;
	this->_wsnb__Subscribe::SubscriptionPolicy = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__Subscribe::__any);
	/* transient soap skipped */
}

void _wsnb__Subscribe::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_wsnb__Subscribe::ConsumerReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &this->_wsnb__Subscribe::ConsumerReference);
	soap_serialize_PointerTowsnb__FilterType(soap, &this->_wsnb__Subscribe::Filter);
	soap_serialize_PointerTowsnb__AbsoluteOrRelativeTimeType(soap, &this->_wsnb__Subscribe::InitialTerminationTime);
	soap_serialize_PointerTo_wsnb__Subscribe_SubscriptionPolicy(soap, &this->_wsnb__Subscribe::SubscriptionPolicy);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__Subscribe::__any);
	/* transient soap skipped */
}

int _wsnb__Subscribe::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__Subscribe(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__Subscribe(struct soap *soap, const char *tag, int id, const _wsnb__Subscribe *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__Subscribe), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnb:ConsumerReference", -1, &(a->_wsnb__Subscribe::ConsumerReference), ""))
		return soap->error;
	if (soap_out_PointerTowsnb__FilterType(soap, "wsnb:Filter", -1, &(a->_wsnb__Subscribe::Filter), ""))
		return soap->error;
	if (soap_out_PointerTowsnb__AbsoluteOrRelativeTimeType(soap, "wsnb:InitialTerminationTime", -1, &(a->_wsnb__Subscribe::InitialTerminationTime), ""))
		return soap->error;
	if (soap_out_PointerTo_wsnb__Subscribe_SubscriptionPolicy(soap, "wsnb:SubscriptionPolicy", -1, &(a->_wsnb__Subscribe::SubscriptionPolicy), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_wsnb__Subscribe::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_wsnb__Subscribe::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__Subscribe(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__Subscribe * SOAP_FMAC4 soap_in__wsnb__Subscribe(struct soap *soap, const char *tag, _wsnb__Subscribe *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__Subscribe *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__Subscribe, sizeof(_wsnb__Subscribe), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__Subscribe)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__Subscribe *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ConsumerReference1 = 1;
	size_t soap_flag_Filter1 = 1;
	size_t soap_flag_InitialTerminationTime1 = 1;
	size_t soap_flag_SubscriptionPolicy1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConsumerReference1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsa5__EndpointReferenceType(soap, "wsnb:ConsumerReference", &(a->_wsnb__Subscribe::ConsumerReference), "wsa5:EndpointReferenceType"))
				{	soap_flag_ConsumerReference1--;
					continue;
				}
			if (soap_flag_Filter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnb__FilterType(soap, "wsnb:Filter", &(a->_wsnb__Subscribe::Filter), "wsnb:FilterType"))
				{	soap_flag_Filter1--;
					continue;
				}
			if (soap_flag_InitialTerminationTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTowsnb__AbsoluteOrRelativeTimeType(soap, "wsnb:InitialTerminationTime", &(a->_wsnb__Subscribe::InitialTerminationTime), "wsnb:AbsoluteOrRelativeTimeType"))
				{	soap_flag_InitialTerminationTime1--;
					continue;
				}
			if (soap_flag_SubscriptionPolicy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnb__Subscribe_SubscriptionPolicy(soap, "wsnb:SubscriptionPolicy", &(a->_wsnb__Subscribe::SubscriptionPolicy), ""))
				{	soap_flag_SubscriptionPolicy1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_wsnb__Subscribe::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__Subscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__Subscribe, 0, sizeof(_wsnb__Subscribe), 0, soap_copy__wsnb__Subscribe);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConsumerReference1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _wsnb__Subscribe::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__Subscribe);
	if (this->soap_out(soap, tag?tag:"wsnb:Subscribe", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__Subscribe::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__Subscribe(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__Subscribe * SOAP_FMAC4 soap_get__wsnb__Subscribe(struct soap *soap, _wsnb__Subscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__Subscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__Subscribe * SOAP_FMAC2 soap_instantiate__wsnb__Subscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__Subscribe(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__Subscribe, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__Subscribe);
		if (size)
			*size = sizeof(_wsnb__Subscribe);
		((_wsnb__Subscribe*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__Subscribe[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__Subscribe);
		for (int i = 0; i < n; i++)
			((_wsnb__Subscribe*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__Subscribe*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__Subscribe(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__Subscribe %p -> %p\n", q, p));
	*(_wsnb__Subscribe*)p = *(_wsnb__Subscribe*)q;
}

void _wsnb__UseRaw::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _wsnb__UseRaw::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _wsnb__UseRaw::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__UseRaw(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__UseRaw(struct soap *soap, const char *tag, int id, const _wsnb__UseRaw *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__UseRaw), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_wsnb__UseRaw::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__UseRaw(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__UseRaw * SOAP_FMAC4 soap_in__wsnb__UseRaw(struct soap *soap, const char *tag, _wsnb__UseRaw *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__UseRaw *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__UseRaw, sizeof(_wsnb__UseRaw), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__UseRaw)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__UseRaw *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__UseRaw *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__UseRaw, 0, sizeof(_wsnb__UseRaw), 0, soap_copy__wsnb__UseRaw);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _wsnb__UseRaw::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__UseRaw);
	if (this->soap_out(soap, tag?tag:"wsnb:UseRaw", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__UseRaw::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__UseRaw(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__UseRaw * SOAP_FMAC4 soap_get__wsnb__UseRaw(struct soap *soap, _wsnb__UseRaw *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__UseRaw(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__UseRaw * SOAP_FMAC2 soap_instantiate__wsnb__UseRaw(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__UseRaw(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__UseRaw, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__UseRaw);
		if (size)
			*size = sizeof(_wsnb__UseRaw);
		((_wsnb__UseRaw*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__UseRaw[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__UseRaw);
		for (int i = 0; i < n; i++)
			((_wsnb__UseRaw*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__UseRaw*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__UseRaw(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__UseRaw %p -> %p\n", q, p));
	*(_wsnb__UseRaw*)p = *(_wsnb__UseRaw*)q;
}

void _wsnb__Notify::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTowsnb__NotificationMessageHolderType(soap, &this->_wsnb__Notify::NotificationMessage);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__Notify::__any);
	/* transient soap skipped */
}

void _wsnb__Notify::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTowsnb__NotificationMessageHolderType(soap, &this->_wsnb__Notify::NotificationMessage);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->_wsnb__Notify::__any);
	/* transient soap skipped */
}

int _wsnb__Notify::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__Notify(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__Notify(struct soap *soap, const char *tag, int id, const _wsnb__Notify *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__Notify), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowsnb__NotificationMessageHolderType(soap, "wsnb:NotificationMessage", -1, &(a->_wsnb__Notify::NotificationMessage), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->_wsnb__Notify::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_wsnb__Notify::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__Notify(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__Notify * SOAP_FMAC4 soap_in__wsnb__Notify(struct soap *soap, const char *tag, _wsnb__Notify *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__Notify *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__Notify, sizeof(_wsnb__Notify), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__Notify)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__Notify *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTowsnb__NotificationMessageHolderType(soap, "wsnb:NotificationMessage", &(a->_wsnb__Notify::NotificationMessage), "wsnb:NotificationMessageHolderType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->_wsnb__Notify::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__Notify *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__Notify, 0, sizeof(_wsnb__Notify), 0, soap_copy__wsnb__Notify);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_wsnb__Notify::NotificationMessage.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _wsnb__Notify::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__Notify);
	if (this->soap_out(soap, tag?tag:"wsnb:Notify", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__Notify::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__Notify(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__Notify * SOAP_FMAC4 soap_get__wsnb__Notify(struct soap *soap, _wsnb__Notify *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__Notify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__Notify * SOAP_FMAC2 soap_instantiate__wsnb__Notify(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__Notify(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__Notify, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__Notify);
		if (size)
			*size = sizeof(_wsnb__Notify);
		((_wsnb__Notify*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__Notify[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__Notify);
		for (int i = 0; i < n; i++)
			((_wsnb__Notify*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__Notify*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__Notify(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__Notify %p -> %p\n", q, p));
	*(_wsnb__Notify*)p = *(_wsnb__Notify*)q;
}

void _wsnb__SubscriptionManagerRP::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_wsa5__EndpointReferenceType(soap, &this->_wsnb__SubscriptionManagerRP::ConsumerReference);
	this->_wsnb__SubscriptionManagerRP::Filter = NULL;
	this->_wsnb__SubscriptionManagerRP::SubscriptionPolicy = NULL;
	this->_wsnb__SubscriptionManagerRP::CreationTime = NULL;
	/* transient soap skipped */
}

void _wsnb__SubscriptionManagerRP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_wsnb__SubscriptionManagerRP::ConsumerReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &this->_wsnb__SubscriptionManagerRP::ConsumerReference);
	soap_serialize_PointerTowsnb__FilterType(soap, &this->_wsnb__SubscriptionManagerRP::Filter);
	soap_serialize_PointerTowsnb__SubscriptionPolicyType(soap, &this->_wsnb__SubscriptionManagerRP::SubscriptionPolicy);
	soap_serialize_PointerTotime(soap, &this->_wsnb__SubscriptionManagerRP::CreationTime);
	/* transient soap skipped */
}

int _wsnb__SubscriptionManagerRP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__SubscriptionManagerRP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__SubscriptionManagerRP(struct soap *soap, const char *tag, int id, const _wsnb__SubscriptionManagerRP *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__SubscriptionManagerRP), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnb:ConsumerReference", -1, &(a->_wsnb__SubscriptionManagerRP::ConsumerReference), ""))
		return soap->error;
	if (soap_out_PointerTowsnb__FilterType(soap, "wsnb:Filter", -1, &(a->_wsnb__SubscriptionManagerRP::Filter), ""))
		return soap->error;
	if (soap_out_PointerTowsnb__SubscriptionPolicyType(soap, "wsnb:SubscriptionPolicy", -1, &(a->_wsnb__SubscriptionManagerRP::SubscriptionPolicy), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "wsnb:CreationTime", -1, &(a->_wsnb__SubscriptionManagerRP::CreationTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_wsnb__SubscriptionManagerRP::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__SubscriptionManagerRP(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__SubscriptionManagerRP * SOAP_FMAC4 soap_in__wsnb__SubscriptionManagerRP(struct soap *soap, const char *tag, _wsnb__SubscriptionManagerRP *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__SubscriptionManagerRP *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__SubscriptionManagerRP, sizeof(_wsnb__SubscriptionManagerRP), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__SubscriptionManagerRP)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__SubscriptionManagerRP *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ConsumerReference1 = 1;
	size_t soap_flag_Filter1 = 1;
	size_t soap_flag_SubscriptionPolicy1 = 1;
	size_t soap_flag_CreationTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConsumerReference1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsa5__EndpointReferenceType(soap, "wsnb:ConsumerReference", &(a->_wsnb__SubscriptionManagerRP::ConsumerReference), "wsa5:EndpointReferenceType"))
				{	soap_flag_ConsumerReference1--;
					continue;
				}
			if (soap_flag_Filter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnb__FilterType(soap, "wsnb:Filter", &(a->_wsnb__SubscriptionManagerRP::Filter), "wsnb:FilterType"))
				{	soap_flag_Filter1--;
					continue;
				}
			if (soap_flag_SubscriptionPolicy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnb__SubscriptionPolicyType(soap, "wsnb:SubscriptionPolicy", &(a->_wsnb__SubscriptionManagerRP::SubscriptionPolicy), "wsnb:SubscriptionPolicyType"))
				{	soap_flag_SubscriptionPolicy1--;
					continue;
				}
			if (soap_flag_CreationTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "wsnb:CreationTime", &(a->_wsnb__SubscriptionManagerRP::CreationTime), "xsd:dateTime"))
				{	soap_flag_CreationTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__SubscriptionManagerRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__SubscriptionManagerRP, 0, sizeof(_wsnb__SubscriptionManagerRP), 0, soap_copy__wsnb__SubscriptionManagerRP);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConsumerReference1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _wsnb__SubscriptionManagerRP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__SubscriptionManagerRP);
	if (this->soap_out(soap, tag?tag:"wsnb:SubscriptionManagerRP", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__SubscriptionManagerRP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__SubscriptionManagerRP(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__SubscriptionManagerRP * SOAP_FMAC4 soap_get__wsnb__SubscriptionManagerRP(struct soap *soap, _wsnb__SubscriptionManagerRP *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__SubscriptionManagerRP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__SubscriptionManagerRP * SOAP_FMAC2 soap_instantiate__wsnb__SubscriptionManagerRP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__SubscriptionManagerRP(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__SubscriptionManagerRP, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__SubscriptionManagerRP);
		if (size)
			*size = sizeof(_wsnb__SubscriptionManagerRP);
		((_wsnb__SubscriptionManagerRP*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__SubscriptionManagerRP[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__SubscriptionManagerRP);
		for (int i = 0; i < n; i++)
			((_wsnb__SubscriptionManagerRP*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__SubscriptionManagerRP*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__SubscriptionManagerRP(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__SubscriptionManagerRP %p -> %p\n", q, p));
	*(_wsnb__SubscriptionManagerRP*)p = *(_wsnb__SubscriptionManagerRP*)q;
}

void _wsnb__NotificationProducerRP::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTowsnb__TopicExpressionType(soap, &this->_wsnb__NotificationProducerRP::TopicExpression);
	this->_wsnb__NotificationProducerRP::FixedTopicSet = NULL;
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_wsnb__NotificationProducerRP::TopicExpressionDialect);
	this->_wsnb__NotificationProducerRP::wstop__TopicSet = NULL;
	/* transient soap skipped */
}

void _wsnb__NotificationProducerRP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTowsnb__TopicExpressionType(soap, &this->_wsnb__NotificationProducerRP::TopicExpression);
	soap_serialize_PointerTobool(soap, &this->_wsnb__NotificationProducerRP::FixedTopicSet);
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_wsnb__NotificationProducerRP::TopicExpressionDialect);
	soap_serialize_PointerTowstop__TopicSetType(soap, &this->_wsnb__NotificationProducerRP::wstop__TopicSet);
	/* transient soap skipped */
}

int _wsnb__NotificationProducerRP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__wsnb__NotificationProducerRP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnb__NotificationProducerRP(struct soap *soap, const char *tag, int id, const _wsnb__NotificationProducerRP *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnb__NotificationProducerRP), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTowsnb__TopicExpressionType(soap, "wsnb:TopicExpression", -1, &(a->_wsnb__NotificationProducerRP::TopicExpression), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "wsnb:FixedTopicSet", -1, &(a->_wsnb__NotificationProducerRP::FixedTopicSet), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "wsnb:TopicExpressionDialect", -1, &(a->_wsnb__NotificationProducerRP::TopicExpressionDialect), ""))
		return soap->error;
	if (soap_out_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", -1, &(a->_wsnb__NotificationProducerRP::wstop__TopicSet), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_wsnb__NotificationProducerRP::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__wsnb__NotificationProducerRP(soap, tag, this, type);
}

SOAP_FMAC3 _wsnb__NotificationProducerRP * SOAP_FMAC4 soap_in__wsnb__NotificationProducerRP(struct soap *soap, const char *tag, _wsnb__NotificationProducerRP *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_wsnb__NotificationProducerRP *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsnb__NotificationProducerRP, sizeof(_wsnb__NotificationProducerRP), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__wsnb__NotificationProducerRP)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_wsnb__NotificationProducerRP *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_FixedTopicSet1 = 1;
	size_t soap_flag_wstop__TopicSet1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTowsnb__TopicExpressionType(soap, "wsnb:TopicExpression", &(a->_wsnb__NotificationProducerRP::TopicExpression), "wsnb:TopicExpressionType"))
					continue;
			if (soap_flag_FixedTopicSet1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "wsnb:FixedTopicSet", &(a->_wsnb__NotificationProducerRP::FixedTopicSet), "xsd:boolean"))
				{	soap_flag_FixedTopicSet1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "wsnb:TopicExpressionDialect", &(a->_wsnb__NotificationProducerRP::TopicExpressionDialect), "xsd:anyURI"))
					continue;
			if (soap_flag_wstop__TopicSet1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", &(a->_wsnb__NotificationProducerRP::wstop__TopicSet), "wstop:TopicSetType"))
				{	soap_flag_wstop__TopicSet1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_wsnb__NotificationProducerRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnb__NotificationProducerRP, 0, sizeof(_wsnb__NotificationProducerRP), 0, soap_copy__wsnb__NotificationProducerRP);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _wsnb__NotificationProducerRP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__wsnb__NotificationProducerRP);
	if (this->soap_out(soap, tag?tag:"wsnb:NotificationProducerRP", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_wsnb__NotificationProducerRP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__wsnb__NotificationProducerRP(soap, this, tag, type);
}

SOAP_FMAC3 _wsnb__NotificationProducerRP * SOAP_FMAC4 soap_get__wsnb__NotificationProducerRP(struct soap *soap, _wsnb__NotificationProducerRP *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnb__NotificationProducerRP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _wsnb__NotificationProducerRP * SOAP_FMAC2 soap_instantiate__wsnb__NotificationProducerRP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsnb__NotificationProducerRP(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsnb__NotificationProducerRP, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__NotificationProducerRP);
		if (size)
			*size = sizeof(_wsnb__NotificationProducerRP);
		((_wsnb__NotificationProducerRP*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_wsnb__NotificationProducerRP[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_wsnb__NotificationProducerRP);
		for (int i = 0; i < n; i++)
			((_wsnb__NotificationProducerRP*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_wsnb__NotificationProducerRP*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsnb__NotificationProducerRP(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _wsnb__NotificationProducerRP %p -> %p\n", q, p));
	*(_wsnb__NotificationProducerRP*)p = *(_wsnb__NotificationProducerRP*)q;
}

void wsnb__ResumeFailedFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_time(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	this->wsrfbf__BaseFaultType::__sizeDescription = 0;
	this->wsrfbf__BaseFaultType::Description = NULL;
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsrfbf__BaseFaultType::__anyAttribute);
	/* transient soap skipped */
}

void wsnb__ResumeFailedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	if (this->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->wsrfbf__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->wsrfbf__BaseFaultType::Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			this->wsrfbf__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int wsnb__ResumeFailedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__ResumeFailedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__ResumeFailedFaultType(struct soap *soap, const char *tag, int id, const wsnb__ResumeFailedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__ResumeFailedFaultType), "wsnb:ResumeFailedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsrfbf__BaseFaultType::__any), ""))
		return soap->error;
	if (soap_out_time(soap, "wsrfbf:Timestamp", -1, &(a->wsrfbf__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &(a->wsrfbf__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->wsrfbf__BaseFaultType::__sizeDescription; i++)
			if (a->wsrfbf__BaseFaultType::Description[i].soap_out(soap, "wsrfbf:Description", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &(a->wsrfbf__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wsnb__ResumeFailedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__ResumeFailedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__ResumeFailedFaultType * SOAP_FMAC4 soap_in_wsnb__ResumeFailedFaultType(struct soap *soap, const char *tag, wsnb__ResumeFailedFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__ResumeFailedFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__ResumeFailedFaultType, sizeof(wsnb__ResumeFailedFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__ResumeFailedFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__ResumeFailedFaultType *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	struct soap_blist *soap_blist_Description2 = NULL;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsrfbf:Timestamp", &(a->wsrfbf__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &(a->wsrfbf__BaseFaultType::Originator), "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__BaseFaultType::Description == NULL)
				{	if (soap_blist_Description2 == NULL)
						soap_blist_Description2 = soap_new_block(soap);
					a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_push_block(soap, soap_blist_Description2, sizeof(_wsrfbf__BaseFaultType_Description));
					if (a->wsrfbf__BaseFaultType::Description == NULL)
						return NULL;
					_wsrfbf__BaseFaultType_Description p;
					memcpy(a->wsrfbf__BaseFaultType::Description, &p, sizeof(_wsrfbf__BaseFaultType_Description)); // a bit rough but portable
					a->wsrfbf__BaseFaultType::Description->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__BaseFaultType::Description, ""))
				{	a->wsrfbf__BaseFaultType::__sizeDescription++;
					a->wsrfbf__BaseFaultType::Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &(a->wsrfbf__BaseFaultType::FaultCause), ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsrfbf__BaseFaultType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__BaseFaultType::Description)
			soap_pop_block(soap, soap_blist_Description2);
		if (a->wsrfbf__BaseFaultType::__sizeDescription)
			a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description2, NULL, 1);
		else
		{	a->wsrfbf__BaseFaultType::Description = NULL;
			if (soap_blist_Description2)
				soap_end_block(soap, soap_blist_Description2);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__ResumeFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__ResumeFailedFaultType, 0, sizeof(wsnb__ResumeFailedFaultType), 0, soap_copy_wsnb__ResumeFailedFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int wsnb__ResumeFailedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__ResumeFailedFaultType);
	if (this->soap_out(soap, tag?tag:"wsnb:ResumeFailedFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__ResumeFailedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__ResumeFailedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__ResumeFailedFaultType * SOAP_FMAC4 soap_get_wsnb__ResumeFailedFaultType(struct soap *soap, wsnb__ResumeFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__ResumeFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__ResumeFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnb__ResumeFailedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__ResumeFailedFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__ResumeFailedFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__ResumeFailedFaultType);
		if (size)
			*size = sizeof(wsnb__ResumeFailedFaultType);
		((wsnb__ResumeFailedFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__ResumeFailedFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__ResumeFailedFaultType);
		for (int i = 0; i < n; i++)
			((wsnb__ResumeFailedFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__ResumeFailedFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__ResumeFailedFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__ResumeFailedFaultType %p -> %p\n", q, p));
	*(wsnb__ResumeFailedFaultType*)p = *(wsnb__ResumeFailedFaultType*)q;
}

void wsnb__PauseFailedFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_time(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	this->wsrfbf__BaseFaultType::__sizeDescription = 0;
	this->wsrfbf__BaseFaultType::Description = NULL;
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsrfbf__BaseFaultType::__anyAttribute);
	/* transient soap skipped */
}

void wsnb__PauseFailedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	if (this->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->wsrfbf__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->wsrfbf__BaseFaultType::Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			this->wsrfbf__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int wsnb__PauseFailedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__PauseFailedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__PauseFailedFaultType(struct soap *soap, const char *tag, int id, const wsnb__PauseFailedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__PauseFailedFaultType), "wsnb:PauseFailedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsrfbf__BaseFaultType::__any), ""))
		return soap->error;
	if (soap_out_time(soap, "wsrfbf:Timestamp", -1, &(a->wsrfbf__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &(a->wsrfbf__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->wsrfbf__BaseFaultType::__sizeDescription; i++)
			if (a->wsrfbf__BaseFaultType::Description[i].soap_out(soap, "wsrfbf:Description", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &(a->wsrfbf__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wsnb__PauseFailedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__PauseFailedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__PauseFailedFaultType * SOAP_FMAC4 soap_in_wsnb__PauseFailedFaultType(struct soap *soap, const char *tag, wsnb__PauseFailedFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__PauseFailedFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__PauseFailedFaultType, sizeof(wsnb__PauseFailedFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__PauseFailedFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__PauseFailedFaultType *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	struct soap_blist *soap_blist_Description2 = NULL;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsrfbf:Timestamp", &(a->wsrfbf__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &(a->wsrfbf__BaseFaultType::Originator), "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__BaseFaultType::Description == NULL)
				{	if (soap_blist_Description2 == NULL)
						soap_blist_Description2 = soap_new_block(soap);
					a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_push_block(soap, soap_blist_Description2, sizeof(_wsrfbf__BaseFaultType_Description));
					if (a->wsrfbf__BaseFaultType::Description == NULL)
						return NULL;
					_wsrfbf__BaseFaultType_Description p;
					memcpy(a->wsrfbf__BaseFaultType::Description, &p, sizeof(_wsrfbf__BaseFaultType_Description)); // a bit rough but portable
					a->wsrfbf__BaseFaultType::Description->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__BaseFaultType::Description, ""))
				{	a->wsrfbf__BaseFaultType::__sizeDescription++;
					a->wsrfbf__BaseFaultType::Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &(a->wsrfbf__BaseFaultType::FaultCause), ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsrfbf__BaseFaultType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__BaseFaultType::Description)
			soap_pop_block(soap, soap_blist_Description2);
		if (a->wsrfbf__BaseFaultType::__sizeDescription)
			a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description2, NULL, 1);
		else
		{	a->wsrfbf__BaseFaultType::Description = NULL;
			if (soap_blist_Description2)
				soap_end_block(soap, soap_blist_Description2);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__PauseFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__PauseFailedFaultType, 0, sizeof(wsnb__PauseFailedFaultType), 0, soap_copy_wsnb__PauseFailedFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int wsnb__PauseFailedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__PauseFailedFaultType);
	if (this->soap_out(soap, tag?tag:"wsnb:PauseFailedFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__PauseFailedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__PauseFailedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__PauseFailedFaultType * SOAP_FMAC4 soap_get_wsnb__PauseFailedFaultType(struct soap *soap, wsnb__PauseFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__PauseFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__PauseFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnb__PauseFailedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__PauseFailedFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__PauseFailedFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__PauseFailedFaultType);
		if (size)
			*size = sizeof(wsnb__PauseFailedFaultType);
		((wsnb__PauseFailedFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__PauseFailedFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__PauseFailedFaultType);
		for (int i = 0; i < n; i++)
			((wsnb__PauseFailedFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__PauseFailedFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__PauseFailedFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__PauseFailedFaultType %p -> %p\n", q, p));
	*(wsnb__PauseFailedFaultType*)p = *(wsnb__PauseFailedFaultType*)q;
}

void wsnb__UnableToDestroySubscriptionFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_time(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	this->wsrfbf__BaseFaultType::__sizeDescription = 0;
	this->wsrfbf__BaseFaultType::Description = NULL;
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsrfbf__BaseFaultType::__anyAttribute);
	/* transient soap skipped */
}

void wsnb__UnableToDestroySubscriptionFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	if (this->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->wsrfbf__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->wsrfbf__BaseFaultType::Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			this->wsrfbf__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int wsnb__UnableToDestroySubscriptionFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__UnableToDestroySubscriptionFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, int id, const wsnb__UnableToDestroySubscriptionFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__UnableToDestroySubscriptionFaultType), "wsnb:UnableToDestroySubscriptionFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsrfbf__BaseFaultType::__any), ""))
		return soap->error;
	if (soap_out_time(soap, "wsrfbf:Timestamp", -1, &(a->wsrfbf__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &(a->wsrfbf__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->wsrfbf__BaseFaultType::__sizeDescription; i++)
			if (a->wsrfbf__BaseFaultType::Description[i].soap_out(soap, "wsrfbf:Description", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &(a->wsrfbf__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wsnb__UnableToDestroySubscriptionFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__UnableToDestroySubscriptionFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_in_wsnb__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, wsnb__UnableToDestroySubscriptionFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__UnableToDestroySubscriptionFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__UnableToDestroySubscriptionFaultType, sizeof(wsnb__UnableToDestroySubscriptionFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__UnableToDestroySubscriptionFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__UnableToDestroySubscriptionFaultType *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	struct soap_blist *soap_blist_Description2 = NULL;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsrfbf:Timestamp", &(a->wsrfbf__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &(a->wsrfbf__BaseFaultType::Originator), "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__BaseFaultType::Description == NULL)
				{	if (soap_blist_Description2 == NULL)
						soap_blist_Description2 = soap_new_block(soap);
					a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_push_block(soap, soap_blist_Description2, sizeof(_wsrfbf__BaseFaultType_Description));
					if (a->wsrfbf__BaseFaultType::Description == NULL)
						return NULL;
					_wsrfbf__BaseFaultType_Description p;
					memcpy(a->wsrfbf__BaseFaultType::Description, &p, sizeof(_wsrfbf__BaseFaultType_Description)); // a bit rough but portable
					a->wsrfbf__BaseFaultType::Description->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__BaseFaultType::Description, ""))
				{	a->wsrfbf__BaseFaultType::__sizeDescription++;
					a->wsrfbf__BaseFaultType::Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &(a->wsrfbf__BaseFaultType::FaultCause), ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsrfbf__BaseFaultType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__BaseFaultType::Description)
			soap_pop_block(soap, soap_blist_Description2);
		if (a->wsrfbf__BaseFaultType::__sizeDescription)
			a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description2, NULL, 1);
		else
		{	a->wsrfbf__BaseFaultType::Description = NULL;
			if (soap_blist_Description2)
				soap_end_block(soap, soap_blist_Description2);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__UnableToDestroySubscriptionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__UnableToDestroySubscriptionFaultType, 0, sizeof(wsnb__UnableToDestroySubscriptionFaultType), 0, soap_copy_wsnb__UnableToDestroySubscriptionFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int wsnb__UnableToDestroySubscriptionFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__UnableToDestroySubscriptionFaultType);
	if (this->soap_out(soap, tag?tag:"wsnb:UnableToDestroySubscriptionFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__UnableToDestroySubscriptionFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__UnableToDestroySubscriptionFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_get_wsnb__UnableToDestroySubscriptionFaultType(struct soap *soap, wsnb__UnableToDestroySubscriptionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__UnableToDestroySubscriptionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__UnableToDestroySubscriptionFaultType * SOAP_FMAC2 soap_instantiate_wsnb__UnableToDestroySubscriptionFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__UnableToDestroySubscriptionFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__UnableToDestroySubscriptionFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__UnableToDestroySubscriptionFaultType);
		if (size)
			*size = sizeof(wsnb__UnableToDestroySubscriptionFaultType);
		((wsnb__UnableToDestroySubscriptionFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__UnableToDestroySubscriptionFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__UnableToDestroySubscriptionFaultType);
		for (int i = 0; i < n; i++)
			((wsnb__UnableToDestroySubscriptionFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__UnableToDestroySubscriptionFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__UnableToDestroySubscriptionFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__UnableToDestroySubscriptionFaultType %p -> %p\n", q, p));
	*(wsnb__UnableToDestroySubscriptionFaultType*)p = *(wsnb__UnableToDestroySubscriptionFaultType*)q;
}

void wsnb__UnacceptableTerminationTimeFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->wsnb__UnacceptableTerminationTimeFaultType::MinimumTime);
	this->wsnb__UnacceptableTerminationTimeFaultType::MaximumTime = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_time(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	this->wsrfbf__BaseFaultType::__sizeDescription = 0;
	this->wsrfbf__BaseFaultType::Description = NULL;
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsrfbf__BaseFaultType::__anyAttribute);
	/* transient soap skipped */
}

void wsnb__UnacceptableTerminationTimeFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->wsnb__UnacceptableTerminationTimeFaultType::MinimumTime, SOAP_TYPE_time);
	soap_serialize_PointerTotime(soap, &this->wsnb__UnacceptableTerminationTimeFaultType::MaximumTime);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	if (this->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->wsrfbf__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->wsrfbf__BaseFaultType::Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			this->wsrfbf__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int wsnb__UnacceptableTerminationTimeFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__UnacceptableTerminationTimeFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, int id, const wsnb__UnacceptableTerminationTimeFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__UnacceptableTerminationTimeFaultType), "wsnb:UnacceptableTerminationTimeFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsrfbf__BaseFaultType::__any), ""))
		return soap->error;
	if (soap_out_time(soap, "wsrfbf:Timestamp", -1, &(a->wsrfbf__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &(a->wsrfbf__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->wsrfbf__BaseFaultType::__sizeDescription; i++)
			if (a->wsrfbf__BaseFaultType::Description[i].soap_out(soap, "wsrfbf:Description", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &(a->wsrfbf__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_time(soap, "wsnb:MinimumTime", -1, &(a->wsnb__UnacceptableTerminationTimeFaultType::MinimumTime), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "wsnb:MaximumTime", -1, &(a->wsnb__UnacceptableTerminationTimeFaultType::MaximumTime), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnb__UnacceptableTerminationTimeFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__UnacceptableTerminationTimeFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_in_wsnb__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, wsnb__UnacceptableTerminationTimeFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__UnacceptableTerminationTimeFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__UnacceptableTerminationTimeFaultType, sizeof(wsnb__UnacceptableTerminationTimeFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__UnacceptableTerminationTimeFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__UnacceptableTerminationTimeFaultType *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	struct soap_blist *soap_blist_Description2 = NULL;
	size_t soap_flag_FaultCause2 = 1;
	size_t soap_flag_MinimumTime1 = 1;
	size_t soap_flag_MaximumTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsrfbf:Timestamp", &(a->wsrfbf__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &(a->wsrfbf__BaseFaultType::Originator), "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__BaseFaultType::Description == NULL)
				{	if (soap_blist_Description2 == NULL)
						soap_blist_Description2 = soap_new_block(soap);
					a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_push_block(soap, soap_blist_Description2, sizeof(_wsrfbf__BaseFaultType_Description));
					if (a->wsrfbf__BaseFaultType::Description == NULL)
						return NULL;
					_wsrfbf__BaseFaultType_Description p;
					memcpy(a->wsrfbf__BaseFaultType::Description, &p, sizeof(_wsrfbf__BaseFaultType_Description)); // a bit rough but portable
					a->wsrfbf__BaseFaultType::Description->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__BaseFaultType::Description, ""))
				{	a->wsrfbf__BaseFaultType::__sizeDescription++;
					a->wsrfbf__BaseFaultType::Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &(a->wsrfbf__BaseFaultType::FaultCause), ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_MinimumTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsnb:MinimumTime", &(a->wsnb__UnacceptableTerminationTimeFaultType::MinimumTime), "xsd:dateTime"))
				{	soap_flag_MinimumTime1--;
					continue;
				}
			if (soap_flag_MaximumTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "wsnb:MaximumTime", &(a->wsnb__UnacceptableTerminationTimeFaultType::MaximumTime), "xsd:dateTime"))
				{	soap_flag_MaximumTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsrfbf__BaseFaultType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__BaseFaultType::Description)
			soap_pop_block(soap, soap_blist_Description2);
		if (a->wsrfbf__BaseFaultType::__sizeDescription)
			a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description2, NULL, 1);
		else
		{	a->wsrfbf__BaseFaultType::Description = NULL;
			if (soap_blist_Description2)
				soap_end_block(soap, soap_blist_Description2);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__UnacceptableTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__UnacceptableTerminationTimeFaultType, 0, sizeof(wsnb__UnacceptableTerminationTimeFaultType), 0, soap_copy_wsnb__UnacceptableTerminationTimeFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0 || soap_flag_MinimumTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int wsnb__UnacceptableTerminationTimeFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__UnacceptableTerminationTimeFaultType);
	if (this->soap_out(soap, tag?tag:"wsnb:UnacceptableTerminationTimeFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__UnacceptableTerminationTimeFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__UnacceptableTerminationTimeFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_get_wsnb__UnacceptableTerminationTimeFaultType(struct soap *soap, wsnb__UnacceptableTerminationTimeFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__UnacceptableTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__UnacceptableTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_wsnb__UnacceptableTerminationTimeFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__UnacceptableTerminationTimeFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__UnacceptableTerminationTimeFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__UnacceptableTerminationTimeFaultType);
		if (size)
			*size = sizeof(wsnb__UnacceptableTerminationTimeFaultType);
		((wsnb__UnacceptableTerminationTimeFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__UnacceptableTerminationTimeFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__UnacceptableTerminationTimeFaultType);
		for (int i = 0; i < n; i++)
			((wsnb__UnacceptableTerminationTimeFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__UnacceptableTerminationTimeFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__UnacceptableTerminationTimeFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__UnacceptableTerminationTimeFaultType %p -> %p\n", q, p));
	*(wsnb__UnacceptableTerminationTimeFaultType*)p = *(wsnb__UnacceptableTerminationTimeFaultType*)q;
}

void wsnb__UnableToCreatePullPointFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_time(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	this->wsrfbf__BaseFaultType::__sizeDescription = 0;
	this->wsrfbf__BaseFaultType::Description = NULL;
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsrfbf__BaseFaultType::__anyAttribute);
	/* transient soap skipped */
}

void wsnb__UnableToCreatePullPointFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	if (this->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->wsrfbf__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->wsrfbf__BaseFaultType::Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			this->wsrfbf__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int wsnb__UnableToCreatePullPointFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__UnableToCreatePullPointFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, int id, const wsnb__UnableToCreatePullPointFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__UnableToCreatePullPointFaultType), "wsnb:UnableToCreatePullPointFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsrfbf__BaseFaultType::__any), ""))
		return soap->error;
	if (soap_out_time(soap, "wsrfbf:Timestamp", -1, &(a->wsrfbf__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &(a->wsrfbf__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->wsrfbf__BaseFaultType::__sizeDescription; i++)
			if (a->wsrfbf__BaseFaultType::Description[i].soap_out(soap, "wsrfbf:Description", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &(a->wsrfbf__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wsnb__UnableToCreatePullPointFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__UnableToCreatePullPointFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_in_wsnb__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, wsnb__UnableToCreatePullPointFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__UnableToCreatePullPointFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__UnableToCreatePullPointFaultType, sizeof(wsnb__UnableToCreatePullPointFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__UnableToCreatePullPointFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__UnableToCreatePullPointFaultType *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	struct soap_blist *soap_blist_Description2 = NULL;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsrfbf:Timestamp", &(a->wsrfbf__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &(a->wsrfbf__BaseFaultType::Originator), "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__BaseFaultType::Description == NULL)
				{	if (soap_blist_Description2 == NULL)
						soap_blist_Description2 = soap_new_block(soap);
					a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_push_block(soap, soap_blist_Description2, sizeof(_wsrfbf__BaseFaultType_Description));
					if (a->wsrfbf__BaseFaultType::Description == NULL)
						return NULL;
					_wsrfbf__BaseFaultType_Description p;
					memcpy(a->wsrfbf__BaseFaultType::Description, &p, sizeof(_wsrfbf__BaseFaultType_Description)); // a bit rough but portable
					a->wsrfbf__BaseFaultType::Description->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__BaseFaultType::Description, ""))
				{	a->wsrfbf__BaseFaultType::__sizeDescription++;
					a->wsrfbf__BaseFaultType::Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &(a->wsrfbf__BaseFaultType::FaultCause), ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsrfbf__BaseFaultType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__BaseFaultType::Description)
			soap_pop_block(soap, soap_blist_Description2);
		if (a->wsrfbf__BaseFaultType::__sizeDescription)
			a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description2, NULL, 1);
		else
		{	a->wsrfbf__BaseFaultType::Description = NULL;
			if (soap_blist_Description2)
				soap_end_block(soap, soap_blist_Description2);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__UnableToCreatePullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__UnableToCreatePullPointFaultType, 0, sizeof(wsnb__UnableToCreatePullPointFaultType), 0, soap_copy_wsnb__UnableToCreatePullPointFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int wsnb__UnableToCreatePullPointFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__UnableToCreatePullPointFaultType);
	if (this->soap_out(soap, tag?tag:"wsnb:UnableToCreatePullPointFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__UnableToCreatePullPointFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__UnableToCreatePullPointFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_get_wsnb__UnableToCreatePullPointFaultType(struct soap *soap, wsnb__UnableToCreatePullPointFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__UnableToCreatePullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__UnableToCreatePullPointFaultType * SOAP_FMAC2 soap_instantiate_wsnb__UnableToCreatePullPointFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__UnableToCreatePullPointFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__UnableToCreatePullPointFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__UnableToCreatePullPointFaultType);
		if (size)
			*size = sizeof(wsnb__UnableToCreatePullPointFaultType);
		((wsnb__UnableToCreatePullPointFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__UnableToCreatePullPointFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__UnableToCreatePullPointFaultType);
		for (int i = 0; i < n; i++)
			((wsnb__UnableToCreatePullPointFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__UnableToCreatePullPointFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__UnableToCreatePullPointFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__UnableToCreatePullPointFaultType %p -> %p\n", q, p));
	*(wsnb__UnableToCreatePullPointFaultType*)p = *(wsnb__UnableToCreatePullPointFaultType*)q;
}

void wsnb__UnableToDestroyPullPointFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_time(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	this->wsrfbf__BaseFaultType::__sizeDescription = 0;
	this->wsrfbf__BaseFaultType::Description = NULL;
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsrfbf__BaseFaultType::__anyAttribute);
	/* transient soap skipped */
}

void wsnb__UnableToDestroyPullPointFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	if (this->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->wsrfbf__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->wsrfbf__BaseFaultType::Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			this->wsrfbf__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int wsnb__UnableToDestroyPullPointFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__UnableToDestroyPullPointFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, int id, const wsnb__UnableToDestroyPullPointFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__UnableToDestroyPullPointFaultType), "wsnb:UnableToDestroyPullPointFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsrfbf__BaseFaultType::__any), ""))
		return soap->error;
	if (soap_out_time(soap, "wsrfbf:Timestamp", -1, &(a->wsrfbf__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &(a->wsrfbf__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->wsrfbf__BaseFaultType::__sizeDescription; i++)
			if (a->wsrfbf__BaseFaultType::Description[i].soap_out(soap, "wsrfbf:Description", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &(a->wsrfbf__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wsnb__UnableToDestroyPullPointFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__UnableToDestroyPullPointFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_in_wsnb__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, wsnb__UnableToDestroyPullPointFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__UnableToDestroyPullPointFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__UnableToDestroyPullPointFaultType, sizeof(wsnb__UnableToDestroyPullPointFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__UnableToDestroyPullPointFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__UnableToDestroyPullPointFaultType *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	struct soap_blist *soap_blist_Description2 = NULL;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsrfbf:Timestamp", &(a->wsrfbf__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &(a->wsrfbf__BaseFaultType::Originator), "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__BaseFaultType::Description == NULL)
				{	if (soap_blist_Description2 == NULL)
						soap_blist_Description2 = soap_new_block(soap);
					a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_push_block(soap, soap_blist_Description2, sizeof(_wsrfbf__BaseFaultType_Description));
					if (a->wsrfbf__BaseFaultType::Description == NULL)
						return NULL;
					_wsrfbf__BaseFaultType_Description p;
					memcpy(a->wsrfbf__BaseFaultType::Description, &p, sizeof(_wsrfbf__BaseFaultType_Description)); // a bit rough but portable
					a->wsrfbf__BaseFaultType::Description->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__BaseFaultType::Description, ""))
				{	a->wsrfbf__BaseFaultType::__sizeDescription++;
					a->wsrfbf__BaseFaultType::Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &(a->wsrfbf__BaseFaultType::FaultCause), ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsrfbf__BaseFaultType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__BaseFaultType::Description)
			soap_pop_block(soap, soap_blist_Description2);
		if (a->wsrfbf__BaseFaultType::__sizeDescription)
			a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description2, NULL, 1);
		else
		{	a->wsrfbf__BaseFaultType::Description = NULL;
			if (soap_blist_Description2)
				soap_end_block(soap, soap_blist_Description2);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__UnableToDestroyPullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__UnableToDestroyPullPointFaultType, 0, sizeof(wsnb__UnableToDestroyPullPointFaultType), 0, soap_copy_wsnb__UnableToDestroyPullPointFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int wsnb__UnableToDestroyPullPointFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__UnableToDestroyPullPointFaultType);
	if (this->soap_out(soap, tag?tag:"wsnb:UnableToDestroyPullPointFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__UnableToDestroyPullPointFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__UnableToDestroyPullPointFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_get_wsnb__UnableToDestroyPullPointFaultType(struct soap *soap, wsnb__UnableToDestroyPullPointFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__UnableToDestroyPullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__UnableToDestroyPullPointFaultType * SOAP_FMAC2 soap_instantiate_wsnb__UnableToDestroyPullPointFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__UnableToDestroyPullPointFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__UnableToDestroyPullPointFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__UnableToDestroyPullPointFaultType);
		if (size)
			*size = sizeof(wsnb__UnableToDestroyPullPointFaultType);
		((wsnb__UnableToDestroyPullPointFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__UnableToDestroyPullPointFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__UnableToDestroyPullPointFaultType);
		for (int i = 0; i < n; i++)
			((wsnb__UnableToDestroyPullPointFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__UnableToDestroyPullPointFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__UnableToDestroyPullPointFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__UnableToDestroyPullPointFaultType %p -> %p\n", q, p));
	*(wsnb__UnableToDestroyPullPointFaultType*)p = *(wsnb__UnableToDestroyPullPointFaultType*)q;
}

void wsnb__UnableToGetMessagesFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_time(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	this->wsrfbf__BaseFaultType::__sizeDescription = 0;
	this->wsrfbf__BaseFaultType::Description = NULL;
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsrfbf__BaseFaultType::__anyAttribute);
	/* transient soap skipped */
}

void wsnb__UnableToGetMessagesFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	if (this->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->wsrfbf__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->wsrfbf__BaseFaultType::Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			this->wsrfbf__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int wsnb__UnableToGetMessagesFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__UnableToGetMessagesFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, int id, const wsnb__UnableToGetMessagesFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__UnableToGetMessagesFaultType), "wsnb:UnableToGetMessagesFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsrfbf__BaseFaultType::__any), ""))
		return soap->error;
	if (soap_out_time(soap, "wsrfbf:Timestamp", -1, &(a->wsrfbf__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &(a->wsrfbf__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->wsrfbf__BaseFaultType::__sizeDescription; i++)
			if (a->wsrfbf__BaseFaultType::Description[i].soap_out(soap, "wsrfbf:Description", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &(a->wsrfbf__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wsnb__UnableToGetMessagesFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__UnableToGetMessagesFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_in_wsnb__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, wsnb__UnableToGetMessagesFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__UnableToGetMessagesFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__UnableToGetMessagesFaultType, sizeof(wsnb__UnableToGetMessagesFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__UnableToGetMessagesFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__UnableToGetMessagesFaultType *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	struct soap_blist *soap_blist_Description2 = NULL;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsrfbf:Timestamp", &(a->wsrfbf__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &(a->wsrfbf__BaseFaultType::Originator), "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__BaseFaultType::Description == NULL)
				{	if (soap_blist_Description2 == NULL)
						soap_blist_Description2 = soap_new_block(soap);
					a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_push_block(soap, soap_blist_Description2, sizeof(_wsrfbf__BaseFaultType_Description));
					if (a->wsrfbf__BaseFaultType::Description == NULL)
						return NULL;
					_wsrfbf__BaseFaultType_Description p;
					memcpy(a->wsrfbf__BaseFaultType::Description, &p, sizeof(_wsrfbf__BaseFaultType_Description)); // a bit rough but portable
					a->wsrfbf__BaseFaultType::Description->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__BaseFaultType::Description, ""))
				{	a->wsrfbf__BaseFaultType::__sizeDescription++;
					a->wsrfbf__BaseFaultType::Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &(a->wsrfbf__BaseFaultType::FaultCause), ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsrfbf__BaseFaultType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__BaseFaultType::Description)
			soap_pop_block(soap, soap_blist_Description2);
		if (a->wsrfbf__BaseFaultType::__sizeDescription)
			a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description2, NULL, 1);
		else
		{	a->wsrfbf__BaseFaultType::Description = NULL;
			if (soap_blist_Description2)
				soap_end_block(soap, soap_blist_Description2);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__UnableToGetMessagesFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__UnableToGetMessagesFaultType, 0, sizeof(wsnb__UnableToGetMessagesFaultType), 0, soap_copy_wsnb__UnableToGetMessagesFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int wsnb__UnableToGetMessagesFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__UnableToGetMessagesFaultType);
	if (this->soap_out(soap, tag?tag:"wsnb:UnableToGetMessagesFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__UnableToGetMessagesFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__UnableToGetMessagesFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_get_wsnb__UnableToGetMessagesFaultType(struct soap *soap, wsnb__UnableToGetMessagesFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__UnableToGetMessagesFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__UnableToGetMessagesFaultType * SOAP_FMAC2 soap_instantiate_wsnb__UnableToGetMessagesFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__UnableToGetMessagesFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__UnableToGetMessagesFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__UnableToGetMessagesFaultType);
		if (size)
			*size = sizeof(wsnb__UnableToGetMessagesFaultType);
		((wsnb__UnableToGetMessagesFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__UnableToGetMessagesFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__UnableToGetMessagesFaultType);
		for (int i = 0; i < n; i++)
			((wsnb__UnableToGetMessagesFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__UnableToGetMessagesFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__UnableToGetMessagesFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__UnableToGetMessagesFaultType %p -> %p\n", q, p));
	*(wsnb__UnableToGetMessagesFaultType*)p = *(wsnb__UnableToGetMessagesFaultType*)q;
}

void wsnb__NoCurrentMessageOnTopicFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_time(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	this->wsrfbf__BaseFaultType::__sizeDescription = 0;
	this->wsrfbf__BaseFaultType::Description = NULL;
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsrfbf__BaseFaultType::__anyAttribute);
	/* transient soap skipped */
}

void wsnb__NoCurrentMessageOnTopicFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	if (this->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->wsrfbf__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->wsrfbf__BaseFaultType::Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			this->wsrfbf__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int wsnb__NoCurrentMessageOnTopicFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__NoCurrentMessageOnTopicFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, int id, const wsnb__NoCurrentMessageOnTopicFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__NoCurrentMessageOnTopicFaultType), "wsnb:NoCurrentMessageOnTopicFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsrfbf__BaseFaultType::__any), ""))
		return soap->error;
	if (soap_out_time(soap, "wsrfbf:Timestamp", -1, &(a->wsrfbf__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &(a->wsrfbf__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->wsrfbf__BaseFaultType::__sizeDescription; i++)
			if (a->wsrfbf__BaseFaultType::Description[i].soap_out(soap, "wsrfbf:Description", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &(a->wsrfbf__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wsnb__NoCurrentMessageOnTopicFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__NoCurrentMessageOnTopicFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_in_wsnb__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, wsnb__NoCurrentMessageOnTopicFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__NoCurrentMessageOnTopicFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__NoCurrentMessageOnTopicFaultType, sizeof(wsnb__NoCurrentMessageOnTopicFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__NoCurrentMessageOnTopicFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__NoCurrentMessageOnTopicFaultType *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	struct soap_blist *soap_blist_Description2 = NULL;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsrfbf:Timestamp", &(a->wsrfbf__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &(a->wsrfbf__BaseFaultType::Originator), "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__BaseFaultType::Description == NULL)
				{	if (soap_blist_Description2 == NULL)
						soap_blist_Description2 = soap_new_block(soap);
					a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_push_block(soap, soap_blist_Description2, sizeof(_wsrfbf__BaseFaultType_Description));
					if (a->wsrfbf__BaseFaultType::Description == NULL)
						return NULL;
					_wsrfbf__BaseFaultType_Description p;
					memcpy(a->wsrfbf__BaseFaultType::Description, &p, sizeof(_wsrfbf__BaseFaultType_Description)); // a bit rough but portable
					a->wsrfbf__BaseFaultType::Description->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__BaseFaultType::Description, ""))
				{	a->wsrfbf__BaseFaultType::__sizeDescription++;
					a->wsrfbf__BaseFaultType::Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &(a->wsrfbf__BaseFaultType::FaultCause), ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsrfbf__BaseFaultType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__BaseFaultType::Description)
			soap_pop_block(soap, soap_blist_Description2);
		if (a->wsrfbf__BaseFaultType::__sizeDescription)
			a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description2, NULL, 1);
		else
		{	a->wsrfbf__BaseFaultType::Description = NULL;
			if (soap_blist_Description2)
				soap_end_block(soap, soap_blist_Description2);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__NoCurrentMessageOnTopicFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__NoCurrentMessageOnTopicFaultType, 0, sizeof(wsnb__NoCurrentMessageOnTopicFaultType), 0, soap_copy_wsnb__NoCurrentMessageOnTopicFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int wsnb__NoCurrentMessageOnTopicFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__NoCurrentMessageOnTopicFaultType);
	if (this->soap_out(soap, tag?tag:"wsnb:NoCurrentMessageOnTopicFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__NoCurrentMessageOnTopicFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__NoCurrentMessageOnTopicFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_get_wsnb__NoCurrentMessageOnTopicFaultType(struct soap *soap, wsnb__NoCurrentMessageOnTopicFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__NoCurrentMessageOnTopicFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__NoCurrentMessageOnTopicFaultType * SOAP_FMAC2 soap_instantiate_wsnb__NoCurrentMessageOnTopicFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__NoCurrentMessageOnTopicFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__NoCurrentMessageOnTopicFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__NoCurrentMessageOnTopicFaultType);
		if (size)
			*size = sizeof(wsnb__NoCurrentMessageOnTopicFaultType);
		((wsnb__NoCurrentMessageOnTopicFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__NoCurrentMessageOnTopicFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__NoCurrentMessageOnTopicFaultType);
		for (int i = 0; i < n; i++)
			((wsnb__NoCurrentMessageOnTopicFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__NoCurrentMessageOnTopicFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__NoCurrentMessageOnTopicFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__NoCurrentMessageOnTopicFaultType %p -> %p\n", q, p));
	*(wsnb__NoCurrentMessageOnTopicFaultType*)p = *(wsnb__NoCurrentMessageOnTopicFaultType*)q;
}

void wsnb__UnacceptableInitialTerminationTimeFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->wsnb__UnacceptableInitialTerminationTimeFaultType::MinimumTime);
	this->wsnb__UnacceptableInitialTerminationTimeFaultType::MaximumTime = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_time(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	this->wsrfbf__BaseFaultType::__sizeDescription = 0;
	this->wsrfbf__BaseFaultType::Description = NULL;
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsrfbf__BaseFaultType::__anyAttribute);
	/* transient soap skipped */
}

void wsnb__UnacceptableInitialTerminationTimeFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->wsnb__UnacceptableInitialTerminationTimeFaultType::MinimumTime, SOAP_TYPE_time);
	soap_serialize_PointerTotime(soap, &this->wsnb__UnacceptableInitialTerminationTimeFaultType::MaximumTime);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	if (this->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->wsrfbf__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->wsrfbf__BaseFaultType::Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			this->wsrfbf__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int wsnb__UnacceptableInitialTerminationTimeFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__UnacceptableInitialTerminationTimeFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, int id, const wsnb__UnacceptableInitialTerminationTimeFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__UnacceptableInitialTerminationTimeFaultType), "wsnb:UnacceptableInitialTerminationTimeFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsrfbf__BaseFaultType::__any), ""))
		return soap->error;
	if (soap_out_time(soap, "wsrfbf:Timestamp", -1, &(a->wsrfbf__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &(a->wsrfbf__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->wsrfbf__BaseFaultType::__sizeDescription; i++)
			if (a->wsrfbf__BaseFaultType::Description[i].soap_out(soap, "wsrfbf:Description", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &(a->wsrfbf__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_time(soap, "wsnb:MinimumTime", -1, &(a->wsnb__UnacceptableInitialTerminationTimeFaultType::MinimumTime), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "wsnb:MaximumTime", -1, &(a->wsnb__UnacceptableInitialTerminationTimeFaultType::MaximumTime), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnb__UnacceptableInitialTerminationTimeFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__UnacceptableInitialTerminationTimeFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_in_wsnb__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, wsnb__UnacceptableInitialTerminationTimeFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__UnacceptableInitialTerminationTimeFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__UnacceptableInitialTerminationTimeFaultType, sizeof(wsnb__UnacceptableInitialTerminationTimeFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__UnacceptableInitialTerminationTimeFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__UnacceptableInitialTerminationTimeFaultType *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	struct soap_blist *soap_blist_Description2 = NULL;
	size_t soap_flag_FaultCause2 = 1;
	size_t soap_flag_MinimumTime1 = 1;
	size_t soap_flag_MaximumTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsrfbf:Timestamp", &(a->wsrfbf__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &(a->wsrfbf__BaseFaultType::Originator), "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__BaseFaultType::Description == NULL)
				{	if (soap_blist_Description2 == NULL)
						soap_blist_Description2 = soap_new_block(soap);
					a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_push_block(soap, soap_blist_Description2, sizeof(_wsrfbf__BaseFaultType_Description));
					if (a->wsrfbf__BaseFaultType::Description == NULL)
						return NULL;
					_wsrfbf__BaseFaultType_Description p;
					memcpy(a->wsrfbf__BaseFaultType::Description, &p, sizeof(_wsrfbf__BaseFaultType_Description)); // a bit rough but portable
					a->wsrfbf__BaseFaultType::Description->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__BaseFaultType::Description, ""))
				{	a->wsrfbf__BaseFaultType::__sizeDescription++;
					a->wsrfbf__BaseFaultType::Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &(a->wsrfbf__BaseFaultType::FaultCause), ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_MinimumTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsnb:MinimumTime", &(a->wsnb__UnacceptableInitialTerminationTimeFaultType::MinimumTime), "xsd:dateTime"))
				{	soap_flag_MinimumTime1--;
					continue;
				}
			if (soap_flag_MaximumTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "wsnb:MaximumTime", &(a->wsnb__UnacceptableInitialTerminationTimeFaultType::MaximumTime), "xsd:dateTime"))
				{	soap_flag_MaximumTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsrfbf__BaseFaultType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__BaseFaultType::Description)
			soap_pop_block(soap, soap_blist_Description2);
		if (a->wsrfbf__BaseFaultType::__sizeDescription)
			a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description2, NULL, 1);
		else
		{	a->wsrfbf__BaseFaultType::Description = NULL;
			if (soap_blist_Description2)
				soap_end_block(soap, soap_blist_Description2);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__UnacceptableInitialTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__UnacceptableInitialTerminationTimeFaultType, 0, sizeof(wsnb__UnacceptableInitialTerminationTimeFaultType), 0, soap_copy_wsnb__UnacceptableInitialTerminationTimeFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0 || soap_flag_MinimumTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int wsnb__UnacceptableInitialTerminationTimeFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__UnacceptableInitialTerminationTimeFaultType);
	if (this->soap_out(soap, tag?tag:"wsnb:UnacceptableInitialTerminationTimeFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__UnacceptableInitialTerminationTimeFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__UnacceptableInitialTerminationTimeFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_get_wsnb__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, wsnb__UnacceptableInitialTerminationTimeFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__UnacceptableInitialTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_wsnb__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__UnacceptableInitialTerminationTimeFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__UnacceptableInitialTerminationTimeFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__UnacceptableInitialTerminationTimeFaultType);
		if (size)
			*size = sizeof(wsnb__UnacceptableInitialTerminationTimeFaultType);
		((wsnb__UnacceptableInitialTerminationTimeFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__UnacceptableInitialTerminationTimeFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__UnacceptableInitialTerminationTimeFaultType);
		for (int i = 0; i < n; i++)
			((wsnb__UnacceptableInitialTerminationTimeFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__UnacceptableInitialTerminationTimeFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__UnacceptableInitialTerminationTimeFaultType %p -> %p\n", q, p));
	*(wsnb__UnacceptableInitialTerminationTimeFaultType*)p = *(wsnb__UnacceptableInitialTerminationTimeFaultType*)q;
}

void wsnb__NotifyMessageNotSupportedFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_time(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	this->wsrfbf__BaseFaultType::__sizeDescription = 0;
	this->wsrfbf__BaseFaultType::Description = NULL;
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsrfbf__BaseFaultType::__anyAttribute);
	/* transient soap skipped */
}

void wsnb__NotifyMessageNotSupportedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	if (this->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->wsrfbf__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->wsrfbf__BaseFaultType::Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			this->wsrfbf__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int wsnb__NotifyMessageNotSupportedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__NotifyMessageNotSupportedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, int id, const wsnb__NotifyMessageNotSupportedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__NotifyMessageNotSupportedFaultType), "wsnb:NotifyMessageNotSupportedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsrfbf__BaseFaultType::__any), ""))
		return soap->error;
	if (soap_out_time(soap, "wsrfbf:Timestamp", -1, &(a->wsrfbf__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &(a->wsrfbf__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->wsrfbf__BaseFaultType::__sizeDescription; i++)
			if (a->wsrfbf__BaseFaultType::Description[i].soap_out(soap, "wsrfbf:Description", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &(a->wsrfbf__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wsnb__NotifyMessageNotSupportedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__NotifyMessageNotSupportedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_in_wsnb__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, wsnb__NotifyMessageNotSupportedFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__NotifyMessageNotSupportedFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__NotifyMessageNotSupportedFaultType, sizeof(wsnb__NotifyMessageNotSupportedFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__NotifyMessageNotSupportedFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__NotifyMessageNotSupportedFaultType *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	struct soap_blist *soap_blist_Description2 = NULL;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsrfbf:Timestamp", &(a->wsrfbf__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &(a->wsrfbf__BaseFaultType::Originator), "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__BaseFaultType::Description == NULL)
				{	if (soap_blist_Description2 == NULL)
						soap_blist_Description2 = soap_new_block(soap);
					a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_push_block(soap, soap_blist_Description2, sizeof(_wsrfbf__BaseFaultType_Description));
					if (a->wsrfbf__BaseFaultType::Description == NULL)
						return NULL;
					_wsrfbf__BaseFaultType_Description p;
					memcpy(a->wsrfbf__BaseFaultType::Description, &p, sizeof(_wsrfbf__BaseFaultType_Description)); // a bit rough but portable
					a->wsrfbf__BaseFaultType::Description->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__BaseFaultType::Description, ""))
				{	a->wsrfbf__BaseFaultType::__sizeDescription++;
					a->wsrfbf__BaseFaultType::Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &(a->wsrfbf__BaseFaultType::FaultCause), ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsrfbf__BaseFaultType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__BaseFaultType::Description)
			soap_pop_block(soap, soap_blist_Description2);
		if (a->wsrfbf__BaseFaultType::__sizeDescription)
			a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description2, NULL, 1);
		else
		{	a->wsrfbf__BaseFaultType::Description = NULL;
			if (soap_blist_Description2)
				soap_end_block(soap, soap_blist_Description2);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__NotifyMessageNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__NotifyMessageNotSupportedFaultType, 0, sizeof(wsnb__NotifyMessageNotSupportedFaultType), 0, soap_copy_wsnb__NotifyMessageNotSupportedFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int wsnb__NotifyMessageNotSupportedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__NotifyMessageNotSupportedFaultType);
	if (this->soap_out(soap, tag?tag:"wsnb:NotifyMessageNotSupportedFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__NotifyMessageNotSupportedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__NotifyMessageNotSupportedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_get_wsnb__NotifyMessageNotSupportedFaultType(struct soap *soap, wsnb__NotifyMessageNotSupportedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__NotifyMessageNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__NotifyMessageNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_wsnb__NotifyMessageNotSupportedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__NotifyMessageNotSupportedFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__NotifyMessageNotSupportedFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__NotifyMessageNotSupportedFaultType);
		if (size)
			*size = sizeof(wsnb__NotifyMessageNotSupportedFaultType);
		((wsnb__NotifyMessageNotSupportedFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__NotifyMessageNotSupportedFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__NotifyMessageNotSupportedFaultType);
		for (int i = 0; i < n; i++)
			((wsnb__NotifyMessageNotSupportedFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__NotifyMessageNotSupportedFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__NotifyMessageNotSupportedFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__NotifyMessageNotSupportedFaultType %p -> %p\n", q, p));
	*(wsnb__NotifyMessageNotSupportedFaultType*)p = *(wsnb__NotifyMessageNotSupportedFaultType*)q;
}

void wsnb__UnsupportedPolicyRequestFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__QName(soap, &this->wsnb__UnsupportedPolicyRequestFaultType::UnsupportedPolicy);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_time(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	this->wsrfbf__BaseFaultType::__sizeDescription = 0;
	this->wsrfbf__BaseFaultType::Description = NULL;
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsrfbf__BaseFaultType::__anyAttribute);
	/* transient soap skipped */
}

void wsnb__UnsupportedPolicyRequestFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &this->wsnb__UnsupportedPolicyRequestFaultType::UnsupportedPolicy);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	if (this->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->wsrfbf__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->wsrfbf__BaseFaultType::Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			this->wsrfbf__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int wsnb__UnsupportedPolicyRequestFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__UnsupportedPolicyRequestFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, const wsnb__UnsupportedPolicyRequestFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__UnsupportedPolicyRequestFaultType), "wsnb:UnsupportedPolicyRequestFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsrfbf__BaseFaultType::__any), ""))
		return soap->error;
	if (soap_out_time(soap, "wsrfbf:Timestamp", -1, &(a->wsrfbf__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &(a->wsrfbf__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->wsrfbf__BaseFaultType::__sizeDescription; i++)
			if (a->wsrfbf__BaseFaultType::Description[i].soap_out(soap, "wsrfbf:Description", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &(a->wsrfbf__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfxsd__QName(soap, "wsnb:UnsupportedPolicy", -1, &(a->wsnb__UnsupportedPolicyRequestFaultType::UnsupportedPolicy), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnb__UnsupportedPolicyRequestFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__UnsupportedPolicyRequestFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_in_wsnb__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, wsnb__UnsupportedPolicyRequestFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__UnsupportedPolicyRequestFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__UnsupportedPolicyRequestFaultType, sizeof(wsnb__UnsupportedPolicyRequestFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__UnsupportedPolicyRequestFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__UnsupportedPolicyRequestFaultType *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	struct soap_blist *soap_blist_Description2 = NULL;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsrfbf:Timestamp", &(a->wsrfbf__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &(a->wsrfbf__BaseFaultType::Originator), "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__BaseFaultType::Description == NULL)
				{	if (soap_blist_Description2 == NULL)
						soap_blist_Description2 = soap_new_block(soap);
					a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_push_block(soap, soap_blist_Description2, sizeof(_wsrfbf__BaseFaultType_Description));
					if (a->wsrfbf__BaseFaultType::Description == NULL)
						return NULL;
					_wsrfbf__BaseFaultType_Description p;
					memcpy(a->wsrfbf__BaseFaultType::Description, &p, sizeof(_wsrfbf__BaseFaultType_Description)); // a bit rough but portable
					a->wsrfbf__BaseFaultType::Description->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__BaseFaultType::Description, ""))
				{	a->wsrfbf__BaseFaultType::__sizeDescription++;
					a->wsrfbf__BaseFaultType::Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &(a->wsrfbf__BaseFaultType::FaultCause), ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__QName(soap, "wsnb:UnsupportedPolicy", &(a->wsnb__UnsupportedPolicyRequestFaultType::UnsupportedPolicy), "xsd:QName"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsrfbf__BaseFaultType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__BaseFaultType::Description)
			soap_pop_block(soap, soap_blist_Description2);
		if (a->wsrfbf__BaseFaultType::__sizeDescription)
			a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description2, NULL, 1);
		else
		{	a->wsrfbf__BaseFaultType::Description = NULL;
			if (soap_blist_Description2)
				soap_end_block(soap, soap_blist_Description2);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__UnsupportedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__UnsupportedPolicyRequestFaultType, 0, sizeof(wsnb__UnsupportedPolicyRequestFaultType), 0, soap_copy_wsnb__UnsupportedPolicyRequestFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int wsnb__UnsupportedPolicyRequestFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__UnsupportedPolicyRequestFaultType);
	if (this->soap_out(soap, tag?tag:"wsnb:UnsupportedPolicyRequestFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__UnsupportedPolicyRequestFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__UnsupportedPolicyRequestFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_get_wsnb__UnsupportedPolicyRequestFaultType(struct soap *soap, wsnb__UnsupportedPolicyRequestFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__UnsupportedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__UnsupportedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_wsnb__UnsupportedPolicyRequestFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__UnsupportedPolicyRequestFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__UnsupportedPolicyRequestFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__UnsupportedPolicyRequestFaultType);
		if (size)
			*size = sizeof(wsnb__UnsupportedPolicyRequestFaultType);
		((wsnb__UnsupportedPolicyRequestFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__UnsupportedPolicyRequestFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__UnsupportedPolicyRequestFaultType);
		for (int i = 0; i < n; i++)
			((wsnb__UnsupportedPolicyRequestFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__UnsupportedPolicyRequestFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__UnsupportedPolicyRequestFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__UnsupportedPolicyRequestFaultType %p -> %p\n", q, p));
	*(wsnb__UnsupportedPolicyRequestFaultType*)p = *(wsnb__UnsupportedPolicyRequestFaultType*)q;
}

void wsnb__UnrecognizedPolicyRequestFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__QName(soap, &this->wsnb__UnrecognizedPolicyRequestFaultType::UnrecognizedPolicy);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_time(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	this->wsrfbf__BaseFaultType::__sizeDescription = 0;
	this->wsrfbf__BaseFaultType::Description = NULL;
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsrfbf__BaseFaultType::__anyAttribute);
	/* transient soap skipped */
}

void wsnb__UnrecognizedPolicyRequestFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &this->wsnb__UnrecognizedPolicyRequestFaultType::UnrecognizedPolicy);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	if (this->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->wsrfbf__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->wsrfbf__BaseFaultType::Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			this->wsrfbf__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int wsnb__UnrecognizedPolicyRequestFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__UnrecognizedPolicyRequestFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, const wsnb__UnrecognizedPolicyRequestFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__UnrecognizedPolicyRequestFaultType), "wsnb:UnrecognizedPolicyRequestFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsrfbf__BaseFaultType::__any), ""))
		return soap->error;
	if (soap_out_time(soap, "wsrfbf:Timestamp", -1, &(a->wsrfbf__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &(a->wsrfbf__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->wsrfbf__BaseFaultType::__sizeDescription; i++)
			if (a->wsrfbf__BaseFaultType::Description[i].soap_out(soap, "wsrfbf:Description", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &(a->wsrfbf__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfxsd__QName(soap, "wsnb:UnrecognizedPolicy", -1, &(a->wsnb__UnrecognizedPolicyRequestFaultType::UnrecognizedPolicy), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnb__UnrecognizedPolicyRequestFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__UnrecognizedPolicyRequestFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_in_wsnb__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, wsnb__UnrecognizedPolicyRequestFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__UnrecognizedPolicyRequestFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__UnrecognizedPolicyRequestFaultType, sizeof(wsnb__UnrecognizedPolicyRequestFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__UnrecognizedPolicyRequestFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__UnrecognizedPolicyRequestFaultType *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	struct soap_blist *soap_blist_Description2 = NULL;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsrfbf:Timestamp", &(a->wsrfbf__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &(a->wsrfbf__BaseFaultType::Originator), "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__BaseFaultType::Description == NULL)
				{	if (soap_blist_Description2 == NULL)
						soap_blist_Description2 = soap_new_block(soap);
					a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_push_block(soap, soap_blist_Description2, sizeof(_wsrfbf__BaseFaultType_Description));
					if (a->wsrfbf__BaseFaultType::Description == NULL)
						return NULL;
					_wsrfbf__BaseFaultType_Description p;
					memcpy(a->wsrfbf__BaseFaultType::Description, &p, sizeof(_wsrfbf__BaseFaultType_Description)); // a bit rough but portable
					a->wsrfbf__BaseFaultType::Description->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__BaseFaultType::Description, ""))
				{	a->wsrfbf__BaseFaultType::__sizeDescription++;
					a->wsrfbf__BaseFaultType::Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &(a->wsrfbf__BaseFaultType::FaultCause), ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__QName(soap, "wsnb:UnrecognizedPolicy", &(a->wsnb__UnrecognizedPolicyRequestFaultType::UnrecognizedPolicy), "xsd:QName"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsrfbf__BaseFaultType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__BaseFaultType::Description)
			soap_pop_block(soap, soap_blist_Description2);
		if (a->wsrfbf__BaseFaultType::__sizeDescription)
			a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description2, NULL, 1);
		else
		{	a->wsrfbf__BaseFaultType::Description = NULL;
			if (soap_blist_Description2)
				soap_end_block(soap, soap_blist_Description2);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__UnrecognizedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__UnrecognizedPolicyRequestFaultType, 0, sizeof(wsnb__UnrecognizedPolicyRequestFaultType), 0, soap_copy_wsnb__UnrecognizedPolicyRequestFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int wsnb__UnrecognizedPolicyRequestFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__UnrecognizedPolicyRequestFaultType);
	if (this->soap_out(soap, tag?tag:"wsnb:UnrecognizedPolicyRequestFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__UnrecognizedPolicyRequestFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__UnrecognizedPolicyRequestFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_get_wsnb__UnrecognizedPolicyRequestFaultType(struct soap *soap, wsnb__UnrecognizedPolicyRequestFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__UnrecognizedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__UnrecognizedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_wsnb__UnrecognizedPolicyRequestFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__UnrecognizedPolicyRequestFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__UnrecognizedPolicyRequestFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__UnrecognizedPolicyRequestFaultType);
		if (size)
			*size = sizeof(wsnb__UnrecognizedPolicyRequestFaultType);
		((wsnb__UnrecognizedPolicyRequestFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__UnrecognizedPolicyRequestFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__UnrecognizedPolicyRequestFaultType);
		for (int i = 0; i < n; i++)
			((wsnb__UnrecognizedPolicyRequestFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__UnrecognizedPolicyRequestFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__UnrecognizedPolicyRequestFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__UnrecognizedPolicyRequestFaultType %p -> %p\n", q, p));
	*(wsnb__UnrecognizedPolicyRequestFaultType*)p = *(wsnb__UnrecognizedPolicyRequestFaultType*)q;
}

void wsnb__InvalidMessageContentExpressionFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_time(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	this->wsrfbf__BaseFaultType::__sizeDescription = 0;
	this->wsrfbf__BaseFaultType::Description = NULL;
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsrfbf__BaseFaultType::__anyAttribute);
	/* transient soap skipped */
}

void wsnb__InvalidMessageContentExpressionFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	if (this->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->wsrfbf__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->wsrfbf__BaseFaultType::Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			this->wsrfbf__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int wsnb__InvalidMessageContentExpressionFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__InvalidMessageContentExpressionFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, int id, const wsnb__InvalidMessageContentExpressionFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__InvalidMessageContentExpressionFaultType), "wsnb:InvalidMessageContentExpressionFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsrfbf__BaseFaultType::__any), ""))
		return soap->error;
	if (soap_out_time(soap, "wsrfbf:Timestamp", -1, &(a->wsrfbf__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &(a->wsrfbf__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->wsrfbf__BaseFaultType::__sizeDescription; i++)
			if (a->wsrfbf__BaseFaultType::Description[i].soap_out(soap, "wsrfbf:Description", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &(a->wsrfbf__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wsnb__InvalidMessageContentExpressionFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__InvalidMessageContentExpressionFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_in_wsnb__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, wsnb__InvalidMessageContentExpressionFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__InvalidMessageContentExpressionFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__InvalidMessageContentExpressionFaultType, sizeof(wsnb__InvalidMessageContentExpressionFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__InvalidMessageContentExpressionFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__InvalidMessageContentExpressionFaultType *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	struct soap_blist *soap_blist_Description2 = NULL;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsrfbf:Timestamp", &(a->wsrfbf__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &(a->wsrfbf__BaseFaultType::Originator), "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__BaseFaultType::Description == NULL)
				{	if (soap_blist_Description2 == NULL)
						soap_blist_Description2 = soap_new_block(soap);
					a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_push_block(soap, soap_blist_Description2, sizeof(_wsrfbf__BaseFaultType_Description));
					if (a->wsrfbf__BaseFaultType::Description == NULL)
						return NULL;
					_wsrfbf__BaseFaultType_Description p;
					memcpy(a->wsrfbf__BaseFaultType::Description, &p, sizeof(_wsrfbf__BaseFaultType_Description)); // a bit rough but portable
					a->wsrfbf__BaseFaultType::Description->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__BaseFaultType::Description, ""))
				{	a->wsrfbf__BaseFaultType::__sizeDescription++;
					a->wsrfbf__BaseFaultType::Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &(a->wsrfbf__BaseFaultType::FaultCause), ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsrfbf__BaseFaultType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__BaseFaultType::Description)
			soap_pop_block(soap, soap_blist_Description2);
		if (a->wsrfbf__BaseFaultType::__sizeDescription)
			a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description2, NULL, 1);
		else
		{	a->wsrfbf__BaseFaultType::Description = NULL;
			if (soap_blist_Description2)
				soap_end_block(soap, soap_blist_Description2);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__InvalidMessageContentExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__InvalidMessageContentExpressionFaultType, 0, sizeof(wsnb__InvalidMessageContentExpressionFaultType), 0, soap_copy_wsnb__InvalidMessageContentExpressionFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int wsnb__InvalidMessageContentExpressionFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__InvalidMessageContentExpressionFaultType);
	if (this->soap_out(soap, tag?tag:"wsnb:InvalidMessageContentExpressionFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__InvalidMessageContentExpressionFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__InvalidMessageContentExpressionFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_get_wsnb__InvalidMessageContentExpressionFaultType(struct soap *soap, wsnb__InvalidMessageContentExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__InvalidMessageContentExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__InvalidMessageContentExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnb__InvalidMessageContentExpressionFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__InvalidMessageContentExpressionFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__InvalidMessageContentExpressionFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__InvalidMessageContentExpressionFaultType);
		if (size)
			*size = sizeof(wsnb__InvalidMessageContentExpressionFaultType);
		((wsnb__InvalidMessageContentExpressionFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__InvalidMessageContentExpressionFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__InvalidMessageContentExpressionFaultType);
		for (int i = 0; i < n; i++)
			((wsnb__InvalidMessageContentExpressionFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__InvalidMessageContentExpressionFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__InvalidMessageContentExpressionFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__InvalidMessageContentExpressionFaultType %p -> %p\n", q, p));
	*(wsnb__InvalidMessageContentExpressionFaultType*)p = *(wsnb__InvalidMessageContentExpressionFaultType*)q;
}

void wsnb__InvalidProducerPropertiesExpressionFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_time(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	this->wsrfbf__BaseFaultType::__sizeDescription = 0;
	this->wsrfbf__BaseFaultType::Description = NULL;
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsrfbf__BaseFaultType::__anyAttribute);
	/* transient soap skipped */
}

void wsnb__InvalidProducerPropertiesExpressionFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	if (this->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->wsrfbf__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->wsrfbf__BaseFaultType::Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			this->wsrfbf__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int wsnb__InvalidProducerPropertiesExpressionFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__InvalidProducerPropertiesExpressionFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, int id, const wsnb__InvalidProducerPropertiesExpressionFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__InvalidProducerPropertiesExpressionFaultType), "wsnb:InvalidProducerPropertiesExpressionFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsrfbf__BaseFaultType::__any), ""))
		return soap->error;
	if (soap_out_time(soap, "wsrfbf:Timestamp", -1, &(a->wsrfbf__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &(a->wsrfbf__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->wsrfbf__BaseFaultType::__sizeDescription; i++)
			if (a->wsrfbf__BaseFaultType::Description[i].soap_out(soap, "wsrfbf:Description", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &(a->wsrfbf__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wsnb__InvalidProducerPropertiesExpressionFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__InvalidProducerPropertiesExpressionFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_in_wsnb__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, wsnb__InvalidProducerPropertiesExpressionFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__InvalidProducerPropertiesExpressionFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__InvalidProducerPropertiesExpressionFaultType, sizeof(wsnb__InvalidProducerPropertiesExpressionFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__InvalidProducerPropertiesExpressionFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__InvalidProducerPropertiesExpressionFaultType *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	struct soap_blist *soap_blist_Description2 = NULL;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsrfbf:Timestamp", &(a->wsrfbf__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &(a->wsrfbf__BaseFaultType::Originator), "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__BaseFaultType::Description == NULL)
				{	if (soap_blist_Description2 == NULL)
						soap_blist_Description2 = soap_new_block(soap);
					a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_push_block(soap, soap_blist_Description2, sizeof(_wsrfbf__BaseFaultType_Description));
					if (a->wsrfbf__BaseFaultType::Description == NULL)
						return NULL;
					_wsrfbf__BaseFaultType_Description p;
					memcpy(a->wsrfbf__BaseFaultType::Description, &p, sizeof(_wsrfbf__BaseFaultType_Description)); // a bit rough but portable
					a->wsrfbf__BaseFaultType::Description->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__BaseFaultType::Description, ""))
				{	a->wsrfbf__BaseFaultType::__sizeDescription++;
					a->wsrfbf__BaseFaultType::Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &(a->wsrfbf__BaseFaultType::FaultCause), ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsrfbf__BaseFaultType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__BaseFaultType::Description)
			soap_pop_block(soap, soap_blist_Description2);
		if (a->wsrfbf__BaseFaultType::__sizeDescription)
			a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description2, NULL, 1);
		else
		{	a->wsrfbf__BaseFaultType::Description = NULL;
			if (soap_blist_Description2)
				soap_end_block(soap, soap_blist_Description2);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__InvalidProducerPropertiesExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__InvalidProducerPropertiesExpressionFaultType, 0, sizeof(wsnb__InvalidProducerPropertiesExpressionFaultType), 0, soap_copy_wsnb__InvalidProducerPropertiesExpressionFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int wsnb__InvalidProducerPropertiesExpressionFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__InvalidProducerPropertiesExpressionFaultType);
	if (this->soap_out(soap, tag?tag:"wsnb:InvalidProducerPropertiesExpressionFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__InvalidProducerPropertiesExpressionFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__InvalidProducerPropertiesExpressionFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_get_wsnb__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, wsnb__InvalidProducerPropertiesExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__InvalidProducerPropertiesExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnb__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__InvalidProducerPropertiesExpressionFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__InvalidProducerPropertiesExpressionFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__InvalidProducerPropertiesExpressionFaultType);
		if (size)
			*size = sizeof(wsnb__InvalidProducerPropertiesExpressionFaultType);
		((wsnb__InvalidProducerPropertiesExpressionFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__InvalidProducerPropertiesExpressionFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__InvalidProducerPropertiesExpressionFaultType);
		for (int i = 0; i < n; i++)
			((wsnb__InvalidProducerPropertiesExpressionFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__InvalidProducerPropertiesExpressionFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__InvalidProducerPropertiesExpressionFaultType %p -> %p\n", q, p));
	*(wsnb__InvalidProducerPropertiesExpressionFaultType*)p = *(wsnb__InvalidProducerPropertiesExpressionFaultType*)q;
}

void wsnb__MultipleTopicsSpecifiedFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_time(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	this->wsrfbf__BaseFaultType::__sizeDescription = 0;
	this->wsrfbf__BaseFaultType::Description = NULL;
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsrfbf__BaseFaultType::__anyAttribute);
	/* transient soap skipped */
}

void wsnb__MultipleTopicsSpecifiedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	if (this->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->wsrfbf__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->wsrfbf__BaseFaultType::Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			this->wsrfbf__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int wsnb__MultipleTopicsSpecifiedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__MultipleTopicsSpecifiedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, int id, const wsnb__MultipleTopicsSpecifiedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__MultipleTopicsSpecifiedFaultType), "wsnb:MultipleTopicsSpecifiedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsrfbf__BaseFaultType::__any), ""))
		return soap->error;
	if (soap_out_time(soap, "wsrfbf:Timestamp", -1, &(a->wsrfbf__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &(a->wsrfbf__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->wsrfbf__BaseFaultType::__sizeDescription; i++)
			if (a->wsrfbf__BaseFaultType::Description[i].soap_out(soap, "wsrfbf:Description", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &(a->wsrfbf__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wsnb__MultipleTopicsSpecifiedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__MultipleTopicsSpecifiedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_in_wsnb__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, wsnb__MultipleTopicsSpecifiedFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__MultipleTopicsSpecifiedFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__MultipleTopicsSpecifiedFaultType, sizeof(wsnb__MultipleTopicsSpecifiedFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__MultipleTopicsSpecifiedFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__MultipleTopicsSpecifiedFaultType *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	struct soap_blist *soap_blist_Description2 = NULL;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsrfbf:Timestamp", &(a->wsrfbf__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &(a->wsrfbf__BaseFaultType::Originator), "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__BaseFaultType::Description == NULL)
				{	if (soap_blist_Description2 == NULL)
						soap_blist_Description2 = soap_new_block(soap);
					a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_push_block(soap, soap_blist_Description2, sizeof(_wsrfbf__BaseFaultType_Description));
					if (a->wsrfbf__BaseFaultType::Description == NULL)
						return NULL;
					_wsrfbf__BaseFaultType_Description p;
					memcpy(a->wsrfbf__BaseFaultType::Description, &p, sizeof(_wsrfbf__BaseFaultType_Description)); // a bit rough but portable
					a->wsrfbf__BaseFaultType::Description->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__BaseFaultType::Description, ""))
				{	a->wsrfbf__BaseFaultType::__sizeDescription++;
					a->wsrfbf__BaseFaultType::Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &(a->wsrfbf__BaseFaultType::FaultCause), ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsrfbf__BaseFaultType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__BaseFaultType::Description)
			soap_pop_block(soap, soap_blist_Description2);
		if (a->wsrfbf__BaseFaultType::__sizeDescription)
			a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description2, NULL, 1);
		else
		{	a->wsrfbf__BaseFaultType::Description = NULL;
			if (soap_blist_Description2)
				soap_end_block(soap, soap_blist_Description2);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__MultipleTopicsSpecifiedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__MultipleTopicsSpecifiedFaultType, 0, sizeof(wsnb__MultipleTopicsSpecifiedFaultType), 0, soap_copy_wsnb__MultipleTopicsSpecifiedFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int wsnb__MultipleTopicsSpecifiedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__MultipleTopicsSpecifiedFaultType);
	if (this->soap_out(soap, tag?tag:"wsnb:MultipleTopicsSpecifiedFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__MultipleTopicsSpecifiedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__MultipleTopicsSpecifiedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_get_wsnb__MultipleTopicsSpecifiedFaultType(struct soap *soap, wsnb__MultipleTopicsSpecifiedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__MultipleTopicsSpecifiedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__MultipleTopicsSpecifiedFaultType * SOAP_FMAC2 soap_instantiate_wsnb__MultipleTopicsSpecifiedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__MultipleTopicsSpecifiedFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__MultipleTopicsSpecifiedFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__MultipleTopicsSpecifiedFaultType);
		if (size)
			*size = sizeof(wsnb__MultipleTopicsSpecifiedFaultType);
		((wsnb__MultipleTopicsSpecifiedFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__MultipleTopicsSpecifiedFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__MultipleTopicsSpecifiedFaultType);
		for (int i = 0; i < n; i++)
			((wsnb__MultipleTopicsSpecifiedFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__MultipleTopicsSpecifiedFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__MultipleTopicsSpecifiedFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__MultipleTopicsSpecifiedFaultType %p -> %p\n", q, p));
	*(wsnb__MultipleTopicsSpecifiedFaultType*)p = *(wsnb__MultipleTopicsSpecifiedFaultType*)q;
}

void wsnb__TopicNotSupportedFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_time(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	this->wsrfbf__BaseFaultType::__sizeDescription = 0;
	this->wsrfbf__BaseFaultType::Description = NULL;
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsrfbf__BaseFaultType::__anyAttribute);
	/* transient soap skipped */
}

void wsnb__TopicNotSupportedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	if (this->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->wsrfbf__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->wsrfbf__BaseFaultType::Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			this->wsrfbf__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int wsnb__TopicNotSupportedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__TopicNotSupportedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__TopicNotSupportedFaultType(struct soap *soap, const char *tag, int id, const wsnb__TopicNotSupportedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__TopicNotSupportedFaultType), "wsnb:TopicNotSupportedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsrfbf__BaseFaultType::__any), ""))
		return soap->error;
	if (soap_out_time(soap, "wsrfbf:Timestamp", -1, &(a->wsrfbf__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &(a->wsrfbf__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->wsrfbf__BaseFaultType::__sizeDescription; i++)
			if (a->wsrfbf__BaseFaultType::Description[i].soap_out(soap, "wsrfbf:Description", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &(a->wsrfbf__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wsnb__TopicNotSupportedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__TopicNotSupportedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__TopicNotSupportedFaultType * SOAP_FMAC4 soap_in_wsnb__TopicNotSupportedFaultType(struct soap *soap, const char *tag, wsnb__TopicNotSupportedFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__TopicNotSupportedFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__TopicNotSupportedFaultType, sizeof(wsnb__TopicNotSupportedFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__TopicNotSupportedFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__TopicNotSupportedFaultType *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	struct soap_blist *soap_blist_Description2 = NULL;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsrfbf:Timestamp", &(a->wsrfbf__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &(a->wsrfbf__BaseFaultType::Originator), "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__BaseFaultType::Description == NULL)
				{	if (soap_blist_Description2 == NULL)
						soap_blist_Description2 = soap_new_block(soap);
					a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_push_block(soap, soap_blist_Description2, sizeof(_wsrfbf__BaseFaultType_Description));
					if (a->wsrfbf__BaseFaultType::Description == NULL)
						return NULL;
					_wsrfbf__BaseFaultType_Description p;
					memcpy(a->wsrfbf__BaseFaultType::Description, &p, sizeof(_wsrfbf__BaseFaultType_Description)); // a bit rough but portable
					a->wsrfbf__BaseFaultType::Description->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__BaseFaultType::Description, ""))
				{	a->wsrfbf__BaseFaultType::__sizeDescription++;
					a->wsrfbf__BaseFaultType::Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &(a->wsrfbf__BaseFaultType::FaultCause), ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsrfbf__BaseFaultType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__BaseFaultType::Description)
			soap_pop_block(soap, soap_blist_Description2);
		if (a->wsrfbf__BaseFaultType::__sizeDescription)
			a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description2, NULL, 1);
		else
		{	a->wsrfbf__BaseFaultType::Description = NULL;
			if (soap_blist_Description2)
				soap_end_block(soap, soap_blist_Description2);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__TopicNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__TopicNotSupportedFaultType, 0, sizeof(wsnb__TopicNotSupportedFaultType), 0, soap_copy_wsnb__TopicNotSupportedFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int wsnb__TopicNotSupportedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__TopicNotSupportedFaultType);
	if (this->soap_out(soap, tag?tag:"wsnb:TopicNotSupportedFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__TopicNotSupportedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__TopicNotSupportedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__TopicNotSupportedFaultType * SOAP_FMAC4 soap_get_wsnb__TopicNotSupportedFaultType(struct soap *soap, wsnb__TopicNotSupportedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__TopicNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__TopicNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_wsnb__TopicNotSupportedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__TopicNotSupportedFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__TopicNotSupportedFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__TopicNotSupportedFaultType);
		if (size)
			*size = sizeof(wsnb__TopicNotSupportedFaultType);
		((wsnb__TopicNotSupportedFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__TopicNotSupportedFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__TopicNotSupportedFaultType);
		for (int i = 0; i < n; i++)
			((wsnb__TopicNotSupportedFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__TopicNotSupportedFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__TopicNotSupportedFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__TopicNotSupportedFaultType %p -> %p\n", q, p));
	*(wsnb__TopicNotSupportedFaultType*)p = *(wsnb__TopicNotSupportedFaultType*)q;
}

void wsnb__InvalidTopicExpressionFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_time(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	this->wsrfbf__BaseFaultType::__sizeDescription = 0;
	this->wsrfbf__BaseFaultType::Description = NULL;
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsrfbf__BaseFaultType::__anyAttribute);
	/* transient soap skipped */
}

void wsnb__InvalidTopicExpressionFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	if (this->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->wsrfbf__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->wsrfbf__BaseFaultType::Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			this->wsrfbf__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int wsnb__InvalidTopicExpressionFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__InvalidTopicExpressionFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, int id, const wsnb__InvalidTopicExpressionFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__InvalidTopicExpressionFaultType), "wsnb:InvalidTopicExpressionFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsrfbf__BaseFaultType::__any), ""))
		return soap->error;
	if (soap_out_time(soap, "wsrfbf:Timestamp", -1, &(a->wsrfbf__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &(a->wsrfbf__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->wsrfbf__BaseFaultType::__sizeDescription; i++)
			if (a->wsrfbf__BaseFaultType::Description[i].soap_out(soap, "wsrfbf:Description", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &(a->wsrfbf__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wsnb__InvalidTopicExpressionFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__InvalidTopicExpressionFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_in_wsnb__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, wsnb__InvalidTopicExpressionFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__InvalidTopicExpressionFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__InvalidTopicExpressionFaultType, sizeof(wsnb__InvalidTopicExpressionFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__InvalidTopicExpressionFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__InvalidTopicExpressionFaultType *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	struct soap_blist *soap_blist_Description2 = NULL;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsrfbf:Timestamp", &(a->wsrfbf__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &(a->wsrfbf__BaseFaultType::Originator), "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__BaseFaultType::Description == NULL)
				{	if (soap_blist_Description2 == NULL)
						soap_blist_Description2 = soap_new_block(soap);
					a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_push_block(soap, soap_blist_Description2, sizeof(_wsrfbf__BaseFaultType_Description));
					if (a->wsrfbf__BaseFaultType::Description == NULL)
						return NULL;
					_wsrfbf__BaseFaultType_Description p;
					memcpy(a->wsrfbf__BaseFaultType::Description, &p, sizeof(_wsrfbf__BaseFaultType_Description)); // a bit rough but portable
					a->wsrfbf__BaseFaultType::Description->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__BaseFaultType::Description, ""))
				{	a->wsrfbf__BaseFaultType::__sizeDescription++;
					a->wsrfbf__BaseFaultType::Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &(a->wsrfbf__BaseFaultType::FaultCause), ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsrfbf__BaseFaultType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__BaseFaultType::Description)
			soap_pop_block(soap, soap_blist_Description2);
		if (a->wsrfbf__BaseFaultType::__sizeDescription)
			a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description2, NULL, 1);
		else
		{	a->wsrfbf__BaseFaultType::Description = NULL;
			if (soap_blist_Description2)
				soap_end_block(soap, soap_blist_Description2);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__InvalidTopicExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__InvalidTopicExpressionFaultType, 0, sizeof(wsnb__InvalidTopicExpressionFaultType), 0, soap_copy_wsnb__InvalidTopicExpressionFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int wsnb__InvalidTopicExpressionFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__InvalidTopicExpressionFaultType);
	if (this->soap_out(soap, tag?tag:"wsnb:InvalidTopicExpressionFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__InvalidTopicExpressionFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__InvalidTopicExpressionFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_get_wsnb__InvalidTopicExpressionFaultType(struct soap *soap, wsnb__InvalidTopicExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__InvalidTopicExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__InvalidTopicExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnb__InvalidTopicExpressionFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__InvalidTopicExpressionFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__InvalidTopicExpressionFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__InvalidTopicExpressionFaultType);
		if (size)
			*size = sizeof(wsnb__InvalidTopicExpressionFaultType);
		((wsnb__InvalidTopicExpressionFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__InvalidTopicExpressionFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__InvalidTopicExpressionFaultType);
		for (int i = 0; i < n; i++)
			((wsnb__InvalidTopicExpressionFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__InvalidTopicExpressionFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__InvalidTopicExpressionFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__InvalidTopicExpressionFaultType %p -> %p\n", q, p));
	*(wsnb__InvalidTopicExpressionFaultType*)p = *(wsnb__InvalidTopicExpressionFaultType*)q;
}

void wsnb__TopicExpressionDialectUnknownFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_time(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	this->wsrfbf__BaseFaultType::__sizeDescription = 0;
	this->wsrfbf__BaseFaultType::Description = NULL;
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsrfbf__BaseFaultType::__anyAttribute);
	/* transient soap skipped */
}

void wsnb__TopicExpressionDialectUnknownFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	if (this->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->wsrfbf__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->wsrfbf__BaseFaultType::Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			this->wsrfbf__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int wsnb__TopicExpressionDialectUnknownFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__TopicExpressionDialectUnknownFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, int id, const wsnb__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__TopicExpressionDialectUnknownFaultType), "wsnb:TopicExpressionDialectUnknownFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsrfbf__BaseFaultType::__any), ""))
		return soap->error;
	if (soap_out_time(soap, "wsrfbf:Timestamp", -1, &(a->wsrfbf__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &(a->wsrfbf__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->wsrfbf__BaseFaultType::__sizeDescription; i++)
			if (a->wsrfbf__BaseFaultType::Description[i].soap_out(soap, "wsrfbf:Description", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &(a->wsrfbf__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wsnb__TopicExpressionDialectUnknownFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__TopicExpressionDialectUnknownFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_in_wsnb__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, wsnb__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__TopicExpressionDialectUnknownFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__TopicExpressionDialectUnknownFaultType, sizeof(wsnb__TopicExpressionDialectUnknownFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__TopicExpressionDialectUnknownFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__TopicExpressionDialectUnknownFaultType *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	struct soap_blist *soap_blist_Description2 = NULL;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsrfbf:Timestamp", &(a->wsrfbf__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &(a->wsrfbf__BaseFaultType::Originator), "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__BaseFaultType::Description == NULL)
				{	if (soap_blist_Description2 == NULL)
						soap_blist_Description2 = soap_new_block(soap);
					a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_push_block(soap, soap_blist_Description2, sizeof(_wsrfbf__BaseFaultType_Description));
					if (a->wsrfbf__BaseFaultType::Description == NULL)
						return NULL;
					_wsrfbf__BaseFaultType_Description p;
					memcpy(a->wsrfbf__BaseFaultType::Description, &p, sizeof(_wsrfbf__BaseFaultType_Description)); // a bit rough but portable
					a->wsrfbf__BaseFaultType::Description->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__BaseFaultType::Description, ""))
				{	a->wsrfbf__BaseFaultType::__sizeDescription++;
					a->wsrfbf__BaseFaultType::Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &(a->wsrfbf__BaseFaultType::FaultCause), ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsrfbf__BaseFaultType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__BaseFaultType::Description)
			soap_pop_block(soap, soap_blist_Description2);
		if (a->wsrfbf__BaseFaultType::__sizeDescription)
			a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description2, NULL, 1);
		else
		{	a->wsrfbf__BaseFaultType::Description = NULL;
			if (soap_blist_Description2)
				soap_end_block(soap, soap_blist_Description2);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__TopicExpressionDialectUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__TopicExpressionDialectUnknownFaultType, 0, sizeof(wsnb__TopicExpressionDialectUnknownFaultType), 0, soap_copy_wsnb__TopicExpressionDialectUnknownFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int wsnb__TopicExpressionDialectUnknownFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__TopicExpressionDialectUnknownFaultType);
	if (this->soap_out(soap, tag?tag:"wsnb:TopicExpressionDialectUnknownFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__TopicExpressionDialectUnknownFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__TopicExpressionDialectUnknownFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_get_wsnb__TopicExpressionDialectUnknownFaultType(struct soap *soap, wsnb__TopicExpressionDialectUnknownFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__TopicExpressionDialectUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__TopicExpressionDialectUnknownFaultType * SOAP_FMAC2 soap_instantiate_wsnb__TopicExpressionDialectUnknownFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__TopicExpressionDialectUnknownFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__TopicExpressionDialectUnknownFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__TopicExpressionDialectUnknownFaultType);
		if (size)
			*size = sizeof(wsnb__TopicExpressionDialectUnknownFaultType);
		((wsnb__TopicExpressionDialectUnknownFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__TopicExpressionDialectUnknownFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__TopicExpressionDialectUnknownFaultType);
		for (int i = 0; i < n; i++)
			((wsnb__TopicExpressionDialectUnknownFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__TopicExpressionDialectUnknownFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__TopicExpressionDialectUnknownFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__TopicExpressionDialectUnknownFaultType %p -> %p\n", q, p));
	*(wsnb__TopicExpressionDialectUnknownFaultType*)p = *(wsnb__TopicExpressionDialectUnknownFaultType*)q;
}

void wsnb__InvalidFilterFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__QName(soap, &this->wsnb__InvalidFilterFaultType::UnknownFilter);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_time(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	this->wsrfbf__BaseFaultType::__sizeDescription = 0;
	this->wsrfbf__BaseFaultType::Description = NULL;
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsrfbf__BaseFaultType::__anyAttribute);
	/* transient soap skipped */
}

void wsnb__InvalidFilterFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &this->wsnb__InvalidFilterFaultType::UnknownFilter);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	if (this->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->wsrfbf__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->wsrfbf__BaseFaultType::Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			this->wsrfbf__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int wsnb__InvalidFilterFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__InvalidFilterFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__InvalidFilterFaultType(struct soap *soap, const char *tag, int id, const wsnb__InvalidFilterFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__InvalidFilterFaultType), "wsnb:InvalidFilterFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsrfbf__BaseFaultType::__any), ""))
		return soap->error;
	if (soap_out_time(soap, "wsrfbf:Timestamp", -1, &(a->wsrfbf__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &(a->wsrfbf__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->wsrfbf__BaseFaultType::__sizeDescription; i++)
			if (a->wsrfbf__BaseFaultType::Description[i].soap_out(soap, "wsrfbf:Description", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &(a->wsrfbf__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfxsd__QName(soap, "wsnb:UnknownFilter", -1, &(a->wsnb__InvalidFilterFaultType::UnknownFilter), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *wsnb__InvalidFilterFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__InvalidFilterFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__InvalidFilterFaultType * SOAP_FMAC4 soap_in_wsnb__InvalidFilterFaultType(struct soap *soap, const char *tag, wsnb__InvalidFilterFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__InvalidFilterFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__InvalidFilterFaultType, sizeof(wsnb__InvalidFilterFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__InvalidFilterFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__InvalidFilterFaultType *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	struct soap_blist *soap_blist_Description2 = NULL;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsrfbf:Timestamp", &(a->wsrfbf__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &(a->wsrfbf__BaseFaultType::Originator), "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__BaseFaultType::Description == NULL)
				{	if (soap_blist_Description2 == NULL)
						soap_blist_Description2 = soap_new_block(soap);
					a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_push_block(soap, soap_blist_Description2, sizeof(_wsrfbf__BaseFaultType_Description));
					if (a->wsrfbf__BaseFaultType::Description == NULL)
						return NULL;
					_wsrfbf__BaseFaultType_Description p;
					memcpy(a->wsrfbf__BaseFaultType::Description, &p, sizeof(_wsrfbf__BaseFaultType_Description)); // a bit rough but portable
					a->wsrfbf__BaseFaultType::Description->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__BaseFaultType::Description, ""))
				{	a->wsrfbf__BaseFaultType::__sizeDescription++;
					a->wsrfbf__BaseFaultType::Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &(a->wsrfbf__BaseFaultType::FaultCause), ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__QName(soap, "wsnb:UnknownFilter", &(a->wsnb__InvalidFilterFaultType::UnknownFilter), "xsd:QName"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsrfbf__BaseFaultType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__BaseFaultType::Description)
			soap_pop_block(soap, soap_blist_Description2);
		if (a->wsrfbf__BaseFaultType::__sizeDescription)
			a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description2, NULL, 1);
		else
		{	a->wsrfbf__BaseFaultType::Description = NULL;
			if (soap_blist_Description2)
				soap_end_block(soap, soap_blist_Description2);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__InvalidFilterFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__InvalidFilterFaultType, 0, sizeof(wsnb__InvalidFilterFaultType), 0, soap_copy_wsnb__InvalidFilterFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0 || a->wsnb__InvalidFilterFaultType::UnknownFilter.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int wsnb__InvalidFilterFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__InvalidFilterFaultType);
	if (this->soap_out(soap, tag?tag:"wsnb:InvalidFilterFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__InvalidFilterFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__InvalidFilterFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__InvalidFilterFaultType * SOAP_FMAC4 soap_get_wsnb__InvalidFilterFaultType(struct soap *soap, wsnb__InvalidFilterFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__InvalidFilterFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__InvalidFilterFaultType * SOAP_FMAC2 soap_instantiate_wsnb__InvalidFilterFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__InvalidFilterFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__InvalidFilterFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__InvalidFilterFaultType);
		if (size)
			*size = sizeof(wsnb__InvalidFilterFaultType);
		((wsnb__InvalidFilterFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__InvalidFilterFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__InvalidFilterFaultType);
		for (int i = 0; i < n; i++)
			((wsnb__InvalidFilterFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__InvalidFilterFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__InvalidFilterFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__InvalidFilterFaultType %p -> %p\n", q, p));
	*(wsnb__InvalidFilterFaultType*)p = *(wsnb__InvalidFilterFaultType*)q;
}

void wsnb__SubscribeCreationFailedFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_default_time(soap, &this->wsrfbf__BaseFaultType::Timestamp);
	this->wsrfbf__BaseFaultType::Originator = NULL;
	this->wsrfbf__BaseFaultType::ErrorCode = NULL;
	this->wsrfbf__BaseFaultType::__sizeDescription = 0;
	this->wsrfbf__BaseFaultType::Description = NULL;
	this->wsrfbf__BaseFaultType::FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &this->wsrfbf__BaseFaultType::__anyAttribute);
	/* transient soap skipped */
}

void wsnb__SubscribeCreationFailedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsrfbf__BaseFaultType::__any);
	soap_embedded(soap, &this->wsrfbf__BaseFaultType::Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsrfbf__BaseFaultType::Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &this->wsrfbf__BaseFaultType::ErrorCode);
	if (this->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < this->wsrfbf__BaseFaultType::__sizeDescription; i++)
		{
			soap_embedded(soap, this->wsrfbf__BaseFaultType::Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			this->wsrfbf__BaseFaultType::Description[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &this->wsrfbf__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int wsnb__SubscribeCreationFailedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__SubscribeCreationFailedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, int id, const wsnb__SubscribeCreationFailedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsrfbf__BaseFaultType*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__SubscribeCreationFailedFaultType), "wsnb:SubscribeCreationFailedFaultType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsrfbf__BaseFaultType::__any), ""))
		return soap->error;
	if (soap_out_time(soap, "wsrfbf:Timestamp", -1, &(a->wsrfbf__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &(a->wsrfbf__BaseFaultType::Originator), ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (a->wsrfbf__BaseFaultType::Description)
	{	int i;
		for (i = 0; i < a->wsrfbf__BaseFaultType::__sizeDescription; i++)
			if (a->wsrfbf__BaseFaultType::Description[i].soap_out(soap, "wsrfbf:Description", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &(a->wsrfbf__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wsnb__SubscribeCreationFailedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__SubscribeCreationFailedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_in_wsnb__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, wsnb__SubscribeCreationFailedFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__SubscribeCreationFailedFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__SubscribeCreationFailedFaultType, sizeof(wsnb__SubscribeCreationFailedFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__SubscribeCreationFailedFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__SubscribeCreationFailedFaultType *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsrfbf__BaseFaultType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_Originator2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	struct soap_blist *soap_blist_Description2 = NULL;
	size_t soap_flag_FaultCause2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsrfbf:Timestamp", &(a->wsrfbf__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_Originator2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &(a->wsrfbf__BaseFaultType::Originator), "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &(a->wsrfbf__BaseFaultType::ErrorCode), ""))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__BaseFaultType::Description == NULL)
				{	if (soap_blist_Description2 == NULL)
						soap_blist_Description2 = soap_new_block(soap);
					a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_push_block(soap, soap_blist_Description2, sizeof(_wsrfbf__BaseFaultType_Description));
					if (a->wsrfbf__BaseFaultType::Description == NULL)
						return NULL;
					_wsrfbf__BaseFaultType_Description p;
					memcpy(a->wsrfbf__BaseFaultType::Description, &p, sizeof(_wsrfbf__BaseFaultType_Description)); // a bit rough but portable
					a->wsrfbf__BaseFaultType::Description->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__BaseFaultType::Description, ""))
				{	a->wsrfbf__BaseFaultType::__sizeDescription++;
					a->wsrfbf__BaseFaultType::Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &(a->wsrfbf__BaseFaultType::FaultCause), ""))
				{	soap_flag_FaultCause2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsrfbf__BaseFaultType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__BaseFaultType::Description)
			soap_pop_block(soap, soap_blist_Description2);
		if (a->wsrfbf__BaseFaultType::__sizeDescription)
			a->wsrfbf__BaseFaultType::Description = (_wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description2, NULL, 1);
		else
		{	a->wsrfbf__BaseFaultType::Description = NULL;
			if (soap_blist_Description2)
				soap_end_block(soap, soap_blist_Description2);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__SubscribeCreationFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__SubscribeCreationFailedFaultType, 0, sizeof(wsnb__SubscribeCreationFailedFaultType), 0, soap_copy_wsnb__SubscribeCreationFailedFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int wsnb__SubscribeCreationFailedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__SubscribeCreationFailedFaultType);
	if (this->soap_out(soap, tag?tag:"wsnb:SubscribeCreationFailedFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__SubscribeCreationFailedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__SubscribeCreationFailedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_get_wsnb__SubscribeCreationFailedFaultType(struct soap *soap, wsnb__SubscribeCreationFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__SubscribeCreationFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__SubscribeCreationFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnb__SubscribeCreationFailedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__SubscribeCreationFailedFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__SubscribeCreationFailedFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__SubscribeCreationFailedFaultType);
		if (size)
			*size = sizeof(wsnb__SubscribeCreationFailedFaultType);
		((wsnb__SubscribeCreationFailedFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__SubscribeCreationFailedFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__SubscribeCreationFailedFaultType);
		for (int i = 0; i < n; i++)
			((wsnb__SubscribeCreationFailedFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__SubscribeCreationFailedFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__SubscribeCreationFailedFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__SubscribeCreationFailedFaultType %p -> %p\n", q, p));
	*(wsnb__SubscribeCreationFailedFaultType*)p = *(wsnb__SubscribeCreationFailedFaultType*)q;
}

void wsnb__NotificationMessageHolderType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->wsnb__NotificationMessageHolderType::SubscriptionReference = NULL;
	this->wsnb__NotificationMessageHolderType::Topic = NULL;
	this->wsnb__NotificationMessageHolderType::ProducerReference = NULL;
	this->wsnb__NotificationMessageHolderType::Message._wsnb__NotificationMessageHolderType_Message::soap_default(soap);
	/* transient soap skipped */
}

void wsnb__NotificationMessageHolderType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsnb__NotificationMessageHolderType::SubscriptionReference);
	soap_serialize_PointerTowsnb__TopicExpressionType(soap, &this->wsnb__NotificationMessageHolderType::Topic);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &this->wsnb__NotificationMessageHolderType::ProducerReference);
	this->wsnb__NotificationMessageHolderType::Message.soap_serialize(soap);
	/* transient soap skipped */
}

int wsnb__NotificationMessageHolderType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__NotificationMessageHolderType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, const wsnb__NotificationMessageHolderType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__NotificationMessageHolderType), type))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsnb:SubscriptionReference", -1, &(a->wsnb__NotificationMessageHolderType::SubscriptionReference), ""))
		return soap->error;
	if (soap_out_PointerTowsnb__TopicExpressionType(soap, "wsnb:Topic", -1, &(a->wsnb__NotificationMessageHolderType::Topic), ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsnb:ProducerReference", -1, &(a->wsnb__NotificationMessageHolderType::ProducerReference), ""))
		return soap->error;
	if ((a->wsnb__NotificationMessageHolderType::Message).soap_out(soap, "wsnb:Message", -1, ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wsnb__NotificationMessageHolderType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__NotificationMessageHolderType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__NotificationMessageHolderType * SOAP_FMAC4 soap_in_wsnb__NotificationMessageHolderType(struct soap *soap, const char *tag, wsnb__NotificationMessageHolderType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__NotificationMessageHolderType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__NotificationMessageHolderType, sizeof(wsnb__NotificationMessageHolderType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__NotificationMessageHolderType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__NotificationMessageHolderType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SubscriptionReference1 = 1;
	size_t soap_flag_Topic1 = 1;
	size_t soap_flag_ProducerReference1 = 1;
	size_t soap_flag_Message1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsnb:SubscriptionReference", &(a->wsnb__NotificationMessageHolderType::SubscriptionReference), "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference1--;
					continue;
				}
			if (soap_flag_Topic1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnb__TopicExpressionType(soap, "wsnb:Topic", &(a->wsnb__NotificationMessageHolderType::Topic), "wsnb:TopicExpressionType"))
				{	soap_flag_Topic1--;
					continue;
				}
			if (soap_flag_ProducerReference1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsnb:ProducerReference", &(a->wsnb__NotificationMessageHolderType::ProducerReference), "wsa5:EndpointReferenceType"))
				{	soap_flag_ProducerReference1--;
					continue;
				}
			if (soap_flag_Message1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->wsnb__NotificationMessageHolderType::Message).soap_in(soap, "wsnb:Message", ""))
				{	soap_flag_Message1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__NotificationMessageHolderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__NotificationMessageHolderType, 0, sizeof(wsnb__NotificationMessageHolderType), 0, soap_copy_wsnb__NotificationMessageHolderType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int wsnb__NotificationMessageHolderType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__NotificationMessageHolderType);
	if (this->soap_out(soap, tag?tag:"wsnb:NotificationMessageHolderType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__NotificationMessageHolderType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__NotificationMessageHolderType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__NotificationMessageHolderType * SOAP_FMAC4 soap_get_wsnb__NotificationMessageHolderType(struct soap *soap, wsnb__NotificationMessageHolderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__NotificationMessageHolderType * SOAP_FMAC2 soap_instantiate_wsnb__NotificationMessageHolderType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__NotificationMessageHolderType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__NotificationMessageHolderType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__NotificationMessageHolderType);
		if (size)
			*size = sizeof(wsnb__NotificationMessageHolderType);
		((wsnb__NotificationMessageHolderType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__NotificationMessageHolderType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__NotificationMessageHolderType);
		for (int i = 0; i < n; i++)
			((wsnb__NotificationMessageHolderType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__NotificationMessageHolderType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__NotificationMessageHolderType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__NotificationMessageHolderType %p -> %p\n", q, p));
	*(wsnb__NotificationMessageHolderType*)p = *(wsnb__NotificationMessageHolderType*)q;
}

void wsnb__SubscriptionPolicyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsnb__SubscriptionPolicyType::__any);
	/* transient soap skipped */
}

void wsnb__SubscriptionPolicyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsnb__SubscriptionPolicyType::__any);
	/* transient soap skipped */
}

int wsnb__SubscriptionPolicyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__SubscriptionPolicyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, const wsnb__SubscriptionPolicyType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__SubscriptionPolicyType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsnb__SubscriptionPolicyType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wsnb__SubscriptionPolicyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__SubscriptionPolicyType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__SubscriptionPolicyType * SOAP_FMAC4 soap_in_wsnb__SubscriptionPolicyType(struct soap *soap, const char *tag, wsnb__SubscriptionPolicyType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__SubscriptionPolicyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__SubscriptionPolicyType, sizeof(wsnb__SubscriptionPolicyType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__SubscriptionPolicyType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__SubscriptionPolicyType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsnb__SubscriptionPolicyType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__SubscriptionPolicyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__SubscriptionPolicyType, 0, sizeof(wsnb__SubscriptionPolicyType), 0, soap_copy_wsnb__SubscriptionPolicyType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int wsnb__SubscriptionPolicyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__SubscriptionPolicyType);
	if (this->soap_out(soap, tag?tag:"wsnb:SubscriptionPolicyType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__SubscriptionPolicyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__SubscriptionPolicyType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__SubscriptionPolicyType * SOAP_FMAC4 soap_get_wsnb__SubscriptionPolicyType(struct soap *soap, wsnb__SubscriptionPolicyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__SubscriptionPolicyType * SOAP_FMAC2 soap_instantiate_wsnb__SubscriptionPolicyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__SubscriptionPolicyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__SubscriptionPolicyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__SubscriptionPolicyType);
		if (size)
			*size = sizeof(wsnb__SubscriptionPolicyType);
		((wsnb__SubscriptionPolicyType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__SubscriptionPolicyType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__SubscriptionPolicyType);
		for (int i = 0; i < n; i++)
			((wsnb__SubscriptionPolicyType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__SubscriptionPolicyType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__SubscriptionPolicyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__SubscriptionPolicyType %p -> %p\n", q, p));
	*(wsnb__SubscriptionPolicyType*)p = *(wsnb__SubscriptionPolicyType*)q;
}

void wsnb__FilterType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->wsnb__FilterType::__any);
	/* transient soap skipped */
}

void wsnb__FilterType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->wsnb__FilterType::__any);
	/* transient soap skipped */
}

int wsnb__FilterType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__FilterType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__FilterType(struct soap *soap, const char *tag, int id, const wsnb__FilterType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__FilterType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->wsnb__FilterType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wsnb__FilterType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__FilterType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__FilterType * SOAP_FMAC4 soap_in_wsnb__FilterType(struct soap *soap, const char *tag, wsnb__FilterType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__FilterType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__FilterType, sizeof(wsnb__FilterType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__FilterType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__FilterType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->wsnb__FilterType::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__FilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__FilterType, 0, sizeof(wsnb__FilterType), 0, soap_copy_wsnb__FilterType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int wsnb__FilterType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__FilterType);
	if (this->soap_out(soap, tag?tag:"wsnb:FilterType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__FilterType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__FilterType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__FilterType * SOAP_FMAC4 soap_get_wsnb__FilterType(struct soap *soap, wsnb__FilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__FilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__FilterType * SOAP_FMAC2 soap_instantiate_wsnb__FilterType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__FilterType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__FilterType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__FilterType);
		if (size)
			*size = sizeof(wsnb__FilterType);
		((wsnb__FilterType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__FilterType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__FilterType);
		for (int i = 0; i < n; i++)
			((wsnb__FilterType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__FilterType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__FilterType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__FilterType %p -> %p\n", q, p));
	*(wsnb__FilterType*)p = *(wsnb__FilterType*)q;
}

void wsnb__TopicExpressionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyType(soap, &this->wsnb__TopicExpressionType::__any);
	soap_default_xsd__anyURI(soap, &this->wsnb__TopicExpressionType::Dialect);
	soap_default_xsd__anyAttribute(soap, &this->wsnb__TopicExpressionType::__anyAttribute);
	soap_default_xsd__anyType(soap, &this->wsnb__TopicExpressionType::__mixed);
	/* transient soap skipped */
}

void wsnb__TopicExpressionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &this->wsnb__TopicExpressionType::__any);
	soap_serialize_xsd__anyType(soap, &this->wsnb__TopicExpressionType::__mixed);
	/* transient soap skipped */
}

int wsnb__TopicExpressionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__TopicExpressionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__TopicExpressionType(struct soap *soap, const char *tag, int id, const wsnb__TopicExpressionType *a, const char *type)
{
	if (!((wsnb__TopicExpressionType*)a)->Dialect.empty())
		soap_set_attr(soap, "Dialect", ((wsnb__TopicExpressionType*)a)->Dialect.c_str(), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((wsnb__TopicExpressionType*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__TopicExpressionType), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &(a->wsnb__TopicExpressionType::__any), ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &(a->wsnb__TopicExpressionType::__mixed), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wsnb__TopicExpressionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__TopicExpressionType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__TopicExpressionType * SOAP_FMAC4 soap_in_wsnb__TopicExpressionType(struct soap *soap, const char *tag, wsnb__TopicExpressionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__TopicExpressionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__TopicExpressionType, sizeof(wsnb__TopicExpressionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__TopicExpressionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__TopicExpressionType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Dialect", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((wsnb__TopicExpressionType*)a)->Dialect.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((wsnb__TopicExpressionType*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag___any1 = 1;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag___any1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &(a->wsnb__TopicExpressionType::__any), "xsd:anyType"))
				{	soap_flag___any1--;
					continue;
				}
			if (soap_flag___mixed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &(a->wsnb__TopicExpressionType::__mixed), "xsd:anyType"))
				{	soap_flag___mixed1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__TopicExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__TopicExpressionType, 0, sizeof(wsnb__TopicExpressionType), 0, soap_copy_wsnb__TopicExpressionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int wsnb__TopicExpressionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__TopicExpressionType);
	if (this->soap_out(soap, tag?tag:"wsnb:TopicExpressionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__TopicExpressionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__TopicExpressionType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__TopicExpressionType * SOAP_FMAC4 soap_get_wsnb__TopicExpressionType(struct soap *soap, wsnb__TopicExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__TopicExpressionType * SOAP_FMAC2 soap_instantiate_wsnb__TopicExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__TopicExpressionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__TopicExpressionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__TopicExpressionType);
		if (size)
			*size = sizeof(wsnb__TopicExpressionType);
		((wsnb__TopicExpressionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__TopicExpressionType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__TopicExpressionType);
		for (int i = 0; i < n; i++)
			((wsnb__TopicExpressionType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__TopicExpressionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__TopicExpressionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__TopicExpressionType %p -> %p\n", q, p));
	*(wsnb__TopicExpressionType*)p = *(wsnb__TopicExpressionType*)q;
}

void wsnb__QueryExpressionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyType(soap, &this->wsnb__QueryExpressionType::__any);
	soap_default_xsd__anyURI(soap, &this->wsnb__QueryExpressionType::Dialect);
	soap_default_xsd__anyType(soap, &this->wsnb__QueryExpressionType::__mixed);
	/* transient soap skipped */
}

void wsnb__QueryExpressionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &this->wsnb__QueryExpressionType::__any);
	soap_serialize_xsd__anyType(soap, &this->wsnb__QueryExpressionType::__mixed);
	/* transient soap skipped */
}

int wsnb__QueryExpressionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsnb__QueryExpressionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnb__QueryExpressionType(struct soap *soap, const char *tag, int id, const wsnb__QueryExpressionType *a, const char *type)
{
	if (!((wsnb__QueryExpressionType*)a)->Dialect.empty())
		soap_set_attr(soap, "Dialect", ((wsnb__QueryExpressionType*)a)->Dialect.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnb__QueryExpressionType), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &(a->wsnb__QueryExpressionType::__any), ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &(a->wsnb__QueryExpressionType::__mixed), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *wsnb__QueryExpressionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_wsnb__QueryExpressionType(soap, tag, this, type);
}

SOAP_FMAC3 wsnb__QueryExpressionType * SOAP_FMAC4 soap_in_wsnb__QueryExpressionType(struct soap *soap, const char *tag, wsnb__QueryExpressionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (wsnb__QueryExpressionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsnb__QueryExpressionType, sizeof(wsnb__QueryExpressionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_wsnb__QueryExpressionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (wsnb__QueryExpressionType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Dialect", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((wsnb__QueryExpressionType*)a)->Dialect.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag___any1 = 1;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag___any1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &(a->wsnb__QueryExpressionType::__any), "xsd:anyType"))
				{	soap_flag___any1--;
					continue;
				}
			if (soap_flag___mixed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &(a->wsnb__QueryExpressionType::__mixed), "xsd:anyType"))
				{	soap_flag___mixed1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (wsnb__QueryExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnb__QueryExpressionType, 0, sizeof(wsnb__QueryExpressionType), 0, soap_copy_wsnb__QueryExpressionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int wsnb__QueryExpressionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_wsnb__QueryExpressionType);
	if (this->soap_out(soap, tag?tag:"wsnb:QueryExpressionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsnb__QueryExpressionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsnb__QueryExpressionType(soap, this, tag, type);
}

SOAP_FMAC3 wsnb__QueryExpressionType * SOAP_FMAC4 soap_get_wsnb__QueryExpressionType(struct soap *soap, wsnb__QueryExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnb__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 wsnb__QueryExpressionType * SOAP_FMAC2 soap_instantiate_wsnb__QueryExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsnb__QueryExpressionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsnb__QueryExpressionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(wsnb__QueryExpressionType);
		if (size)
			*size = sizeof(wsnb__QueryExpressionType);
		((wsnb__QueryExpressionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(wsnb__QueryExpressionType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(wsnb__QueryExpressionType);
		for (int i = 0; i < n; i++)
			((wsnb__QueryExpressionType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (wsnb__QueryExpressionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsnb__QueryExpressionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying wsnb__QueryExpressionType %p -> %p\n", q, p));
	*(wsnb__QueryExpressionType*)p = *(wsnb__QueryExpressionType*)q;
}

void _tt__Message::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tt__Message::Source = NULL;
	this->_tt__Message::Key = NULL;
	this->_tt__Message::Data = NULL;
	this->_tt__Message::Extension = NULL;
	soap_default_time(soap, &this->_tt__Message::UtcTime);
	this->_tt__Message::PropertyOperation = NULL;
	soap_default_xsd__anyAttribute(soap, &this->_tt__Message::__anyAttribute);
	/* transient soap skipped */
}

void _tt__Message::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ItemList(soap, &this->_tt__Message::Source);
	soap_serialize_PointerTott__ItemList(soap, &this->_tt__Message::Key);
	soap_serialize_PointerTott__ItemList(soap, &this->_tt__Message::Data);
	soap_serialize_PointerTott__MessageExtension(soap, &this->_tt__Message::Extension);
	/* transient soap skipped */
}

int _tt__Message::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tt__Message(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__Message(struct soap *soap, const char *tag, int id, const _tt__Message *a, const char *type)
{
	soap_set_attr(soap, "UtcTime", soap_dateTime2s(soap, ((_tt__Message*)a)->UtcTime), 1);
	if (((_tt__Message*)a)->PropertyOperation)
		soap_set_attr(soap, "PropertyOperation", soap_tt__PropertyOperation2s(soap, *((_tt__Message*)a)->PropertyOperation), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((_tt__Message*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__Message), type))
		return soap->error;
	if (soap_out_PointerTott__ItemList(soap, "tt:Source", -1, &(a->_tt__Message::Source), ""))
		return soap->error;
	if (soap_out_PointerTott__ItemList(soap, "tt:Key", -1, &(a->_tt__Message::Key), ""))
		return soap->error;
	if (soap_out_PointerTott__ItemList(soap, "tt:Data", -1, &(a->_tt__Message::Data), ""))
		return soap->error;
	if (soap_out_PointerTott__MessageExtension(soap, "tt:Extension", -1, &(a->_tt__Message::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tt__Message::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tt__Message(soap, tag, this, type);
}

SOAP_FMAC3 _tt__Message * SOAP_FMAC4 soap_in__tt__Message(struct soap *soap, const char *tag, _tt__Message *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tt__Message *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tt__Message, sizeof(_tt__Message), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tt__Message)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tt__Message *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "UtcTime", 1), &((_tt__Message*)a)->UtcTime))
		return NULL;
	{	const char *t = soap_attr_value(soap, "PropertyOperation", 0);
		if (t)
		{
			if (!(((_tt__Message*)a)->PropertyOperation = (enum tt__PropertyOperation *)soap_malloc(soap, sizeof(enum tt__PropertyOperation))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__PropertyOperation(soap, t, ((_tt__Message*)a)->PropertyOperation))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((_tt__Message*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Source1 = 1;
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_Data1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemList(soap, "tt:Source", &(a->_tt__Message::Source), "tt:ItemList"))
				{	soap_flag_Source1--;
					continue;
				}
			if (soap_flag_Key1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemList(soap, "tt:Key", &(a->_tt__Message::Key), "tt:ItemList"))
				{	soap_flag_Key1--;
					continue;
				}
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemList(soap, "tt:Data", &(a->_tt__Message::Data), "tt:ItemList"))
				{	soap_flag_Data1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MessageExtension(soap, "tt:Extension", &(a->_tt__Message::Extension), "tt:MessageExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tt__Message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__Message, 0, sizeof(_tt__Message), 0, soap_copy__tt__Message);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tt__Message::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tt__Message);
	if (this->soap_out(soap, tag?tag:"tt:Message", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tt__Message::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tt__Message(soap, this, tag, type);
}

SOAP_FMAC3 _tt__Message * SOAP_FMAC4 soap_get__tt__Message(struct soap *soap, _tt__Message *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__Message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tt__Message * SOAP_FMAC2 soap_instantiate__tt__Message(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tt__Message(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tt__Message, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tt__Message);
		if (size)
			*size = sizeof(_tt__Message);
		((_tt__Message*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tt__Message[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tt__Message);
		for (int i = 0; i < n; i++)
			((_tt__Message*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tt__Message*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tt__Message(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tt__Message %p -> %p\n", q, p));
	*(_tt__Message*)p = *(_tt__Message*)q;
}

void tt__EventStreamExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__EventStreamExtension::__any);
	/* transient soap skipped */
}

void tt__EventStreamExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__EventStreamExtension::__any);
	/* transient soap skipped */
}

int tt__EventStreamExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EventStreamExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventStreamExtension(struct soap *soap, const char *tag, int id, const tt__EventStreamExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventStreamExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__EventStreamExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__EventStreamExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__EventStreamExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__EventStreamExtension * SOAP_FMAC4 soap_in_tt__EventStreamExtension(struct soap *soap, const char *tag, tt__EventStreamExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EventStreamExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventStreamExtension, sizeof(tt__EventStreamExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__EventStreamExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__EventStreamExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__EventStreamExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__EventStreamExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventStreamExtension, 0, sizeof(tt__EventStreamExtension), 0, soap_copy_tt__EventStreamExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__EventStreamExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__EventStreamExtension);
	if (this->soap_out(soap, tag?tag:"tt:EventStreamExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EventStreamExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EventStreamExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__EventStreamExtension * SOAP_FMAC4 soap_get_tt__EventStreamExtension(struct soap *soap, tt__EventStreamExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__EventStreamExtension * SOAP_FMAC2 soap_instantiate_tt__EventStreamExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EventStreamExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__EventStreamExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__EventStreamExtension);
		if (size)
			*size = sizeof(tt__EventStreamExtension);
		((tt__EventStreamExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__EventStreamExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__EventStreamExtension);
		for (int i = 0; i < n; i++)
			((tt__EventStreamExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__EventStreamExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__EventStreamExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__EventStreamExtension %p -> %p\n", q, p));
	*(tt__EventStreamExtension*)p = *(tt__EventStreamExtension*)q;
}

void tt__EventStream::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__EventStream::__size_EventStream = 0;
	this->tt__EventStream::__union_EventStream = NULL;
	/* transient soap skipped */
}

void tt__EventStream::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->tt__EventStream::__union_EventStream)
	{	int i;
		for (i = 0; i < this->tt__EventStream::__size_EventStream; i++)
		{
			this->tt__EventStream::__union_EventStream[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
}

int tt__EventStream::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EventStream(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventStream(struct soap *soap, const char *tag, int id, const tt__EventStream *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventStream), type))
		return soap->error;
	if (a->tt__EventStream::__union_EventStream)
	{	int i;
		for (i = 0; i < a->tt__EventStream::__size_EventStream; i++)
			if (a->tt__EventStream::__union_EventStream[i].soap_out(soap, "-union-EventStream", -1, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__EventStream::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__EventStream(soap, tag, this, type);
}

SOAP_FMAC3 tt__EventStream * SOAP_FMAC4 soap_in_tt__EventStream(struct soap *soap, const char *tag, tt__EventStream *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EventStream *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventStream, sizeof(tt__EventStream), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__EventStream)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__EventStream *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist___union_EventStream1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__EventStream::__union_EventStream == NULL)
				{	if (soap_blist___union_EventStream1 == NULL)
						soap_blist___union_EventStream1 = soap_new_block(soap);
					a->tt__EventStream::__union_EventStream = (__tt__union_EventStream *)soap_push_block(soap, soap_blist___union_EventStream1, sizeof(__tt__union_EventStream));
					if (a->tt__EventStream::__union_EventStream == NULL)
						return NULL;
					__tt__union_EventStream p;
					memcpy(a->tt__EventStream::__union_EventStream, &p, sizeof(__tt__union_EventStream)); // a bit rough but portable
					a->tt__EventStream::__union_EventStream->soap_default(soap);
				}
				if (soap_in___tt__union_EventStream(soap, "-union-EventStream", a->tt__EventStream::__union_EventStream, "-tt:union-EventStream"))
				{	a->tt__EventStream::__size_EventStream++;
					a->tt__EventStream::__union_EventStream = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__EventStream::__union_EventStream)
			soap_pop_block(soap, soap_blist___union_EventStream1);
		if (a->tt__EventStream::__size_EventStream)
			a->tt__EventStream::__union_EventStream = (__tt__union_EventStream *)soap_save_block(soap, soap_blist___union_EventStream1, NULL, 1);
		else
		{	a->tt__EventStream::__union_EventStream = NULL;
			if (soap_blist___union_EventStream1)
				soap_end_block(soap, soap_blist___union_EventStream1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__EventStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventStream, 0, sizeof(tt__EventStream), 0, soap_copy_tt__EventStream);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__EventStream::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__EventStream);
	if (this->soap_out(soap, tag?tag:"tt:EventStream", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EventStream::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EventStream(soap, this, tag, type);
}

SOAP_FMAC3 tt__EventStream * SOAP_FMAC4 soap_get_tt__EventStream(struct soap *soap, tt__EventStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__EventStream * SOAP_FMAC2 soap_instantiate_tt__EventStream(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EventStream(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__EventStream, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__EventStream);
		if (size)
			*size = sizeof(tt__EventStream);
		((tt__EventStream*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__EventStream[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__EventStream);
		for (int i = 0; i < n; i++)
			((tt__EventStream*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__EventStream*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__EventStream(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__EventStream %p -> %p\n", q, p));
	*(tt__EventStream*)p = *(tt__EventStream*)q;
}

void tt__PTZStreamExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZStreamExtension::__any);
	/* transient soap skipped */
}

void tt__PTZStreamExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZStreamExtension::__any);
	/* transient soap skipped */
}

int tt__PTZStreamExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZStreamExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStreamExtension(struct soap *soap, const char *tag, int id, const tt__PTZStreamExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZStreamExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__PTZStreamExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__PTZStreamExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__PTZStreamExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZStreamExtension * SOAP_FMAC4 soap_in_tt__PTZStreamExtension(struct soap *soap, const char *tag, tt__PTZStreamExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZStreamExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStreamExtension, sizeof(tt__PTZStreamExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__PTZStreamExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__PTZStreamExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__PTZStreamExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZStreamExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStreamExtension, 0, sizeof(tt__PTZStreamExtension), 0, soap_copy_tt__PTZStreamExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__PTZStreamExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__PTZStreamExtension);
	if (this->soap_out(soap, tag?tag:"tt:PTZStreamExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZStreamExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZStreamExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZStreamExtension * SOAP_FMAC4 soap_get_tt__PTZStreamExtension(struct soap *soap, tt__PTZStreamExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__PTZStreamExtension * SOAP_FMAC2 soap_instantiate_tt__PTZStreamExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZStreamExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__PTZStreamExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZStreamExtension);
		if (size)
			*size = sizeof(tt__PTZStreamExtension);
		((tt__PTZStreamExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZStreamExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__PTZStreamExtension);
		for (int i = 0; i < n; i++)
			((tt__PTZStreamExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__PTZStreamExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__PTZStreamExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__PTZStreamExtension %p -> %p\n", q, p));
	*(tt__PTZStreamExtension*)p = *(tt__PTZStreamExtension*)q;
}

void tt__PTZStream::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTZStream::__size_PTZStream = 0;
	this->tt__PTZStream::__union_PTZStream = NULL;
	/* transient soap skipped */
}

void tt__PTZStream::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->tt__PTZStream::__union_PTZStream)
	{	int i;
		for (i = 0; i < this->tt__PTZStream::__size_PTZStream; i++)
		{
			this->tt__PTZStream::__union_PTZStream[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
}

int tt__PTZStream::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZStream(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStream(struct soap *soap, const char *tag, int id, const tt__PTZStream *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZStream), type))
		return soap->error;
	if (a->tt__PTZStream::__union_PTZStream)
	{	int i;
		for (i = 0; i < a->tt__PTZStream::__size_PTZStream; i++)
			if (a->tt__PTZStream::__union_PTZStream[i].soap_out(soap, "-union-PTZStream", -1, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__PTZStream::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__PTZStream(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZStream * SOAP_FMAC4 soap_in_tt__PTZStream(struct soap *soap, const char *tag, tt__PTZStream *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZStream *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStream, sizeof(tt__PTZStream), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__PTZStream)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__PTZStream *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist___union_PTZStream1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__PTZStream::__union_PTZStream == NULL)
				{	if (soap_blist___union_PTZStream1 == NULL)
						soap_blist___union_PTZStream1 = soap_new_block(soap);
					a->tt__PTZStream::__union_PTZStream = (__tt__union_PTZStream *)soap_push_block(soap, soap_blist___union_PTZStream1, sizeof(__tt__union_PTZStream));
					if (a->tt__PTZStream::__union_PTZStream == NULL)
						return NULL;
					__tt__union_PTZStream p;
					memcpy(a->tt__PTZStream::__union_PTZStream, &p, sizeof(__tt__union_PTZStream)); // a bit rough but portable
					a->tt__PTZStream::__union_PTZStream->soap_default(soap);
				}
				if (soap_in___tt__union_PTZStream(soap, "-union-PTZStream", a->tt__PTZStream::__union_PTZStream, "-tt:union-PTZStream"))
				{	a->tt__PTZStream::__size_PTZStream++;
					a->tt__PTZStream::__union_PTZStream = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__PTZStream::__union_PTZStream)
			soap_pop_block(soap, soap_blist___union_PTZStream1);
		if (a->tt__PTZStream::__size_PTZStream)
			a->tt__PTZStream::__union_PTZStream = (__tt__union_PTZStream *)soap_save_block(soap, soap_blist___union_PTZStream1, NULL, 1);
		else
		{	a->tt__PTZStream::__union_PTZStream = NULL;
			if (soap_blist___union_PTZStream1)
				soap_end_block(soap, soap_blist___union_PTZStream1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStream, 0, sizeof(tt__PTZStream), 0, soap_copy_tt__PTZStream);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__PTZStream::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__PTZStream);
	if (this->soap_out(soap, tag?tag:"tt:PTZStream", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZStream::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZStream(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZStream * SOAP_FMAC4 soap_get_tt__PTZStream(struct soap *soap, tt__PTZStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__PTZStream * SOAP_FMAC2 soap_instantiate_tt__PTZStream(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZStream(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__PTZStream, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZStream);
		if (size)
			*size = sizeof(tt__PTZStream);
		((tt__PTZStream*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZStream[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__PTZStream);
		for (int i = 0; i < n; i++)
			((tt__PTZStream*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__PTZStream*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__PTZStream(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__PTZStream %p -> %p\n", q, p));
	*(tt__PTZStream*)p = *(tt__PTZStream*)q;
}

void tt__VideoAnalyticsStreamExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoAnalyticsStreamExtension::__any);
	/* transient soap skipped */
}

void tt__VideoAnalyticsStreamExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoAnalyticsStreamExtension::__any);
	/* transient soap skipped */
}

int tt__VideoAnalyticsStreamExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoAnalyticsStreamExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoAnalyticsStreamExtension(struct soap *soap, const char *tag, int id, const tt__VideoAnalyticsStreamExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoAnalyticsStreamExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__VideoAnalyticsStreamExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__VideoAnalyticsStreamExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoAnalyticsStreamExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoAnalyticsStreamExtension * SOAP_FMAC4 soap_in_tt__VideoAnalyticsStreamExtension(struct soap *soap, const char *tag, tt__VideoAnalyticsStreamExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoAnalyticsStreamExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoAnalyticsStreamExtension, sizeof(tt__VideoAnalyticsStreamExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoAnalyticsStreamExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoAnalyticsStreamExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__VideoAnalyticsStreamExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoAnalyticsStreamExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoAnalyticsStreamExtension, 0, sizeof(tt__VideoAnalyticsStreamExtension), 0, soap_copy_tt__VideoAnalyticsStreamExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__VideoAnalyticsStreamExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoAnalyticsStreamExtension);
	if (this->soap_out(soap, tag?tag:"tt:VideoAnalyticsStreamExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoAnalyticsStreamExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoAnalyticsStreamExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoAnalyticsStreamExtension * SOAP_FMAC4 soap_get_tt__VideoAnalyticsStreamExtension(struct soap *soap, tt__VideoAnalyticsStreamExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoAnalyticsStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoAnalyticsStreamExtension * SOAP_FMAC2 soap_instantiate_tt__VideoAnalyticsStreamExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoAnalyticsStreamExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoAnalyticsStreamExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoAnalyticsStreamExtension);
		if (size)
			*size = sizeof(tt__VideoAnalyticsStreamExtension);
		((tt__VideoAnalyticsStreamExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoAnalyticsStreamExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__VideoAnalyticsStreamExtension);
		for (int i = 0; i < n; i++)
			((tt__VideoAnalyticsStreamExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__VideoAnalyticsStreamExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoAnalyticsStreamExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoAnalyticsStreamExtension %p -> %p\n", q, p));
	*(tt__VideoAnalyticsStreamExtension*)p = *(tt__VideoAnalyticsStreamExtension*)q;
}

void tt__VideoAnalyticsStream::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__VideoAnalyticsStream::__size_VideoAnalyticsStream = 0;
	this->tt__VideoAnalyticsStream::__union_VideoAnalyticsStream = NULL;
	/* transient soap skipped */
}

void tt__VideoAnalyticsStream::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->tt__VideoAnalyticsStream::__union_VideoAnalyticsStream)
	{	int i;
		for (i = 0; i < this->tt__VideoAnalyticsStream::__size_VideoAnalyticsStream; i++)
		{
			this->tt__VideoAnalyticsStream::__union_VideoAnalyticsStream[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
}

int tt__VideoAnalyticsStream::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoAnalyticsStream(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoAnalyticsStream(struct soap *soap, const char *tag, int id, const tt__VideoAnalyticsStream *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoAnalyticsStream), type))
		return soap->error;
	if (a->tt__VideoAnalyticsStream::__union_VideoAnalyticsStream)
	{	int i;
		for (i = 0; i < a->tt__VideoAnalyticsStream::__size_VideoAnalyticsStream; i++)
			if (a->tt__VideoAnalyticsStream::__union_VideoAnalyticsStream[i].soap_out(soap, "-union-VideoAnalyticsStream", -1, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__VideoAnalyticsStream::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoAnalyticsStream(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoAnalyticsStream * SOAP_FMAC4 soap_in_tt__VideoAnalyticsStream(struct soap *soap, const char *tag, tt__VideoAnalyticsStream *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoAnalyticsStream *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoAnalyticsStream, sizeof(tt__VideoAnalyticsStream), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoAnalyticsStream)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoAnalyticsStream *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist___union_VideoAnalyticsStream1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__VideoAnalyticsStream::__union_VideoAnalyticsStream == NULL)
				{	if (soap_blist___union_VideoAnalyticsStream1 == NULL)
						soap_blist___union_VideoAnalyticsStream1 = soap_new_block(soap);
					a->tt__VideoAnalyticsStream::__union_VideoAnalyticsStream = (__tt__union_VideoAnalyticsStream *)soap_push_block(soap, soap_blist___union_VideoAnalyticsStream1, sizeof(__tt__union_VideoAnalyticsStream));
					if (a->tt__VideoAnalyticsStream::__union_VideoAnalyticsStream == NULL)
						return NULL;
					__tt__union_VideoAnalyticsStream p;
					memcpy(a->tt__VideoAnalyticsStream::__union_VideoAnalyticsStream, &p, sizeof(__tt__union_VideoAnalyticsStream)); // a bit rough but portable
					a->tt__VideoAnalyticsStream::__union_VideoAnalyticsStream->soap_default(soap);
				}
				if (soap_in___tt__union_VideoAnalyticsStream(soap, "-union-VideoAnalyticsStream", a->tt__VideoAnalyticsStream::__union_VideoAnalyticsStream, "-tt:union-VideoAnalyticsStream"))
				{	a->tt__VideoAnalyticsStream::__size_VideoAnalyticsStream++;
					a->tt__VideoAnalyticsStream::__union_VideoAnalyticsStream = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__VideoAnalyticsStream::__union_VideoAnalyticsStream)
			soap_pop_block(soap, soap_blist___union_VideoAnalyticsStream1);
		if (a->tt__VideoAnalyticsStream::__size_VideoAnalyticsStream)
			a->tt__VideoAnalyticsStream::__union_VideoAnalyticsStream = (__tt__union_VideoAnalyticsStream *)soap_save_block(soap, soap_blist___union_VideoAnalyticsStream1, NULL, 1);
		else
		{	a->tt__VideoAnalyticsStream::__union_VideoAnalyticsStream = NULL;
			if (soap_blist___union_VideoAnalyticsStream1)
				soap_end_block(soap, soap_blist___union_VideoAnalyticsStream1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoAnalyticsStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoAnalyticsStream, 0, sizeof(tt__VideoAnalyticsStream), 0, soap_copy_tt__VideoAnalyticsStream);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__VideoAnalyticsStream::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoAnalyticsStream);
	if (this->soap_out(soap, tag?tag:"tt:VideoAnalyticsStream", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoAnalyticsStream::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoAnalyticsStream(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoAnalyticsStream * SOAP_FMAC4 soap_get_tt__VideoAnalyticsStream(struct soap *soap, tt__VideoAnalyticsStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoAnalyticsStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoAnalyticsStream * SOAP_FMAC2 soap_instantiate_tt__VideoAnalyticsStream(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoAnalyticsStream(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoAnalyticsStream, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoAnalyticsStream);
		if (size)
			*size = sizeof(tt__VideoAnalyticsStream);
		((tt__VideoAnalyticsStream*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoAnalyticsStream[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__VideoAnalyticsStream);
		for (int i = 0; i < n; i++)
			((tt__VideoAnalyticsStream*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__VideoAnalyticsStream*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoAnalyticsStream(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoAnalyticsStream %p -> %p\n", q, p));
	*(tt__VideoAnalyticsStream*)p = *(tt__VideoAnalyticsStream*)q;
}

void tt__MetadataStreamExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MetadataStreamExtension::__any);
	/* transient soap skipped */
}

void tt__MetadataStreamExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MetadataStreamExtension::__any);
	/* transient soap skipped */
}

int tt__MetadataStreamExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MetadataStreamExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataStreamExtension(struct soap *soap, const char *tag, int id, const tt__MetadataStreamExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataStreamExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__MetadataStreamExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__MetadataStreamExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__MetadataStreamExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__MetadataStreamExtension * SOAP_FMAC4 soap_in_tt__MetadataStreamExtension(struct soap *soap, const char *tag, tt__MetadataStreamExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MetadataStreamExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataStreamExtension, sizeof(tt__MetadataStreamExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__MetadataStreamExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__MetadataStreamExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__MetadataStreamExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MetadataStreamExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataStreamExtension, 0, sizeof(tt__MetadataStreamExtension), 0, soap_copy_tt__MetadataStreamExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__MetadataStreamExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__MetadataStreamExtension);
	if (this->soap_out(soap, tag?tag:"tt:MetadataStreamExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MetadataStreamExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MetadataStreamExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__MetadataStreamExtension * SOAP_FMAC4 soap_get_tt__MetadataStreamExtension(struct soap *soap, tt__MetadataStreamExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__MetadataStreamExtension * SOAP_FMAC2 soap_instantiate_tt__MetadataStreamExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MetadataStreamExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__MetadataStreamExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__MetadataStreamExtension);
		if (size)
			*size = sizeof(tt__MetadataStreamExtension);
		((tt__MetadataStreamExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__MetadataStreamExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__MetadataStreamExtension);
		for (int i = 0; i < n; i++)
			((tt__MetadataStreamExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__MetadataStreamExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__MetadataStreamExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__MetadataStreamExtension %p -> %p\n", q, p));
	*(tt__MetadataStreamExtension*)p = *(tt__MetadataStreamExtension*)q;
}

void tt__MetadataStream::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__MetadataStream::__size_MetadataStream = 0;
	this->tt__MetadataStream::__union_MetadataStream = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__MetadataStream::__anyAttribute);
	/* transient soap skipped */
}

void tt__MetadataStream::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->tt__MetadataStream::__union_MetadataStream)
	{	int i;
		for (i = 0; i < this->tt__MetadataStream::__size_MetadataStream; i++)
		{
			this->tt__MetadataStream::__union_MetadataStream[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
}

int tt__MetadataStream::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MetadataStream(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataStream(struct soap *soap, const char *tag, int id, const tt__MetadataStream *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__MetadataStream*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataStream), type))
		return soap->error;
	if (a->tt__MetadataStream::__union_MetadataStream)
	{	int i;
		for (i = 0; i < a->tt__MetadataStream::__size_MetadataStream; i++)
			if (a->tt__MetadataStream::__union_MetadataStream[i].soap_out(soap, "-union-MetadataStream", -1, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__MetadataStream::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__MetadataStream(soap, tag, this, type);
}

SOAP_FMAC3 tt__MetadataStream * SOAP_FMAC4 soap_in_tt__MetadataStream(struct soap *soap, const char *tag, tt__MetadataStream *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MetadataStream *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataStream, sizeof(tt__MetadataStream), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__MetadataStream)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__MetadataStream *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__MetadataStream*)a)->__anyAttribute, "xsd:anyAttribute");
	struct soap_blist *soap_blist___union_MetadataStream1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__MetadataStream::__union_MetadataStream == NULL)
				{	if (soap_blist___union_MetadataStream1 == NULL)
						soap_blist___union_MetadataStream1 = soap_new_block(soap);
					a->tt__MetadataStream::__union_MetadataStream = (__tt__union_MetadataStream *)soap_push_block(soap, soap_blist___union_MetadataStream1, sizeof(__tt__union_MetadataStream));
					if (a->tt__MetadataStream::__union_MetadataStream == NULL)
						return NULL;
					__tt__union_MetadataStream p;
					memcpy(a->tt__MetadataStream::__union_MetadataStream, &p, sizeof(__tt__union_MetadataStream)); // a bit rough but portable
					a->tt__MetadataStream::__union_MetadataStream->soap_default(soap);
				}
				if (soap_in___tt__union_MetadataStream(soap, "-union-MetadataStream", a->tt__MetadataStream::__union_MetadataStream, "-tt:union-MetadataStream"))
				{	a->tt__MetadataStream::__size_MetadataStream++;
					a->tt__MetadataStream::__union_MetadataStream = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__MetadataStream::__union_MetadataStream)
			soap_pop_block(soap, soap_blist___union_MetadataStream1);
		if (a->tt__MetadataStream::__size_MetadataStream)
			a->tt__MetadataStream::__union_MetadataStream = (__tt__union_MetadataStream *)soap_save_block(soap, soap_blist___union_MetadataStream1, NULL, 1);
		else
		{	a->tt__MetadataStream::__union_MetadataStream = NULL;
			if (soap_blist___union_MetadataStream1)
				soap_end_block(soap, soap_blist___union_MetadataStream1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MetadataStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataStream, 0, sizeof(tt__MetadataStream), 0, soap_copy_tt__MetadataStream);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__MetadataStream::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__MetadataStream);
	if (this->soap_out(soap, tag?tag:"tt:MetadataStream", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MetadataStream::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MetadataStream(soap, this, tag, type);
}

SOAP_FMAC3 tt__MetadataStream * SOAP_FMAC4 soap_get_tt__MetadataStream(struct soap *soap, tt__MetadataStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__MetadataStream * SOAP_FMAC2 soap_instantiate_tt__MetadataStream(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MetadataStream(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__MetadataStream, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__MetadataStream);
		if (size)
			*size = sizeof(tt__MetadataStream);
		((tt__MetadataStream*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__MetadataStream[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__MetadataStream);
		for (int i = 0; i < n; i++)
			((tt__MetadataStream*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__MetadataStream*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__MetadataStream(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__MetadataStream %p -> %p\n", q, p));
	*(tt__MetadataStream*)p = *(tt__MetadataStream*)q;
}

void tt__SupportedAnalyticsModulesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SupportedAnalyticsModulesExtension::__any);
	/* transient soap skipped */
}

void tt__SupportedAnalyticsModulesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SupportedAnalyticsModulesExtension::__any);
	/* transient soap skipped */
}

int tt__SupportedAnalyticsModulesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SupportedAnalyticsModulesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, int id, const tt__SupportedAnalyticsModulesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__SupportedAnalyticsModulesExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__SupportedAnalyticsModulesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__SupportedAnalyticsModulesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__SupportedAnalyticsModulesExtension * SOAP_FMAC4 soap_in_tt__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, tt__SupportedAnalyticsModulesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SupportedAnalyticsModulesExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, sizeof(tt__SupportedAnalyticsModulesExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__SupportedAnalyticsModulesExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__SupportedAnalyticsModulesExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__SupportedAnalyticsModulesExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SupportedAnalyticsModulesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, 0, sizeof(tt__SupportedAnalyticsModulesExtension), 0, soap_copy_tt__SupportedAnalyticsModulesExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__SupportedAnalyticsModulesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension);
	if (this->soap_out(soap, tag?tag:"tt:SupportedAnalyticsModulesExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SupportedAnalyticsModulesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SupportedAnalyticsModulesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__SupportedAnalyticsModulesExtension * SOAP_FMAC4 soap_get_tt__SupportedAnalyticsModulesExtension(struct soap *soap, tt__SupportedAnalyticsModulesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportedAnalyticsModulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__SupportedAnalyticsModulesExtension * SOAP_FMAC2 soap_instantiate_tt__SupportedAnalyticsModulesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SupportedAnalyticsModulesExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__SupportedAnalyticsModulesExtension);
		if (size)
			*size = sizeof(tt__SupportedAnalyticsModulesExtension);
		((tt__SupportedAnalyticsModulesExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__SupportedAnalyticsModulesExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__SupportedAnalyticsModulesExtension);
		for (int i = 0; i < n; i++)
			((tt__SupportedAnalyticsModulesExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__SupportedAnalyticsModulesExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__SupportedAnalyticsModulesExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__SupportedAnalyticsModulesExtension %p -> %p\n", q, p));
	*(tt__SupportedAnalyticsModulesExtension*)p = *(tt__SupportedAnalyticsModulesExtension*)q;
}

void tt__SupportedAnalyticsModules::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->tt__SupportedAnalyticsModules::AnalyticsModuleContentSchemaLocation);
	soap_default_std__vectorTemplateOfPointerTott__ConfigDescription(soap, &this->tt__SupportedAnalyticsModules::AnalyticsModuleDescription);
	this->tt__SupportedAnalyticsModules::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__SupportedAnalyticsModules::__anyAttribute);
	/* transient soap skipped */
}

void tt__SupportedAnalyticsModules::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->tt__SupportedAnalyticsModules::AnalyticsModuleContentSchemaLocation);
	soap_serialize_std__vectorTemplateOfPointerTott__ConfigDescription(soap, &this->tt__SupportedAnalyticsModules::AnalyticsModuleDescription);
	soap_serialize_PointerTott__SupportedAnalyticsModulesExtension(soap, &this->tt__SupportedAnalyticsModules::Extension);
	/* transient soap skipped */
}

int tt__SupportedAnalyticsModules::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SupportedAnalyticsModules(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportedAnalyticsModules(struct soap *soap, const char *tag, int id, const tt__SupportedAnalyticsModules *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__SupportedAnalyticsModules*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportedAnalyticsModules), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tt:AnalyticsModuleContentSchemaLocation", -1, &(a->tt__SupportedAnalyticsModules::AnalyticsModuleContentSchemaLocation), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__ConfigDescription(soap, "tt:AnalyticsModuleDescription", -1, &(a->tt__SupportedAnalyticsModules::AnalyticsModuleDescription), ""))
		return soap->error;
	if (soap_out_PointerTott__SupportedAnalyticsModulesExtension(soap, "tt:Extension", -1, &(a->tt__SupportedAnalyticsModules::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__SupportedAnalyticsModules::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__SupportedAnalyticsModules(soap, tag, this, type);
}

SOAP_FMAC3 tt__SupportedAnalyticsModules * SOAP_FMAC4 soap_in_tt__SupportedAnalyticsModules(struct soap *soap, const char *tag, tt__SupportedAnalyticsModules *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SupportedAnalyticsModules *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedAnalyticsModules, sizeof(tt__SupportedAnalyticsModules), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__SupportedAnalyticsModules)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__SupportedAnalyticsModules *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__SupportedAnalyticsModules*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tt:AnalyticsModuleContentSchemaLocation", &(a->tt__SupportedAnalyticsModules::AnalyticsModuleContentSchemaLocation), "xsd:anyURI"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__ConfigDescription(soap, "tt:AnalyticsModuleDescription", &(a->tt__SupportedAnalyticsModules::AnalyticsModuleDescription), "tt:ConfigDescription"))
					continue;
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SupportedAnalyticsModulesExtension(soap, "tt:Extension", &(a->tt__SupportedAnalyticsModules::Extension), "tt:SupportedAnalyticsModulesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SupportedAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedAnalyticsModules, 0, sizeof(tt__SupportedAnalyticsModules), 0, soap_copy_tt__SupportedAnalyticsModules);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__SupportedAnalyticsModules::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__SupportedAnalyticsModules);
	if (this->soap_out(soap, tag?tag:"tt:SupportedAnalyticsModules", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SupportedAnalyticsModules::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SupportedAnalyticsModules(soap, this, tag, type);
}

SOAP_FMAC3 tt__SupportedAnalyticsModules * SOAP_FMAC4 soap_get_tt__SupportedAnalyticsModules(struct soap *soap, tt__SupportedAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportedAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__SupportedAnalyticsModules * SOAP_FMAC2 soap_instantiate_tt__SupportedAnalyticsModules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SupportedAnalyticsModules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__SupportedAnalyticsModules, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__SupportedAnalyticsModules);
		if (size)
			*size = sizeof(tt__SupportedAnalyticsModules);
		((tt__SupportedAnalyticsModules*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__SupportedAnalyticsModules[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__SupportedAnalyticsModules);
		for (int i = 0; i < n; i++)
			((tt__SupportedAnalyticsModules*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__SupportedAnalyticsModules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__SupportedAnalyticsModules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__SupportedAnalyticsModules %p -> %p\n", q, p));
	*(tt__SupportedAnalyticsModules*)p = *(tt__SupportedAnalyticsModules*)q;
}

void tt__SupportedRulesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SupportedRulesExtension::__any);
	/* transient soap skipped */
}

void tt__SupportedRulesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SupportedRulesExtension::__any);
	/* transient soap skipped */
}

int tt__SupportedRulesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SupportedRulesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportedRulesExtension(struct soap *soap, const char *tag, int id, const tt__SupportedRulesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportedRulesExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__SupportedRulesExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__SupportedRulesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__SupportedRulesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__SupportedRulesExtension * SOAP_FMAC4 soap_in_tt__SupportedRulesExtension(struct soap *soap, const char *tag, tt__SupportedRulesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SupportedRulesExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedRulesExtension, sizeof(tt__SupportedRulesExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__SupportedRulesExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__SupportedRulesExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__SupportedRulesExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SupportedRulesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedRulesExtension, 0, sizeof(tt__SupportedRulesExtension), 0, soap_copy_tt__SupportedRulesExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__SupportedRulesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__SupportedRulesExtension);
	if (this->soap_out(soap, tag?tag:"tt:SupportedRulesExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SupportedRulesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SupportedRulesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__SupportedRulesExtension * SOAP_FMAC4 soap_get_tt__SupportedRulesExtension(struct soap *soap, tt__SupportedRulesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportedRulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__SupportedRulesExtension * SOAP_FMAC2 soap_instantiate_tt__SupportedRulesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SupportedRulesExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__SupportedRulesExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__SupportedRulesExtension);
		if (size)
			*size = sizeof(tt__SupportedRulesExtension);
		((tt__SupportedRulesExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__SupportedRulesExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__SupportedRulesExtension);
		for (int i = 0; i < n; i++)
			((tt__SupportedRulesExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__SupportedRulesExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__SupportedRulesExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__SupportedRulesExtension %p -> %p\n", q, p));
	*(tt__SupportedRulesExtension*)p = *(tt__SupportedRulesExtension*)q;
}

void tt__SupportedRules::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->tt__SupportedRules::RuleContentSchemaLocation);
	soap_default_std__vectorTemplateOfPointerTott__ConfigDescription(soap, &this->tt__SupportedRules::RuleDescription);
	this->tt__SupportedRules::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__SupportedRules::__anyAttribute);
	/* transient soap skipped */
}

void tt__SupportedRules::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->tt__SupportedRules::RuleContentSchemaLocation);
	soap_serialize_std__vectorTemplateOfPointerTott__ConfigDescription(soap, &this->tt__SupportedRules::RuleDescription);
	soap_serialize_PointerTott__SupportedRulesExtension(soap, &this->tt__SupportedRules::Extension);
	/* transient soap skipped */
}

int tt__SupportedRules::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SupportedRules(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportedRules(struct soap *soap, const char *tag, int id, const tt__SupportedRules *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__SupportedRules*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportedRules), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tt:RuleContentSchemaLocation", -1, &(a->tt__SupportedRules::RuleContentSchemaLocation), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__ConfigDescription(soap, "tt:RuleDescription", -1, &(a->tt__SupportedRules::RuleDescription), ""))
		return soap->error;
	if (soap_out_PointerTott__SupportedRulesExtension(soap, "tt:Extension", -1, &(a->tt__SupportedRules::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__SupportedRules::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__SupportedRules(soap, tag, this, type);
}

SOAP_FMAC3 tt__SupportedRules * SOAP_FMAC4 soap_in_tt__SupportedRules(struct soap *soap, const char *tag, tt__SupportedRules *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SupportedRules *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedRules, sizeof(tt__SupportedRules), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__SupportedRules)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__SupportedRules *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__SupportedRules*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tt:RuleContentSchemaLocation", &(a->tt__SupportedRules::RuleContentSchemaLocation), "xsd:anyURI"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__ConfigDescription(soap, "tt:RuleDescription", &(a->tt__SupportedRules::RuleDescription), "tt:ConfigDescription"))
					continue;
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SupportedRulesExtension(soap, "tt:Extension", &(a->tt__SupportedRules::Extension), "tt:SupportedRulesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SupportedRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedRules, 0, sizeof(tt__SupportedRules), 0, soap_copy_tt__SupportedRules);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__SupportedRules::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__SupportedRules);
	if (this->soap_out(soap, tag?tag:"tt:SupportedRules", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SupportedRules::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SupportedRules(soap, this, tag, type);
}

SOAP_FMAC3 tt__SupportedRules * SOAP_FMAC4 soap_get_tt__SupportedRules(struct soap *soap, tt__SupportedRules *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportedRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__SupportedRules * SOAP_FMAC2 soap_instantiate_tt__SupportedRules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SupportedRules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__SupportedRules, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__SupportedRules);
		if (size)
			*size = sizeof(tt__SupportedRules);
		((tt__SupportedRules*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__SupportedRules[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__SupportedRules);
		for (int i = 0; i < n; i++)
			((tt__SupportedRules*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__SupportedRules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__SupportedRules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__SupportedRules %p -> %p\n", q, p));
	*(tt__SupportedRules*)p = *(tt__SupportedRules*)q;
}

void tt__ConfigDescriptionExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ConfigDescriptionExtension::__any);
	/* transient soap skipped */
}

void tt__ConfigDescriptionExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ConfigDescriptionExtension::__any);
	/* transient soap skipped */
}

int tt__ConfigDescriptionExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ConfigDescriptionExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ConfigDescriptionExtension(struct soap *soap, const char *tag, int id, const tt__ConfigDescriptionExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ConfigDescriptionExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__ConfigDescriptionExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ConfigDescriptionExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ConfigDescriptionExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ConfigDescriptionExtension * SOAP_FMAC4 soap_in_tt__ConfigDescriptionExtension(struct soap *soap, const char *tag, tt__ConfigDescriptionExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ConfigDescriptionExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ConfigDescriptionExtension, sizeof(tt__ConfigDescriptionExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ConfigDescriptionExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ConfigDescriptionExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__ConfigDescriptionExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ConfigDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ConfigDescriptionExtension, 0, sizeof(tt__ConfigDescriptionExtension), 0, soap_copy_tt__ConfigDescriptionExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ConfigDescriptionExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ConfigDescriptionExtension);
	if (this->soap_out(soap, tag?tag:"tt:ConfigDescriptionExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ConfigDescriptionExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ConfigDescriptionExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ConfigDescriptionExtension * SOAP_FMAC4 soap_get_tt__ConfigDescriptionExtension(struct soap *soap, tt__ConfigDescriptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ConfigDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ConfigDescriptionExtension * SOAP_FMAC2 soap_instantiate_tt__ConfigDescriptionExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ConfigDescriptionExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ConfigDescriptionExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ConfigDescriptionExtension);
		if (size)
			*size = sizeof(tt__ConfigDescriptionExtension);
		((tt__ConfigDescriptionExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ConfigDescriptionExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ConfigDescriptionExtension);
		for (int i = 0; i < n; i++)
			((tt__ConfigDescriptionExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ConfigDescriptionExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ConfigDescriptionExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ConfigDescriptionExtension %p -> %p\n", q, p));
	*(tt__ConfigDescriptionExtension*)p = *(tt__ConfigDescriptionExtension*)q;
}

void tt__ConfigDescription::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigDescription::Parameters = NULL;
	this->tt__ConfigDescription::__sizeMessages = 0;
	this->tt__ConfigDescription::Messages = NULL;
	this->tt__ConfigDescription::Extension = NULL;
	soap_default_xsd__QName(soap, &this->tt__ConfigDescription::Name);
	soap_default_xsd__anyAttribute(soap, &this->tt__ConfigDescription::__anyAttribute);
	/* transient soap skipped */
}

void tt__ConfigDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ItemListDescription(soap, &this->tt__ConfigDescription::Parameters);
	if (this->tt__ConfigDescription::Messages)
	{	int i;
		for (i = 0; i < this->tt__ConfigDescription::__sizeMessages; i++)
		{
			soap_embedded(soap, this->tt__ConfigDescription::Messages + i, SOAP_TYPE__tt__ConfigDescription_Messages);
			this->tt__ConfigDescription::Messages[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTott__ConfigDescriptionExtension(soap, &this->tt__ConfigDescription::Extension);
	/* transient soap skipped */
}

int tt__ConfigDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ConfigDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ConfigDescription(struct soap *soap, const char *tag, int id, const tt__ConfigDescription *a, const char *type)
{
	if (!((tt__ConfigDescription*)a)->Name.empty())
		soap_set_attr(soap, "Name", soap_QName2s(soap, ((tt__ConfigDescription*)a)->Name.c_str()), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ConfigDescription*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ConfigDescription), type))
		return soap->error;
	if (a->tt__ConfigDescription::Parameters)
	{	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Parameters", -1, &a->tt__ConfigDescription::Parameters, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Parameters"))
		return soap->error;
	if (a->tt__ConfigDescription::Messages)
	{	int i;
		for (i = 0; i < a->tt__ConfigDescription::__sizeMessages; i++)
			if (a->tt__ConfigDescription::Messages[i].soap_out(soap, "tt:Messages", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ConfigDescriptionExtension(soap, "tt:Extension", -1, &(a->tt__ConfigDescription::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ConfigDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ConfigDescription(soap, tag, this, type);
}

SOAP_FMAC3 tt__ConfigDescription * SOAP_FMAC4 soap_in_tt__ConfigDescription(struct soap *soap, const char *tag, tt__ConfigDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ConfigDescription *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ConfigDescription, sizeof(tt__ConfigDescription), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ConfigDescription)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ConfigDescription *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Name", 1);
		if (t)
		{	char *s;
			if (soap_s2QName(soap, t, &s, -1, -1))
				return NULL;
			((tt__ConfigDescription*)a)->Name.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ConfigDescription*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Parameters1 = 1;
	struct soap_blist *soap_blist_Messages1 = NULL;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Parameters1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescription(soap, "tt:Parameters", &(a->tt__ConfigDescription::Parameters), "tt:ItemListDescription"))
				{	soap_flag_Parameters1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Messages", 1, NULL))
			{	if (a->tt__ConfigDescription::Messages == NULL)
				{	if (soap_blist_Messages1 == NULL)
						soap_blist_Messages1 = soap_new_block(soap);
					a->tt__ConfigDescription::Messages = (_tt__ConfigDescription_Messages *)soap_push_block(soap, soap_blist_Messages1, sizeof(_tt__ConfigDescription_Messages));
					if (a->tt__ConfigDescription::Messages == NULL)
						return NULL;
					_tt__ConfigDescription_Messages p;
					memcpy(a->tt__ConfigDescription::Messages, &p, sizeof(_tt__ConfigDescription_Messages)); // a bit rough but portable
					a->tt__ConfigDescription::Messages->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__tt__ConfigDescription_Messages(soap, "tt:Messages", a->tt__ConfigDescription::Messages, ""))
				{	a->tt__ConfigDescription::__sizeMessages++;
					a->tt__ConfigDescription::Messages = NULL;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ConfigDescriptionExtension(soap, "tt:Extension", &(a->tt__ConfigDescription::Extension), "tt:ConfigDescriptionExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__ConfigDescription::Messages)
			soap_pop_block(soap, soap_blist_Messages1);
		if (a->tt__ConfigDescription::__sizeMessages)
			a->tt__ConfigDescription::Messages = (_tt__ConfigDescription_Messages *)soap_save_block(soap, soap_blist_Messages1, NULL, 1);
		else
		{	a->tt__ConfigDescription::Messages = NULL;
			if (soap_blist_Messages1)
				soap_end_block(soap, soap_blist_Messages1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ConfigDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ConfigDescription, 0, sizeof(tt__ConfigDescription), 0, soap_copy_tt__ConfigDescription);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Parameters1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__ConfigDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ConfigDescription);
	if (this->soap_out(soap, tag?tag:"tt:ConfigDescription", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ConfigDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ConfigDescription(soap, this, tag, type);
}

SOAP_FMAC3 tt__ConfigDescription * SOAP_FMAC4 soap_get_tt__ConfigDescription(struct soap *soap, tt__ConfigDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ConfigDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ConfigDescription * SOAP_FMAC2 soap_instantiate_tt__ConfigDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ConfigDescription(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ConfigDescription, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ConfigDescription);
		if (size)
			*size = sizeof(tt__ConfigDescription);
		((tt__ConfigDescription*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ConfigDescription[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ConfigDescription);
		for (int i = 0; i < n; i++)
			((tt__ConfigDescription*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ConfigDescription*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ConfigDescription(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ConfigDescription %p -> %p\n", q, p));
	*(tt__ConfigDescription*)p = *(tt__ConfigDescription*)q;
}

void tt__Config::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__Config::Parameters = NULL;
	soap_default_std__string(soap, &this->tt__Config::Name);
	soap_default_xsd__QName(soap, &this->tt__Config::Type);
	/* transient soap skipped */
}

void tt__Config::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ItemList(soap, &this->tt__Config::Parameters);
	/* transient soap skipped */
}

int tt__Config::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Config(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Config(struct soap *soap, const char *tag, int id, const tt__Config *a, const char *type)
{
	if (!((tt__Config*)a)->Name.empty())
		soap_set_attr(soap, "Name", ((tt__Config*)a)->Name.c_str(), 1);
	if (!((tt__Config*)a)->Type.empty())
		soap_set_attr(soap, "Type", soap_QName2s(soap, ((tt__Config*)a)->Type.c_str()), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Config), type))
		return soap->error;
	if (a->tt__Config::Parameters)
	{	if (soap_out_PointerTott__ItemList(soap, "tt:Parameters", -1, &a->tt__Config::Parameters, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Parameters"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Config::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Config(soap, tag, this, type);
}

SOAP_FMAC3 tt__Config * SOAP_FMAC4 soap_in_tt__Config(struct soap *soap, const char *tag, tt__Config *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Config *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Config, sizeof(tt__Config), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Config)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Config *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((tt__Config*)a)->Name.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Type", 1);
		if (t)
		{	char *s;
			if (soap_s2QName(soap, t, &s, -1, -1))
				return NULL;
			((tt__Config*)a)->Type.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Parameters1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Parameters1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemList(soap, "tt:Parameters", &(a->tt__Config::Parameters), "tt:ItemList"))
				{	soap_flag_Parameters1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Config *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Config, 0, sizeof(tt__Config), 0, soap_copy_tt__Config);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Parameters1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Config::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Config);
	if (this->soap_out(soap, tag?tag:"tt:Config", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Config::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Config(soap, this, tag, type);
}

SOAP_FMAC3 tt__Config * SOAP_FMAC4 soap_get_tt__Config(struct soap *soap, tt__Config *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Config(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Config * SOAP_FMAC2 soap_instantiate_tt__Config(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Config(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Config, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Config);
		if (size)
			*size = sizeof(tt__Config);
		((tt__Config*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Config[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Config);
		for (int i = 0; i < n; i++)
			((tt__Config*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Config*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Config(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Config %p -> %p\n", q, p));
	*(tt__Config*)p = *(tt__Config*)q;
}

void tt__RuleEngineConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RuleEngineConfigurationExtension::__any);
	/* transient soap skipped */
}

void tt__RuleEngineConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RuleEngineConfigurationExtension::__any);
	/* transient soap skipped */
}

int tt__RuleEngineConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RuleEngineConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__RuleEngineConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RuleEngineConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__RuleEngineConfigurationExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__RuleEngineConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__RuleEngineConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__RuleEngineConfigurationExtension * SOAP_FMAC4 soap_in_tt__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, tt__RuleEngineConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RuleEngineConfigurationExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RuleEngineConfigurationExtension, sizeof(tt__RuleEngineConfigurationExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__RuleEngineConfigurationExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__RuleEngineConfigurationExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__RuleEngineConfigurationExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RuleEngineConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RuleEngineConfigurationExtension, 0, sizeof(tt__RuleEngineConfigurationExtension), 0, soap_copy_tt__RuleEngineConfigurationExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__RuleEngineConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__RuleEngineConfigurationExtension);
	if (this->soap_out(soap, tag?tag:"tt:RuleEngineConfigurationExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RuleEngineConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RuleEngineConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__RuleEngineConfigurationExtension * SOAP_FMAC4 soap_get_tt__RuleEngineConfigurationExtension(struct soap *soap, tt__RuleEngineConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RuleEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__RuleEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__RuleEngineConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RuleEngineConfigurationExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__RuleEngineConfigurationExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__RuleEngineConfigurationExtension);
		if (size)
			*size = sizeof(tt__RuleEngineConfigurationExtension);
		((tt__RuleEngineConfigurationExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__RuleEngineConfigurationExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__RuleEngineConfigurationExtension);
		for (int i = 0; i < n; i++)
			((tt__RuleEngineConfigurationExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__RuleEngineConfigurationExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__RuleEngineConfigurationExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__RuleEngineConfigurationExtension %p -> %p\n", q, p));
	*(tt__RuleEngineConfigurationExtension*)p = *(tt__RuleEngineConfigurationExtension*)q;
}

void tt__RuleEngineConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Config(soap, &this->tt__RuleEngineConfiguration::Rule);
	this->tt__RuleEngineConfiguration::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__RuleEngineConfiguration::__anyAttribute);
	/* transient soap skipped */
}

void tt__RuleEngineConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTott__Config(soap, &this->tt__RuleEngineConfiguration::Rule);
	soap_serialize_PointerTott__RuleEngineConfigurationExtension(soap, &this->tt__RuleEngineConfiguration::Extension);
	/* transient soap skipped */
}

int tt__RuleEngineConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RuleEngineConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RuleEngineConfiguration(struct soap *soap, const char *tag, int id, const tt__RuleEngineConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__RuleEngineConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RuleEngineConfiguration), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Config(soap, "tt:Rule", -1, &(a->tt__RuleEngineConfiguration::Rule), ""))
		return soap->error;
	if (soap_out_PointerTott__RuleEngineConfigurationExtension(soap, "tt:Extension", -1, &(a->tt__RuleEngineConfiguration::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__RuleEngineConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__RuleEngineConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__RuleEngineConfiguration * SOAP_FMAC4 soap_in_tt__RuleEngineConfiguration(struct soap *soap, const char *tag, tt__RuleEngineConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RuleEngineConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(tt__RuleEngineConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__RuleEngineConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__RuleEngineConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__RuleEngineConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Config(soap, "tt:Rule", &(a->tt__RuleEngineConfiguration::Rule), "tt:Config"))
					continue;
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RuleEngineConfigurationExtension(soap, "tt:Extension", &(a->tt__RuleEngineConfiguration::Extension), "tt:RuleEngineConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RuleEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RuleEngineConfiguration, 0, sizeof(tt__RuleEngineConfiguration), 0, soap_copy_tt__RuleEngineConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__RuleEngineConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__RuleEngineConfiguration);
	if (this->soap_out(soap, tag?tag:"tt:RuleEngineConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RuleEngineConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RuleEngineConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__RuleEngineConfiguration * SOAP_FMAC4 soap_get_tt__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RuleEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__RuleEngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__RuleEngineConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RuleEngineConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__RuleEngineConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__RuleEngineConfiguration);
		if (size)
			*size = sizeof(tt__RuleEngineConfiguration);
		((tt__RuleEngineConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__RuleEngineConfiguration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__RuleEngineConfiguration);
		for (int i = 0; i < n; i++)
			((tt__RuleEngineConfiguration*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__RuleEngineConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__RuleEngineConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__RuleEngineConfiguration %p -> %p\n", q, p));
	*(tt__RuleEngineConfiguration*)p = *(tt__RuleEngineConfiguration*)q;
}

void tt__AnalyticsEngineConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsEngineConfigurationExtension::__any);
	/* transient soap skipped */
}

void tt__AnalyticsEngineConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsEngineConfigurationExtension::__any);
	/* transient soap skipped */
}

int tt__AnalyticsEngineConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsEngineConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__AnalyticsEngineConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__AnalyticsEngineConfigurationExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsEngineConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__AnalyticsEngineConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC4 soap_in_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, tt__AnalyticsEngineConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsEngineConfigurationExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, sizeof(tt__AnalyticsEngineConfigurationExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__AnalyticsEngineConfigurationExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__AnalyticsEngineConfigurationExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AnalyticsEngineConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, 0, sizeof(tt__AnalyticsEngineConfigurationExtension), 0, soap_copy_tt__AnalyticsEngineConfigurationExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__AnalyticsEngineConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension);
	if (this->soap_out(soap, tag?tag:"tt:AnalyticsEngineConfigurationExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsEngineConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsEngineConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC4 soap_get_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, tt__AnalyticsEngineConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsEngineConfigurationExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__AnalyticsEngineConfigurationExtension);
		if (size)
			*size = sizeof(tt__AnalyticsEngineConfigurationExtension);
		((tt__AnalyticsEngineConfigurationExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__AnalyticsEngineConfigurationExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__AnalyticsEngineConfigurationExtension);
		for (int i = 0; i < n; i++)
			((tt__AnalyticsEngineConfigurationExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__AnalyticsEngineConfigurationExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__AnalyticsEngineConfigurationExtension %p -> %p\n", q, p));
	*(tt__AnalyticsEngineConfigurationExtension*)p = *(tt__AnalyticsEngineConfigurationExtension*)q;
}

void tt__AnalyticsEngineConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Config(soap, &this->tt__AnalyticsEngineConfiguration::AnalyticsModule);
	this->tt__AnalyticsEngineConfiguration::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__AnalyticsEngineConfiguration::__anyAttribute);
	/* transient soap skipped */
}

void tt__AnalyticsEngineConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTott__Config(soap, &this->tt__AnalyticsEngineConfiguration::AnalyticsModule);
	soap_serialize_PointerTott__AnalyticsEngineConfigurationExtension(soap, &this->tt__AnalyticsEngineConfiguration::Extension);
	/* transient soap skipped */
}

int tt__AnalyticsEngineConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsEngineConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, int id, const tt__AnalyticsEngineConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AnalyticsEngineConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineConfiguration), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Config(soap, "tt:AnalyticsModule", -1, &(a->tt__AnalyticsEngineConfiguration::AnalyticsModule), ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsEngineConfigurationExtension(soap, "tt:Extension", -1, &(a->tt__AnalyticsEngineConfiguration::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsEngineConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__AnalyticsEngineConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsEngineConfiguration * SOAP_FMAC4 soap_in_tt__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, tt__AnalyticsEngineConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsEngineConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(tt__AnalyticsEngineConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__AnalyticsEngineConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__AnalyticsEngineConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AnalyticsEngineConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Config(soap, "tt:AnalyticsModule", &(a->tt__AnalyticsEngineConfiguration::AnalyticsModule), "tt:Config"))
					continue;
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsEngineConfigurationExtension(soap, "tt:Extension", &(a->tt__AnalyticsEngineConfiguration::Extension), "tt:AnalyticsEngineConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AnalyticsEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineConfiguration, 0, sizeof(tt__AnalyticsEngineConfiguration), 0, soap_copy_tt__AnalyticsEngineConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__AnalyticsEngineConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__AnalyticsEngineConfiguration);
	if (this->soap_out(soap, tag?tag:"tt:AnalyticsEngineConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsEngineConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsEngineConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsEngineConfiguration * SOAP_FMAC4 soap_get_tt__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__AnalyticsEngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsEngineConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__AnalyticsEngineConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__AnalyticsEngineConfiguration);
		if (size)
			*size = sizeof(tt__AnalyticsEngineConfiguration);
		((tt__AnalyticsEngineConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__AnalyticsEngineConfiguration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__AnalyticsEngineConfiguration);
		for (int i = 0; i < n; i++)
			((tt__AnalyticsEngineConfiguration*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__AnalyticsEngineConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__AnalyticsEngineConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__AnalyticsEngineConfiguration %p -> %p\n", q, p));
	*(tt__AnalyticsEngineConfiguration*)p = *(tt__AnalyticsEngineConfiguration*)q;
}

void tt__ObjectTreeExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ObjectTreeExtension::__any);
	/* transient soap skipped */
}

void tt__ObjectTreeExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ObjectTreeExtension::__any);
	/* transient soap skipped */
}

int tt__ObjectTreeExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ObjectTreeExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ObjectTreeExtension(struct soap *soap, const char *tag, int id, const tt__ObjectTreeExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ObjectTreeExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__ObjectTreeExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ObjectTreeExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ObjectTreeExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ObjectTreeExtension * SOAP_FMAC4 soap_in_tt__ObjectTreeExtension(struct soap *soap, const char *tag, tt__ObjectTreeExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ObjectTreeExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ObjectTreeExtension, sizeof(tt__ObjectTreeExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ObjectTreeExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ObjectTreeExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__ObjectTreeExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ObjectTreeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ObjectTreeExtension, 0, sizeof(tt__ObjectTreeExtension), 0, soap_copy_tt__ObjectTreeExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ObjectTreeExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ObjectTreeExtension);
	if (this->soap_out(soap, tag?tag:"tt:ObjectTreeExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ObjectTreeExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ObjectTreeExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ObjectTreeExtension * SOAP_FMAC4 soap_get_tt__ObjectTreeExtension(struct soap *soap, tt__ObjectTreeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ObjectTreeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ObjectTreeExtension * SOAP_FMAC2 soap_instantiate_tt__ObjectTreeExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ObjectTreeExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ObjectTreeExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ObjectTreeExtension);
		if (size)
			*size = sizeof(tt__ObjectTreeExtension);
		((tt__ObjectTreeExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ObjectTreeExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ObjectTreeExtension);
		for (int i = 0; i < n; i++)
			((tt__ObjectTreeExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ObjectTreeExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ObjectTreeExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ObjectTreeExtension %p -> %p\n", q, p));
	*(tt__ObjectTreeExtension*)p = *(tt__ObjectTreeExtension*)q;
}

void tt__ObjectTree::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Rename(soap, &this->tt__ObjectTree::Rename);
	soap_default_std__vectorTemplateOfPointerTott__Split(soap, &this->tt__ObjectTree::Split);
	soap_default_std__vectorTemplateOfPointerTott__Merge(soap, &this->tt__ObjectTree::Merge);
	soap_default_std__vectorTemplateOfPointerTott__ObjectId(soap, &this->tt__ObjectTree::Delete);
	this->tt__ObjectTree::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ObjectTree::__anyAttribute);
	/* transient soap skipped */
}

void tt__ObjectTree::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTott__Rename(soap, &this->tt__ObjectTree::Rename);
	soap_serialize_std__vectorTemplateOfPointerTott__Split(soap, &this->tt__ObjectTree::Split);
	soap_serialize_std__vectorTemplateOfPointerTott__Merge(soap, &this->tt__ObjectTree::Merge);
	soap_serialize_std__vectorTemplateOfPointerTott__ObjectId(soap, &this->tt__ObjectTree::Delete);
	soap_serialize_PointerTott__ObjectTreeExtension(soap, &this->tt__ObjectTree::Extension);
	/* transient soap skipped */
}

int tt__ObjectTree::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ObjectTree(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ObjectTree(struct soap *soap, const char *tag, int id, const tt__ObjectTree *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ObjectTree*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ObjectTree), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Rename(soap, "tt:Rename", -1, &(a->tt__ObjectTree::Rename), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Split(soap, "tt:Split", -1, &(a->tt__ObjectTree::Split), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Merge(soap, "tt:Merge", -1, &(a->tt__ObjectTree::Merge), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__ObjectId(soap, "tt:Delete", -1, &(a->tt__ObjectTree::Delete), ""))
		return soap->error;
	if (soap_out_PointerTott__ObjectTreeExtension(soap, "tt:Extension", -1, &(a->tt__ObjectTree::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ObjectTree::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ObjectTree(soap, tag, this, type);
}

SOAP_FMAC3 tt__ObjectTree * SOAP_FMAC4 soap_in_tt__ObjectTree(struct soap *soap, const char *tag, tt__ObjectTree *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ObjectTree *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ObjectTree, sizeof(tt__ObjectTree), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ObjectTree)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ObjectTree *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ObjectTree*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Rename(soap, "tt:Rename", &(a->tt__ObjectTree::Rename), "tt:Rename"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Split(soap, "tt:Split", &(a->tt__ObjectTree::Split), "tt:Split"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Merge(soap, "tt:Merge", &(a->tt__ObjectTree::Merge), "tt:Merge"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__ObjectId(soap, "tt:Delete", &(a->tt__ObjectTree::Delete), "tt:ObjectId"))
					continue;
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ObjectTreeExtension(soap, "tt:Extension", &(a->tt__ObjectTree::Extension), "tt:ObjectTreeExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ObjectTree *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ObjectTree, 0, sizeof(tt__ObjectTree), 0, soap_copy_tt__ObjectTree);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ObjectTree::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ObjectTree);
	if (this->soap_out(soap, tag?tag:"tt:ObjectTree", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ObjectTree::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ObjectTree(soap, this, tag, type);
}

SOAP_FMAC3 tt__ObjectTree * SOAP_FMAC4 soap_get_tt__ObjectTree(struct soap *soap, tt__ObjectTree *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ObjectTree(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ObjectTree * SOAP_FMAC2 soap_instantiate_tt__ObjectTree(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ObjectTree(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ObjectTree, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ObjectTree);
		if (size)
			*size = sizeof(tt__ObjectTree);
		((tt__ObjectTree*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ObjectTree[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ObjectTree);
		for (int i = 0; i < n; i++)
			((tt__ObjectTree*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ObjectTree*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ObjectTree(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ObjectTree %p -> %p\n", q, p));
	*(tt__ObjectTree*)p = *(tt__ObjectTree*)q;
}

void tt__BehaviourExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__BehaviourExtension::__any);
	/* transient soap skipped */
}

void tt__BehaviourExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__BehaviourExtension::__any);
	/* transient soap skipped */
}

int tt__BehaviourExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BehaviourExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BehaviourExtension(struct soap *soap, const char *tag, int id, const tt__BehaviourExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BehaviourExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__BehaviourExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__BehaviourExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__BehaviourExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__BehaviourExtension * SOAP_FMAC4 soap_in_tt__BehaviourExtension(struct soap *soap, const char *tag, tt__BehaviourExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__BehaviourExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BehaviourExtension, sizeof(tt__BehaviourExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__BehaviourExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__BehaviourExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__BehaviourExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__BehaviourExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BehaviourExtension, 0, sizeof(tt__BehaviourExtension), 0, soap_copy_tt__BehaviourExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__BehaviourExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__BehaviourExtension);
	if (this->soap_out(soap, tag?tag:"tt:BehaviourExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BehaviourExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BehaviourExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__BehaviourExtension * SOAP_FMAC4 soap_get_tt__BehaviourExtension(struct soap *soap, tt__BehaviourExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BehaviourExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__BehaviourExtension * SOAP_FMAC2 soap_instantiate_tt__BehaviourExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__BehaviourExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__BehaviourExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__BehaviourExtension);
		if (size)
			*size = sizeof(tt__BehaviourExtension);
		((tt__BehaviourExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__BehaviourExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__BehaviourExtension);
		for (int i = 0; i < n; i++)
			((tt__BehaviourExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__BehaviourExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__BehaviourExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__BehaviourExtension %p -> %p\n", q, p));
	*(tt__BehaviourExtension*)p = *(tt__BehaviourExtension*)q;
}

void tt__Behaviour::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__Behaviour::Removed = NULL;
	this->tt__Behaviour::Idle = NULL;
	this->tt__Behaviour::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__Behaviour::__anyAttribute);
	/* transient soap skipped */
}

void tt__Behaviour::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tt__Behaviour_Removed(soap, &this->tt__Behaviour::Removed);
	soap_serialize_PointerTo_tt__Behaviour_Idle(soap, &this->tt__Behaviour::Idle);
	soap_serialize_PointerTott__BehaviourExtension(soap, &this->tt__Behaviour::Extension);
	/* transient soap skipped */
}

int tt__Behaviour::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Behaviour(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Behaviour(struct soap *soap, const char *tag, int id, const tt__Behaviour *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Behaviour*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Behaviour), type))
		return soap->error;
	if (soap_out_PointerTo_tt__Behaviour_Removed(soap, "tt:Removed", -1, &(a->tt__Behaviour::Removed), ""))
		return soap->error;
	if (soap_out_PointerTo_tt__Behaviour_Idle(soap, "tt:Idle", -1, &(a->tt__Behaviour::Idle), ""))
		return soap->error;
	if (soap_out_PointerTott__BehaviourExtension(soap, "tt:Extension", -1, &(a->tt__Behaviour::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Behaviour::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Behaviour(soap, tag, this, type);
}

SOAP_FMAC3 tt__Behaviour * SOAP_FMAC4 soap_in_tt__Behaviour(struct soap *soap, const char *tag, tt__Behaviour *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Behaviour *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Behaviour, sizeof(tt__Behaviour), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Behaviour)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Behaviour *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Behaviour*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Removed1 = 1;
	size_t soap_flag_Idle1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Removed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tt__Behaviour_Removed(soap, "tt:Removed", &(a->tt__Behaviour::Removed), ""))
				{	soap_flag_Removed1--;
					continue;
				}
			if (soap_flag_Idle1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tt__Behaviour_Idle(soap, "tt:Idle", &(a->tt__Behaviour::Idle), ""))
				{	soap_flag_Idle1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BehaviourExtension(soap, "tt:Extension", &(a->tt__Behaviour::Extension), "tt:BehaviourExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Behaviour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Behaviour, 0, sizeof(tt__Behaviour), 0, soap_copy_tt__Behaviour);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__Behaviour::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Behaviour);
	if (this->soap_out(soap, tag?tag:"tt:Behaviour", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Behaviour::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Behaviour(soap, this, tag, type);
}

SOAP_FMAC3 tt__Behaviour * SOAP_FMAC4 soap_get_tt__Behaviour(struct soap *soap, tt__Behaviour *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Behaviour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Behaviour * SOAP_FMAC2 soap_instantiate_tt__Behaviour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Behaviour(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Behaviour, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Behaviour);
		if (size)
			*size = sizeof(tt__Behaviour);
		((tt__Behaviour*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Behaviour[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Behaviour);
		for (int i = 0; i < n; i++)
			((tt__Behaviour*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Behaviour*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Behaviour(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Behaviour %p -> %p\n", q, p));
	*(tt__Behaviour*)p = *(tt__Behaviour*)q;
}

void tt__ObjectId::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ObjectId::ObjectId = NULL;
	/* transient soap skipped */
}

void tt__ObjectId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tt__ObjectId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ObjectId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ObjectId(struct soap *soap, const char *tag, int id, const tt__ObjectId *a, const char *type)
{
	if (((tt__ObjectId*)a)->ObjectId)
		soap_set_attr(soap, "ObjectId", ((tt__ObjectId*)a)->ObjectId->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ObjectId), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ObjectId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ObjectId(soap, tag, this, type);
}

SOAP_FMAC3 tt__ObjectId * SOAP_FMAC4 soap_in_tt__ObjectId(struct soap *soap, const char *tag, tt__ObjectId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ObjectId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ObjectId, sizeof(tt__ObjectId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ObjectId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ObjectId *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ObjectId", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((tt__ObjectId*)a)->ObjectId = soap_new_std__string(soap, -1);
				((tt__ObjectId*)a)->ObjectId->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ObjectId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ObjectId, 0, sizeof(tt__ObjectId), 0, soap_copy_tt__ObjectId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ObjectId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ObjectId);
	if (this->soap_out(soap, tag?tag:"tt:ObjectId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ObjectId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ObjectId(soap, this, tag, type);
}

SOAP_FMAC3 tt__ObjectId * SOAP_FMAC4 soap_get_tt__ObjectId(struct soap *soap, tt__ObjectId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ObjectId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ObjectId * SOAP_FMAC2 soap_instantiate_tt__ObjectId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ObjectId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ObjectId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "tt:Object"))
	{	cp->type = SOAP_TYPE_tt__Object;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__Object);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(tt__Object);
			((tt__Object*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(tt__Object[n]);
			if (size)
				*size = n * sizeof(tt__Object);
			for (int i = 0; i < n; i++)
				((tt__Object*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (tt__Object*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ObjectId);
		if (size)
			*size = sizeof(tt__ObjectId);
		((tt__ObjectId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ObjectId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ObjectId);
		for (int i = 0; i < n; i++)
			((tt__ObjectId*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ObjectId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ObjectId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ObjectId %p -> %p\n", q, p));
	*(tt__ObjectId*)p = *(tt__ObjectId*)q;
}

void tt__Rename::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__Rename::from = NULL;
	this->tt__Rename::to = NULL;
	/* transient soap skipped */
}

void tt__Rename::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ObjectId(soap, &this->tt__Rename::from);
	soap_serialize_PointerTott__ObjectId(soap, &this->tt__Rename::to);
	/* transient soap skipped */
}

int tt__Rename::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Rename(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Rename(struct soap *soap, const char *tag, int id, const tt__Rename *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Rename), type))
		return soap->error;
	if (a->tt__Rename::from)
	{	if (soap_out_PointerTott__ObjectId(soap, "tt:from", -1, &a->tt__Rename::from, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:from"))
		return soap->error;
	if (a->tt__Rename::to)
	{	if (soap_out_PointerTott__ObjectId(soap, "tt:to", -1, &a->tt__Rename::to, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:to"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Rename::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Rename(soap, tag, this, type);
}

SOAP_FMAC3 tt__Rename * SOAP_FMAC4 soap_in_tt__Rename(struct soap *soap, const char *tag, tt__Rename *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Rename *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Rename, sizeof(tt__Rename), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Rename)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Rename *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_from1 = 1;
	size_t soap_flag_to1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_from1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ObjectId(soap, "tt:from", &(a->tt__Rename::from), "tt:ObjectId"))
				{	soap_flag_from1--;
					continue;
				}
			if (soap_flag_to1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ObjectId(soap, "tt:to", &(a->tt__Rename::to), "tt:ObjectId"))
				{	soap_flag_to1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Rename *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Rename, 0, sizeof(tt__Rename), 0, soap_copy_tt__Rename);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_from1 > 0 || soap_flag_to1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Rename::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Rename);
	if (this->soap_out(soap, tag?tag:"tt:Rename", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Rename::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Rename(soap, this, tag, type);
}

SOAP_FMAC3 tt__Rename * SOAP_FMAC4 soap_get_tt__Rename(struct soap *soap, tt__Rename *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Rename(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Rename * SOAP_FMAC2 soap_instantiate_tt__Rename(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Rename(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Rename, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Rename);
		if (size)
			*size = sizeof(tt__Rename);
		((tt__Rename*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Rename[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Rename);
		for (int i = 0; i < n; i++)
			((tt__Rename*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Rename*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Rename(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Rename %p -> %p\n", q, p));
	*(tt__Rename*)p = *(tt__Rename*)q;
}

void tt__Split::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__Split::from = NULL;
	soap_default_std__vectorTemplateOfPointerTott__ObjectId(soap, &this->tt__Split::to);
	/* transient soap skipped */
}

void tt__Split::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ObjectId(soap, &this->tt__Split::from);
	soap_serialize_std__vectorTemplateOfPointerTott__ObjectId(soap, &this->tt__Split::to);
	/* transient soap skipped */
}

int tt__Split::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Split(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Split(struct soap *soap, const char *tag, int id, const tt__Split *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Split), type))
		return soap->error;
	if (a->tt__Split::from)
	{	if (soap_out_PointerTott__ObjectId(soap, "tt:from", -1, &a->tt__Split::from, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:from"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__ObjectId(soap, "tt:to", -1, &(a->tt__Split::to), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Split::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Split(soap, tag, this, type);
}

SOAP_FMAC3 tt__Split * SOAP_FMAC4 soap_in_tt__Split(struct soap *soap, const char *tag, tt__Split *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Split *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Split, sizeof(tt__Split), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Split)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Split *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_from1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_from1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ObjectId(soap, "tt:from", &(a->tt__Split::from), "tt:ObjectId"))
				{	soap_flag_from1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__ObjectId(soap, "tt:to", &(a->tt__Split::to), "tt:ObjectId"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Split *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Split, 0, sizeof(tt__Split), 0, soap_copy_tt__Split);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_from1 > 0 || a->tt__Split::to.size() < 2))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Split::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Split);
	if (this->soap_out(soap, tag?tag:"tt:Split", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Split::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Split(soap, this, tag, type);
}

SOAP_FMAC3 tt__Split * SOAP_FMAC4 soap_get_tt__Split(struct soap *soap, tt__Split *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Split(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Split * SOAP_FMAC2 soap_instantiate_tt__Split(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Split(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Split, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Split);
		if (size)
			*size = sizeof(tt__Split);
		((tt__Split*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Split[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Split);
		for (int i = 0; i < n; i++)
			((tt__Split*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Split*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Split(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Split %p -> %p\n", q, p));
	*(tt__Split*)p = *(tt__Split*)q;
}

void tt__Merge::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__ObjectId(soap, &this->tt__Merge::from);
	this->tt__Merge::to = NULL;
	/* transient soap skipped */
}

void tt__Merge::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTott__ObjectId(soap, &this->tt__Merge::from);
	soap_serialize_PointerTott__ObjectId(soap, &this->tt__Merge::to);
	/* transient soap skipped */
}

int tt__Merge::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Merge(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Merge(struct soap *soap, const char *tag, int id, const tt__Merge *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Merge), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__ObjectId(soap, "tt:from", -1, &(a->tt__Merge::from), ""))
		return soap->error;
	if (a->tt__Merge::to)
	{	if (soap_out_PointerTott__ObjectId(soap, "tt:to", -1, &a->tt__Merge::to, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:to"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Merge::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Merge(soap, tag, this, type);
}

SOAP_FMAC3 tt__Merge * SOAP_FMAC4 soap_in_tt__Merge(struct soap *soap, const char *tag, tt__Merge *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Merge *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Merge, sizeof(tt__Merge), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Merge)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Merge *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_to1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__ObjectId(soap, "tt:from", &(a->tt__Merge::from), "tt:ObjectId"))
					continue;
			if (soap_flag_to1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ObjectId(soap, "tt:to", &(a->tt__Merge::to), "tt:ObjectId"))
				{	soap_flag_to1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Merge *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Merge, 0, sizeof(tt__Merge), 0, soap_copy_tt__Merge);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__Merge::from.size() < 2 || soap_flag_to1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Merge::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Merge);
	if (this->soap_out(soap, tag?tag:"tt:Merge", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Merge::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Merge(soap, this, tag, type);
}

SOAP_FMAC3 tt__Merge * SOAP_FMAC4 soap_get_tt__Merge(struct soap *soap, tt__Merge *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Merge(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Merge * SOAP_FMAC2 soap_instantiate_tt__Merge(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Merge(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Merge, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Merge);
		if (size)
			*size = sizeof(tt__Merge);
		((tt__Merge*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Merge[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Merge);
		for (int i = 0; i < n; i++)
			((tt__Merge*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Merge*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Merge(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Merge %p -> %p\n", q, p));
	*(tt__Merge*)p = *(tt__Merge*)q;
}

void tt__FrameExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FrameExtension::__any);
	/* transient soap skipped */
}

void tt__FrameExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FrameExtension::__any);
	/* transient soap skipped */
}

int tt__FrameExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FrameExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FrameExtension(struct soap *soap, const char *tag, int id, const tt__FrameExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FrameExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__FrameExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__FrameExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__FrameExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__FrameExtension * SOAP_FMAC4 soap_in_tt__FrameExtension(struct soap *soap, const char *tag, tt__FrameExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FrameExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FrameExtension, sizeof(tt__FrameExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__FrameExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__FrameExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__FrameExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FrameExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FrameExtension, 0, sizeof(tt__FrameExtension), 0, soap_copy_tt__FrameExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__FrameExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__FrameExtension);
	if (this->soap_out(soap, tag?tag:"tt:FrameExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FrameExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FrameExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__FrameExtension * SOAP_FMAC4 soap_get_tt__FrameExtension(struct soap *soap, tt__FrameExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FrameExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__FrameExtension * SOAP_FMAC2 soap_instantiate_tt__FrameExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FrameExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__FrameExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__FrameExtension);
		if (size)
			*size = sizeof(tt__FrameExtension);
		((tt__FrameExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__FrameExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__FrameExtension);
		for (int i = 0; i < n; i++)
			((tt__FrameExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__FrameExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__FrameExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__FrameExtension %p -> %p\n", q, p));
	*(tt__FrameExtension*)p = *(tt__FrameExtension*)q;
}

void tt__Frame::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__Frame::PTZStatus = NULL;
	this->tt__Frame::Transformation = NULL;
	soap_default_std__vectorTemplateOfPointerTott__Object(soap, &this->tt__Frame::Object);
	this->tt__Frame::ObjectTree = NULL;
	this->tt__Frame::Extension = NULL;
	soap_default_time(soap, &this->tt__Frame::UtcTime);
	soap_default_xsd__anyAttribute(soap, &this->tt__Frame::__anyAttribute);
	/* transient soap skipped */
}

void tt__Frame::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__PTZStatus(soap, &this->tt__Frame::PTZStatus);
	soap_serialize_PointerTott__Transformation(soap, &this->tt__Frame::Transformation);
	soap_serialize_std__vectorTemplateOfPointerTott__Object(soap, &this->tt__Frame::Object);
	soap_serialize_PointerTott__ObjectTree(soap, &this->tt__Frame::ObjectTree);
	soap_serialize_PointerTott__FrameExtension(soap, &this->tt__Frame::Extension);
	/* transient soap skipped */
}

int tt__Frame::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Frame(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Frame(struct soap *soap, const char *tag, int id, const tt__Frame *a, const char *type)
{
	soap_set_attr(soap, "UtcTime", soap_dateTime2s(soap, ((tt__Frame*)a)->UtcTime), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Frame*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Frame), type))
		return soap->error;
	if (soap_out_PointerTott__PTZStatus(soap, "tt:PTZStatus", -1, &(a->tt__Frame::PTZStatus), ""))
		return soap->error;
	if (soap_out_PointerTott__Transformation(soap, "tt:Transformation", -1, &(a->tt__Frame::Transformation), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Object(soap, "tt:Object", -1, &(a->tt__Frame::Object), ""))
		return soap->error;
	if (soap_out_PointerTott__ObjectTree(soap, "tt:ObjectTree", -1, &(a->tt__Frame::ObjectTree), ""))
		return soap->error;
	if (soap_out_PointerTott__FrameExtension(soap, "tt:Extension", -1, &(a->tt__Frame::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Frame::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Frame(soap, tag, this, type);
}

SOAP_FMAC3 tt__Frame * SOAP_FMAC4 soap_in_tt__Frame(struct soap *soap, const char *tag, tt__Frame *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Frame *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Frame, sizeof(tt__Frame), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Frame)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Frame *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "UtcTime", 1), &((tt__Frame*)a)->UtcTime))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Frame*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_PTZStatus1 = 1;
	size_t soap_flag_Transformation1 = 1;
	size_t soap_flag_ObjectTree1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZStatus(soap, "tt:PTZStatus", &(a->tt__Frame::PTZStatus), "tt:PTZStatus"))
				{	soap_flag_PTZStatus1--;
					continue;
				}
			if (soap_flag_Transformation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Transformation(soap, "tt:Transformation", &(a->tt__Frame::Transformation), "tt:Transformation"))
				{	soap_flag_Transformation1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Object(soap, "tt:Object", &(a->tt__Frame::Object), "tt:Object"))
					continue;
			if (soap_flag_ObjectTree1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ObjectTree(soap, "tt:ObjectTree", &(a->tt__Frame::ObjectTree), "tt:ObjectTree"))
				{	soap_flag_ObjectTree1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FrameExtension(soap, "tt:Extension", &(a->tt__Frame::Extension), "tt:FrameExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Frame *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Frame, 0, sizeof(tt__Frame), 0, soap_copy_tt__Frame);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__Frame::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Frame);
	if (this->soap_out(soap, tag?tag:"tt:Frame", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Frame::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Frame(soap, this, tag, type);
}

SOAP_FMAC3 tt__Frame * SOAP_FMAC4 soap_get_tt__Frame(struct soap *soap, tt__Frame *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Frame(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Frame * SOAP_FMAC2 soap_instantiate_tt__Frame(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Frame(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Frame, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Frame);
		if (size)
			*size = sizeof(tt__Frame);
		((tt__Frame*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Frame[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Frame);
		for (int i = 0; i < n; i++)
			((tt__Frame*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Frame*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Frame(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Frame %p -> %p\n", q, p));
	*(tt__Frame*)p = *(tt__Frame*)q;
}

void tt__TransformationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__TransformationExtension::__any);
	/* transient soap skipped */
}

void tt__TransformationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__TransformationExtension::__any);
	/* transient soap skipped */
}

int tt__TransformationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__TransformationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TransformationExtension(struct soap *soap, const char *tag, int id, const tt__TransformationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TransformationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__TransformationExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__TransformationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__TransformationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__TransformationExtension * SOAP_FMAC4 soap_in_tt__TransformationExtension(struct soap *soap, const char *tag, tt__TransformationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__TransformationExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TransformationExtension, sizeof(tt__TransformationExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__TransformationExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__TransformationExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__TransformationExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__TransformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TransformationExtension, 0, sizeof(tt__TransformationExtension), 0, soap_copy_tt__TransformationExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__TransformationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__TransformationExtension);
	if (this->soap_out(soap, tag?tag:"tt:TransformationExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__TransformationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__TransformationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__TransformationExtension * SOAP_FMAC4 soap_get_tt__TransformationExtension(struct soap *soap, tt__TransformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TransformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__TransformationExtension * SOAP_FMAC2 soap_instantiate_tt__TransformationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__TransformationExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__TransformationExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__TransformationExtension);
		if (size)
			*size = sizeof(tt__TransformationExtension);
		((tt__TransformationExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__TransformationExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__TransformationExtension);
		for (int i = 0; i < n; i++)
			((tt__TransformationExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__TransformationExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__TransformationExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__TransformationExtension %p -> %p\n", q, p));
	*(tt__TransformationExtension*)p = *(tt__TransformationExtension*)q;
}

void tt__Transformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__Transformation::Translate = NULL;
	this->tt__Transformation::Scale = NULL;
	this->tt__Transformation::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__Transformation::__anyAttribute);
	/* transient soap skipped */
}

void tt__Transformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Vector(soap, &this->tt__Transformation::Translate);
	soap_serialize_PointerTott__Vector(soap, &this->tt__Transformation::Scale);
	soap_serialize_PointerTott__TransformationExtension(soap, &this->tt__Transformation::Extension);
	/* transient soap skipped */
}

int tt__Transformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Transformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Transformation(struct soap *soap, const char *tag, int id, const tt__Transformation *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Transformation*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Transformation), type))
		return soap->error;
	if (soap_out_PointerTott__Vector(soap, "tt:Translate", -1, &(a->tt__Transformation::Translate), ""))
		return soap->error;
	if (soap_out_PointerTott__Vector(soap, "tt:Scale", -1, &(a->tt__Transformation::Scale), ""))
		return soap->error;
	if (soap_out_PointerTott__TransformationExtension(soap, "tt:Extension", -1, &(a->tt__Transformation::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Transformation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Transformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__Transformation * SOAP_FMAC4 soap_in_tt__Transformation(struct soap *soap, const char *tag, tt__Transformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Transformation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Transformation, sizeof(tt__Transformation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Transformation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Transformation *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Transformation*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Translate1 = 1;
	size_t soap_flag_Scale1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Translate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector(soap, "tt:Translate", &(a->tt__Transformation::Translate), "tt:Vector"))
				{	soap_flag_Translate1--;
					continue;
				}
			if (soap_flag_Scale1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector(soap, "tt:Scale", &(a->tt__Transformation::Scale), "tt:Vector"))
				{	soap_flag_Scale1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__TransformationExtension(soap, "tt:Extension", &(a->tt__Transformation::Extension), "tt:TransformationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Transformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Transformation, 0, sizeof(tt__Transformation), 0, soap_copy_tt__Transformation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__Transformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Transformation);
	if (this->soap_out(soap, tag?tag:"tt:Transformation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Transformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Transformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__Transformation * SOAP_FMAC4 soap_get_tt__Transformation(struct soap *soap, tt__Transformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Transformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Transformation * SOAP_FMAC2 soap_instantiate_tt__Transformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Transformation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Transformation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Transformation);
		if (size)
			*size = sizeof(tt__Transformation);
		((tt__Transformation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Transformation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Transformation);
		for (int i = 0; i < n; i++)
			((tt__Transformation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Transformation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Transformation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Transformation %p -> %p\n", q, p));
	*(tt__Transformation*)p = *(tt__Transformation*)q;
}

void tt__ObjectExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ObjectExtension::__any);
	/* transient soap skipped */
}

void tt__ObjectExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ObjectExtension::__any);
	/* transient soap skipped */
}

int tt__ObjectExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ObjectExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ObjectExtension(struct soap *soap, const char *tag, int id, const tt__ObjectExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ObjectExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__ObjectExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ObjectExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ObjectExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ObjectExtension * SOAP_FMAC4 soap_in_tt__ObjectExtension(struct soap *soap, const char *tag, tt__ObjectExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ObjectExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ObjectExtension, sizeof(tt__ObjectExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ObjectExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ObjectExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__ObjectExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ObjectExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ObjectExtension, 0, sizeof(tt__ObjectExtension), 0, soap_copy_tt__ObjectExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ObjectExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ObjectExtension);
	if (this->soap_out(soap, tag?tag:"tt:ObjectExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ObjectExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ObjectExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ObjectExtension * SOAP_FMAC4 soap_get_tt__ObjectExtension(struct soap *soap, tt__ObjectExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ObjectExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ObjectExtension * SOAP_FMAC2 soap_instantiate_tt__ObjectExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ObjectExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ObjectExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ObjectExtension);
		if (size)
			*size = sizeof(tt__ObjectExtension);
		((tt__ObjectExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ObjectExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ObjectExtension);
		for (int i = 0; i < n; i++)
			((tt__ObjectExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ObjectExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ObjectExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ObjectExtension %p -> %p\n", q, p));
	*(tt__ObjectExtension*)p = *(tt__ObjectExtension*)q;
}

void tt__Object::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__Object::Appearance = NULL;
	this->tt__Object::Behaviour = NULL;
	this->tt__Object::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__Object::__anyAttribute);
	this->tt__ObjectId::ObjectId = NULL;
	/* transient soap skipped */
}

void tt__Object::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Appearance(soap, &this->tt__Object::Appearance);
	soap_serialize_PointerTott__Behaviour(soap, &this->tt__Object::Behaviour);
	soap_serialize_PointerTott__ObjectExtension(soap, &this->tt__Object::Extension);
	/* transient soap skipped */
}

int tt__Object::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Object(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Object(struct soap *soap, const char *tag, int id, const tt__Object *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Object*)a)->__anyAttribute, ""))
		return soap->error;
	if (((tt__ObjectId*)a)->ObjectId)
		soap_set_attr(soap, "ObjectId", ((tt__ObjectId*)a)->ObjectId->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Object), "tt:Object"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTott__Appearance(soap, "tt:Appearance", -1, &(a->tt__Object::Appearance), ""))
		return soap->error;
	if (soap_out_PointerTott__Behaviour(soap, "tt:Behaviour", -1, &(a->tt__Object::Behaviour), ""))
		return soap->error;
	if (soap_out_PointerTott__ObjectExtension(soap, "tt:Extension", -1, &(a->tt__Object::Extension), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Object::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Object(soap, tag, this, type);
}

SOAP_FMAC3 tt__Object * SOAP_FMAC4 soap_in_tt__Object(struct soap *soap, const char *tag, tt__Object *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Object *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Object, sizeof(tt__Object), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Object)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Object *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Object*)a)->__anyAttribute, "xsd:anyAttribute");
	{	const char *t = soap_attr_value(soap, "ObjectId", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((tt__ObjectId*)a)->ObjectId = soap_new_std__string(soap, -1);
				((tt__ObjectId*)a)->ObjectId->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Appearance1 = 1;
	size_t soap_flag_Behaviour1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Appearance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Appearance(soap, "tt:Appearance", &(a->tt__Object::Appearance), "tt:Appearance"))
				{	soap_flag_Appearance1--;
					continue;
				}
			if (soap_flag_Behaviour1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Behaviour(soap, "tt:Behaviour", &(a->tt__Object::Behaviour), "tt:Behaviour"))
				{	soap_flag_Behaviour1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ObjectExtension(soap, "tt:Extension", &(a->tt__Object::Extension), "tt:ObjectExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Object *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Object, 0, sizeof(tt__Object), 0, soap_copy_tt__Object);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__Object::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Object);
	if (this->soap_out(soap, tag?tag:"tt:Object", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Object::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Object(soap, this, tag, type);
}

SOAP_FMAC3 tt__Object * SOAP_FMAC4 soap_get_tt__Object(struct soap *soap, tt__Object *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Object(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Object * SOAP_FMAC2 soap_instantiate_tt__Object(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Object(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Object, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Object);
		if (size)
			*size = sizeof(tt__Object);
		((tt__Object*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Object[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Object);
		for (int i = 0; i < n; i++)
			((tt__Object*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Object*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Object(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Object %p -> %p\n", q, p));
	*(tt__Object*)p = *(tt__Object*)q;
}

void tt__ClassDescriptorExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ClassDescriptorExtension::__any);
	/* transient soap skipped */
}

void tt__ClassDescriptorExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ClassDescriptorExtension::__any);
	/* transient soap skipped */
}

int tt__ClassDescriptorExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ClassDescriptorExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ClassDescriptorExtension(struct soap *soap, const char *tag, int id, const tt__ClassDescriptorExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ClassDescriptorExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__ClassDescriptorExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ClassDescriptorExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ClassDescriptorExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ClassDescriptorExtension * SOAP_FMAC4 soap_in_tt__ClassDescriptorExtension(struct soap *soap, const char *tag, tt__ClassDescriptorExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ClassDescriptorExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ClassDescriptorExtension, sizeof(tt__ClassDescriptorExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ClassDescriptorExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ClassDescriptorExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__ClassDescriptorExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ClassDescriptorExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ClassDescriptorExtension, 0, sizeof(tt__ClassDescriptorExtension), 0, soap_copy_tt__ClassDescriptorExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ClassDescriptorExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ClassDescriptorExtension);
	if (this->soap_out(soap, tag?tag:"tt:ClassDescriptorExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ClassDescriptorExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ClassDescriptorExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ClassDescriptorExtension * SOAP_FMAC4 soap_get_tt__ClassDescriptorExtension(struct soap *soap, tt__ClassDescriptorExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ClassDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ClassDescriptorExtension * SOAP_FMAC2 soap_instantiate_tt__ClassDescriptorExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ClassDescriptorExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ClassDescriptorExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ClassDescriptorExtension);
		if (size)
			*size = sizeof(tt__ClassDescriptorExtension);
		((tt__ClassDescriptorExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ClassDescriptorExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ClassDescriptorExtension);
		for (int i = 0; i < n; i++)
			((tt__ClassDescriptorExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ClassDescriptorExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ClassDescriptorExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ClassDescriptorExtension %p -> %p\n", q, p));
	*(tt__ClassDescriptorExtension*)p = *(tt__ClassDescriptorExtension*)q;
}

void tt__ClassDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ClassDescriptor::__sizeClassCandidate = 0;
	this->tt__ClassDescriptor::ClassCandidate = NULL;
	this->tt__ClassDescriptor::Extension = NULL;
	/* transient soap skipped */
}

void tt__ClassDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->tt__ClassDescriptor::ClassCandidate)
	{	int i;
		for (i = 0; i < this->tt__ClassDescriptor::__sizeClassCandidate; i++)
		{
			soap_embedded(soap, this->tt__ClassDescriptor::ClassCandidate + i, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate);
			this->tt__ClassDescriptor::ClassCandidate[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTott__ClassDescriptorExtension(soap, &this->tt__ClassDescriptor::Extension);
	/* transient soap skipped */
}

int tt__ClassDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ClassDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ClassDescriptor(struct soap *soap, const char *tag, int id, const tt__ClassDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ClassDescriptor), type))
		return soap->error;
	if (a->tt__ClassDescriptor::ClassCandidate)
	{	int i;
		for (i = 0; i < a->tt__ClassDescriptor::__sizeClassCandidate; i++)
			if (a->tt__ClassDescriptor::ClassCandidate[i].soap_out(soap, "tt:ClassCandidate", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ClassDescriptorExtension(soap, "tt:Extension", -1, &(a->tt__ClassDescriptor::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ClassDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ClassDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 tt__ClassDescriptor * SOAP_FMAC4 soap_in_tt__ClassDescriptor(struct soap *soap, const char *tag, tt__ClassDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ClassDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ClassDescriptor, sizeof(tt__ClassDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ClassDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ClassDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_ClassCandidate1 = NULL;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ClassCandidate", 1, NULL))
			{	if (a->tt__ClassDescriptor::ClassCandidate == NULL)
				{	if (soap_blist_ClassCandidate1 == NULL)
						soap_blist_ClassCandidate1 = soap_new_block(soap);
					a->tt__ClassDescriptor::ClassCandidate = (_tt__ClassDescriptor_ClassCandidate *)soap_push_block(soap, soap_blist_ClassCandidate1, sizeof(_tt__ClassDescriptor_ClassCandidate));
					if (a->tt__ClassDescriptor::ClassCandidate == NULL)
						return NULL;
					_tt__ClassDescriptor_ClassCandidate p;
					memcpy(a->tt__ClassDescriptor::ClassCandidate, &p, sizeof(_tt__ClassDescriptor_ClassCandidate)); // a bit rough but portable
					a->tt__ClassDescriptor::ClassCandidate->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__tt__ClassDescriptor_ClassCandidate(soap, "tt:ClassCandidate", a->tt__ClassDescriptor::ClassCandidate, ""))
				{	a->tt__ClassDescriptor::__sizeClassCandidate++;
					a->tt__ClassDescriptor::ClassCandidate = NULL;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ClassDescriptorExtension(soap, "tt:Extension", &(a->tt__ClassDescriptor::Extension), "tt:ClassDescriptorExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__ClassDescriptor::ClassCandidate)
			soap_pop_block(soap, soap_blist_ClassCandidate1);
		if (a->tt__ClassDescriptor::__sizeClassCandidate)
			a->tt__ClassDescriptor::ClassCandidate = (_tt__ClassDescriptor_ClassCandidate *)soap_save_block(soap, soap_blist_ClassCandidate1, NULL, 1);
		else
		{	a->tt__ClassDescriptor::ClassCandidate = NULL;
			if (soap_blist_ClassCandidate1)
				soap_end_block(soap, soap_blist_ClassCandidate1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ClassDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ClassDescriptor, 0, sizeof(tt__ClassDescriptor), 0, soap_copy_tt__ClassDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ClassDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ClassDescriptor);
	if (this->soap_out(soap, tag?tag:"tt:ClassDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ClassDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ClassDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 tt__ClassDescriptor * SOAP_FMAC4 soap_get_tt__ClassDescriptor(struct soap *soap, tt__ClassDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ClassDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ClassDescriptor * SOAP_FMAC2 soap_instantiate_tt__ClassDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ClassDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ClassDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ClassDescriptor);
		if (size)
			*size = sizeof(tt__ClassDescriptor);
		((tt__ClassDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ClassDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ClassDescriptor);
		for (int i = 0; i < n; i++)
			((tt__ClassDescriptor*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ClassDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ClassDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ClassDescriptor %p -> %p\n", q, p));
	*(tt__ClassDescriptor*)p = *(tt__ClassDescriptor*)q;
}

void tt__ColorDescriptorExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ColorDescriptorExtension::__any);
	/* transient soap skipped */
}

void tt__ColorDescriptorExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ColorDescriptorExtension::__any);
	/* transient soap skipped */
}

int tt__ColorDescriptorExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ColorDescriptorExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ColorDescriptorExtension(struct soap *soap, const char *tag, int id, const tt__ColorDescriptorExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ColorDescriptorExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__ColorDescriptorExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ColorDescriptorExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ColorDescriptorExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ColorDescriptorExtension * SOAP_FMAC4 soap_in_tt__ColorDescriptorExtension(struct soap *soap, const char *tag, tt__ColorDescriptorExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ColorDescriptorExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorDescriptorExtension, sizeof(tt__ColorDescriptorExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ColorDescriptorExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ColorDescriptorExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__ColorDescriptorExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ColorDescriptorExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorDescriptorExtension, 0, sizeof(tt__ColorDescriptorExtension), 0, soap_copy_tt__ColorDescriptorExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ColorDescriptorExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ColorDescriptorExtension);
	if (this->soap_out(soap, tag?tag:"tt:ColorDescriptorExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ColorDescriptorExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ColorDescriptorExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ColorDescriptorExtension * SOAP_FMAC4 soap_get_tt__ColorDescriptorExtension(struct soap *soap, tt__ColorDescriptorExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ColorDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ColorDescriptorExtension * SOAP_FMAC2 soap_instantiate_tt__ColorDescriptorExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ColorDescriptorExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ColorDescriptorExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ColorDescriptorExtension);
		if (size)
			*size = sizeof(tt__ColorDescriptorExtension);
		((tt__ColorDescriptorExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ColorDescriptorExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ColorDescriptorExtension);
		for (int i = 0; i < n; i++)
			((tt__ColorDescriptorExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ColorDescriptorExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ColorDescriptorExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ColorDescriptorExtension %p -> %p\n", q, p));
	*(tt__ColorDescriptorExtension*)p = *(tt__ColorDescriptorExtension*)q;
}

void tt__ColorDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ColorDescriptor::__sizeColorCluster = 0;
	this->tt__ColorDescriptor::ColorCluster = NULL;
	this->tt__ColorDescriptor::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ColorDescriptor::__anyAttribute);
	/* transient soap skipped */
}

void tt__ColorDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->tt__ColorDescriptor::ColorCluster)
	{	int i;
		for (i = 0; i < this->tt__ColorDescriptor::__sizeColorCluster; i++)
		{
			soap_embedded(soap, this->tt__ColorDescriptor::ColorCluster + i, SOAP_TYPE__tt__ColorDescriptor_ColorCluster);
			this->tt__ColorDescriptor::ColorCluster[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTott__ColorDescriptorExtension(soap, &this->tt__ColorDescriptor::Extension);
	/* transient soap skipped */
}

int tt__ColorDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ColorDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ColorDescriptor(struct soap *soap, const char *tag, int id, const tt__ColorDescriptor *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ColorDescriptor*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ColorDescriptor), type))
		return soap->error;
	if (a->tt__ColorDescriptor::ColorCluster)
	{	int i;
		for (i = 0; i < a->tt__ColorDescriptor::__sizeColorCluster; i++)
			if (a->tt__ColorDescriptor::ColorCluster[i].soap_out(soap, "tt:ColorCluster", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ColorDescriptorExtension(soap, "tt:Extension", -1, &(a->tt__ColorDescriptor::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ColorDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ColorDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 tt__ColorDescriptor * SOAP_FMAC4 soap_in_tt__ColorDescriptor(struct soap *soap, const char *tag, tt__ColorDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ColorDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorDescriptor, sizeof(tt__ColorDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ColorDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ColorDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ColorDescriptor*)a)->__anyAttribute, "xsd:anyAttribute");
	struct soap_blist *soap_blist_ColorCluster1 = NULL;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ColorCluster", 1, NULL))
			{	if (a->tt__ColorDescriptor::ColorCluster == NULL)
				{	if (soap_blist_ColorCluster1 == NULL)
						soap_blist_ColorCluster1 = soap_new_block(soap);
					a->tt__ColorDescriptor::ColorCluster = (_tt__ColorDescriptor_ColorCluster *)soap_push_block(soap, soap_blist_ColorCluster1, sizeof(_tt__ColorDescriptor_ColorCluster));
					if (a->tt__ColorDescriptor::ColorCluster == NULL)
						return NULL;
					_tt__ColorDescriptor_ColorCluster p;
					memcpy(a->tt__ColorDescriptor::ColorCluster, &p, sizeof(_tt__ColorDescriptor_ColorCluster)); // a bit rough but portable
					a->tt__ColorDescriptor::ColorCluster->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__tt__ColorDescriptor_ColorCluster(soap, "tt:ColorCluster", a->tt__ColorDescriptor::ColorCluster, ""))
				{	a->tt__ColorDescriptor::__sizeColorCluster++;
					a->tt__ColorDescriptor::ColorCluster = NULL;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ColorDescriptorExtension(soap, "tt:Extension", &(a->tt__ColorDescriptor::Extension), "tt:ColorDescriptorExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__ColorDescriptor::ColorCluster)
			soap_pop_block(soap, soap_blist_ColorCluster1);
		if (a->tt__ColorDescriptor::__sizeColorCluster)
			a->tt__ColorDescriptor::ColorCluster = (_tt__ColorDescriptor_ColorCluster *)soap_save_block(soap, soap_blist_ColorCluster1, NULL, 1);
		else
		{	a->tt__ColorDescriptor::ColorCluster = NULL;
			if (soap_blist_ColorCluster1)
				soap_end_block(soap, soap_blist_ColorCluster1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ColorDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorDescriptor, 0, sizeof(tt__ColorDescriptor), 0, soap_copy_tt__ColorDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ColorDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ColorDescriptor);
	if (this->soap_out(soap, tag?tag:"tt:ColorDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ColorDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ColorDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 tt__ColorDescriptor * SOAP_FMAC4 soap_get_tt__ColorDescriptor(struct soap *soap, tt__ColorDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ColorDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ColorDescriptor * SOAP_FMAC2 soap_instantiate_tt__ColorDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ColorDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ColorDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ColorDescriptor);
		if (size)
			*size = sizeof(tt__ColorDescriptor);
		((tt__ColorDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ColorDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ColorDescriptor);
		for (int i = 0; i < n; i++)
			((tt__ColorDescriptor*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ColorDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ColorDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ColorDescriptor %p -> %p\n", q, p));
	*(tt__ColorDescriptor*)p = *(tt__ColorDescriptor*)q;
}

void tt__ShapeDescriptorExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ShapeDescriptorExtension::__any);
	/* transient soap skipped */
}

void tt__ShapeDescriptorExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ShapeDescriptorExtension::__any);
	/* transient soap skipped */
}

int tt__ShapeDescriptorExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ShapeDescriptorExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ShapeDescriptorExtension(struct soap *soap, const char *tag, int id, const tt__ShapeDescriptorExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ShapeDescriptorExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__ShapeDescriptorExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ShapeDescriptorExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ShapeDescriptorExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ShapeDescriptorExtension * SOAP_FMAC4 soap_in_tt__ShapeDescriptorExtension(struct soap *soap, const char *tag, tt__ShapeDescriptorExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ShapeDescriptorExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ShapeDescriptorExtension, sizeof(tt__ShapeDescriptorExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ShapeDescriptorExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ShapeDescriptorExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__ShapeDescriptorExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ShapeDescriptorExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ShapeDescriptorExtension, 0, sizeof(tt__ShapeDescriptorExtension), 0, soap_copy_tt__ShapeDescriptorExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ShapeDescriptorExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ShapeDescriptorExtension);
	if (this->soap_out(soap, tag?tag:"tt:ShapeDescriptorExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ShapeDescriptorExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ShapeDescriptorExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ShapeDescriptorExtension * SOAP_FMAC4 soap_get_tt__ShapeDescriptorExtension(struct soap *soap, tt__ShapeDescriptorExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ShapeDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ShapeDescriptorExtension * SOAP_FMAC2 soap_instantiate_tt__ShapeDescriptorExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ShapeDescriptorExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ShapeDescriptorExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ShapeDescriptorExtension);
		if (size)
			*size = sizeof(tt__ShapeDescriptorExtension);
		((tt__ShapeDescriptorExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ShapeDescriptorExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ShapeDescriptorExtension);
		for (int i = 0; i < n; i++)
			((tt__ShapeDescriptorExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ShapeDescriptorExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ShapeDescriptorExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ShapeDescriptorExtension %p -> %p\n", q, p));
	*(tt__ShapeDescriptorExtension*)p = *(tt__ShapeDescriptorExtension*)q;
}

void tt__ShapeDescriptor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ShapeDescriptor::BoundingBox = NULL;
	this->tt__ShapeDescriptor::CenterOfGravity = NULL;
	soap_default_std__vectorTemplateOfPointerTott__Polygon(soap, &this->tt__ShapeDescriptor::Polygon);
	this->tt__ShapeDescriptor::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ShapeDescriptor::__anyAttribute);
	/* transient soap skipped */
}

void tt__ShapeDescriptor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Rectangle(soap, &this->tt__ShapeDescriptor::BoundingBox);
	soap_serialize_PointerTott__Vector(soap, &this->tt__ShapeDescriptor::CenterOfGravity);
	soap_serialize_std__vectorTemplateOfPointerTott__Polygon(soap, &this->tt__ShapeDescriptor::Polygon);
	soap_serialize_PointerTott__ShapeDescriptorExtension(soap, &this->tt__ShapeDescriptor::Extension);
	/* transient soap skipped */
}

int tt__ShapeDescriptor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ShapeDescriptor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ShapeDescriptor(struct soap *soap, const char *tag, int id, const tt__ShapeDescriptor *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ShapeDescriptor*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ShapeDescriptor), type))
		return soap->error;
	if (a->tt__ShapeDescriptor::BoundingBox)
	{	if (soap_out_PointerTott__Rectangle(soap, "tt:BoundingBox", -1, &a->tt__ShapeDescriptor::BoundingBox, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:BoundingBox"))
		return soap->error;
	if (a->tt__ShapeDescriptor::CenterOfGravity)
	{	if (soap_out_PointerTott__Vector(soap, "tt:CenterOfGravity", -1, &a->tt__ShapeDescriptor::CenterOfGravity, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:CenterOfGravity"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Polygon(soap, "tt:Polygon", -1, &(a->tt__ShapeDescriptor::Polygon), ""))
		return soap->error;
	if (soap_out_PointerTott__ShapeDescriptorExtension(soap, "tt:Extension", -1, &(a->tt__ShapeDescriptor::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ShapeDescriptor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ShapeDescriptor(soap, tag, this, type);
}

SOAP_FMAC3 tt__ShapeDescriptor * SOAP_FMAC4 soap_in_tt__ShapeDescriptor(struct soap *soap, const char *tag, tt__ShapeDescriptor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ShapeDescriptor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ShapeDescriptor, sizeof(tt__ShapeDescriptor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ShapeDescriptor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ShapeDescriptor *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ShapeDescriptor*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_BoundingBox1 = 1;
	size_t soap_flag_CenterOfGravity1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BoundingBox1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Rectangle(soap, "tt:BoundingBox", &(a->tt__ShapeDescriptor::BoundingBox), "tt:Rectangle"))
				{	soap_flag_BoundingBox1--;
					continue;
				}
			if (soap_flag_CenterOfGravity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector(soap, "tt:CenterOfGravity", &(a->tt__ShapeDescriptor::CenterOfGravity), "tt:Vector"))
				{	soap_flag_CenterOfGravity1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Polygon(soap, "tt:Polygon", &(a->tt__ShapeDescriptor::Polygon), "tt:Polygon"))
					continue;
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ShapeDescriptorExtension(soap, "tt:Extension", &(a->tt__ShapeDescriptor::Extension), "tt:ShapeDescriptorExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ShapeDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ShapeDescriptor, 0, sizeof(tt__ShapeDescriptor), 0, soap_copy_tt__ShapeDescriptor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_BoundingBox1 > 0 || soap_flag_CenterOfGravity1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__ShapeDescriptor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ShapeDescriptor);
	if (this->soap_out(soap, tag?tag:"tt:ShapeDescriptor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ShapeDescriptor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ShapeDescriptor(soap, this, tag, type);
}

SOAP_FMAC3 tt__ShapeDescriptor * SOAP_FMAC4 soap_get_tt__ShapeDescriptor(struct soap *soap, tt__ShapeDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ShapeDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ShapeDescriptor * SOAP_FMAC2 soap_instantiate_tt__ShapeDescriptor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ShapeDescriptor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ShapeDescriptor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ShapeDescriptor);
		if (size)
			*size = sizeof(tt__ShapeDescriptor);
		((tt__ShapeDescriptor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ShapeDescriptor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ShapeDescriptor);
		for (int i = 0; i < n; i++)
			((tt__ShapeDescriptor*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ShapeDescriptor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ShapeDescriptor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ShapeDescriptor %p -> %p\n", q, p));
	*(tt__ShapeDescriptor*)p = *(tt__ShapeDescriptor*)q;
}

void tt__AppearanceExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AppearanceExtension::__any);
	/* transient soap skipped */
}

void tt__AppearanceExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AppearanceExtension::__any);
	/* transient soap skipped */
}

int tt__AppearanceExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AppearanceExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AppearanceExtension(struct soap *soap, const char *tag, int id, const tt__AppearanceExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AppearanceExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__AppearanceExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__AppearanceExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__AppearanceExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__AppearanceExtension * SOAP_FMAC4 soap_in_tt__AppearanceExtension(struct soap *soap, const char *tag, tt__AppearanceExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AppearanceExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AppearanceExtension, sizeof(tt__AppearanceExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__AppearanceExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__AppearanceExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__AppearanceExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AppearanceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AppearanceExtension, 0, sizeof(tt__AppearanceExtension), 0, soap_copy_tt__AppearanceExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__AppearanceExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__AppearanceExtension);
	if (this->soap_out(soap, tag?tag:"tt:AppearanceExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AppearanceExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AppearanceExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__AppearanceExtension * SOAP_FMAC4 soap_get_tt__AppearanceExtension(struct soap *soap, tt__AppearanceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AppearanceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__AppearanceExtension * SOAP_FMAC2 soap_instantiate_tt__AppearanceExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AppearanceExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__AppearanceExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__AppearanceExtension);
		if (size)
			*size = sizeof(tt__AppearanceExtension);
		((tt__AppearanceExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__AppearanceExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__AppearanceExtension);
		for (int i = 0; i < n; i++)
			((tt__AppearanceExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__AppearanceExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__AppearanceExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__AppearanceExtension %p -> %p\n", q, p));
	*(tt__AppearanceExtension*)p = *(tt__AppearanceExtension*)q;
}

void tt__Appearance::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__Appearance::Transformation = NULL;
	this->tt__Appearance::Shape = NULL;
	this->tt__Appearance::Color = NULL;
	this->tt__Appearance::Class = NULL;
	this->tt__Appearance::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__Appearance::__anyAttribute);
	/* transient soap skipped */
}

void tt__Appearance::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Transformation(soap, &this->tt__Appearance::Transformation);
	soap_serialize_PointerTott__ShapeDescriptor(soap, &this->tt__Appearance::Shape);
	soap_serialize_PointerTott__ColorDescriptor(soap, &this->tt__Appearance::Color);
	soap_serialize_PointerTott__ClassDescriptor(soap, &this->tt__Appearance::Class);
	soap_serialize_PointerTott__AppearanceExtension(soap, &this->tt__Appearance::Extension);
	/* transient soap skipped */
}

int tt__Appearance::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Appearance(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Appearance(struct soap *soap, const char *tag, int id, const tt__Appearance *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Appearance*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Appearance), type))
		return soap->error;
	if (soap_out_PointerTott__Transformation(soap, "tt:Transformation", -1, &(a->tt__Appearance::Transformation), ""))
		return soap->error;
	if (soap_out_PointerTott__ShapeDescriptor(soap, "tt:Shape", -1, &(a->tt__Appearance::Shape), ""))
		return soap->error;
	if (soap_out_PointerTott__ColorDescriptor(soap, "tt:Color", -1, &(a->tt__Appearance::Color), ""))
		return soap->error;
	if (soap_out_PointerTott__ClassDescriptor(soap, "tt:Class", -1, &(a->tt__Appearance::Class), ""))
		return soap->error;
	if (soap_out_PointerTott__AppearanceExtension(soap, "tt:Extension", -1, &(a->tt__Appearance::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Appearance::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Appearance(soap, tag, this, type);
}

SOAP_FMAC3 tt__Appearance * SOAP_FMAC4 soap_in_tt__Appearance(struct soap *soap, const char *tag, tt__Appearance *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Appearance *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Appearance, sizeof(tt__Appearance), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Appearance)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Appearance *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Appearance*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Transformation1 = 1;
	size_t soap_flag_Shape1 = 1;
	size_t soap_flag_Color1 = 1;
	size_t soap_flag_Class1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transformation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Transformation(soap, "tt:Transformation", &(a->tt__Appearance::Transformation), "tt:Transformation"))
				{	soap_flag_Transformation1--;
					continue;
				}
			if (soap_flag_Shape1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ShapeDescriptor(soap, "tt:Shape", &(a->tt__Appearance::Shape), "tt:ShapeDescriptor"))
				{	soap_flag_Shape1--;
					continue;
				}
			if (soap_flag_Color1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ColorDescriptor(soap, "tt:Color", &(a->tt__Appearance::Color), "tt:ColorDescriptor"))
				{	soap_flag_Color1--;
					continue;
				}
			if (soap_flag_Class1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ClassDescriptor(soap, "tt:Class", &(a->tt__Appearance::Class), "tt:ClassDescriptor"))
				{	soap_flag_Class1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AppearanceExtension(soap, "tt:Extension", &(a->tt__Appearance::Extension), "tt:AppearanceExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Appearance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Appearance, 0, sizeof(tt__Appearance), 0, soap_copy_tt__Appearance);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__Appearance::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Appearance);
	if (this->soap_out(soap, tag?tag:"tt:Appearance", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Appearance::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Appearance(soap, this, tag, type);
}

SOAP_FMAC3 tt__Appearance * SOAP_FMAC4 soap_get_tt__Appearance(struct soap *soap, tt__Appearance *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Appearance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Appearance * SOAP_FMAC2 soap_instantiate_tt__Appearance(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Appearance(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Appearance, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Appearance);
		if (size)
			*size = sizeof(tt__Appearance);
		((tt__Appearance*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Appearance[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Appearance);
		for (int i = 0; i < n; i++)
			((tt__Appearance*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Appearance*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Appearance(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Appearance %p -> %p\n", q, p));
	*(tt__Appearance*)p = *(tt__Appearance*)q;
}

void tt__ColorCovariance::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_float(soap, &this->tt__ColorCovariance::XX);
	soap_default_float(soap, &this->tt__ColorCovariance::YY);
	soap_default_float(soap, &this->tt__ColorCovariance::ZZ);
	this->tt__ColorCovariance::XY = NULL;
	this->tt__ColorCovariance::XZ = NULL;
	this->tt__ColorCovariance::YZ = NULL;
	this->tt__ColorCovariance::Colorspace = NULL;
	/* transient soap skipped */
}

void tt__ColorCovariance::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tt__ColorCovariance::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ColorCovariance(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ColorCovariance(struct soap *soap, const char *tag, int id, const tt__ColorCovariance *a, const char *type)
{
	soap_set_attr(soap, "XX", soap_float2s(soap, ((tt__ColorCovariance*)a)->XX), 1);
	soap_set_attr(soap, "YY", soap_float2s(soap, ((tt__ColorCovariance*)a)->YY), 1);
	soap_set_attr(soap, "ZZ", soap_float2s(soap, ((tt__ColorCovariance*)a)->ZZ), 1);
	if (((tt__ColorCovariance*)a)->XY)
		soap_set_attr(soap, "XY", soap_float2s(soap, *((tt__ColorCovariance*)a)->XY), 1);
	if (((tt__ColorCovariance*)a)->XZ)
		soap_set_attr(soap, "XZ", soap_float2s(soap, *((tt__ColorCovariance*)a)->XZ), 1);
	if (((tt__ColorCovariance*)a)->YZ)
		soap_set_attr(soap, "YZ", soap_float2s(soap, *((tt__ColorCovariance*)a)->YZ), 1);
	if (((tt__ColorCovariance*)a)->Colorspace)
		soap_set_attr(soap, "Colorspace", ((tt__ColorCovariance*)a)->Colorspace->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ColorCovariance), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ColorCovariance::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ColorCovariance(soap, tag, this, type);
}

SOAP_FMAC3 tt__ColorCovariance * SOAP_FMAC4 soap_in_tt__ColorCovariance(struct soap *soap, const char *tag, tt__ColorCovariance *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ColorCovariance *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorCovariance, sizeof(tt__ColorCovariance), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ColorCovariance)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ColorCovariance *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2float(soap, soap_attr_value(soap, "XX", 1), &((tt__ColorCovariance*)a)->XX))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "YY", 1), &((tt__ColorCovariance*)a)->YY))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "ZZ", 1), &((tt__ColorCovariance*)a)->ZZ))
		return NULL;
	{	const char *t = soap_attr_value(soap, "XY", 0);
		if (t)
		{
			if (!(((tt__ColorCovariance*)a)->XY = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__ColorCovariance*)a)->XY))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "XZ", 0);
		if (t)
		{
			if (!(((tt__ColorCovariance*)a)->XZ = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__ColorCovariance*)a)->XZ))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "YZ", 0);
		if (t)
		{
			if (!(((tt__ColorCovariance*)a)->YZ = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__ColorCovariance*)a)->YZ))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Colorspace", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((tt__ColorCovariance*)a)->Colorspace = soap_new_std__string(soap, -1);
				((tt__ColorCovariance*)a)->Colorspace->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ColorCovariance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorCovariance, 0, sizeof(tt__ColorCovariance), 0, soap_copy_tt__ColorCovariance);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ColorCovariance::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ColorCovariance);
	if (this->soap_out(soap, tag?tag:"tt:ColorCovariance", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ColorCovariance::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ColorCovariance(soap, this, tag, type);
}

SOAP_FMAC3 tt__ColorCovariance * SOAP_FMAC4 soap_get_tt__ColorCovariance(struct soap *soap, tt__ColorCovariance *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ColorCovariance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ColorCovariance * SOAP_FMAC2 soap_instantiate_tt__ColorCovariance(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ColorCovariance(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ColorCovariance, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ColorCovariance);
		if (size)
			*size = sizeof(tt__ColorCovariance);
		((tt__ColorCovariance*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ColorCovariance[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ColorCovariance);
		for (int i = 0; i < n; i++)
			((tt__ColorCovariance*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ColorCovariance*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ColorCovariance(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ColorCovariance %p -> %p\n", q, p));
	*(tt__ColorCovariance*)p = *(tt__ColorCovariance*)q;
}

void tt__Color::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_float(soap, &this->tt__Color::X);
	soap_default_float(soap, &this->tt__Color::Y);
	soap_default_float(soap, &this->tt__Color::Z);
	this->tt__Color::Colorspace = NULL;
	/* transient soap skipped */
}

void tt__Color::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tt__Color::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Color(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Color(struct soap *soap, const char *tag, int id, const tt__Color *a, const char *type)
{
	soap_set_attr(soap, "X", soap_float2s(soap, ((tt__Color*)a)->X), 1);
	soap_set_attr(soap, "Y", soap_float2s(soap, ((tt__Color*)a)->Y), 1);
	soap_set_attr(soap, "Z", soap_float2s(soap, ((tt__Color*)a)->Z), 1);
	if (((tt__Color*)a)->Colorspace)
		soap_set_attr(soap, "Colorspace", ((tt__Color*)a)->Colorspace->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Color), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Color::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Color(soap, tag, this, type);
}

SOAP_FMAC3 tt__Color * SOAP_FMAC4 soap_in_tt__Color(struct soap *soap, const char *tag, tt__Color *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Color *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Color, sizeof(tt__Color), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Color)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Color *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2float(soap, soap_attr_value(soap, "X", 1), &((tt__Color*)a)->X))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "Y", 1), &((tt__Color*)a)->Y))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "Z", 1), &((tt__Color*)a)->Z))
		return NULL;
	{	const char *t = soap_attr_value(soap, "Colorspace", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((tt__Color*)a)->Colorspace = soap_new_std__string(soap, -1);
				((tt__Color*)a)->Colorspace->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Color *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Color, 0, sizeof(tt__Color), 0, soap_copy_tt__Color);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__Color::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Color);
	if (this->soap_out(soap, tag?tag:"tt:Color", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Color::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Color(soap, this, tag, type);
}

SOAP_FMAC3 tt__Color * SOAP_FMAC4 soap_get_tt__Color(struct soap *soap, tt__Color *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Color(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Color * SOAP_FMAC2 soap_instantiate_tt__Color(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Color(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Color, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Color);
		if (size)
			*size = sizeof(tt__Color);
		((tt__Color*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Color[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Color);
		for (int i = 0; i < n; i++)
			((tt__Color*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Color*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Color(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Color %p -> %p\n", q, p));
	*(tt__Color*)p = *(tt__Color*)q;
}

void tt__Polyline::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Vector(soap, &this->tt__Polyline::Point);
	/* transient soap skipped */
}

void tt__Polyline::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTott__Vector(soap, &this->tt__Polyline::Point);
	/* transient soap skipped */
}

int tt__Polyline::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Polyline(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Polyline(struct soap *soap, const char *tag, int id, const tt__Polyline *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Polyline), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Vector(soap, "tt:Point", -1, &(a->tt__Polyline::Point), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Polyline::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Polyline(soap, tag, this, type);
}

SOAP_FMAC3 tt__Polyline * SOAP_FMAC4 soap_in_tt__Polyline(struct soap *soap, const char *tag, tt__Polyline *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Polyline *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Polyline, sizeof(tt__Polyline), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Polyline)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Polyline *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Vector(soap, "tt:Point", &(a->tt__Polyline::Point), "tt:Vector"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Polyline *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Polyline, 0, sizeof(tt__Polyline), 0, soap_copy_tt__Polyline);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__Polyline::Point.size() < 2))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Polyline::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Polyline);
	if (this->soap_out(soap, tag?tag:"tt:Polyline", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Polyline::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Polyline(soap, this, tag, type);
}

SOAP_FMAC3 tt__Polyline * SOAP_FMAC4 soap_get_tt__Polyline(struct soap *soap, tt__Polyline *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Polyline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Polyline * SOAP_FMAC2 soap_instantiate_tt__Polyline(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Polyline(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Polyline, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Polyline);
		if (size)
			*size = sizeof(tt__Polyline);
		((tt__Polyline*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Polyline[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Polyline);
		for (int i = 0; i < n; i++)
			((tt__Polyline*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Polyline*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Polyline(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Polyline %p -> %p\n", q, p));
	*(tt__Polyline*)p = *(tt__Polyline*)q;
}

void tt__Polygon::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Vector(soap, &this->tt__Polygon::Point);
	/* transient soap skipped */
}

void tt__Polygon::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTott__Vector(soap, &this->tt__Polygon::Point);
	/* transient soap skipped */
}

int tt__Polygon::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Polygon(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Polygon(struct soap *soap, const char *tag, int id, const tt__Polygon *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Polygon), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Vector(soap, "tt:Point", -1, &(a->tt__Polygon::Point), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Polygon::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Polygon(soap, tag, this, type);
}

SOAP_FMAC3 tt__Polygon * SOAP_FMAC4 soap_in_tt__Polygon(struct soap *soap, const char *tag, tt__Polygon *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Polygon *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Polygon, sizeof(tt__Polygon), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Polygon)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Polygon *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Vector(soap, "tt:Point", &(a->tt__Polygon::Point), "tt:Vector"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Polygon *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Polygon, 0, sizeof(tt__Polygon), 0, soap_copy_tt__Polygon);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__Polygon::Point.size() < 3))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Polygon::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Polygon);
	if (this->soap_out(soap, tag?tag:"tt:Polygon", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Polygon::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Polygon(soap, this, tag, type);
}

SOAP_FMAC3 tt__Polygon * SOAP_FMAC4 soap_get_tt__Polygon(struct soap *soap, tt__Polygon *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Polygon(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Polygon * SOAP_FMAC2 soap_instantiate_tt__Polygon(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Polygon(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Polygon, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Polygon);
		if (size)
			*size = sizeof(tt__Polygon);
		((tt__Polygon*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Polygon[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Polygon);
		for (int i = 0; i < n; i++)
			((tt__Polygon*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Polygon*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Polygon(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Polygon %p -> %p\n", q, p));
	*(tt__Polygon*)p = *(tt__Polygon*)q;
}

void tt__Rectangle::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__Rectangle::bottom = NULL;
	this->tt__Rectangle::top = NULL;
	this->tt__Rectangle::right = NULL;
	this->tt__Rectangle::left = NULL;
	/* transient soap skipped */
}

void tt__Rectangle::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tt__Rectangle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Rectangle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Rectangle(struct soap *soap, const char *tag, int id, const tt__Rectangle *a, const char *type)
{
	if (((tt__Rectangle*)a)->bottom)
		soap_set_attr(soap, "bottom", soap_float2s(soap, *((tt__Rectangle*)a)->bottom), 1);
	if (((tt__Rectangle*)a)->top)
		soap_set_attr(soap, "top", soap_float2s(soap, *((tt__Rectangle*)a)->top), 1);
	if (((tt__Rectangle*)a)->right)
		soap_set_attr(soap, "right", soap_float2s(soap, *((tt__Rectangle*)a)->right), 1);
	if (((tt__Rectangle*)a)->left)
		soap_set_attr(soap, "left", soap_float2s(soap, *((tt__Rectangle*)a)->left), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Rectangle), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Rectangle::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Rectangle(soap, tag, this, type);
}

SOAP_FMAC3 tt__Rectangle * SOAP_FMAC4 soap_in_tt__Rectangle(struct soap *soap, const char *tag, tt__Rectangle *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Rectangle *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Rectangle, sizeof(tt__Rectangle), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Rectangle)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Rectangle *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "bottom", 0);
		if (t)
		{
			if (!(((tt__Rectangle*)a)->bottom = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__Rectangle*)a)->bottom))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "top", 0);
		if (t)
		{
			if (!(((tt__Rectangle*)a)->top = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__Rectangle*)a)->top))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "right", 0);
		if (t)
		{
			if (!(((tt__Rectangle*)a)->right = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__Rectangle*)a)->right))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "left", 0);
		if (t)
		{
			if (!(((tt__Rectangle*)a)->left = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__Rectangle*)a)->left))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Rectangle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Rectangle, 0, sizeof(tt__Rectangle), 0, soap_copy_tt__Rectangle);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__Rectangle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Rectangle);
	if (this->soap_out(soap, tag?tag:"tt:Rectangle", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Rectangle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Rectangle(soap, this, tag, type);
}

SOAP_FMAC3 tt__Rectangle * SOAP_FMAC4 soap_get_tt__Rectangle(struct soap *soap, tt__Rectangle *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Rectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Rectangle * SOAP_FMAC2 soap_instantiate_tt__Rectangle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Rectangle(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Rectangle, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Rectangle);
		if (size)
			*size = sizeof(tt__Rectangle);
		((tt__Rectangle*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Rectangle[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Rectangle);
		for (int i = 0; i < n; i++)
			((tt__Rectangle*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Rectangle*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Rectangle(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Rectangle %p -> %p\n", q, p));
	*(tt__Rectangle*)p = *(tt__Rectangle*)q;
}

void tt__Vector::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__Vector::x = NULL;
	this->tt__Vector::y = NULL;
	/* transient soap skipped */
}

void tt__Vector::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tt__Vector::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Vector(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector(struct soap *soap, const char *tag, int id, const tt__Vector *a, const char *type)
{
	if (((tt__Vector*)a)->x)
		soap_set_attr(soap, "x", soap_float2s(soap, *((tt__Vector*)a)->x), 1);
	if (((tt__Vector*)a)->y)
		soap_set_attr(soap, "y", soap_float2s(soap, *((tt__Vector*)a)->y), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Vector), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Vector::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Vector(soap, tag, this, type);
}

SOAP_FMAC3 tt__Vector * SOAP_FMAC4 soap_in_tt__Vector(struct soap *soap, const char *tag, tt__Vector *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Vector *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector, sizeof(tt__Vector), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Vector)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Vector *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "x", 0);
		if (t)
		{
			if (!(((tt__Vector*)a)->x = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__Vector*)a)->x))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "y", 0);
		if (t)
		{
			if (!(((tt__Vector*)a)->y = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__Vector*)a)->y))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Vector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector, 0, sizeof(tt__Vector), 0, soap_copy_tt__Vector);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__Vector::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Vector);
	if (this->soap_out(soap, tag?tag:"tt:Vector", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Vector::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Vector(soap, this, tag, type);
}

SOAP_FMAC3 tt__Vector * SOAP_FMAC4 soap_get_tt__Vector(struct soap *soap, tt__Vector *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Vector * SOAP_FMAC2 soap_instantiate_tt__Vector(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Vector(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Vector, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Vector);
		if (size)
			*size = sizeof(tt__Vector);
		((tt__Vector*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Vector[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Vector);
		for (int i = 0; i < n; i++)
			((tt__Vector*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Vector*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Vector(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Vector %p -> %p\n", q, p));
	*(tt__Vector*)p = *(tt__Vector*)q;
}

void tt__ItemListDescriptionExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ItemListDescriptionExtension::__any);
	/* transient soap skipped */
}

void tt__ItemListDescriptionExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ItemListDescriptionExtension::__any);
	/* transient soap skipped */
}

int tt__ItemListDescriptionExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ItemListDescriptionExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemListDescriptionExtension(struct soap *soap, const char *tag, int id, const tt__ItemListDescriptionExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemListDescriptionExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__ItemListDescriptionExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ItemListDescriptionExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ItemListDescriptionExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ItemListDescriptionExtension * SOAP_FMAC4 soap_in_tt__ItemListDescriptionExtension(struct soap *soap, const char *tag, tt__ItemListDescriptionExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ItemListDescriptionExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListDescriptionExtension, sizeof(tt__ItemListDescriptionExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ItemListDescriptionExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ItemListDescriptionExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__ItemListDescriptionExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ItemListDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListDescriptionExtension, 0, sizeof(tt__ItemListDescriptionExtension), 0, soap_copy_tt__ItemListDescriptionExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ItemListDescriptionExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ItemListDescriptionExtension);
	if (this->soap_out(soap, tag?tag:"tt:ItemListDescriptionExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ItemListDescriptionExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ItemListDescriptionExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ItemListDescriptionExtension * SOAP_FMAC4 soap_get_tt__ItemListDescriptionExtension(struct soap *soap, tt__ItemListDescriptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemListDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ItemListDescriptionExtension * SOAP_FMAC2 soap_instantiate_tt__ItemListDescriptionExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ItemListDescriptionExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ItemListDescriptionExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ItemListDescriptionExtension);
		if (size)
			*size = sizeof(tt__ItemListDescriptionExtension);
		((tt__ItemListDescriptionExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ItemListDescriptionExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ItemListDescriptionExtension);
		for (int i = 0; i < n; i++)
			((tt__ItemListDescriptionExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ItemListDescriptionExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ItemListDescriptionExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ItemListDescriptionExtension %p -> %p\n", q, p));
	*(tt__ItemListDescriptionExtension*)p = *(tt__ItemListDescriptionExtension*)q;
}

void tt__ItemListDescription::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ItemListDescription::__sizeSimpleItemDescription = 0;
	this->tt__ItemListDescription::SimpleItemDescription = NULL;
	this->tt__ItemListDescription::__sizeElementItemDescription = 0;
	this->tt__ItemListDescription::ElementItemDescription = NULL;
	this->tt__ItemListDescription::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ItemListDescription::__anyAttribute);
	/* transient soap skipped */
}

void tt__ItemListDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->tt__ItemListDescription::SimpleItemDescription)
	{	int i;
		for (i = 0; i < this->tt__ItemListDescription::__sizeSimpleItemDescription; i++)
		{
			soap_embedded(soap, this->tt__ItemListDescription::SimpleItemDescription + i, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription);
			this->tt__ItemListDescription::SimpleItemDescription[i].soap_serialize(soap);
		}
	}
	if (this->tt__ItemListDescription::ElementItemDescription)
	{	int i;
		for (i = 0; i < this->tt__ItemListDescription::__sizeElementItemDescription; i++)
		{
			soap_embedded(soap, this->tt__ItemListDescription::ElementItemDescription + i, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription);
			this->tt__ItemListDescription::ElementItemDescription[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTott__ItemListDescriptionExtension(soap, &this->tt__ItemListDescription::Extension);
	/* transient soap skipped */
}

int tt__ItemListDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ItemListDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemListDescription(struct soap *soap, const char *tag, int id, const tt__ItemListDescription *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ItemListDescription*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemListDescription), type))
		return soap->error;
	if (a->tt__ItemListDescription::SimpleItemDescription)
	{	int i;
		for (i = 0; i < a->tt__ItemListDescription::__sizeSimpleItemDescription; i++)
			if (a->tt__ItemListDescription::SimpleItemDescription[i].soap_out(soap, "tt:SimpleItemDescription", -1, ""))
				return soap->error;
	}
	if (a->tt__ItemListDescription::ElementItemDescription)
	{	int i;
		for (i = 0; i < a->tt__ItemListDescription::__sizeElementItemDescription; i++)
			if (a->tt__ItemListDescription::ElementItemDescription[i].soap_out(soap, "tt:ElementItemDescription", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ItemListDescriptionExtension(soap, "tt:Extension", -1, &(a->tt__ItemListDescription::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ItemListDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ItemListDescription(soap, tag, this, type);
}

SOAP_FMAC3 tt__ItemListDescription * SOAP_FMAC4 soap_in_tt__ItemListDescription(struct soap *soap, const char *tag, tt__ItemListDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ItemListDescription *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListDescription, sizeof(tt__ItemListDescription), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ItemListDescription)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ItemListDescription *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ItemListDescription*)a)->__anyAttribute, "xsd:anyAttribute");
	struct soap_blist *soap_blist_SimpleItemDescription1 = NULL;
	struct soap_blist *soap_blist_ElementItemDescription1 = NULL;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SimpleItemDescription", 1, NULL))
			{	if (a->tt__ItemListDescription::SimpleItemDescription == NULL)
				{	if (soap_blist_SimpleItemDescription1 == NULL)
						soap_blist_SimpleItemDescription1 = soap_new_block(soap);
					a->tt__ItemListDescription::SimpleItemDescription = (_tt__ItemListDescription_SimpleItemDescription *)soap_push_block(soap, soap_blist_SimpleItemDescription1, sizeof(_tt__ItemListDescription_SimpleItemDescription));
					if (a->tt__ItemListDescription::SimpleItemDescription == NULL)
						return NULL;
					_tt__ItemListDescription_SimpleItemDescription p;
					memcpy(a->tt__ItemListDescription::SimpleItemDescription, &p, sizeof(_tt__ItemListDescription_SimpleItemDescription)); // a bit rough but portable
					a->tt__ItemListDescription::SimpleItemDescription->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__tt__ItemListDescription_SimpleItemDescription(soap, "tt:SimpleItemDescription", a->tt__ItemListDescription::SimpleItemDescription, ""))
				{	a->tt__ItemListDescription::__sizeSimpleItemDescription++;
					a->tt__ItemListDescription::SimpleItemDescription = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ElementItemDescription", 1, NULL))
			{	if (a->tt__ItemListDescription::ElementItemDescription == NULL)
				{	if (soap_blist_ElementItemDescription1 == NULL)
						soap_blist_ElementItemDescription1 = soap_new_block(soap);
					a->tt__ItemListDescription::ElementItemDescription = (_tt__ItemListDescription_ElementItemDescription *)soap_push_block(soap, soap_blist_ElementItemDescription1, sizeof(_tt__ItemListDescription_ElementItemDescription));
					if (a->tt__ItemListDescription::ElementItemDescription == NULL)
						return NULL;
					_tt__ItemListDescription_ElementItemDescription p;
					memcpy(a->tt__ItemListDescription::ElementItemDescription, &p, sizeof(_tt__ItemListDescription_ElementItemDescription)); // a bit rough but portable
					a->tt__ItemListDescription::ElementItemDescription->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__tt__ItemListDescription_ElementItemDescription(soap, "tt:ElementItemDescription", a->tt__ItemListDescription::ElementItemDescription, ""))
				{	a->tt__ItemListDescription::__sizeElementItemDescription++;
					a->tt__ItemListDescription::ElementItemDescription = NULL;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescriptionExtension(soap, "tt:Extension", &(a->tt__ItemListDescription::Extension), "tt:ItemListDescriptionExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__ItemListDescription::SimpleItemDescription)
			soap_pop_block(soap, soap_blist_SimpleItemDescription1);
		if (a->tt__ItemListDescription::__sizeSimpleItemDescription)
			a->tt__ItemListDescription::SimpleItemDescription = (_tt__ItemListDescription_SimpleItemDescription *)soap_save_block(soap, soap_blist_SimpleItemDescription1, NULL, 1);
		else
		{	a->tt__ItemListDescription::SimpleItemDescription = NULL;
			if (soap_blist_SimpleItemDescription1)
				soap_end_block(soap, soap_blist_SimpleItemDescription1);
		}
		if (a->tt__ItemListDescription::ElementItemDescription)
			soap_pop_block(soap, soap_blist_ElementItemDescription1);
		if (a->tt__ItemListDescription::__sizeElementItemDescription)
			a->tt__ItemListDescription::ElementItemDescription = (_tt__ItemListDescription_ElementItemDescription *)soap_save_block(soap, soap_blist_ElementItemDescription1, NULL, 1);
		else
		{	a->tt__ItemListDescription::ElementItemDescription = NULL;
			if (soap_blist_ElementItemDescription1)
				soap_end_block(soap, soap_blist_ElementItemDescription1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ItemListDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListDescription, 0, sizeof(tt__ItemListDescription), 0, soap_copy_tt__ItemListDescription);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ItemListDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ItemListDescription);
	if (this->soap_out(soap, tag?tag:"tt:ItemListDescription", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ItemListDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ItemListDescription(soap, this, tag, type);
}

SOAP_FMAC3 tt__ItemListDescription * SOAP_FMAC4 soap_get_tt__ItemListDescription(struct soap *soap, tt__ItemListDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemListDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ItemListDescription * SOAP_FMAC2 soap_instantiate_tt__ItemListDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ItemListDescription(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ItemListDescription, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ItemListDescription);
		if (size)
			*size = sizeof(tt__ItemListDescription);
		((tt__ItemListDescription*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ItemListDescription[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ItemListDescription);
		for (int i = 0; i < n; i++)
			((tt__ItemListDescription*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ItemListDescription*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ItemListDescription(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ItemListDescription %p -> %p\n", q, p));
	*(tt__ItemListDescription*)p = *(tt__ItemListDescription*)q;
}

void tt__MessageDescriptionExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MessageDescriptionExtension::__any);
	/* transient soap skipped */
}

void tt__MessageDescriptionExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MessageDescriptionExtension::__any);
	/* transient soap skipped */
}

int tt__MessageDescriptionExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MessageDescriptionExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MessageDescriptionExtension(struct soap *soap, const char *tag, int id, const tt__MessageDescriptionExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MessageDescriptionExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__MessageDescriptionExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__MessageDescriptionExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__MessageDescriptionExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__MessageDescriptionExtension * SOAP_FMAC4 soap_in_tt__MessageDescriptionExtension(struct soap *soap, const char *tag, tt__MessageDescriptionExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MessageDescriptionExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageDescriptionExtension, sizeof(tt__MessageDescriptionExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__MessageDescriptionExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__MessageDescriptionExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__MessageDescriptionExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MessageDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MessageDescriptionExtension, 0, sizeof(tt__MessageDescriptionExtension), 0, soap_copy_tt__MessageDescriptionExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__MessageDescriptionExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__MessageDescriptionExtension);
	if (this->soap_out(soap, tag?tag:"tt:MessageDescriptionExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MessageDescriptionExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MessageDescriptionExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__MessageDescriptionExtension * SOAP_FMAC4 soap_get_tt__MessageDescriptionExtension(struct soap *soap, tt__MessageDescriptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MessageDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__MessageDescriptionExtension * SOAP_FMAC2 soap_instantiate_tt__MessageDescriptionExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MessageDescriptionExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__MessageDescriptionExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__MessageDescriptionExtension);
		if (size)
			*size = sizeof(tt__MessageDescriptionExtension);
		((tt__MessageDescriptionExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__MessageDescriptionExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__MessageDescriptionExtension);
		for (int i = 0; i < n; i++)
			((tt__MessageDescriptionExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__MessageDescriptionExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__MessageDescriptionExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__MessageDescriptionExtension %p -> %p\n", q, p));
	*(tt__MessageDescriptionExtension*)p = *(tt__MessageDescriptionExtension*)q;
}

void tt__MessageDescription::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__MessageDescription::Source = NULL;
	this->tt__MessageDescription::Key = NULL;
	this->tt__MessageDescription::Data = NULL;
	this->tt__MessageDescription::Extension = NULL;
	this->tt__MessageDescription::IsProperty = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__MessageDescription::__anyAttribute);
	/* transient soap skipped */
}

void tt__MessageDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ItemListDescription(soap, &this->tt__MessageDescription::Source);
	soap_serialize_PointerTott__ItemListDescription(soap, &this->tt__MessageDescription::Key);
	soap_serialize_PointerTott__ItemListDescription(soap, &this->tt__MessageDescription::Data);
	soap_serialize_PointerTott__MessageDescriptionExtension(soap, &this->tt__MessageDescription::Extension);
	/* transient soap skipped */
}

int tt__MessageDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MessageDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MessageDescription(struct soap *soap, const char *tag, int id, const tt__MessageDescription *a, const char *type)
{
	if (((tt__MessageDescription*)a)->IsProperty)
		soap_set_attr(soap, "IsProperty", soap_bool2s(soap, *((tt__MessageDescription*)a)->IsProperty), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__MessageDescription*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MessageDescription), type))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Source", -1, &(a->tt__MessageDescription::Source), ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Key", -1, &(a->tt__MessageDescription::Key), ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Data", -1, &(a->tt__MessageDescription::Data), ""))
		return soap->error;
	if (soap_out_PointerTott__MessageDescriptionExtension(soap, "tt:Extension", -1, &(a->tt__MessageDescription::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__MessageDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__MessageDescription(soap, tag, this, type);
}

SOAP_FMAC3 tt__MessageDescription * SOAP_FMAC4 soap_in_tt__MessageDescription(struct soap *soap, const char *tag, tt__MessageDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MessageDescription *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageDescription, sizeof(tt__MessageDescription), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__MessageDescription)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__MessageDescription *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "IsProperty", 0);
		if (t)
		{
			if (!(((tt__MessageDescription*)a)->IsProperty = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tt__MessageDescription*)a)->IsProperty))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__MessageDescription*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Source1 = 1;
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_Data1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescription(soap, "tt:Source", &(a->tt__MessageDescription::Source), "tt:ItemListDescription"))
				{	soap_flag_Source1--;
					continue;
				}
			if (soap_flag_Key1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescription(soap, "tt:Key", &(a->tt__MessageDescription::Key), "tt:ItemListDescription"))
				{	soap_flag_Key1--;
					continue;
				}
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescription(soap, "tt:Data", &(a->tt__MessageDescription::Data), "tt:ItemListDescription"))
				{	soap_flag_Data1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MessageDescriptionExtension(soap, "tt:Extension", &(a->tt__MessageDescription::Extension), "tt:MessageDescriptionExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MessageDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MessageDescription, 0, sizeof(tt__MessageDescription), 0, soap_copy_tt__MessageDescription);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__MessageDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__MessageDescription);
	if (this->soap_out(soap, tag?tag:"tt:MessageDescription", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MessageDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MessageDescription(soap, this, tag, type);
}

SOAP_FMAC3 tt__MessageDescription * SOAP_FMAC4 soap_get_tt__MessageDescription(struct soap *soap, tt__MessageDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MessageDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__MessageDescription * SOAP_FMAC2 soap_instantiate_tt__MessageDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MessageDescription(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__MessageDescription, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__MessageDescription);
		if (size)
			*size = sizeof(tt__MessageDescription);
		((tt__MessageDescription*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__MessageDescription[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__MessageDescription);
		for (int i = 0; i < n; i++)
			((tt__MessageDescription*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__MessageDescription*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__MessageDescription(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__MessageDescription %p -> %p\n", q, p));
	*(tt__MessageDescription*)p = *(tt__MessageDescription*)q;
}

void tt__ItemListExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ItemListExtension::__any);
	/* transient soap skipped */
}

void tt__ItemListExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ItemListExtension::__any);
	/* transient soap skipped */
}

int tt__ItemListExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ItemListExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemListExtension(struct soap *soap, const char *tag, int id, const tt__ItemListExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemListExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__ItemListExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ItemListExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ItemListExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ItemListExtension * SOAP_FMAC4 soap_in_tt__ItemListExtension(struct soap *soap, const char *tag, tt__ItemListExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ItemListExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListExtension, sizeof(tt__ItemListExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ItemListExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ItemListExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__ItemListExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ItemListExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListExtension, 0, sizeof(tt__ItemListExtension), 0, soap_copy_tt__ItemListExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ItemListExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ItemListExtension);
	if (this->soap_out(soap, tag?tag:"tt:ItemListExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ItemListExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ItemListExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ItemListExtension * SOAP_FMAC4 soap_get_tt__ItemListExtension(struct soap *soap, tt__ItemListExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemListExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ItemListExtension * SOAP_FMAC2 soap_instantiate_tt__ItemListExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ItemListExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ItemListExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ItemListExtension);
		if (size)
			*size = sizeof(tt__ItemListExtension);
		((tt__ItemListExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ItemListExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ItemListExtension);
		for (int i = 0; i < n; i++)
			((tt__ItemListExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ItemListExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ItemListExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ItemListExtension %p -> %p\n", q, p));
	*(tt__ItemListExtension*)p = *(tt__ItemListExtension*)q;
}

void tt__ItemList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ItemList::__sizeSimpleItem = 0;
	this->tt__ItemList::SimpleItem = NULL;
	this->tt__ItemList::__sizeElementItem = 0;
	this->tt__ItemList::ElementItem = NULL;
	this->tt__ItemList::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ItemList::__anyAttribute);
	/* transient soap skipped */
}

void tt__ItemList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->tt__ItemList::SimpleItem)
	{	int i;
		for (i = 0; i < this->tt__ItemList::__sizeSimpleItem; i++)
		{
			soap_embedded(soap, this->tt__ItemList::SimpleItem + i, SOAP_TYPE__tt__ItemList_SimpleItem);
			this->tt__ItemList::SimpleItem[i].soap_serialize(soap);
		}
	}
	if (this->tt__ItemList::ElementItem)
	{	int i;
		for (i = 0; i < this->tt__ItemList::__sizeElementItem; i++)
		{
			soap_embedded(soap, this->tt__ItemList::ElementItem + i, SOAP_TYPE__tt__ItemList_ElementItem);
			this->tt__ItemList::ElementItem[i].soap_serialize(soap);
		}
	}
	soap_serialize_PointerTott__ItemListExtension(soap, &this->tt__ItemList::Extension);
	/* transient soap skipped */
}

int tt__ItemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemList(struct soap *soap, const char *tag, int id, const tt__ItemList *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ItemList*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemList), type))
		return soap->error;
	if (a->tt__ItemList::SimpleItem)
	{	int i;
		for (i = 0; i < a->tt__ItemList::__sizeSimpleItem; i++)
			if (a->tt__ItemList::SimpleItem[i].soap_out(soap, "tt:SimpleItem", -1, ""))
				return soap->error;
	}
	if (a->tt__ItemList::ElementItem)
	{	int i;
		for (i = 0; i < a->tt__ItemList::__sizeElementItem; i++)
			if (a->tt__ItemList::ElementItem[i].soap_out(soap, "tt:ElementItem", -1, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ItemListExtension(soap, "tt:Extension", -1, &(a->tt__ItemList::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ItemList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ItemList(soap, tag, this, type);
}

SOAP_FMAC3 tt__ItemList * SOAP_FMAC4 soap_in_tt__ItemList(struct soap *soap, const char *tag, tt__ItemList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ItemList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemList, sizeof(tt__ItemList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ItemList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ItemList *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ItemList*)a)->__anyAttribute, "xsd:anyAttribute");
	struct soap_blist *soap_blist_SimpleItem1 = NULL;
	struct soap_blist *soap_blist_ElementItem1 = NULL;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SimpleItem", 1, NULL))
			{	if (a->tt__ItemList::SimpleItem == NULL)
				{	if (soap_blist_SimpleItem1 == NULL)
						soap_blist_SimpleItem1 = soap_new_block(soap);
					a->tt__ItemList::SimpleItem = (_tt__ItemList_SimpleItem *)soap_push_block(soap, soap_blist_SimpleItem1, sizeof(_tt__ItemList_SimpleItem));
					if (a->tt__ItemList::SimpleItem == NULL)
						return NULL;
					_tt__ItemList_SimpleItem p;
					memcpy(a->tt__ItemList::SimpleItem, &p, sizeof(_tt__ItemList_SimpleItem)); // a bit rough but portable
					a->tt__ItemList::SimpleItem->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__tt__ItemList_SimpleItem(soap, "tt:SimpleItem", a->tt__ItemList::SimpleItem, ""))
				{	a->tt__ItemList::__sizeSimpleItem++;
					a->tt__ItemList::SimpleItem = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ElementItem", 1, NULL))
			{	if (a->tt__ItemList::ElementItem == NULL)
				{	if (soap_blist_ElementItem1 == NULL)
						soap_blist_ElementItem1 = soap_new_block(soap);
					a->tt__ItemList::ElementItem = (_tt__ItemList_ElementItem *)soap_push_block(soap, soap_blist_ElementItem1, sizeof(_tt__ItemList_ElementItem));
					if (a->tt__ItemList::ElementItem == NULL)
						return NULL;
					_tt__ItemList_ElementItem p;
					memcpy(a->tt__ItemList::ElementItem, &p, sizeof(_tt__ItemList_ElementItem)); // a bit rough but portable
					a->tt__ItemList::ElementItem->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__tt__ItemList_ElementItem(soap, "tt:ElementItem", a->tt__ItemList::ElementItem, ""))
				{	a->tt__ItemList::__sizeElementItem++;
					a->tt__ItemList::ElementItem = NULL;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListExtension(soap, "tt:Extension", &(a->tt__ItemList::Extension), "tt:ItemListExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__ItemList::SimpleItem)
			soap_pop_block(soap, soap_blist_SimpleItem1);
		if (a->tt__ItemList::__sizeSimpleItem)
			a->tt__ItemList::SimpleItem = (_tt__ItemList_SimpleItem *)soap_save_block(soap, soap_blist_SimpleItem1, NULL, 1);
		else
		{	a->tt__ItemList::SimpleItem = NULL;
			if (soap_blist_SimpleItem1)
				soap_end_block(soap, soap_blist_SimpleItem1);
		}
		if (a->tt__ItemList::ElementItem)
			soap_pop_block(soap, soap_blist_ElementItem1);
		if (a->tt__ItemList::__sizeElementItem)
			a->tt__ItemList::ElementItem = (_tt__ItemList_ElementItem *)soap_save_block(soap, soap_blist_ElementItem1, NULL, 1);
		else
		{	a->tt__ItemList::ElementItem = NULL;
			if (soap_blist_ElementItem1)
				soap_end_block(soap, soap_blist_ElementItem1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemList, 0, sizeof(tt__ItemList), 0, soap_copy_tt__ItemList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ItemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ItemList);
	if (this->soap_out(soap, tag?tag:"tt:ItemList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ItemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ItemList(soap, this, tag, type);
}

SOAP_FMAC3 tt__ItemList * SOAP_FMAC4 soap_get_tt__ItemList(struct soap *soap, tt__ItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ItemList * SOAP_FMAC2 soap_instantiate_tt__ItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ItemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ItemList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ItemList);
		if (size)
			*size = sizeof(tt__ItemList);
		((tt__ItemList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ItemList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ItemList);
		for (int i = 0; i < n; i++)
			((tt__ItemList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ItemList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ItemList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ItemList %p -> %p\n", q, p));
	*(tt__ItemList*)p = *(tt__ItemList*)q;
}

void tt__MessageExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MessageExtension::__any);
	/* transient soap skipped */
}

void tt__MessageExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MessageExtension::__any);
	/* transient soap skipped */
}

int tt__MessageExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MessageExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MessageExtension(struct soap *soap, const char *tag, int id, const tt__MessageExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MessageExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__MessageExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__MessageExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__MessageExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__MessageExtension * SOAP_FMAC4 soap_in_tt__MessageExtension(struct soap *soap, const char *tag, tt__MessageExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MessageExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageExtension, sizeof(tt__MessageExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__MessageExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__MessageExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__MessageExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MessageExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MessageExtension, 0, sizeof(tt__MessageExtension), 0, soap_copy_tt__MessageExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__MessageExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__MessageExtension);
	if (this->soap_out(soap, tag?tag:"tt:MessageExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MessageExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MessageExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__MessageExtension * SOAP_FMAC4 soap_get_tt__MessageExtension(struct soap *soap, tt__MessageExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MessageExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__MessageExtension * SOAP_FMAC2 soap_instantiate_tt__MessageExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MessageExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__MessageExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__MessageExtension);
		if (size)
			*size = sizeof(tt__MessageExtension);
		((tt__MessageExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__MessageExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__MessageExtension);
		for (int i = 0; i < n; i++)
			((tt__MessageExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__MessageExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__MessageExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__MessageExtension %p -> %p\n", q, p));
	*(tt__MessageExtension*)p = *(tt__MessageExtension*)q;
}

void tt__FocusOptions20Extension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FocusOptions20Extension::__any);
	/* transient soap skipped */
}

void tt__FocusOptions20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FocusOptions20Extension::__any);
	/* transient soap skipped */
}

int tt__FocusOptions20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusOptions20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusOptions20Extension(struct soap *soap, const char *tag, int id, const tt__FocusOptions20Extension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusOptions20Extension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__FocusOptions20Extension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__FocusOptions20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__FocusOptions20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusOptions20Extension * SOAP_FMAC4 soap_in_tt__FocusOptions20Extension(struct soap *soap, const char *tag, tt__FocusOptions20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusOptions20Extension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusOptions20Extension, sizeof(tt__FocusOptions20Extension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__FocusOptions20Extension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__FocusOptions20Extension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__FocusOptions20Extension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusOptions20Extension, 0, sizeof(tt__FocusOptions20Extension), 0, soap_copy_tt__FocusOptions20Extension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__FocusOptions20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__FocusOptions20Extension);
	if (this->soap_out(soap, tag?tag:"tt:FocusOptions20Extension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusOptions20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusOptions20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusOptions20Extension * SOAP_FMAC4 soap_get_tt__FocusOptions20Extension(struct soap *soap, tt__FocusOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__FocusOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusOptions20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusOptions20Extension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__FocusOptions20Extension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__FocusOptions20Extension);
		if (size)
			*size = sizeof(tt__FocusOptions20Extension);
		((tt__FocusOptions20Extension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__FocusOptions20Extension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__FocusOptions20Extension);
		for (int i = 0; i < n; i++)
			((tt__FocusOptions20Extension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__FocusOptions20Extension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__FocusOptions20Extension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__FocusOptions20Extension %p -> %p\n", q, p));
	*(tt__FocusOptions20Extension*)p = *(tt__FocusOptions20Extension*)q;
}

void tt__FocusOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__AutoFocusMode(soap, &this->tt__FocusOptions20::AutoFocusModes);
	this->tt__FocusOptions20::DefaultSpeed = NULL;
	this->tt__FocusOptions20::NearLimit = NULL;
	this->tt__FocusOptions20::FarLimit = NULL;
	this->tt__FocusOptions20::Extension = NULL;
	/* transient soap skipped */
}

void tt__FocusOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOftt__AutoFocusMode(soap, &this->tt__FocusOptions20::AutoFocusModes);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__FocusOptions20::DefaultSpeed);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__FocusOptions20::NearLimit);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__FocusOptions20::FarLimit);
	soap_serialize_PointerTott__FocusOptions20Extension(soap, &this->tt__FocusOptions20::Extension);
	/* transient soap skipped */
}

int tt__FocusOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusOptions20(struct soap *soap, const char *tag, int id, const tt__FocusOptions20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusOptions20), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__AutoFocusMode(soap, "tt:AutoFocusModes", -1, &(a->tt__FocusOptions20::AutoFocusModes), ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:DefaultSpeed", -1, &(a->tt__FocusOptions20::DefaultSpeed), ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:NearLimit", -1, &(a->tt__FocusOptions20::NearLimit), ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:FarLimit", -1, &(a->tt__FocusOptions20::FarLimit), ""))
		return soap->error;
	if (soap_out_PointerTott__FocusOptions20Extension(soap, "tt:Extension", -1, &(a->tt__FocusOptions20::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__FocusOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__FocusOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusOptions20 * SOAP_FMAC4 soap_in_tt__FocusOptions20(struct soap *soap, const char *tag, tt__FocusOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusOptions20 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusOptions20, sizeof(tt__FocusOptions20), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__FocusOptions20)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__FocusOptions20 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_DefaultSpeed1 = 1;
	size_t soap_flag_NearLimit1 = 1;
	size_t soap_flag_FarLimit1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftt__AutoFocusMode(soap, "tt:AutoFocusModes", &(a->tt__FocusOptions20::AutoFocusModes), "tt:AutoFocusMode"))
					continue;
			if (soap_flag_DefaultSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:DefaultSpeed", &(a->tt__FocusOptions20::DefaultSpeed), "tt:FloatRange"))
				{	soap_flag_DefaultSpeed1--;
					continue;
				}
			if (soap_flag_NearLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:NearLimit", &(a->tt__FocusOptions20::NearLimit), "tt:FloatRange"))
				{	soap_flag_NearLimit1--;
					continue;
				}
			if (soap_flag_FarLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:FarLimit", &(a->tt__FocusOptions20::FarLimit), "tt:FloatRange"))
				{	soap_flag_FarLimit1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusOptions20Extension(soap, "tt:Extension", &(a->tt__FocusOptions20::Extension), "tt:FocusOptions20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusOptions20, 0, sizeof(tt__FocusOptions20), 0, soap_copy_tt__FocusOptions20);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__FocusOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__FocusOptions20);
	if (this->soap_out(soap, tag?tag:"tt:FocusOptions20", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusOptions20 * SOAP_FMAC4 soap_get_tt__FocusOptions20(struct soap *soap, tt__FocusOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__FocusOptions20 * SOAP_FMAC2 soap_instantiate_tt__FocusOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusOptions20(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__FocusOptions20, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__FocusOptions20);
		if (size)
			*size = sizeof(tt__FocusOptions20);
		((tt__FocusOptions20*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__FocusOptions20[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__FocusOptions20);
		for (int i = 0; i < n; i++)
			((tt__FocusOptions20*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__FocusOptions20*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__FocusOptions20(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__FocusOptions20 %p -> %p\n", q, p));
	*(tt__FocusOptions20*)p = *(tt__FocusOptions20*)q;
}

void tt__WhiteBalanceOptions20Extension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__WhiteBalanceOptions20Extension::__any);
	/* transient soap skipped */
}

void tt__WhiteBalanceOptions20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__WhiteBalanceOptions20Extension::__any);
	/* transient soap skipped */
}

int tt__WhiteBalanceOptions20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalanceOptions20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, int id, const tt__WhiteBalanceOptions20Extension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__WhiteBalanceOptions20Extension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__WhiteBalanceOptions20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__WhiteBalanceOptions20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20Extension * SOAP_FMAC4 soap_in_tt__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, tt__WhiteBalanceOptions20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WhiteBalanceOptions20Extension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, sizeof(tt__WhiteBalanceOptions20Extension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__WhiteBalanceOptions20Extension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__WhiteBalanceOptions20Extension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__WhiteBalanceOptions20Extension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__WhiteBalanceOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, 0, sizeof(tt__WhiteBalanceOptions20Extension), 0, soap_copy_tt__WhiteBalanceOptions20Extension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__WhiteBalanceOptions20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__WhiteBalanceOptions20Extension);
	if (this->soap_out(soap, tag?tag:"tt:WhiteBalanceOptions20Extension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalanceOptions20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalanceOptions20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20Extension * SOAP_FMAC4 soap_get_tt__WhiteBalanceOptions20Extension(struct soap *soap, tt__WhiteBalanceOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__WhiteBalanceOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceOptions20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WhiteBalanceOptions20Extension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__WhiteBalanceOptions20Extension);
		if (size)
			*size = sizeof(tt__WhiteBalanceOptions20Extension);
		((tt__WhiteBalanceOptions20Extension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__WhiteBalanceOptions20Extension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__WhiteBalanceOptions20Extension);
		for (int i = 0; i < n; i++)
			((tt__WhiteBalanceOptions20Extension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__WhiteBalanceOptions20Extension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__WhiteBalanceOptions20Extension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__WhiteBalanceOptions20Extension %p -> %p\n", q, p));
	*(tt__WhiteBalanceOptions20Extension*)p = *(tt__WhiteBalanceOptions20Extension*)q;
}

void tt__WhiteBalanceOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__WhiteBalanceMode(soap, &this->tt__WhiteBalanceOptions20::Mode);
	this->tt__WhiteBalanceOptions20::YrGain = NULL;
	this->tt__WhiteBalanceOptions20::YbGain = NULL;
	this->tt__WhiteBalanceOptions20::Extension = NULL;
	/* transient soap skipped */
}

void tt__WhiteBalanceOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOftt__WhiteBalanceMode(soap, &this->tt__WhiteBalanceOptions20::Mode);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__WhiteBalanceOptions20::YrGain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__WhiteBalanceOptions20::YbGain);
	soap_serialize_PointerTott__WhiteBalanceOptions20Extension(soap, &this->tt__WhiteBalanceOptions20::Extension);
	/* transient soap skipped */
}

int tt__WhiteBalanceOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalanceOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceOptions20(struct soap *soap, const char *tag, int id, const tt__WhiteBalanceOptions20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalanceOptions20), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__WhiteBalanceMode(soap, "tt:Mode", -1, &(a->tt__WhiteBalanceOptions20::Mode), ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:YrGain", -1, &(a->tt__WhiteBalanceOptions20::YrGain), ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:YbGain", -1, &(a->tt__WhiteBalanceOptions20::YbGain), ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalanceOptions20Extension(soap, "tt:Extension", -1, &(a->tt__WhiteBalanceOptions20::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__WhiteBalanceOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__WhiteBalanceOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20 * SOAP_FMAC4 soap_in_tt__WhiteBalanceOptions20(struct soap *soap, const char *tag, tt__WhiteBalanceOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WhiteBalanceOptions20 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceOptions20, sizeof(tt__WhiteBalanceOptions20), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__WhiteBalanceOptions20)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__WhiteBalanceOptions20 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_YrGain1 = 1;
	size_t soap_flag_YbGain1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftt__WhiteBalanceMode(soap, "tt:Mode", &(a->tt__WhiteBalanceOptions20::Mode), "tt:WhiteBalanceMode"))
					continue;
			if (soap_flag_YrGain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:YrGain", &(a->tt__WhiteBalanceOptions20::YrGain), "tt:FloatRange"))
				{	soap_flag_YrGain1--;
					continue;
				}
			if (soap_flag_YbGain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:YbGain", &(a->tt__WhiteBalanceOptions20::YbGain), "tt:FloatRange"))
				{	soap_flag_YbGain1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WhiteBalanceOptions20Extension(soap, "tt:Extension", &(a->tt__WhiteBalanceOptions20::Extension), "tt:WhiteBalanceOptions20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__WhiteBalanceOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceOptions20, 0, sizeof(tt__WhiteBalanceOptions20), 0, soap_copy_tt__WhiteBalanceOptions20);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__WhiteBalanceOptions20::Mode.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__WhiteBalanceOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__WhiteBalanceOptions20);
	if (this->soap_out(soap, tag?tag:"tt:WhiteBalanceOptions20", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalanceOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalanceOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20 * SOAP_FMAC4 soap_get_tt__WhiteBalanceOptions20(struct soap *soap, tt__WhiteBalanceOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__WhiteBalanceOptions20 * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WhiteBalanceOptions20(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__WhiteBalanceOptions20, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__WhiteBalanceOptions20);
		if (size)
			*size = sizeof(tt__WhiteBalanceOptions20);
		((tt__WhiteBalanceOptions20*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__WhiteBalanceOptions20[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__WhiteBalanceOptions20);
		for (int i = 0; i < n; i++)
			((tt__WhiteBalanceOptions20*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__WhiteBalanceOptions20*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__WhiteBalanceOptions20(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__WhiteBalanceOptions20 %p -> %p\n", q, p));
	*(tt__WhiteBalanceOptions20*)p = *(tt__WhiteBalanceOptions20*)q;
}

void tt__FocusConfiguration20Extension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FocusConfiguration20Extension::__any);
	/* transient soap skipped */
}

void tt__FocusConfiguration20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FocusConfiguration20Extension::__any);
	/* transient soap skipped */
}

int tt__FocusConfiguration20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusConfiguration20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusConfiguration20Extension(struct soap *soap, const char *tag, int id, const tt__FocusConfiguration20Extension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusConfiguration20Extension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__FocusConfiguration20Extension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__FocusConfiguration20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__FocusConfiguration20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusConfiguration20Extension * SOAP_FMAC4 soap_in_tt__FocusConfiguration20Extension(struct soap *soap, const char *tag, tt__FocusConfiguration20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusConfiguration20Extension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(tt__FocusConfiguration20Extension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__FocusConfiguration20Extension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__FocusConfiguration20Extension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__FocusConfiguration20Extension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusConfiguration20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusConfiguration20Extension, 0, sizeof(tt__FocusConfiguration20Extension), 0, soap_copy_tt__FocusConfiguration20Extension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__FocusConfiguration20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__FocusConfiguration20Extension);
	if (this->soap_out(soap, tag?tag:"tt:FocusConfiguration20Extension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusConfiguration20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusConfiguration20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusConfiguration20Extension * SOAP_FMAC4 soap_get_tt__FocusConfiguration20Extension(struct soap *soap, tt__FocusConfiguration20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusConfiguration20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__FocusConfiguration20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusConfiguration20Extension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__FocusConfiguration20Extension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__FocusConfiguration20Extension);
		if (size)
			*size = sizeof(tt__FocusConfiguration20Extension);
		((tt__FocusConfiguration20Extension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__FocusConfiguration20Extension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__FocusConfiguration20Extension);
		for (int i = 0; i < n; i++)
			((tt__FocusConfiguration20Extension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__FocusConfiguration20Extension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__FocusConfiguration20Extension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__FocusConfiguration20Extension %p -> %p\n", q, p));
	*(tt__FocusConfiguration20Extension*)p = *(tt__FocusConfiguration20Extension*)q;
}

void tt__FocusConfiguration20::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__AutoFocusMode(soap, &this->tt__FocusConfiguration20::AutoFocusMode);
	this->tt__FocusConfiguration20::DefaultSpeed = NULL;
	this->tt__FocusConfiguration20::NearLimit = NULL;
	this->tt__FocusConfiguration20::FarLimit = NULL;
	this->tt__FocusConfiguration20::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__FocusConfiguration20::__anyAttribute);
	/* transient soap skipped */
}

void tt__FocusConfiguration20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofloat(soap, &this->tt__FocusConfiguration20::DefaultSpeed);
	soap_serialize_PointerTofloat(soap, &this->tt__FocusConfiguration20::NearLimit);
	soap_serialize_PointerTofloat(soap, &this->tt__FocusConfiguration20::FarLimit);
	soap_serialize_PointerTott__FocusConfiguration20Extension(soap, &this->tt__FocusConfiguration20::Extension);
	/* transient soap skipped */
}

int tt__FocusConfiguration20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusConfiguration20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusConfiguration20(struct soap *soap, const char *tag, int id, const tt__FocusConfiguration20 *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__FocusConfiguration20*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusConfiguration20), type))
		return soap->error;
	if (soap_out_tt__AutoFocusMode(soap, "tt:AutoFocusMode", -1, &(a->tt__FocusConfiguration20::AutoFocusMode), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:DefaultSpeed", -1, &(a->tt__FocusConfiguration20::DefaultSpeed), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:NearLimit", -1, &(a->tt__FocusConfiguration20::NearLimit), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:FarLimit", -1, &(a->tt__FocusConfiguration20::FarLimit), ""))
		return soap->error;
	if (a->tt__FocusConfiguration20::Extension)
	{	if (soap_out_PointerTott__FocusConfiguration20Extension(soap, "tt:Extension", -1, &a->tt__FocusConfiguration20::Extension, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Extension"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__FocusConfiguration20::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__FocusConfiguration20(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusConfiguration20 * SOAP_FMAC4 soap_in_tt__FocusConfiguration20(struct soap *soap, const char *tag, tt__FocusConfiguration20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusConfiguration20 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration20, sizeof(tt__FocusConfiguration20), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__FocusConfiguration20)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__FocusConfiguration20 *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__FocusConfiguration20*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_AutoFocusMode1 = 1;
	size_t soap_flag_DefaultSpeed1 = 1;
	size_t soap_flag_NearLimit1 = 1;
	size_t soap_flag_FarLimit1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoFocusMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__AutoFocusMode(soap, "tt:AutoFocusMode", &(a->tt__FocusConfiguration20::AutoFocusMode), "tt:AutoFocusMode"))
				{	soap_flag_AutoFocusMode1--;
					continue;
				}
			if (soap_flag_DefaultSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:DefaultSpeed", &(a->tt__FocusConfiguration20::DefaultSpeed), "xsd:float"))
				{	soap_flag_DefaultSpeed1--;
					continue;
				}
			if (soap_flag_NearLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:NearLimit", &(a->tt__FocusConfiguration20::NearLimit), "xsd:float"))
				{	soap_flag_NearLimit1--;
					continue;
				}
			if (soap_flag_FarLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:FarLimit", &(a->tt__FocusConfiguration20::FarLimit), "xsd:float"))
				{	soap_flag_FarLimit1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusConfiguration20Extension(soap, "tt:Extension", &(a->tt__FocusConfiguration20::Extension), "tt:FocusConfiguration20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusConfiguration20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusConfiguration20, 0, sizeof(tt__FocusConfiguration20), 0, soap_copy_tt__FocusConfiguration20);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoFocusMode1 > 0 || soap_flag_Extension1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__FocusConfiguration20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__FocusConfiguration20);
	if (this->soap_out(soap, tag?tag:"tt:FocusConfiguration20", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusConfiguration20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusConfiguration20(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusConfiguration20 * SOAP_FMAC4 soap_get_tt__FocusConfiguration20(struct soap *soap, tt__FocusConfiguration20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusConfiguration20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__FocusConfiguration20 * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusConfiguration20(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__FocusConfiguration20, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__FocusConfiguration20);
		if (size)
			*size = sizeof(tt__FocusConfiguration20);
		((tt__FocusConfiguration20*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__FocusConfiguration20[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__FocusConfiguration20);
		for (int i = 0; i < n; i++)
			((tt__FocusConfiguration20*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__FocusConfiguration20*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__FocusConfiguration20(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__FocusConfiguration20 %p -> %p\n", q, p));
	*(tt__FocusConfiguration20*)p = *(tt__FocusConfiguration20*)q;
}

void tt__WhiteBalance20Extension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__WhiteBalance20Extension::__any);
	/* transient soap skipped */
}

void tt__WhiteBalance20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__WhiteBalance20Extension::__any);
	/* transient soap skipped */
}

int tt__WhiteBalance20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalance20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalance20Extension(struct soap *soap, const char *tag, int id, const tt__WhiteBalance20Extension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalance20Extension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__WhiteBalance20Extension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__WhiteBalance20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__WhiteBalance20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalance20Extension * SOAP_FMAC4 soap_in_tt__WhiteBalance20Extension(struct soap *soap, const char *tag, tt__WhiteBalance20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WhiteBalance20Extension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(tt__WhiteBalance20Extension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__WhiteBalance20Extension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__WhiteBalance20Extension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__WhiteBalance20Extension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__WhiteBalance20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalance20Extension, 0, sizeof(tt__WhiteBalance20Extension), 0, soap_copy_tt__WhiteBalance20Extension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__WhiteBalance20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__WhiteBalance20Extension);
	if (this->soap_out(soap, tag?tag:"tt:WhiteBalance20Extension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalance20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalance20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalance20Extension * SOAP_FMAC4 soap_get_tt__WhiteBalance20Extension(struct soap *soap, tt__WhiteBalance20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalance20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__WhiteBalance20Extension * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WhiteBalance20Extension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__WhiteBalance20Extension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__WhiteBalance20Extension);
		if (size)
			*size = sizeof(tt__WhiteBalance20Extension);
		((tt__WhiteBalance20Extension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__WhiteBalance20Extension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__WhiteBalance20Extension);
		for (int i = 0; i < n; i++)
			((tt__WhiteBalance20Extension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__WhiteBalance20Extension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__WhiteBalance20Extension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__WhiteBalance20Extension %p -> %p\n", q, p));
	*(tt__WhiteBalance20Extension*)p = *(tt__WhiteBalance20Extension*)q;
}

void tt__WhiteBalance20::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__WhiteBalanceMode(soap, &this->tt__WhiteBalance20::Mode);
	this->tt__WhiteBalance20::CrGain = NULL;
	this->tt__WhiteBalance20::CbGain = NULL;
	this->tt__WhiteBalance20::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__WhiteBalance20::__anyAttribute);
	/* transient soap skipped */
}

void tt__WhiteBalance20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofloat(soap, &this->tt__WhiteBalance20::CrGain);
	soap_serialize_PointerTofloat(soap, &this->tt__WhiteBalance20::CbGain);
	soap_serialize_PointerTott__WhiteBalance20Extension(soap, &this->tt__WhiteBalance20::Extension);
	/* transient soap skipped */
}

int tt__WhiteBalance20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalance20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalance20(struct soap *soap, const char *tag, int id, const tt__WhiteBalance20 *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__WhiteBalance20*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalance20), type))
		return soap->error;
	if (soap_out_tt__WhiteBalanceMode(soap, "tt:Mode", -1, &(a->tt__WhiteBalance20::Mode), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:CrGain", -1, &(a->tt__WhiteBalance20::CrGain), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:CbGain", -1, &(a->tt__WhiteBalance20::CbGain), ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalance20Extension(soap, "tt:Extension", -1, &(a->tt__WhiteBalance20::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__WhiteBalance20::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__WhiteBalance20(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalance20 * SOAP_FMAC4 soap_in_tt__WhiteBalance20(struct soap *soap, const char *tag, tt__WhiteBalance20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WhiteBalance20 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance20, sizeof(tt__WhiteBalance20), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__WhiteBalance20)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__WhiteBalance20 *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__WhiteBalance20*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_CrGain1 = 1;
	size_t soap_flag_CbGain1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__WhiteBalanceMode(soap, "tt:Mode", &(a->tt__WhiteBalance20::Mode), "tt:WhiteBalanceMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			if (soap_flag_CrGain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:CrGain", &(a->tt__WhiteBalance20::CrGain), "xsd:float"))
				{	soap_flag_CrGain1--;
					continue;
				}
			if (soap_flag_CbGain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:CbGain", &(a->tt__WhiteBalance20::CbGain), "xsd:float"))
				{	soap_flag_CbGain1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WhiteBalance20Extension(soap, "tt:Extension", &(a->tt__WhiteBalance20::Extension), "tt:WhiteBalance20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__WhiteBalance20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalance20, 0, sizeof(tt__WhiteBalance20), 0, soap_copy_tt__WhiteBalance20);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__WhiteBalance20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__WhiteBalance20);
	if (this->soap_out(soap, tag?tag:"tt:WhiteBalance20", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalance20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalance20(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalance20 * SOAP_FMAC4 soap_get_tt__WhiteBalance20(struct soap *soap, tt__WhiteBalance20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalance20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__WhiteBalance20 * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WhiteBalance20(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__WhiteBalance20, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__WhiteBalance20);
		if (size)
			*size = sizeof(tt__WhiteBalance20);
		((tt__WhiteBalance20*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__WhiteBalance20[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__WhiteBalance20);
		for (int i = 0; i < n; i++)
			((tt__WhiteBalance20*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__WhiteBalance20*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__WhiteBalance20(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__WhiteBalance20 %p -> %p\n", q, p));
	*(tt__WhiteBalance20*)p = *(tt__WhiteBalance20*)q;
}

void tt__RelativeFocusOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__RelativeFocusOptions20::Distance = NULL;
	this->tt__RelativeFocusOptions20::Speed = NULL;
	/* transient soap skipped */
}

void tt__RelativeFocusOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__RelativeFocusOptions20::Distance);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__RelativeFocusOptions20::Speed);
	/* transient soap skipped */
}

int tt__RelativeFocusOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RelativeFocusOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelativeFocusOptions20(struct soap *soap, const char *tag, int id, const tt__RelativeFocusOptions20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelativeFocusOptions20), type))
		return soap->error;
	if (a->tt__RelativeFocusOptions20::Distance)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Distance", -1, &a->tt__RelativeFocusOptions20::Distance, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Distance"))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &(a->tt__RelativeFocusOptions20::Speed), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__RelativeFocusOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__RelativeFocusOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__RelativeFocusOptions20 * SOAP_FMAC4 soap_in_tt__RelativeFocusOptions20(struct soap *soap, const char *tag, tt__RelativeFocusOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RelativeFocusOptions20 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelativeFocusOptions20, sizeof(tt__RelativeFocusOptions20), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__RelativeFocusOptions20)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__RelativeFocusOptions20 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Distance1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Distance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Distance", &(a->tt__RelativeFocusOptions20::Distance), "tt:FloatRange"))
				{	soap_flag_Distance1--;
					continue;
				}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &(a->tt__RelativeFocusOptions20::Speed), "tt:FloatRange"))
				{	soap_flag_Speed1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RelativeFocusOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelativeFocusOptions20, 0, sizeof(tt__RelativeFocusOptions20), 0, soap_copy_tt__RelativeFocusOptions20);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Distance1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__RelativeFocusOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__RelativeFocusOptions20);
	if (this->soap_out(soap, tag?tag:"tt:RelativeFocusOptions20", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RelativeFocusOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RelativeFocusOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__RelativeFocusOptions20 * SOAP_FMAC4 soap_get_tt__RelativeFocusOptions20(struct soap *soap, tt__RelativeFocusOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelativeFocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__RelativeFocusOptions20 * SOAP_FMAC2 soap_instantiate_tt__RelativeFocusOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RelativeFocusOptions20(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__RelativeFocusOptions20, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__RelativeFocusOptions20);
		if (size)
			*size = sizeof(tt__RelativeFocusOptions20);
		((tt__RelativeFocusOptions20*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__RelativeFocusOptions20[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__RelativeFocusOptions20);
		for (int i = 0; i < n; i++)
			((tt__RelativeFocusOptions20*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__RelativeFocusOptions20*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__RelativeFocusOptions20(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__RelativeFocusOptions20 %p -> %p\n", q, p));
	*(tt__RelativeFocusOptions20*)p = *(tt__RelativeFocusOptions20*)q;
}

void tt__MoveOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__MoveOptions20::Absolute = NULL;
	this->tt__MoveOptions20::Relative = NULL;
	this->tt__MoveOptions20::Continuous = NULL;
	/* transient soap skipped */
}

void tt__MoveOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AbsoluteFocusOptions(soap, &this->tt__MoveOptions20::Absolute);
	soap_serialize_PointerTott__RelativeFocusOptions20(soap, &this->tt__MoveOptions20::Relative);
	soap_serialize_PointerTott__ContinuousFocusOptions(soap, &this->tt__MoveOptions20::Continuous);
	/* transient soap skipped */
}

int tt__MoveOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MoveOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MoveOptions20(struct soap *soap, const char *tag, int id, const tt__MoveOptions20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MoveOptions20), type))
		return soap->error;
	if (soap_out_PointerTott__AbsoluteFocusOptions(soap, "tt:Absolute", -1, &(a->tt__MoveOptions20::Absolute), ""))
		return soap->error;
	if (soap_out_PointerTott__RelativeFocusOptions20(soap, "tt:Relative", -1, &(a->tt__MoveOptions20::Relative), ""))
		return soap->error;
	if (soap_out_PointerTott__ContinuousFocusOptions(soap, "tt:Continuous", -1, &(a->tt__MoveOptions20::Continuous), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__MoveOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__MoveOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__MoveOptions20 * SOAP_FMAC4 soap_in_tt__MoveOptions20(struct soap *soap, const char *tag, tt__MoveOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MoveOptions20 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MoveOptions20, sizeof(tt__MoveOptions20), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__MoveOptions20)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__MoveOptions20 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Absolute1 = 1;
	size_t soap_flag_Relative1 = 1;
	size_t soap_flag_Continuous1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Absolute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AbsoluteFocusOptions(soap, "tt:Absolute", &(a->tt__MoveOptions20::Absolute), "tt:AbsoluteFocusOptions"))
				{	soap_flag_Absolute1--;
					continue;
				}
			if (soap_flag_Relative1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RelativeFocusOptions20(soap, "tt:Relative", &(a->tt__MoveOptions20::Relative), "tt:RelativeFocusOptions20"))
				{	soap_flag_Relative1--;
					continue;
				}
			if (soap_flag_Continuous1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ContinuousFocusOptions(soap, "tt:Continuous", &(a->tt__MoveOptions20::Continuous), "tt:ContinuousFocusOptions"))
				{	soap_flag_Continuous1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MoveOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MoveOptions20, 0, sizeof(tt__MoveOptions20), 0, soap_copy_tt__MoveOptions20);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__MoveOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__MoveOptions20);
	if (this->soap_out(soap, tag?tag:"tt:MoveOptions20", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MoveOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MoveOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__MoveOptions20 * SOAP_FMAC4 soap_get_tt__MoveOptions20(struct soap *soap, tt__MoveOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MoveOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__MoveOptions20 * SOAP_FMAC2 soap_instantiate_tt__MoveOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MoveOptions20(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__MoveOptions20, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__MoveOptions20);
		if (size)
			*size = sizeof(tt__MoveOptions20);
		((tt__MoveOptions20*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__MoveOptions20[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__MoveOptions20);
		for (int i = 0; i < n; i++)
			((tt__MoveOptions20*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__MoveOptions20*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__MoveOptions20(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__MoveOptions20 %p -> %p\n", q, p));
	*(tt__MoveOptions20*)p = *(tt__MoveOptions20*)q;
}

void tt__ExposureOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__ExposureMode(soap, &this->tt__ExposureOptions20::Mode);
	soap_default_std__vectorTemplateOftt__ExposurePriority(soap, &this->tt__ExposureOptions20::Priority);
	this->tt__ExposureOptions20::MinExposureTime = NULL;
	this->tt__ExposureOptions20::MaxExposureTime = NULL;
	this->tt__ExposureOptions20::MinGain = NULL;
	this->tt__ExposureOptions20::MaxGain = NULL;
	this->tt__ExposureOptions20::MinIris = NULL;
	this->tt__ExposureOptions20::MaxIris = NULL;
	this->tt__ExposureOptions20::ExposureTime = NULL;
	this->tt__ExposureOptions20::Gain = NULL;
	this->tt__ExposureOptions20::Iris = NULL;
	/* transient soap skipped */
}

void tt__ExposureOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOftt__ExposureMode(soap, &this->tt__ExposureOptions20::Mode);
	soap_serialize_std__vectorTemplateOftt__ExposurePriority(soap, &this->tt__ExposureOptions20::Priority);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MinExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MaxExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MinGain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MaxGain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MinIris);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MaxIris);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::ExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::Gain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::Iris);
	/* transient soap skipped */
}

int tt__ExposureOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ExposureOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposureOptions20(struct soap *soap, const char *tag, int id, const tt__ExposureOptions20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ExposureOptions20), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ExposureMode(soap, "tt:Mode", -1, &(a->tt__ExposureOptions20::Mode), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ExposurePriority(soap, "tt:Priority", -1, &(a->tt__ExposureOptions20::Priority), ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MinExposureTime", -1, &(a->tt__ExposureOptions20::MinExposureTime), ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxExposureTime", -1, &(a->tt__ExposureOptions20::MaxExposureTime), ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MinGain", -1, &(a->tt__ExposureOptions20::MinGain), ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxGain", -1, &(a->tt__ExposureOptions20::MaxGain), ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MinIris", -1, &(a->tt__ExposureOptions20::MinIris), ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxIris", -1, &(a->tt__ExposureOptions20::MaxIris), ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:ExposureTime", -1, &(a->tt__ExposureOptions20::ExposureTime), ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Gain", -1, &(a->tt__ExposureOptions20::Gain), ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Iris", -1, &(a->tt__ExposureOptions20::Iris), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ExposureOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ExposureOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__ExposureOptions20 * SOAP_FMAC4 soap_in_tt__ExposureOptions20(struct soap *soap, const char *tag, tt__ExposureOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ExposureOptions20 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposureOptions20, sizeof(tt__ExposureOptions20), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ExposureOptions20)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ExposureOptions20 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_MinExposureTime1 = 1;
	size_t soap_flag_MaxExposureTime1 = 1;
	size_t soap_flag_MinGain1 = 1;
	size_t soap_flag_MaxGain1 = 1;
	size_t soap_flag_MinIris1 = 1;
	size_t soap_flag_MaxIris1 = 1;
	size_t soap_flag_ExposureTime1 = 1;
	size_t soap_flag_Gain1 = 1;
	size_t soap_flag_Iris1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftt__ExposureMode(soap, "tt:Mode", &(a->tt__ExposureOptions20::Mode), "tt:ExposureMode"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftt__ExposurePriority(soap, "tt:Priority", &(a->tt__ExposureOptions20::Priority), "tt:ExposurePriority"))
					continue;
			if (soap_flag_MinExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MinExposureTime", &(a->tt__ExposureOptions20::MinExposureTime), "tt:FloatRange"))
				{	soap_flag_MinExposureTime1--;
					continue;
				}
			if (soap_flag_MaxExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MaxExposureTime", &(a->tt__ExposureOptions20::MaxExposureTime), "tt:FloatRange"))
				{	soap_flag_MaxExposureTime1--;
					continue;
				}
			if (soap_flag_MinGain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MinGain", &(a->tt__ExposureOptions20::MinGain), "tt:FloatRange"))
				{	soap_flag_MinGain1--;
					continue;
				}
			if (soap_flag_MaxGain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MaxGain", &(a->tt__ExposureOptions20::MaxGain), "tt:FloatRange"))
				{	soap_flag_MaxGain1--;
					continue;
				}
			if (soap_flag_MinIris1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MinIris", &(a->tt__ExposureOptions20::MinIris), "tt:FloatRange"))
				{	soap_flag_MinIris1--;
					continue;
				}
			if (soap_flag_MaxIris1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MaxIris", &(a->tt__ExposureOptions20::MaxIris), "tt:FloatRange"))
				{	soap_flag_MaxIris1--;
					continue;
				}
			if (soap_flag_ExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:ExposureTime", &(a->tt__ExposureOptions20::ExposureTime), "tt:FloatRange"))
				{	soap_flag_ExposureTime1--;
					continue;
				}
			if (soap_flag_Gain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Gain", &(a->tt__ExposureOptions20::Gain), "tt:FloatRange"))
				{	soap_flag_Gain1--;
					continue;
				}
			if (soap_flag_Iris1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Iris", &(a->tt__ExposureOptions20::Iris), "tt:FloatRange"))
				{	soap_flag_Iris1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ExposureOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposureOptions20, 0, sizeof(tt__ExposureOptions20), 0, soap_copy_tt__ExposureOptions20);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__ExposureOptions20::Mode.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__ExposureOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ExposureOptions20);
	if (this->soap_out(soap, tag?tag:"tt:ExposureOptions20", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ExposureOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ExposureOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__ExposureOptions20 * SOAP_FMAC4 soap_get_tt__ExposureOptions20(struct soap *soap, tt__ExposureOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposureOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ExposureOptions20 * SOAP_FMAC2 soap_instantiate_tt__ExposureOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ExposureOptions20(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ExposureOptions20, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ExposureOptions20);
		if (size)
			*size = sizeof(tt__ExposureOptions20);
		((tt__ExposureOptions20*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ExposureOptions20[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ExposureOptions20);
		for (int i = 0; i < n; i++)
			((tt__ExposureOptions20*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ExposureOptions20*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ExposureOptions20(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ExposureOptions20 %p -> %p\n", q, p));
	*(tt__ExposureOptions20*)p = *(tt__ExposureOptions20*)q;
}

void tt__BacklightCompensationOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__BacklightCompensationMode(soap, &this->tt__BacklightCompensationOptions20::Mode);
	this->tt__BacklightCompensationOptions20::Level = NULL;
	/* transient soap skipped */
}

void tt__BacklightCompensationOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOftt__BacklightCompensationMode(soap, &this->tt__BacklightCompensationOptions20::Mode);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__BacklightCompensationOptions20::Level);
	/* transient soap skipped */
}

int tt__BacklightCompensationOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BacklightCompensationOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensationOptions20(struct soap *soap, const char *tag, int id, const tt__BacklightCompensationOptions20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensationOptions20), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__BacklightCompensationMode(soap, "tt:Mode", -1, &(a->tt__BacklightCompensationOptions20::Mode), ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &(a->tt__BacklightCompensationOptions20::Level), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__BacklightCompensationOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__BacklightCompensationOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__BacklightCompensationOptions20 * SOAP_FMAC4 soap_in_tt__BacklightCompensationOptions20(struct soap *soap, const char *tag, tt__BacklightCompensationOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__BacklightCompensationOptions20 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensationOptions20, sizeof(tt__BacklightCompensationOptions20), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__BacklightCompensationOptions20)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__BacklightCompensationOptions20 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Level1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftt__BacklightCompensationMode(soap, "tt:Mode", &(a->tt__BacklightCompensationOptions20::Mode), "tt:BacklightCompensationMode"))
					continue;
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &(a->tt__BacklightCompensationOptions20::Level), "tt:FloatRange"))
				{	soap_flag_Level1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__BacklightCompensationOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensationOptions20, 0, sizeof(tt__BacklightCompensationOptions20), 0, soap_copy_tt__BacklightCompensationOptions20);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__BacklightCompensationOptions20::Mode.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__BacklightCompensationOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__BacklightCompensationOptions20);
	if (this->soap_out(soap, tag?tag:"tt:BacklightCompensationOptions20", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BacklightCompensationOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BacklightCompensationOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__BacklightCompensationOptions20 * SOAP_FMAC4 soap_get_tt__BacklightCompensationOptions20(struct soap *soap, tt__BacklightCompensationOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensationOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__BacklightCompensationOptions20 * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensationOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__BacklightCompensationOptions20(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__BacklightCompensationOptions20, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__BacklightCompensationOptions20);
		if (size)
			*size = sizeof(tt__BacklightCompensationOptions20);
		((tt__BacklightCompensationOptions20*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__BacklightCompensationOptions20[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__BacklightCompensationOptions20);
		for (int i = 0; i < n; i++)
			((tt__BacklightCompensationOptions20*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__BacklightCompensationOptions20*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__BacklightCompensationOptions20(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__BacklightCompensationOptions20 %p -> %p\n", q, p));
	*(tt__BacklightCompensationOptions20*)p = *(tt__BacklightCompensationOptions20*)q;
}

void tt__WideDynamicRangeOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__WideDynamicMode(soap, &this->tt__WideDynamicRangeOptions20::Mode);
	this->tt__WideDynamicRangeOptions20::Level = NULL;
	/* transient soap skipped */
}

void tt__WideDynamicRangeOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOftt__WideDynamicMode(soap, &this->tt__WideDynamicRangeOptions20::Mode);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__WideDynamicRangeOptions20::Level);
	/* transient soap skipped */
}

int tt__WideDynamicRangeOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WideDynamicRangeOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRangeOptions20(struct soap *soap, const char *tag, int id, const tt__WideDynamicRangeOptions20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRangeOptions20), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__WideDynamicMode(soap, "tt:Mode", -1, &(a->tt__WideDynamicRangeOptions20::Mode), ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &(a->tt__WideDynamicRangeOptions20::Level), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__WideDynamicRangeOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__WideDynamicRangeOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__WideDynamicRangeOptions20 * SOAP_FMAC4 soap_in_tt__WideDynamicRangeOptions20(struct soap *soap, const char *tag, tt__WideDynamicRangeOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WideDynamicRangeOptions20 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRangeOptions20, sizeof(tt__WideDynamicRangeOptions20), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__WideDynamicRangeOptions20)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__WideDynamicRangeOptions20 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Level1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftt__WideDynamicMode(soap, "tt:Mode", &(a->tt__WideDynamicRangeOptions20::Mode), "tt:WideDynamicMode"))
					continue;
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &(a->tt__WideDynamicRangeOptions20::Level), "tt:FloatRange"))
				{	soap_flag_Level1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__WideDynamicRangeOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRangeOptions20, 0, sizeof(tt__WideDynamicRangeOptions20), 0, soap_copy_tt__WideDynamicRangeOptions20);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__WideDynamicRangeOptions20::Mode.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__WideDynamicRangeOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__WideDynamicRangeOptions20);
	if (this->soap_out(soap, tag?tag:"tt:WideDynamicRangeOptions20", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WideDynamicRangeOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WideDynamicRangeOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__WideDynamicRangeOptions20 * SOAP_FMAC4 soap_get_tt__WideDynamicRangeOptions20(struct soap *soap, tt__WideDynamicRangeOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRangeOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__WideDynamicRangeOptions20 * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRangeOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WideDynamicRangeOptions20(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__WideDynamicRangeOptions20, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__WideDynamicRangeOptions20);
		if (size)
			*size = sizeof(tt__WideDynamicRangeOptions20);
		((tt__WideDynamicRangeOptions20*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__WideDynamicRangeOptions20[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__WideDynamicRangeOptions20);
		for (int i = 0; i < n; i++)
			((tt__WideDynamicRangeOptions20*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__WideDynamicRangeOptions20*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__WideDynamicRangeOptions20(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__WideDynamicRangeOptions20 %p -> %p\n", q, p));
	*(tt__WideDynamicRangeOptions20*)p = *(tt__WideDynamicRangeOptions20*)q;
}

void tt__ImagingOptions20Extension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingOptions20Extension::__any);
	/* transient soap skipped */
}

void tt__ImagingOptions20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingOptions20Extension::__any);
	/* transient soap skipped */
}

int tt__ImagingOptions20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingOptions20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension(struct soap *soap, const char *tag, int id, const tt__ImagingOptions20Extension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20Extension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__ImagingOptions20Extension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingOptions20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ImagingOptions20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension(struct soap *soap, const char *tag, tt__ImagingOptions20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingOptions20Extension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension, sizeof(tt__ImagingOptions20Extension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ImagingOptions20Extension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ImagingOptions20Extension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__ImagingOptions20Extension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension, 0, sizeof(tt__ImagingOptions20Extension), 0, soap_copy_tt__ImagingOptions20Extension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ImagingOptions20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ImagingOptions20Extension);
	if (this->soap_out(soap, tag?tag:"tt:ImagingOptions20Extension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingOptions20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingOptions20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension(struct soap *soap, tt__ImagingOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ImagingOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingOptions20Extension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ImagingOptions20Extension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ImagingOptions20Extension);
		if (size)
			*size = sizeof(tt__ImagingOptions20Extension);
		((tt__ImagingOptions20Extension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ImagingOptions20Extension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ImagingOptions20Extension);
		for (int i = 0; i < n; i++)
			((tt__ImagingOptions20Extension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ImagingOptions20Extension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ImagingOptions20Extension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ImagingOptions20Extension %p -> %p\n", q, p));
	*(tt__ImagingOptions20Extension*)p = *(tt__ImagingOptions20Extension*)q;
}

void tt__ImagingOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ImagingOptions20::BacklightCompensation = NULL;
	this->tt__ImagingOptions20::Brightness = NULL;
	this->tt__ImagingOptions20::ColorSaturation = NULL;
	this->tt__ImagingOptions20::Contrast = NULL;
	this->tt__ImagingOptions20::Exposure = NULL;
	this->tt__ImagingOptions20::Focus = NULL;
	soap_default_std__vectorTemplateOftt__IrCutFilterMode(soap, &this->tt__ImagingOptions20::IrCutFilterModes);
	this->tt__ImagingOptions20::Sharpness = NULL;
	this->tt__ImagingOptions20::WideDynamicRange = NULL;
	this->tt__ImagingOptions20::WhiteBalance = NULL;
	this->tt__ImagingOptions20::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ImagingOptions20::__anyAttribute);
	/* transient soap skipped */
}

void tt__ImagingOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__BacklightCompensationOptions20(soap, &this->tt__ImagingOptions20::BacklightCompensation);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions20::Brightness);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions20::ColorSaturation);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions20::Contrast);
	soap_serialize_PointerTott__ExposureOptions20(soap, &this->tt__ImagingOptions20::Exposure);
	soap_serialize_PointerTott__FocusOptions20(soap, &this->tt__ImagingOptions20::Focus);
	soap_serialize_std__vectorTemplateOftt__IrCutFilterMode(soap, &this->tt__ImagingOptions20::IrCutFilterModes);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions20::Sharpness);
	soap_serialize_PointerTott__WideDynamicRangeOptions20(soap, &this->tt__ImagingOptions20::WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalanceOptions20(soap, &this->tt__ImagingOptions20::WhiteBalance);
	soap_serialize_PointerTott__ImagingOptions20Extension(soap, &this->tt__ImagingOptions20::Extension);
	/* transient soap skipped */
}

int tt__ImagingOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20(struct soap *soap, const char *tag, int id, const tt__ImagingOptions20 *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ImagingOptions20*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20), type))
		return soap->error;
	if (soap_out_PointerTott__BacklightCompensationOptions20(soap, "tt:BacklightCompensation", -1, &(a->tt__ImagingOptions20::BacklightCompensation), ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Brightness", -1, &(a->tt__ImagingOptions20::Brightness), ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:ColorSaturation", -1, &(a->tt__ImagingOptions20::ColorSaturation), ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Contrast", -1, &(a->tt__ImagingOptions20::Contrast), ""))
		return soap->error;
	if (soap_out_PointerTott__ExposureOptions20(soap, "tt:Exposure", -1, &(a->tt__ImagingOptions20::Exposure), ""))
		return soap->error;
	if (soap_out_PointerTott__FocusOptions20(soap, "tt:Focus", -1, &(a->tt__ImagingOptions20::Focus), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IrCutFilterMode(soap, "tt:IrCutFilterModes", -1, &(a->tt__ImagingOptions20::IrCutFilterModes), ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Sharpness", -1, &(a->tt__ImagingOptions20::Sharpness), ""))
		return soap->error;
	if (soap_out_PointerTott__WideDynamicRangeOptions20(soap, "tt:WideDynamicRange", -1, &(a->tt__ImagingOptions20::WideDynamicRange), ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalanceOptions20(soap, "tt:WhiteBalance", -1, &(a->tt__ImagingOptions20::WhiteBalance), ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingOptions20Extension(soap, "tt:Extension", -1, &(a->tt__ImagingOptions20::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ImagingOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingOptions20 * SOAP_FMAC4 soap_in_tt__ImagingOptions20(struct soap *soap, const char *tag, tt__ImagingOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingOptions20 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20, sizeof(tt__ImagingOptions20), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ImagingOptions20)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ImagingOptions20 *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ImagingOptions20*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_BacklightCompensation1 = 1;
	size_t soap_flag_Brightness1 = 1;
	size_t soap_flag_ColorSaturation1 = 1;
	size_t soap_flag_Contrast1 = 1;
	size_t soap_flag_Exposure1 = 1;
	size_t soap_flag_Focus1 = 1;
	size_t soap_flag_Sharpness1 = 1;
	size_t soap_flag_WideDynamicRange1 = 1;
	size_t soap_flag_WhiteBalance1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BacklightCompensationOptions20(soap, "tt:BacklightCompensation", &(a->tt__ImagingOptions20::BacklightCompensation), "tt:BacklightCompensationOptions20"))
				{	soap_flag_BacklightCompensation1--;
					continue;
				}
			if (soap_flag_Brightness1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Brightness", &(a->tt__ImagingOptions20::Brightness), "tt:FloatRange"))
				{	soap_flag_Brightness1--;
					continue;
				}
			if (soap_flag_ColorSaturation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:ColorSaturation", &(a->tt__ImagingOptions20::ColorSaturation), "tt:FloatRange"))
				{	soap_flag_ColorSaturation1--;
					continue;
				}
			if (soap_flag_Contrast1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Contrast", &(a->tt__ImagingOptions20::Contrast), "tt:FloatRange"))
				{	soap_flag_Contrast1--;
					continue;
				}
			if (soap_flag_Exposure1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ExposureOptions20(soap, "tt:Exposure", &(a->tt__ImagingOptions20::Exposure), "tt:ExposureOptions20"))
				{	soap_flag_Exposure1--;
					continue;
				}
			if (soap_flag_Focus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusOptions20(soap, "tt:Focus", &(a->tt__ImagingOptions20::Focus), "tt:FocusOptions20"))
				{	soap_flag_Focus1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftt__IrCutFilterMode(soap, "tt:IrCutFilterModes", &(a->tt__ImagingOptions20::IrCutFilterModes), "tt:IrCutFilterMode"))
					continue;
			if (soap_flag_Sharpness1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Sharpness", &(a->tt__ImagingOptions20::Sharpness), "tt:FloatRange"))
				{	soap_flag_Sharpness1--;
					continue;
				}
			if (soap_flag_WideDynamicRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WideDynamicRangeOptions20(soap, "tt:WideDynamicRange", &(a->tt__ImagingOptions20::WideDynamicRange), "tt:WideDynamicRangeOptions20"))
				{	soap_flag_WideDynamicRange1--;
					continue;
				}
			if (soap_flag_WhiteBalance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WhiteBalanceOptions20(soap, "tt:WhiteBalance", &(a->tt__ImagingOptions20::WhiteBalance), "tt:WhiteBalanceOptions20"))
				{	soap_flag_WhiteBalance1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingOptions20Extension(soap, "tt:Extension", &(a->tt__ImagingOptions20::Extension), "tt:ImagingOptions20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20, 0, sizeof(tt__ImagingOptions20), 0, soap_copy_tt__ImagingOptions20);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ImagingOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ImagingOptions20);
	if (this->soap_out(soap, tag?tag:"tt:ImagingOptions20", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingOptions20 * SOAP_FMAC4 soap_get_tt__ImagingOptions20(struct soap *soap, tt__ImagingOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ImagingOptions20 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingOptions20(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ImagingOptions20, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ImagingOptions20);
		if (size)
			*size = sizeof(tt__ImagingOptions20);
		((tt__ImagingOptions20*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ImagingOptions20[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ImagingOptions20);
		for (int i = 0; i < n; i++)
			((tt__ImagingOptions20*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ImagingOptions20*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ImagingOptions20(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ImagingOptions20 %p -> %p\n", q, p));
	*(tt__ImagingOptions20*)p = *(tt__ImagingOptions20*)q;
}

void tt__Exposure20::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ExposureMode(soap, &this->tt__Exposure20::Mode);
	this->tt__Exposure20::Priority = NULL;
	this->tt__Exposure20::Window = NULL;
	this->tt__Exposure20::MinExposureTime = NULL;
	this->tt__Exposure20::MaxExposureTime = NULL;
	this->tt__Exposure20::MinGain = NULL;
	this->tt__Exposure20::MaxGain = NULL;
	this->tt__Exposure20::MinIris = NULL;
	this->tt__Exposure20::MaxIris = NULL;
	this->tt__Exposure20::ExposureTime = NULL;
	this->tt__Exposure20::Gain = NULL;
	this->tt__Exposure20::Iris = NULL;
	/* transient soap skipped */
}

void tt__Exposure20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ExposurePriority(soap, &this->tt__Exposure20::Priority);
	soap_serialize_PointerTott__Rectangle(soap, &this->tt__Exposure20::Window);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MinExposureTime);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MaxExposureTime);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MinGain);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MaxGain);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MinIris);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MaxIris);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::ExposureTime);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::Gain);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::Iris);
	/* transient soap skipped */
}

int tt__Exposure20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Exposure20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Exposure20(struct soap *soap, const char *tag, int id, const tt__Exposure20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Exposure20), type))
		return soap->error;
	if (soap_out_tt__ExposureMode(soap, "tt:Mode", -1, &(a->tt__Exposure20::Mode), ""))
		return soap->error;
	if (soap_out_PointerTott__ExposurePriority(soap, "tt:Priority", -1, &(a->tt__Exposure20::Priority), ""))
		return soap->error;
	if (soap_out_PointerTott__Rectangle(soap, "tt:Window", -1, &(a->tt__Exposure20::Window), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MinExposureTime", -1, &(a->tt__Exposure20::MinExposureTime), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MaxExposureTime", -1, &(a->tt__Exposure20::MaxExposureTime), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MinGain", -1, &(a->tt__Exposure20::MinGain), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MaxGain", -1, &(a->tt__Exposure20::MaxGain), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MinIris", -1, &(a->tt__Exposure20::MinIris), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MaxIris", -1, &(a->tt__Exposure20::MaxIris), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:ExposureTime", -1, &(a->tt__Exposure20::ExposureTime), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Gain", -1, &(a->tt__Exposure20::Gain), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Iris", -1, &(a->tt__Exposure20::Iris), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Exposure20::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Exposure20(soap, tag, this, type);
}

SOAP_FMAC3 tt__Exposure20 * SOAP_FMAC4 soap_in_tt__Exposure20(struct soap *soap, const char *tag, tt__Exposure20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Exposure20 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Exposure20, sizeof(tt__Exposure20), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Exposure20)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Exposure20 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Priority1 = 1;
	size_t soap_flag_Window1 = 1;
	size_t soap_flag_MinExposureTime1 = 1;
	size_t soap_flag_MaxExposureTime1 = 1;
	size_t soap_flag_MinGain1 = 1;
	size_t soap_flag_MaxGain1 = 1;
	size_t soap_flag_MinIris1 = 1;
	size_t soap_flag_MaxIris1 = 1;
	size_t soap_flag_ExposureTime1 = 1;
	size_t soap_flag_Gain1 = 1;
	size_t soap_flag_Iris1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__ExposureMode(soap, "tt:Mode", &(a->tt__Exposure20::Mode), "tt:ExposureMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			if (soap_flag_Priority1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ExposurePriority(soap, "tt:Priority", &(a->tt__Exposure20::Priority), "tt:ExposurePriority"))
				{	soap_flag_Priority1--;
					continue;
				}
			if (soap_flag_Window1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Rectangle(soap, "tt:Window", &(a->tt__Exposure20::Window), "tt:Rectangle"))
				{	soap_flag_Window1--;
					continue;
				}
			if (soap_flag_MinExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:MinExposureTime", &(a->tt__Exposure20::MinExposureTime), "xsd:float"))
				{	soap_flag_MinExposureTime1--;
					continue;
				}
			if (soap_flag_MaxExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:MaxExposureTime", &(a->tt__Exposure20::MaxExposureTime), "xsd:float"))
				{	soap_flag_MaxExposureTime1--;
					continue;
				}
			if (soap_flag_MinGain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:MinGain", &(a->tt__Exposure20::MinGain), "xsd:float"))
				{	soap_flag_MinGain1--;
					continue;
				}
			if (soap_flag_MaxGain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:MaxGain", &(a->tt__Exposure20::MaxGain), "xsd:float"))
				{	soap_flag_MaxGain1--;
					continue;
				}
			if (soap_flag_MinIris1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:MinIris", &(a->tt__Exposure20::MinIris), "xsd:float"))
				{	soap_flag_MinIris1--;
					continue;
				}
			if (soap_flag_MaxIris1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:MaxIris", &(a->tt__Exposure20::MaxIris), "xsd:float"))
				{	soap_flag_MaxIris1--;
					continue;
				}
			if (soap_flag_ExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:ExposureTime", &(a->tt__Exposure20::ExposureTime), "xsd:float"))
				{	soap_flag_ExposureTime1--;
					continue;
				}
			if (soap_flag_Gain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Gain", &(a->tt__Exposure20::Gain), "xsd:float"))
				{	soap_flag_Gain1--;
					continue;
				}
			if (soap_flag_Iris1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Iris", &(a->tt__Exposure20::Iris), "xsd:float"))
				{	soap_flag_Iris1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Exposure20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Exposure20, 0, sizeof(tt__Exposure20), 0, soap_copy_tt__Exposure20);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Exposure20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Exposure20);
	if (this->soap_out(soap, tag?tag:"tt:Exposure20", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Exposure20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Exposure20(soap, this, tag, type);
}

SOAP_FMAC3 tt__Exposure20 * SOAP_FMAC4 soap_get_tt__Exposure20(struct soap *soap, tt__Exposure20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Exposure20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Exposure20 * SOAP_FMAC2 soap_instantiate_tt__Exposure20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Exposure20(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Exposure20, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Exposure20);
		if (size)
			*size = sizeof(tt__Exposure20);
		((tt__Exposure20*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Exposure20[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Exposure20);
		for (int i = 0; i < n; i++)
			((tt__Exposure20*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Exposure20*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Exposure20(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Exposure20 %p -> %p\n", q, p));
	*(tt__Exposure20*)p = *(tt__Exposure20*)q;
}

void tt__BacklightCompensation20::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__BacklightCompensationMode(soap, &this->tt__BacklightCompensation20::Mode);
	this->tt__BacklightCompensation20::Level = NULL;
	/* transient soap skipped */
}

void tt__BacklightCompensation20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofloat(soap, &this->tt__BacklightCompensation20::Level);
	/* transient soap skipped */
}

int tt__BacklightCompensation20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BacklightCompensation20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensation20(struct soap *soap, const char *tag, int id, const tt__BacklightCompensation20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensation20), type))
		return soap->error;
	if (soap_out_tt__BacklightCompensationMode(soap, "tt:Mode", -1, &(a->tt__BacklightCompensation20::Mode), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &(a->tt__BacklightCompensation20::Level), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__BacklightCompensation20::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__BacklightCompensation20(soap, tag, this, type);
}

SOAP_FMAC3 tt__BacklightCompensation20 * SOAP_FMAC4 soap_in_tt__BacklightCompensation20(struct soap *soap, const char *tag, tt__BacklightCompensation20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__BacklightCompensation20 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensation20, sizeof(tt__BacklightCompensation20), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__BacklightCompensation20)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__BacklightCompensation20 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__BacklightCompensationMode(soap, "tt:Mode", &(a->tt__BacklightCompensation20::Mode), "tt:BacklightCompensationMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Level", &(a->tt__BacklightCompensation20::Level), "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__BacklightCompensation20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensation20, 0, sizeof(tt__BacklightCompensation20), 0, soap_copy_tt__BacklightCompensation20);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__BacklightCompensation20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__BacklightCompensation20);
	if (this->soap_out(soap, tag?tag:"tt:BacklightCompensation20", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BacklightCompensation20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BacklightCompensation20(soap, this, tag, type);
}

SOAP_FMAC3 tt__BacklightCompensation20 * SOAP_FMAC4 soap_get_tt__BacklightCompensation20(struct soap *soap, tt__BacklightCompensation20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensation20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__BacklightCompensation20 * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensation20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__BacklightCompensation20(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__BacklightCompensation20, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__BacklightCompensation20);
		if (size)
			*size = sizeof(tt__BacklightCompensation20);
		((tt__BacklightCompensation20*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__BacklightCompensation20[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__BacklightCompensation20);
		for (int i = 0; i < n; i++)
			((tt__BacklightCompensation20*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__BacklightCompensation20*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__BacklightCompensation20(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__BacklightCompensation20 %p -> %p\n", q, p));
	*(tt__BacklightCompensation20*)p = *(tt__BacklightCompensation20*)q;
}

void tt__WideDynamicRange20::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__WideDynamicMode(soap, &this->tt__WideDynamicRange20::Mode);
	this->tt__WideDynamicRange20::Level = NULL;
	/* transient soap skipped */
}

void tt__WideDynamicRange20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofloat(soap, &this->tt__WideDynamicRange20::Level);
	/* transient soap skipped */
}

int tt__WideDynamicRange20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WideDynamicRange20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRange20(struct soap *soap, const char *tag, int id, const tt__WideDynamicRange20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRange20), type))
		return soap->error;
	if (soap_out_tt__WideDynamicMode(soap, "tt:Mode", -1, &(a->tt__WideDynamicRange20::Mode), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &(a->tt__WideDynamicRange20::Level), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__WideDynamicRange20::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__WideDynamicRange20(soap, tag, this, type);
}

SOAP_FMAC3 tt__WideDynamicRange20 * SOAP_FMAC4 soap_in_tt__WideDynamicRange20(struct soap *soap, const char *tag, tt__WideDynamicRange20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WideDynamicRange20 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRange20, sizeof(tt__WideDynamicRange20), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__WideDynamicRange20)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__WideDynamicRange20 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__WideDynamicMode(soap, "tt:Mode", &(a->tt__WideDynamicRange20::Mode), "tt:WideDynamicMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Level", &(a->tt__WideDynamicRange20::Level), "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__WideDynamicRange20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRange20, 0, sizeof(tt__WideDynamicRange20), 0, soap_copy_tt__WideDynamicRange20);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__WideDynamicRange20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__WideDynamicRange20);
	if (this->soap_out(soap, tag?tag:"tt:WideDynamicRange20", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WideDynamicRange20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WideDynamicRange20(soap, this, tag, type);
}

SOAP_FMAC3 tt__WideDynamicRange20 * SOAP_FMAC4 soap_get_tt__WideDynamicRange20(struct soap *soap, tt__WideDynamicRange20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRange20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__WideDynamicRange20 * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRange20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WideDynamicRange20(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__WideDynamicRange20, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__WideDynamicRange20);
		if (size)
			*size = sizeof(tt__WideDynamicRange20);
		((tt__WideDynamicRange20*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__WideDynamicRange20[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__WideDynamicRange20);
		for (int i = 0; i < n; i++)
			((tt__WideDynamicRange20*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__WideDynamicRange20*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__WideDynamicRange20(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__WideDynamicRange20 %p -> %p\n", q, p));
	*(tt__WideDynamicRange20*)p = *(tt__WideDynamicRange20*)q;
}

void tt__ImagingSettingsExtension20::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingSettingsExtension20::__any);
	/* transient soap skipped */
}

void tt__ImagingSettingsExtension20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingSettingsExtension20::__any);
	/* transient soap skipped */
}

int tt__ImagingSettingsExtension20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettingsExtension20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension20(struct soap *soap, const char *tag, int id, const tt__ImagingSettingsExtension20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettingsExtension20), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__ImagingSettingsExtension20::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingSettingsExtension20::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ImagingSettingsExtension20(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension20 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension20(struct soap *soap, const char *tag, tt__ImagingSettingsExtension20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingSettingsExtension20 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension20, sizeof(tt__ImagingSettingsExtension20), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ImagingSettingsExtension20)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ImagingSettingsExtension20 *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__ImagingSettingsExtension20::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingSettingsExtension20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension20, 0, sizeof(tt__ImagingSettingsExtension20), 0, soap_copy_tt__ImagingSettingsExtension20);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ImagingSettingsExtension20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ImagingSettingsExtension20);
	if (this->soap_out(soap, tag?tag:"tt:ImagingSettingsExtension20", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettingsExtension20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettingsExtension20(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension20 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension20(struct soap *soap, tt__ImagingSettingsExtension20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ImagingSettingsExtension20 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingSettingsExtension20(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ImagingSettingsExtension20, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ImagingSettingsExtension20);
		if (size)
			*size = sizeof(tt__ImagingSettingsExtension20);
		((tt__ImagingSettingsExtension20*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ImagingSettingsExtension20[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ImagingSettingsExtension20);
		for (int i = 0; i < n; i++)
			((tt__ImagingSettingsExtension20*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ImagingSettingsExtension20*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ImagingSettingsExtension20(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ImagingSettingsExtension20 %p -> %p\n", q, p));
	*(tt__ImagingSettingsExtension20*)p = *(tt__ImagingSettingsExtension20*)q;
}

void tt__ImagingSettings20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ImagingSettings20::BacklightCompensation = NULL;
	this->tt__ImagingSettings20::Brightness = NULL;
	this->tt__ImagingSettings20::ColorSaturation = NULL;
	this->tt__ImagingSettings20::Contrast = NULL;
	this->tt__ImagingSettings20::Exposure = NULL;
	this->tt__ImagingSettings20::Focus = NULL;
	this->tt__ImagingSettings20::IrCutFilter = NULL;
	this->tt__ImagingSettings20::Sharpness = NULL;
	this->tt__ImagingSettings20::WideDynamicRange = NULL;
	this->tt__ImagingSettings20::WhiteBalance = NULL;
	this->tt__ImagingSettings20::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ImagingSettings20::__anyAttribute);
	/* transient soap skipped */
}

void tt__ImagingSettings20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__BacklightCompensation20(soap, &this->tt__ImagingSettings20::BacklightCompensation);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings20::Brightness);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings20::ColorSaturation);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings20::Contrast);
	soap_serialize_PointerTott__Exposure20(soap, &this->tt__ImagingSettings20::Exposure);
	soap_serialize_PointerTott__FocusConfiguration20(soap, &this->tt__ImagingSettings20::Focus);
	soap_serialize_PointerTott__IrCutFilterMode(soap, &this->tt__ImagingSettings20::IrCutFilter);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings20::Sharpness);
	soap_serialize_PointerTott__WideDynamicRange20(soap, &this->tt__ImagingSettings20::WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalance20(soap, &this->tt__ImagingSettings20::WhiteBalance);
	soap_serialize_PointerTott__ImagingSettingsExtension20(soap, &this->tt__ImagingSettings20::Extension);
	/* transient soap skipped */
}

int tt__ImagingSettings20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettings20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettings20(struct soap *soap, const char *tag, int id, const tt__ImagingSettings20 *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ImagingSettings20*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettings20), type))
		return soap->error;
	if (soap_out_PointerTott__BacklightCompensation20(soap, "tt:BacklightCompensation", -1, &(a->tt__ImagingSettings20::BacklightCompensation), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Brightness", -1, &(a->tt__ImagingSettings20::Brightness), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:ColorSaturation", -1, &(a->tt__ImagingSettings20::ColorSaturation), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Contrast", -1, &(a->tt__ImagingSettings20::Contrast), ""))
		return soap->error;
	if (soap_out_PointerTott__Exposure20(soap, "tt:Exposure", -1, &(a->tt__ImagingSettings20::Exposure), ""))
		return soap->error;
	if (soap_out_PointerTott__FocusConfiguration20(soap, "tt:Focus", -1, &(a->tt__ImagingSettings20::Focus), ""))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", -1, &(a->tt__ImagingSettings20::IrCutFilter), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Sharpness", -1, &(a->tt__ImagingSettings20::Sharpness), ""))
		return soap->error;
	if (soap_out_PointerTott__WideDynamicRange20(soap, "tt:WideDynamicRange", -1, &(a->tt__ImagingSettings20::WideDynamicRange), ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalance20(soap, "tt:WhiteBalance", -1, &(a->tt__ImagingSettings20::WhiteBalance), ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettingsExtension20(soap, "tt:Extension", -1, &(a->tt__ImagingSettings20::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingSettings20::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ImagingSettings20(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettings20 * SOAP_FMAC4 soap_in_tt__ImagingSettings20(struct soap *soap, const char *tag, tt__ImagingSettings20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingSettings20 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettings20, sizeof(tt__ImagingSettings20), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ImagingSettings20)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ImagingSettings20 *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ImagingSettings20*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_BacklightCompensation1 = 1;
	size_t soap_flag_Brightness1 = 1;
	size_t soap_flag_ColorSaturation1 = 1;
	size_t soap_flag_Contrast1 = 1;
	size_t soap_flag_Exposure1 = 1;
	size_t soap_flag_Focus1 = 1;
	size_t soap_flag_IrCutFilter1 = 1;
	size_t soap_flag_Sharpness1 = 1;
	size_t soap_flag_WideDynamicRange1 = 1;
	size_t soap_flag_WhiteBalance1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BacklightCompensation20(soap, "tt:BacklightCompensation", &(a->tt__ImagingSettings20::BacklightCompensation), "tt:BacklightCompensation20"))
				{	soap_flag_BacklightCompensation1--;
					continue;
				}
			if (soap_flag_Brightness1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Brightness", &(a->tt__ImagingSettings20::Brightness), "xsd:float"))
				{	soap_flag_Brightness1--;
					continue;
				}
			if (soap_flag_ColorSaturation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:ColorSaturation", &(a->tt__ImagingSettings20::ColorSaturation), "xsd:float"))
				{	soap_flag_ColorSaturation1--;
					continue;
				}
			if (soap_flag_Contrast1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Contrast", &(a->tt__ImagingSettings20::Contrast), "xsd:float"))
				{	soap_flag_Contrast1--;
					continue;
				}
			if (soap_flag_Exposure1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Exposure20(soap, "tt:Exposure", &(a->tt__ImagingSettings20::Exposure), "tt:Exposure20"))
				{	soap_flag_Exposure1--;
					continue;
				}
			if (soap_flag_Focus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusConfiguration20(soap, "tt:Focus", &(a->tt__ImagingSettings20::Focus), "tt:FocusConfiguration20"))
				{	soap_flag_Focus1--;
					continue;
				}
			if (soap_flag_IrCutFilter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", &(a->tt__ImagingSettings20::IrCutFilter), "tt:IrCutFilterMode"))
				{	soap_flag_IrCutFilter1--;
					continue;
				}
			if (soap_flag_Sharpness1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Sharpness", &(a->tt__ImagingSettings20::Sharpness), "xsd:float"))
				{	soap_flag_Sharpness1--;
					continue;
				}
			if (soap_flag_WideDynamicRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WideDynamicRange20(soap, "tt:WideDynamicRange", &(a->tt__ImagingSettings20::WideDynamicRange), "tt:WideDynamicRange20"))
				{	soap_flag_WideDynamicRange1--;
					continue;
				}
			if (soap_flag_WhiteBalance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WhiteBalance20(soap, "tt:WhiteBalance", &(a->tt__ImagingSettings20::WhiteBalance), "tt:WhiteBalance20"))
				{	soap_flag_WhiteBalance1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingSettingsExtension20(soap, "tt:Extension", &(a->tt__ImagingSettings20::Extension), "tt:ImagingSettingsExtension20"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingSettings20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettings20, 0, sizeof(tt__ImagingSettings20), 0, soap_copy_tt__ImagingSettings20);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ImagingSettings20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ImagingSettings20);
	if (this->soap_out(soap, tag?tag:"tt:ImagingSettings20", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettings20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettings20(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettings20 * SOAP_FMAC4 soap_get_tt__ImagingSettings20(struct soap *soap, tt__ImagingSettings20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettings20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ImagingSettings20 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettings20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingSettings20(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ImagingSettings20, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ImagingSettings20);
		if (size)
			*size = sizeof(tt__ImagingSettings20);
		((tt__ImagingSettings20*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ImagingSettings20[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ImagingSettings20);
		for (int i = 0; i < n; i++)
			((tt__ImagingSettings20*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ImagingSettings20*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ImagingSettings20(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ImagingSettings20 %p -> %p\n", q, p));
	*(tt__ImagingSettings20*)p = *(tt__ImagingSettings20*)q;
}

void tt__FocusStatus20Extension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FocusStatus20Extension::__any);
	/* transient soap skipped */
}

void tt__FocusStatus20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FocusStatus20Extension::__any);
	/* transient soap skipped */
}

int tt__FocusStatus20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusStatus20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusStatus20Extension(struct soap *soap, const char *tag, int id, const tt__FocusStatus20Extension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusStatus20Extension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__FocusStatus20Extension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__FocusStatus20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__FocusStatus20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusStatus20Extension * SOAP_FMAC4 soap_in_tt__FocusStatus20Extension(struct soap *soap, const char *tag, tt__FocusStatus20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusStatus20Extension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusStatus20Extension, sizeof(tt__FocusStatus20Extension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__FocusStatus20Extension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__FocusStatus20Extension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__FocusStatus20Extension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusStatus20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusStatus20Extension, 0, sizeof(tt__FocusStatus20Extension), 0, soap_copy_tt__FocusStatus20Extension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__FocusStatus20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__FocusStatus20Extension);
	if (this->soap_out(soap, tag?tag:"tt:FocusStatus20Extension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusStatus20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusStatus20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusStatus20Extension * SOAP_FMAC4 soap_get_tt__FocusStatus20Extension(struct soap *soap, tt__FocusStatus20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__FocusStatus20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusStatus20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusStatus20Extension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__FocusStatus20Extension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__FocusStatus20Extension);
		if (size)
			*size = sizeof(tt__FocusStatus20Extension);
		((tt__FocusStatus20Extension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__FocusStatus20Extension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__FocusStatus20Extension);
		for (int i = 0; i < n; i++)
			((tt__FocusStatus20Extension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__FocusStatus20Extension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__FocusStatus20Extension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__FocusStatus20Extension %p -> %p\n", q, p));
	*(tt__FocusStatus20Extension*)p = *(tt__FocusStatus20Extension*)q;
}

void tt__FocusStatus20::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_float(soap, &this->tt__FocusStatus20::Position);
	soap_default_tt__MoveStatus(soap, &this->tt__FocusStatus20::MoveStatus);
	this->tt__FocusStatus20::Error = NULL;
	this->tt__FocusStatus20::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__FocusStatus20::__anyAttribute);
	/* transient soap skipped */
}

void tt__FocusStatus20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__FocusStatus20::Position, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__FocusStatus20::MoveStatus, SOAP_TYPE_tt__MoveStatus);
	soap_serialize_PointerTostd__string(soap, &this->tt__FocusStatus20::Error);
	soap_serialize_PointerTott__FocusStatus20Extension(soap, &this->tt__FocusStatus20::Extension);
	/* transient soap skipped */
}

int tt__FocusStatus20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusStatus20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusStatus20(struct soap *soap, const char *tag, int id, const tt__FocusStatus20 *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__FocusStatus20*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusStatus20), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Position", -1, &(a->tt__FocusStatus20::Position), ""))
		return soap->error;
	if (soap_out_tt__MoveStatus(soap, "tt:MoveStatus", -1, &(a->tt__FocusStatus20::MoveStatus), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Error", -1, &(a->tt__FocusStatus20::Error), ""))
		return soap->error;
	if (soap_out_PointerTott__FocusStatus20Extension(soap, "tt:Extension", -1, &(a->tt__FocusStatus20::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__FocusStatus20::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__FocusStatus20(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusStatus20 * SOAP_FMAC4 soap_in_tt__FocusStatus20(struct soap *soap, const char *tag, tt__FocusStatus20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusStatus20 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusStatus20, sizeof(tt__FocusStatus20), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__FocusStatus20)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__FocusStatus20 *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__FocusStatus20*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_MoveStatus1 = 1;
	size_t soap_flag_Error1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Position", &(a->tt__FocusStatus20::Position), "xsd:float"))
				{	soap_flag_Position1--;
					continue;
				}
			if (soap_flag_MoveStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__MoveStatus(soap, "tt:MoveStatus", &(a->tt__FocusStatus20::MoveStatus), "tt:MoveStatus"))
				{	soap_flag_MoveStatus1--;
					continue;
				}
			if (soap_flag_Error1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "tt:Error", &(a->tt__FocusStatus20::Error), "xsd:string"))
				{	soap_flag_Error1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusStatus20Extension(soap, "tt:Extension", &(a->tt__FocusStatus20::Extension), "tt:FocusStatus20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusStatus20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusStatus20, 0, sizeof(tt__FocusStatus20), 0, soap_copy_tt__FocusStatus20);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position1 > 0 || soap_flag_MoveStatus1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__FocusStatus20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__FocusStatus20);
	if (this->soap_out(soap, tag?tag:"tt:FocusStatus20", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusStatus20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusStatus20(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusStatus20 * SOAP_FMAC4 soap_get_tt__FocusStatus20(struct soap *soap, tt__FocusStatus20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__FocusStatus20 * SOAP_FMAC2 soap_instantiate_tt__FocusStatus20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusStatus20(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__FocusStatus20, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__FocusStatus20);
		if (size)
			*size = sizeof(tt__FocusStatus20);
		((tt__FocusStatus20*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__FocusStatus20[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__FocusStatus20);
		for (int i = 0; i < n; i++)
			((tt__FocusStatus20*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__FocusStatus20*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__FocusStatus20(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__FocusStatus20 %p -> %p\n", q, p));
	*(tt__FocusStatus20*)p = *(tt__FocusStatus20*)q;
}

void tt__ImagingStatus20Extension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingStatus20Extension::__any);
	/* transient soap skipped */
}

void tt__ImagingStatus20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingStatus20Extension::__any);
	/* transient soap skipped */
}

int tt__ImagingStatus20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingStatus20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingStatus20Extension(struct soap *soap, const char *tag, int id, const tt__ImagingStatus20Extension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingStatus20Extension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__ImagingStatus20Extension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingStatus20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ImagingStatus20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingStatus20Extension * SOAP_FMAC4 soap_in_tt__ImagingStatus20Extension(struct soap *soap, const char *tag, tt__ImagingStatus20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingStatus20Extension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingStatus20Extension, sizeof(tt__ImagingStatus20Extension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ImagingStatus20Extension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ImagingStatus20Extension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__ImagingStatus20Extension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingStatus20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingStatus20Extension, 0, sizeof(tt__ImagingStatus20Extension), 0, soap_copy_tt__ImagingStatus20Extension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ImagingStatus20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ImagingStatus20Extension);
	if (this->soap_out(soap, tag?tag:"tt:ImagingStatus20Extension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingStatus20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingStatus20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingStatus20Extension * SOAP_FMAC4 soap_get_tt__ImagingStatus20Extension(struct soap *soap, tt__ImagingStatus20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ImagingStatus20Extension * SOAP_FMAC2 soap_instantiate_tt__ImagingStatus20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingStatus20Extension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ImagingStatus20Extension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ImagingStatus20Extension);
		if (size)
			*size = sizeof(tt__ImagingStatus20Extension);
		((tt__ImagingStatus20Extension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ImagingStatus20Extension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ImagingStatus20Extension);
		for (int i = 0; i < n; i++)
			((tt__ImagingStatus20Extension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ImagingStatus20Extension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ImagingStatus20Extension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ImagingStatus20Extension %p -> %p\n", q, p));
	*(tt__ImagingStatus20Extension*)p = *(tt__ImagingStatus20Extension*)q;
}

void tt__ImagingStatus20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ImagingStatus20::FocusStatus20 = NULL;
	this->tt__ImagingStatus20::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ImagingStatus20::__anyAttribute);
	/* transient soap skipped */
}

void tt__ImagingStatus20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__FocusStatus20(soap, &this->tt__ImagingStatus20::FocusStatus20);
	soap_serialize_PointerTott__ImagingStatus20Extension(soap, &this->tt__ImagingStatus20::Extension);
	/* transient soap skipped */
}

int tt__ImagingStatus20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingStatus20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingStatus20(struct soap *soap, const char *tag, int id, const tt__ImagingStatus20 *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ImagingStatus20*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingStatus20), type))
		return soap->error;
	if (soap_out_PointerTott__FocusStatus20(soap, "tt:FocusStatus20", -1, &(a->tt__ImagingStatus20::FocusStatus20), ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingStatus20Extension(soap, "tt:Extension", -1, &(a->tt__ImagingStatus20::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingStatus20::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ImagingStatus20(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingStatus20 * SOAP_FMAC4 soap_in_tt__ImagingStatus20(struct soap *soap, const char *tag, tt__ImagingStatus20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingStatus20 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingStatus20, sizeof(tt__ImagingStatus20), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ImagingStatus20)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ImagingStatus20 *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ImagingStatus20*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_FocusStatus201 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FocusStatus201 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusStatus20(soap, "tt:FocusStatus20", &(a->tt__ImagingStatus20::FocusStatus20), "tt:FocusStatus20"))
				{	soap_flag_FocusStatus201--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingStatus20Extension(soap, "tt:Extension", &(a->tt__ImagingStatus20::Extension), "tt:ImagingStatus20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingStatus20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingStatus20, 0, sizeof(tt__ImagingStatus20), 0, soap_copy_tt__ImagingStatus20);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ImagingStatus20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ImagingStatus20);
	if (this->soap_out(soap, tag?tag:"tt:ImagingStatus20", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingStatus20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingStatus20(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingStatus20 * SOAP_FMAC4 soap_get_tt__ImagingStatus20(struct soap *soap, tt__ImagingStatus20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ImagingStatus20 * SOAP_FMAC2 soap_instantiate_tt__ImagingStatus20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingStatus20(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ImagingStatus20, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ImagingStatus20);
		if (size)
			*size = sizeof(tt__ImagingStatus20);
		((tt__ImagingStatus20*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ImagingStatus20[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ImagingStatus20);
		for (int i = 0; i < n; i++)
			((tt__ImagingStatus20*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ImagingStatus20*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ImagingStatus20(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ImagingStatus20 %p -> %p\n", q, p));
	*(tt__ImagingStatus20*)p = *(tt__ImagingStatus20*)q;
}

void tt__WhiteBalance::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__WhiteBalanceMode(soap, &this->tt__WhiteBalance::Mode);
	soap_default_float(soap, &this->tt__WhiteBalance::CrGain);
	soap_default_float(soap, &this->tt__WhiteBalance::CbGain);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__WhiteBalance::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__WhiteBalance::__anyAttribute);
	/* transient soap skipped */
}

void tt__WhiteBalance::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__WhiteBalance::CrGain, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__WhiteBalance::CbGain, SOAP_TYPE_float);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__WhiteBalance::__any);
	/* transient soap skipped */
}

int tt__WhiteBalance::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalance(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalance(struct soap *soap, const char *tag, int id, const tt__WhiteBalance *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__WhiteBalance*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalance), type))
		return soap->error;
	if (soap_out_tt__WhiteBalanceMode(soap, "tt:Mode", -1, &(a->tt__WhiteBalance::Mode), ""))
		return soap->error;
	if (soap_out_float(soap, "tt:CrGain", -1, &(a->tt__WhiteBalance::CrGain), ""))
		return soap->error;
	if (soap_out_float(soap, "tt:CbGain", -1, &(a->tt__WhiteBalance::CbGain), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__WhiteBalance::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__WhiteBalance::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__WhiteBalance(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalance * SOAP_FMAC4 soap_in_tt__WhiteBalance(struct soap *soap, const char *tag, tt__WhiteBalance *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WhiteBalance *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance, sizeof(tt__WhiteBalance), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__WhiteBalance)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__WhiteBalance *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__WhiteBalance*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_CrGain1 = 1;
	size_t soap_flag_CbGain1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__WhiteBalanceMode(soap, "tt:Mode", &(a->tt__WhiteBalance::Mode), "tt:WhiteBalanceMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			if (soap_flag_CrGain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:CrGain", &(a->tt__WhiteBalance::CrGain), "xsd:float"))
				{	soap_flag_CrGain1--;
					continue;
				}
			if (soap_flag_CbGain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:CbGain", &(a->tt__WhiteBalance::CbGain), "xsd:float"))
				{	soap_flag_CbGain1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__WhiteBalance::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__WhiteBalance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalance, 0, sizeof(tt__WhiteBalance), 0, soap_copy_tt__WhiteBalance);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0 || soap_flag_CrGain1 > 0 || soap_flag_CbGain1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__WhiteBalance::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__WhiteBalance);
	if (this->soap_out(soap, tag?tag:"tt:WhiteBalance", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalance::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalance(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalance * SOAP_FMAC4 soap_get_tt__WhiteBalance(struct soap *soap, tt__WhiteBalance *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__WhiteBalance * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WhiteBalance(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__WhiteBalance, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__WhiteBalance);
		if (size)
			*size = sizeof(tt__WhiteBalance);
		((tt__WhiteBalance*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__WhiteBalance[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__WhiteBalance);
		for (int i = 0; i < n; i++)
			((tt__WhiteBalance*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__WhiteBalance*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__WhiteBalance(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__WhiteBalance %p -> %p\n", q, p));
	*(tt__WhiteBalance*)p = *(tt__WhiteBalance*)q;
}

void tt__ContinuousFocusOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ContinuousFocusOptions::Speed = NULL;
	/* transient soap skipped */
}

void tt__ContinuousFocusOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ContinuousFocusOptions::Speed);
	/* transient soap skipped */
}

int tt__ContinuousFocusOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ContinuousFocusOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ContinuousFocusOptions(struct soap *soap, const char *tag, int id, const tt__ContinuousFocusOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ContinuousFocusOptions), type))
		return soap->error;
	if (a->tt__ContinuousFocusOptions::Speed)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &a->tt__ContinuousFocusOptions::Speed, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Speed"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ContinuousFocusOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ContinuousFocusOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__ContinuousFocusOptions * SOAP_FMAC4 soap_in_tt__ContinuousFocusOptions(struct soap *soap, const char *tag, tt__ContinuousFocusOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ContinuousFocusOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ContinuousFocusOptions, sizeof(tt__ContinuousFocusOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ContinuousFocusOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ContinuousFocusOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Speed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &(a->tt__ContinuousFocusOptions::Speed), "tt:FloatRange"))
				{	soap_flag_Speed1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ContinuousFocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ContinuousFocusOptions, 0, sizeof(tt__ContinuousFocusOptions), 0, soap_copy_tt__ContinuousFocusOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Speed1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__ContinuousFocusOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ContinuousFocusOptions);
	if (this->soap_out(soap, tag?tag:"tt:ContinuousFocusOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ContinuousFocusOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ContinuousFocusOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__ContinuousFocusOptions * SOAP_FMAC4 soap_get_tt__ContinuousFocusOptions(struct soap *soap, tt__ContinuousFocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ContinuousFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ContinuousFocusOptions * SOAP_FMAC2 soap_instantiate_tt__ContinuousFocusOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ContinuousFocusOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ContinuousFocusOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ContinuousFocusOptions);
		if (size)
			*size = sizeof(tt__ContinuousFocusOptions);
		((tt__ContinuousFocusOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ContinuousFocusOptions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ContinuousFocusOptions);
		for (int i = 0; i < n; i++)
			((tt__ContinuousFocusOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ContinuousFocusOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ContinuousFocusOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ContinuousFocusOptions %p -> %p\n", q, p));
	*(tt__ContinuousFocusOptions*)p = *(tt__ContinuousFocusOptions*)q;
}

void tt__RelativeFocusOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__RelativeFocusOptions::Distance = NULL;
	this->tt__RelativeFocusOptions::Speed = NULL;
	/* transient soap skipped */
}

void tt__RelativeFocusOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__RelativeFocusOptions::Distance);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__RelativeFocusOptions::Speed);
	/* transient soap skipped */
}

int tt__RelativeFocusOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RelativeFocusOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelativeFocusOptions(struct soap *soap, const char *tag, int id, const tt__RelativeFocusOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelativeFocusOptions), type))
		return soap->error;
	if (a->tt__RelativeFocusOptions::Distance)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Distance", -1, &a->tt__RelativeFocusOptions::Distance, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Distance"))
		return soap->error;
	if (a->tt__RelativeFocusOptions::Speed)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &a->tt__RelativeFocusOptions::Speed, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Speed"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__RelativeFocusOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__RelativeFocusOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__RelativeFocusOptions * SOAP_FMAC4 soap_in_tt__RelativeFocusOptions(struct soap *soap, const char *tag, tt__RelativeFocusOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RelativeFocusOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelativeFocusOptions, sizeof(tt__RelativeFocusOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__RelativeFocusOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__RelativeFocusOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Distance1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Distance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Distance", &(a->tt__RelativeFocusOptions::Distance), "tt:FloatRange"))
				{	soap_flag_Distance1--;
					continue;
				}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &(a->tt__RelativeFocusOptions::Speed), "tt:FloatRange"))
				{	soap_flag_Speed1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RelativeFocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelativeFocusOptions, 0, sizeof(tt__RelativeFocusOptions), 0, soap_copy_tt__RelativeFocusOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Distance1 > 0 || soap_flag_Speed1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__RelativeFocusOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__RelativeFocusOptions);
	if (this->soap_out(soap, tag?tag:"tt:RelativeFocusOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RelativeFocusOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RelativeFocusOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__RelativeFocusOptions * SOAP_FMAC4 soap_get_tt__RelativeFocusOptions(struct soap *soap, tt__RelativeFocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelativeFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__RelativeFocusOptions * SOAP_FMAC2 soap_instantiate_tt__RelativeFocusOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RelativeFocusOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__RelativeFocusOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__RelativeFocusOptions);
		if (size)
			*size = sizeof(tt__RelativeFocusOptions);
		((tt__RelativeFocusOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__RelativeFocusOptions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__RelativeFocusOptions);
		for (int i = 0; i < n; i++)
			((tt__RelativeFocusOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__RelativeFocusOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__RelativeFocusOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__RelativeFocusOptions %p -> %p\n", q, p));
	*(tt__RelativeFocusOptions*)p = *(tt__RelativeFocusOptions*)q;
}

void tt__AbsoluteFocusOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__AbsoluteFocusOptions::Position = NULL;
	this->tt__AbsoluteFocusOptions::Speed = NULL;
	/* transient soap skipped */
}

void tt__AbsoluteFocusOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__AbsoluteFocusOptions::Position);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__AbsoluteFocusOptions::Speed);
	/* transient soap skipped */
}

int tt__AbsoluteFocusOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AbsoluteFocusOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AbsoluteFocusOptions(struct soap *soap, const char *tag, int id, const tt__AbsoluteFocusOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AbsoluteFocusOptions), type))
		return soap->error;
	if (a->tt__AbsoluteFocusOptions::Position)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Position", -1, &a->tt__AbsoluteFocusOptions::Position, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Position"))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &(a->tt__AbsoluteFocusOptions::Speed), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__AbsoluteFocusOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__AbsoluteFocusOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__AbsoluteFocusOptions * SOAP_FMAC4 soap_in_tt__AbsoluteFocusOptions(struct soap *soap, const char *tag, tt__AbsoluteFocusOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AbsoluteFocusOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AbsoluteFocusOptions, sizeof(tt__AbsoluteFocusOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__AbsoluteFocusOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__AbsoluteFocusOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Position", &(a->tt__AbsoluteFocusOptions::Position), "tt:FloatRange"))
				{	soap_flag_Position1--;
					continue;
				}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &(a->tt__AbsoluteFocusOptions::Speed), "tt:FloatRange"))
				{	soap_flag_Speed1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AbsoluteFocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AbsoluteFocusOptions, 0, sizeof(tt__AbsoluteFocusOptions), 0, soap_copy_tt__AbsoluteFocusOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__AbsoluteFocusOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__AbsoluteFocusOptions);
	if (this->soap_out(soap, tag?tag:"tt:AbsoluteFocusOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AbsoluteFocusOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AbsoluteFocusOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__AbsoluteFocusOptions * SOAP_FMAC4 soap_get_tt__AbsoluteFocusOptions(struct soap *soap, tt__AbsoluteFocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AbsoluteFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__AbsoluteFocusOptions * SOAP_FMAC2 soap_instantiate_tt__AbsoluteFocusOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AbsoluteFocusOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__AbsoluteFocusOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__AbsoluteFocusOptions);
		if (size)
			*size = sizeof(tt__AbsoluteFocusOptions);
		((tt__AbsoluteFocusOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__AbsoluteFocusOptions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__AbsoluteFocusOptions);
		for (int i = 0; i < n; i++)
			((tt__AbsoluteFocusOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__AbsoluteFocusOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__AbsoluteFocusOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__AbsoluteFocusOptions %p -> %p\n", q, p));
	*(tt__AbsoluteFocusOptions*)p = *(tt__AbsoluteFocusOptions*)q;
}

void tt__MoveOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__MoveOptions::Absolute = NULL;
	this->tt__MoveOptions::Relative = NULL;
	this->tt__MoveOptions::Continuous = NULL;
	/* transient soap skipped */
}

void tt__MoveOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AbsoluteFocusOptions(soap, &this->tt__MoveOptions::Absolute);
	soap_serialize_PointerTott__RelativeFocusOptions(soap, &this->tt__MoveOptions::Relative);
	soap_serialize_PointerTott__ContinuousFocusOptions(soap, &this->tt__MoveOptions::Continuous);
	/* transient soap skipped */
}

int tt__MoveOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MoveOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MoveOptions(struct soap *soap, const char *tag, int id, const tt__MoveOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MoveOptions), type))
		return soap->error;
	if (soap_out_PointerTott__AbsoluteFocusOptions(soap, "tt:Absolute", -1, &(a->tt__MoveOptions::Absolute), ""))
		return soap->error;
	if (soap_out_PointerTott__RelativeFocusOptions(soap, "tt:Relative", -1, &(a->tt__MoveOptions::Relative), ""))
		return soap->error;
	if (soap_out_PointerTott__ContinuousFocusOptions(soap, "tt:Continuous", -1, &(a->tt__MoveOptions::Continuous), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__MoveOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__MoveOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__MoveOptions * SOAP_FMAC4 soap_in_tt__MoveOptions(struct soap *soap, const char *tag, tt__MoveOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MoveOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MoveOptions, sizeof(tt__MoveOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__MoveOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__MoveOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Absolute1 = 1;
	size_t soap_flag_Relative1 = 1;
	size_t soap_flag_Continuous1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Absolute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AbsoluteFocusOptions(soap, "tt:Absolute", &(a->tt__MoveOptions::Absolute), "tt:AbsoluteFocusOptions"))
				{	soap_flag_Absolute1--;
					continue;
				}
			if (soap_flag_Relative1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RelativeFocusOptions(soap, "tt:Relative", &(a->tt__MoveOptions::Relative), "tt:RelativeFocusOptions"))
				{	soap_flag_Relative1--;
					continue;
				}
			if (soap_flag_Continuous1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ContinuousFocusOptions(soap, "tt:Continuous", &(a->tt__MoveOptions::Continuous), "tt:ContinuousFocusOptions"))
				{	soap_flag_Continuous1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MoveOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MoveOptions, 0, sizeof(tt__MoveOptions), 0, soap_copy_tt__MoveOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__MoveOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__MoveOptions);
	if (this->soap_out(soap, tag?tag:"tt:MoveOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MoveOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MoveOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__MoveOptions * SOAP_FMAC4 soap_get_tt__MoveOptions(struct soap *soap, tt__MoveOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MoveOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__MoveOptions * SOAP_FMAC2 soap_instantiate_tt__MoveOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MoveOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__MoveOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__MoveOptions);
		if (size)
			*size = sizeof(tt__MoveOptions);
		((tt__MoveOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__MoveOptions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__MoveOptions);
		for (int i = 0; i < n; i++)
			((tt__MoveOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__MoveOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__MoveOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__MoveOptions %p -> %p\n", q, p));
	*(tt__MoveOptions*)p = *(tt__MoveOptions*)q;
}

void tt__ContinuousFocus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_float(soap, &this->tt__ContinuousFocus::Speed);
	/* transient soap skipped */
}

void tt__ContinuousFocus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__ContinuousFocus::Speed, SOAP_TYPE_float);
	/* transient soap skipped */
}

int tt__ContinuousFocus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ContinuousFocus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ContinuousFocus(struct soap *soap, const char *tag, int id, const tt__ContinuousFocus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ContinuousFocus), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Speed", -1, &(a->tt__ContinuousFocus::Speed), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ContinuousFocus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ContinuousFocus(soap, tag, this, type);
}

SOAP_FMAC3 tt__ContinuousFocus * SOAP_FMAC4 soap_in_tt__ContinuousFocus(struct soap *soap, const char *tag, tt__ContinuousFocus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ContinuousFocus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ContinuousFocus, sizeof(tt__ContinuousFocus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ContinuousFocus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ContinuousFocus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Speed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Speed", &(a->tt__ContinuousFocus::Speed), "xsd:float"))
				{	soap_flag_Speed1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ContinuousFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ContinuousFocus, 0, sizeof(tt__ContinuousFocus), 0, soap_copy_tt__ContinuousFocus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Speed1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__ContinuousFocus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ContinuousFocus);
	if (this->soap_out(soap, tag?tag:"tt:ContinuousFocus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ContinuousFocus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ContinuousFocus(soap, this, tag, type);
}

SOAP_FMAC3 tt__ContinuousFocus * SOAP_FMAC4 soap_get_tt__ContinuousFocus(struct soap *soap, tt__ContinuousFocus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ContinuousFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ContinuousFocus * SOAP_FMAC2 soap_instantiate_tt__ContinuousFocus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ContinuousFocus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ContinuousFocus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ContinuousFocus);
		if (size)
			*size = sizeof(tt__ContinuousFocus);
		((tt__ContinuousFocus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ContinuousFocus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ContinuousFocus);
		for (int i = 0; i < n; i++)
			((tt__ContinuousFocus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ContinuousFocus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ContinuousFocus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ContinuousFocus %p -> %p\n", q, p));
	*(tt__ContinuousFocus*)p = *(tt__ContinuousFocus*)q;
}

void tt__RelativeFocus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_float(soap, &this->tt__RelativeFocus::Distance);
	this->tt__RelativeFocus::Speed = NULL;
	/* transient soap skipped */
}

void tt__RelativeFocus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__RelativeFocus::Distance, SOAP_TYPE_float);
	soap_serialize_PointerTofloat(soap, &this->tt__RelativeFocus::Speed);
	/* transient soap skipped */
}

int tt__RelativeFocus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RelativeFocus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelativeFocus(struct soap *soap, const char *tag, int id, const tt__RelativeFocus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelativeFocus), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Distance", -1, &(a->tt__RelativeFocus::Distance), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Speed", -1, &(a->tt__RelativeFocus::Speed), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__RelativeFocus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__RelativeFocus(soap, tag, this, type);
}

SOAP_FMAC3 tt__RelativeFocus * SOAP_FMAC4 soap_in_tt__RelativeFocus(struct soap *soap, const char *tag, tt__RelativeFocus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RelativeFocus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelativeFocus, sizeof(tt__RelativeFocus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__RelativeFocus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__RelativeFocus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Distance1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Distance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Distance", &(a->tt__RelativeFocus::Distance), "xsd:float"))
				{	soap_flag_Distance1--;
					continue;
				}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Speed", &(a->tt__RelativeFocus::Speed), "xsd:float"))
				{	soap_flag_Speed1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RelativeFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelativeFocus, 0, sizeof(tt__RelativeFocus), 0, soap_copy_tt__RelativeFocus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Distance1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__RelativeFocus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__RelativeFocus);
	if (this->soap_out(soap, tag?tag:"tt:RelativeFocus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RelativeFocus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RelativeFocus(soap, this, tag, type);
}

SOAP_FMAC3 tt__RelativeFocus * SOAP_FMAC4 soap_get_tt__RelativeFocus(struct soap *soap, tt__RelativeFocus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelativeFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__RelativeFocus * SOAP_FMAC2 soap_instantiate_tt__RelativeFocus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RelativeFocus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__RelativeFocus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__RelativeFocus);
		if (size)
			*size = sizeof(tt__RelativeFocus);
		((tt__RelativeFocus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__RelativeFocus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__RelativeFocus);
		for (int i = 0; i < n; i++)
			((tt__RelativeFocus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__RelativeFocus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__RelativeFocus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__RelativeFocus %p -> %p\n", q, p));
	*(tt__RelativeFocus*)p = *(tt__RelativeFocus*)q;
}

void tt__AbsoluteFocus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_float(soap, &this->tt__AbsoluteFocus::Position);
	this->tt__AbsoluteFocus::Speed = NULL;
	/* transient soap skipped */
}

void tt__AbsoluteFocus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__AbsoluteFocus::Position, SOAP_TYPE_float);
	soap_serialize_PointerTofloat(soap, &this->tt__AbsoluteFocus::Speed);
	/* transient soap skipped */
}

int tt__AbsoluteFocus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AbsoluteFocus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AbsoluteFocus(struct soap *soap, const char *tag, int id, const tt__AbsoluteFocus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AbsoluteFocus), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Position", -1, &(a->tt__AbsoluteFocus::Position), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Speed", -1, &(a->tt__AbsoluteFocus::Speed), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__AbsoluteFocus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__AbsoluteFocus(soap, tag, this, type);
}

SOAP_FMAC3 tt__AbsoluteFocus * SOAP_FMAC4 soap_in_tt__AbsoluteFocus(struct soap *soap, const char *tag, tt__AbsoluteFocus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AbsoluteFocus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AbsoluteFocus, sizeof(tt__AbsoluteFocus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__AbsoluteFocus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__AbsoluteFocus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Position", &(a->tt__AbsoluteFocus::Position), "xsd:float"))
				{	soap_flag_Position1--;
					continue;
				}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Speed", &(a->tt__AbsoluteFocus::Speed), "xsd:float"))
				{	soap_flag_Speed1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AbsoluteFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AbsoluteFocus, 0, sizeof(tt__AbsoluteFocus), 0, soap_copy_tt__AbsoluteFocus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__AbsoluteFocus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__AbsoluteFocus);
	if (this->soap_out(soap, tag?tag:"tt:AbsoluteFocus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AbsoluteFocus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AbsoluteFocus(soap, this, tag, type);
}

SOAP_FMAC3 tt__AbsoluteFocus * SOAP_FMAC4 soap_get_tt__AbsoluteFocus(struct soap *soap, tt__AbsoluteFocus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AbsoluteFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__AbsoluteFocus * SOAP_FMAC2 soap_instantiate_tt__AbsoluteFocus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AbsoluteFocus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__AbsoluteFocus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__AbsoluteFocus);
		if (size)
			*size = sizeof(tt__AbsoluteFocus);
		((tt__AbsoluteFocus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__AbsoluteFocus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__AbsoluteFocus);
		for (int i = 0; i < n; i++)
			((tt__AbsoluteFocus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__AbsoluteFocus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__AbsoluteFocus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__AbsoluteFocus %p -> %p\n", q, p));
	*(tt__AbsoluteFocus*)p = *(tt__AbsoluteFocus*)q;
}

void tt__FocusMove::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__FocusMove::Absolute = NULL;
	this->tt__FocusMove::Relative = NULL;
	this->tt__FocusMove::Continuous = NULL;
	/* transient soap skipped */
}

void tt__FocusMove::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AbsoluteFocus(soap, &this->tt__FocusMove::Absolute);
	soap_serialize_PointerTott__RelativeFocus(soap, &this->tt__FocusMove::Relative);
	soap_serialize_PointerTott__ContinuousFocus(soap, &this->tt__FocusMove::Continuous);
	/* transient soap skipped */
}

int tt__FocusMove::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusMove(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusMove(struct soap *soap, const char *tag, int id, const tt__FocusMove *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusMove), type))
		return soap->error;
	if (soap_out_PointerTott__AbsoluteFocus(soap, "tt:Absolute", -1, &(a->tt__FocusMove::Absolute), ""))
		return soap->error;
	if (soap_out_PointerTott__RelativeFocus(soap, "tt:Relative", -1, &(a->tt__FocusMove::Relative), ""))
		return soap->error;
	if (soap_out_PointerTott__ContinuousFocus(soap, "tt:Continuous", -1, &(a->tt__FocusMove::Continuous), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__FocusMove::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__FocusMove(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusMove * SOAP_FMAC4 soap_in_tt__FocusMove(struct soap *soap, const char *tag, tt__FocusMove *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusMove *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusMove, sizeof(tt__FocusMove), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__FocusMove)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__FocusMove *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Absolute1 = 1;
	size_t soap_flag_Relative1 = 1;
	size_t soap_flag_Continuous1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Absolute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AbsoluteFocus(soap, "tt:Absolute", &(a->tt__FocusMove::Absolute), "tt:AbsoluteFocus"))
				{	soap_flag_Absolute1--;
					continue;
				}
			if (soap_flag_Relative1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RelativeFocus(soap, "tt:Relative", &(a->tt__FocusMove::Relative), "tt:RelativeFocus"))
				{	soap_flag_Relative1--;
					continue;
				}
			if (soap_flag_Continuous1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ContinuousFocus(soap, "tt:Continuous", &(a->tt__FocusMove::Continuous), "tt:ContinuousFocus"))
				{	soap_flag_Continuous1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusMove, 0, sizeof(tt__FocusMove), 0, soap_copy_tt__FocusMove);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__FocusMove::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__FocusMove);
	if (this->soap_out(soap, tag?tag:"tt:FocusMove", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusMove::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusMove(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusMove * SOAP_FMAC4 soap_get_tt__FocusMove(struct soap *soap, tt__FocusMove *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__FocusMove * SOAP_FMAC2 soap_instantiate_tt__FocusMove(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusMove(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__FocusMove, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__FocusMove);
		if (size)
			*size = sizeof(tt__FocusMove);
		((tt__FocusMove*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__FocusMove[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__FocusMove);
		for (int i = 0; i < n; i++)
			((tt__FocusMove*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__FocusMove*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__FocusMove(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__FocusMove %p -> %p\n", q, p));
	*(tt__FocusMove*)p = *(tt__FocusMove*)q;
}

void tt__WhiteBalanceOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__WhiteBalanceMode(soap, &this->tt__WhiteBalanceOptions::Mode);
	this->tt__WhiteBalanceOptions::YrGain = NULL;
	this->tt__WhiteBalanceOptions::YbGain = NULL;
	/* transient soap skipped */
}

void tt__WhiteBalanceOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOftt__WhiteBalanceMode(soap, &this->tt__WhiteBalanceOptions::Mode);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__WhiteBalanceOptions::YrGain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__WhiteBalanceOptions::YbGain);
	/* transient soap skipped */
}

int tt__WhiteBalanceOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalanceOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceOptions(struct soap *soap, const char *tag, int id, const tt__WhiteBalanceOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalanceOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__WhiteBalanceMode(soap, "tt:Mode", -1, &(a->tt__WhiteBalanceOptions::Mode), ""))
		return soap->error;
	if (a->tt__WhiteBalanceOptions::YrGain)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:YrGain", -1, &a->tt__WhiteBalanceOptions::YrGain, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:YrGain"))
		return soap->error;
	if (a->tt__WhiteBalanceOptions::YbGain)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:YbGain", -1, &a->tt__WhiteBalanceOptions::YbGain, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:YbGain"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__WhiteBalanceOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__WhiteBalanceOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions * SOAP_FMAC4 soap_in_tt__WhiteBalanceOptions(struct soap *soap, const char *tag, tt__WhiteBalanceOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WhiteBalanceOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceOptions, sizeof(tt__WhiteBalanceOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__WhiteBalanceOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__WhiteBalanceOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_YrGain1 = 1;
	size_t soap_flag_YbGain1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftt__WhiteBalanceMode(soap, "tt:Mode", &(a->tt__WhiteBalanceOptions::Mode), "tt:WhiteBalanceMode"))
					continue;
			if (soap_flag_YrGain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:YrGain", &(a->tt__WhiteBalanceOptions::YrGain), "tt:FloatRange"))
				{	soap_flag_YrGain1--;
					continue;
				}
			if (soap_flag_YbGain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:YbGain", &(a->tt__WhiteBalanceOptions::YbGain), "tt:FloatRange"))
				{	soap_flag_YbGain1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__WhiteBalanceOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceOptions, 0, sizeof(tt__WhiteBalanceOptions), 0, soap_copy_tt__WhiteBalanceOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__WhiteBalanceOptions::Mode.size() < 1 || soap_flag_YrGain1 > 0 || soap_flag_YbGain1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__WhiteBalanceOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__WhiteBalanceOptions);
	if (this->soap_out(soap, tag?tag:"tt:WhiteBalanceOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalanceOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalanceOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions * SOAP_FMAC4 soap_get_tt__WhiteBalanceOptions(struct soap *soap, tt__WhiteBalanceOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__WhiteBalanceOptions * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WhiteBalanceOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__WhiteBalanceOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__WhiteBalanceOptions);
		if (size)
			*size = sizeof(tt__WhiteBalanceOptions);
		((tt__WhiteBalanceOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__WhiteBalanceOptions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__WhiteBalanceOptions);
		for (int i = 0; i < n; i++)
			((tt__WhiteBalanceOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__WhiteBalanceOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__WhiteBalanceOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__WhiteBalanceOptions %p -> %p\n", q, p));
	*(tt__WhiteBalanceOptions*)p = *(tt__WhiteBalanceOptions*)q;
}

void tt__ExposureOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__ExposureMode(soap, &this->tt__ExposureOptions::Mode);
	soap_default_std__vectorTemplateOftt__ExposurePriority(soap, &this->tt__ExposureOptions::Priority);
	this->tt__ExposureOptions::MinExposureTime = NULL;
	this->tt__ExposureOptions::MaxExposureTime = NULL;
	this->tt__ExposureOptions::MinGain = NULL;
	this->tt__ExposureOptions::MaxGain = NULL;
	this->tt__ExposureOptions::MinIris = NULL;
	this->tt__ExposureOptions::MaxIris = NULL;
	this->tt__ExposureOptions::ExposureTime = NULL;
	this->tt__ExposureOptions::Gain = NULL;
	this->tt__ExposureOptions::Iris = NULL;
	/* transient soap skipped */
}

void tt__ExposureOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOftt__ExposureMode(soap, &this->tt__ExposureOptions::Mode);
	soap_serialize_std__vectorTemplateOftt__ExposurePriority(soap, &this->tt__ExposureOptions::Priority);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions::MinExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions::MaxExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions::MinGain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions::MaxGain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions::MinIris);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions::MaxIris);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions::ExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions::Gain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions::Iris);
	/* transient soap skipped */
}

int tt__ExposureOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ExposureOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposureOptions(struct soap *soap, const char *tag, int id, const tt__ExposureOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ExposureOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ExposureMode(soap, "tt:Mode", -1, &(a->tt__ExposureOptions::Mode), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ExposurePriority(soap, "tt:Priority", -1, &(a->tt__ExposureOptions::Priority), ""))
		return soap->error;
	if (a->tt__ExposureOptions::MinExposureTime)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:MinExposureTime", -1, &a->tt__ExposureOptions::MinExposureTime, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:MinExposureTime"))
		return soap->error;
	if (a->tt__ExposureOptions::MaxExposureTime)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxExposureTime", -1, &a->tt__ExposureOptions::MaxExposureTime, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:MaxExposureTime"))
		return soap->error;
	if (a->tt__ExposureOptions::MinGain)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:MinGain", -1, &a->tt__ExposureOptions::MinGain, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:MinGain"))
		return soap->error;
	if (a->tt__ExposureOptions::MaxGain)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxGain", -1, &a->tt__ExposureOptions::MaxGain, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:MaxGain"))
		return soap->error;
	if (a->tt__ExposureOptions::MinIris)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:MinIris", -1, &a->tt__ExposureOptions::MinIris, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:MinIris"))
		return soap->error;
	if (a->tt__ExposureOptions::MaxIris)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxIris", -1, &a->tt__ExposureOptions::MaxIris, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:MaxIris"))
		return soap->error;
	if (a->tt__ExposureOptions::ExposureTime)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:ExposureTime", -1, &a->tt__ExposureOptions::ExposureTime, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:ExposureTime"))
		return soap->error;
	if (a->tt__ExposureOptions::Gain)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Gain", -1, &a->tt__ExposureOptions::Gain, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Gain"))
		return soap->error;
	if (a->tt__ExposureOptions::Iris)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Iris", -1, &a->tt__ExposureOptions::Iris, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Iris"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ExposureOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ExposureOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__ExposureOptions * SOAP_FMAC4 soap_in_tt__ExposureOptions(struct soap *soap, const char *tag, tt__ExposureOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ExposureOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposureOptions, sizeof(tt__ExposureOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ExposureOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ExposureOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_MinExposureTime1 = 1;
	size_t soap_flag_MaxExposureTime1 = 1;
	size_t soap_flag_MinGain1 = 1;
	size_t soap_flag_MaxGain1 = 1;
	size_t soap_flag_MinIris1 = 1;
	size_t soap_flag_MaxIris1 = 1;
	size_t soap_flag_ExposureTime1 = 1;
	size_t soap_flag_Gain1 = 1;
	size_t soap_flag_Iris1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftt__ExposureMode(soap, "tt:Mode", &(a->tt__ExposureOptions::Mode), "tt:ExposureMode"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftt__ExposurePriority(soap, "tt:Priority", &(a->tt__ExposureOptions::Priority), "tt:ExposurePriority"))
					continue;
			if (soap_flag_MinExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MinExposureTime", &(a->tt__ExposureOptions::MinExposureTime), "tt:FloatRange"))
				{	soap_flag_MinExposureTime1--;
					continue;
				}
			if (soap_flag_MaxExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MaxExposureTime", &(a->tt__ExposureOptions::MaxExposureTime), "tt:FloatRange"))
				{	soap_flag_MaxExposureTime1--;
					continue;
				}
			if (soap_flag_MinGain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MinGain", &(a->tt__ExposureOptions::MinGain), "tt:FloatRange"))
				{	soap_flag_MinGain1--;
					continue;
				}
			if (soap_flag_MaxGain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MaxGain", &(a->tt__ExposureOptions::MaxGain), "tt:FloatRange"))
				{	soap_flag_MaxGain1--;
					continue;
				}
			if (soap_flag_MinIris1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MinIris", &(a->tt__ExposureOptions::MinIris), "tt:FloatRange"))
				{	soap_flag_MinIris1--;
					continue;
				}
			if (soap_flag_MaxIris1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MaxIris", &(a->tt__ExposureOptions::MaxIris), "tt:FloatRange"))
				{	soap_flag_MaxIris1--;
					continue;
				}
			if (soap_flag_ExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:ExposureTime", &(a->tt__ExposureOptions::ExposureTime), "tt:FloatRange"))
				{	soap_flag_ExposureTime1--;
					continue;
				}
			if (soap_flag_Gain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Gain", &(a->tt__ExposureOptions::Gain), "tt:FloatRange"))
				{	soap_flag_Gain1--;
					continue;
				}
			if (soap_flag_Iris1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Iris", &(a->tt__ExposureOptions::Iris), "tt:FloatRange"))
				{	soap_flag_Iris1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ExposureOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposureOptions, 0, sizeof(tt__ExposureOptions), 0, soap_copy_tt__ExposureOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__ExposureOptions::Mode.size() < 1 || a->tt__ExposureOptions::Priority.size() < 1 || soap_flag_MinExposureTime1 > 0 || soap_flag_MaxExposureTime1 > 0 || soap_flag_MinGain1 > 0 || soap_flag_MaxGain1 > 0 || soap_flag_MinIris1 > 0 || soap_flag_MaxIris1 > 0 || soap_flag_ExposureTime1 > 0 || soap_flag_Gain1 > 0 || soap_flag_Iris1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__ExposureOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ExposureOptions);
	if (this->soap_out(soap, tag?tag:"tt:ExposureOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ExposureOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ExposureOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__ExposureOptions * SOAP_FMAC4 soap_get_tt__ExposureOptions(struct soap *soap, tt__ExposureOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposureOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ExposureOptions * SOAP_FMAC2 soap_instantiate_tt__ExposureOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ExposureOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ExposureOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ExposureOptions);
		if (size)
			*size = sizeof(tt__ExposureOptions);
		((tt__ExposureOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ExposureOptions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ExposureOptions);
		for (int i = 0; i < n; i++)
			((tt__ExposureOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ExposureOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ExposureOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ExposureOptions %p -> %p\n", q, p));
	*(tt__ExposureOptions*)p = *(tt__ExposureOptions*)q;
}

void tt__FocusOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__AutoFocusMode(soap, &this->tt__FocusOptions::AutoFocusModes);
	this->tt__FocusOptions::DefaultSpeed = NULL;
	this->tt__FocusOptions::NearLimit = NULL;
	this->tt__FocusOptions::FarLimit = NULL;
	/* transient soap skipped */
}

void tt__FocusOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOftt__AutoFocusMode(soap, &this->tt__FocusOptions::AutoFocusModes);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__FocusOptions::DefaultSpeed);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__FocusOptions::NearLimit);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__FocusOptions::FarLimit);
	/* transient soap skipped */
}

int tt__FocusOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusOptions(struct soap *soap, const char *tag, int id, const tt__FocusOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__AutoFocusMode(soap, "tt:AutoFocusModes", -1, &(a->tt__FocusOptions::AutoFocusModes), ""))
		return soap->error;
	if (a->tt__FocusOptions::DefaultSpeed)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:DefaultSpeed", -1, &a->tt__FocusOptions::DefaultSpeed, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:DefaultSpeed"))
		return soap->error;
	if (a->tt__FocusOptions::NearLimit)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:NearLimit", -1, &a->tt__FocusOptions::NearLimit, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:NearLimit"))
		return soap->error;
	if (a->tt__FocusOptions::FarLimit)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:FarLimit", -1, &a->tt__FocusOptions::FarLimit, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:FarLimit"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__FocusOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__FocusOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusOptions * SOAP_FMAC4 soap_in_tt__FocusOptions(struct soap *soap, const char *tag, tt__FocusOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusOptions, sizeof(tt__FocusOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__FocusOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__FocusOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_DefaultSpeed1 = 1;
	size_t soap_flag_NearLimit1 = 1;
	size_t soap_flag_FarLimit1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftt__AutoFocusMode(soap, "tt:AutoFocusModes", &(a->tt__FocusOptions::AutoFocusModes), "tt:AutoFocusMode"))
					continue;
			if (soap_flag_DefaultSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:DefaultSpeed", &(a->tt__FocusOptions::DefaultSpeed), "tt:FloatRange"))
				{	soap_flag_DefaultSpeed1--;
					continue;
				}
			if (soap_flag_NearLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:NearLimit", &(a->tt__FocusOptions::NearLimit), "tt:FloatRange"))
				{	soap_flag_NearLimit1--;
					continue;
				}
			if (soap_flag_FarLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:FarLimit", &(a->tt__FocusOptions::FarLimit), "tt:FloatRange"))
				{	soap_flag_FarLimit1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusOptions, 0, sizeof(tt__FocusOptions), 0, soap_copy_tt__FocusOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DefaultSpeed1 > 0 || soap_flag_NearLimit1 > 0 || soap_flag_FarLimit1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__FocusOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__FocusOptions);
	if (this->soap_out(soap, tag?tag:"tt:FocusOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusOptions * SOAP_FMAC4 soap_get_tt__FocusOptions(struct soap *soap, tt__FocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__FocusOptions * SOAP_FMAC2 soap_instantiate_tt__FocusOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__FocusOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__FocusOptions);
		if (size)
			*size = sizeof(tt__FocusOptions);
		((tt__FocusOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__FocusOptions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__FocusOptions);
		for (int i = 0; i < n; i++)
			((tt__FocusOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__FocusOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__FocusOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__FocusOptions %p -> %p\n", q, p));
	*(tt__FocusOptions*)p = *(tt__FocusOptions*)q;
}

void tt__BacklightCompensationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__WideDynamicMode(soap, &this->tt__BacklightCompensationOptions::Mode);
	this->tt__BacklightCompensationOptions::Level = NULL;
	/* transient soap skipped */
}

void tt__BacklightCompensationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOftt__WideDynamicMode(soap, &this->tt__BacklightCompensationOptions::Mode);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__BacklightCompensationOptions::Level);
	/* transient soap skipped */
}

int tt__BacklightCompensationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BacklightCompensationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensationOptions(struct soap *soap, const char *tag, int id, const tt__BacklightCompensationOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensationOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__WideDynamicMode(soap, "tt:Mode", -1, &(a->tt__BacklightCompensationOptions::Mode), ""))
		return soap->error;
	if (a->tt__BacklightCompensationOptions::Level)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->tt__BacklightCompensationOptions::Level, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Level"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__BacklightCompensationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__BacklightCompensationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__BacklightCompensationOptions * SOAP_FMAC4 soap_in_tt__BacklightCompensationOptions(struct soap *soap, const char *tag, tt__BacklightCompensationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__BacklightCompensationOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensationOptions, sizeof(tt__BacklightCompensationOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__BacklightCompensationOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__BacklightCompensationOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Level1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftt__WideDynamicMode(soap, "tt:Mode", &(a->tt__BacklightCompensationOptions::Mode), "tt:WideDynamicMode"))
					continue;
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &(a->tt__BacklightCompensationOptions::Level), "tt:FloatRange"))
				{	soap_flag_Level1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__BacklightCompensationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensationOptions, 0, sizeof(tt__BacklightCompensationOptions), 0, soap_copy_tt__BacklightCompensationOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__BacklightCompensationOptions::Mode.size() < 1 || soap_flag_Level1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__BacklightCompensationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__BacklightCompensationOptions);
	if (this->soap_out(soap, tag?tag:"tt:BacklightCompensationOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BacklightCompensationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BacklightCompensationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__BacklightCompensationOptions * SOAP_FMAC4 soap_get_tt__BacklightCompensationOptions(struct soap *soap, tt__BacklightCompensationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__BacklightCompensationOptions * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__BacklightCompensationOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__BacklightCompensationOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__BacklightCompensationOptions);
		if (size)
			*size = sizeof(tt__BacklightCompensationOptions);
		((tt__BacklightCompensationOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__BacklightCompensationOptions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__BacklightCompensationOptions);
		for (int i = 0; i < n; i++)
			((tt__BacklightCompensationOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__BacklightCompensationOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__BacklightCompensationOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__BacklightCompensationOptions %p -> %p\n", q, p));
	*(tt__BacklightCompensationOptions*)p = *(tt__BacklightCompensationOptions*)q;
}

void tt__WideDynamicRangeOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__WideDynamicMode(soap, &this->tt__WideDynamicRangeOptions::Mode);
	this->tt__WideDynamicRangeOptions::Level = NULL;
	/* transient soap skipped */
}

void tt__WideDynamicRangeOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOftt__WideDynamicMode(soap, &this->tt__WideDynamicRangeOptions::Mode);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__WideDynamicRangeOptions::Level);
	/* transient soap skipped */
}

int tt__WideDynamicRangeOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WideDynamicRangeOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRangeOptions(struct soap *soap, const char *tag, int id, const tt__WideDynamicRangeOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRangeOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__WideDynamicMode(soap, "tt:Mode", -1, &(a->tt__WideDynamicRangeOptions::Mode), ""))
		return soap->error;
	if (a->tt__WideDynamicRangeOptions::Level)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->tt__WideDynamicRangeOptions::Level, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Level"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__WideDynamicRangeOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__WideDynamicRangeOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__WideDynamicRangeOptions * SOAP_FMAC4 soap_in_tt__WideDynamicRangeOptions(struct soap *soap, const char *tag, tt__WideDynamicRangeOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WideDynamicRangeOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRangeOptions, sizeof(tt__WideDynamicRangeOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__WideDynamicRangeOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__WideDynamicRangeOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Level1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftt__WideDynamicMode(soap, "tt:Mode", &(a->tt__WideDynamicRangeOptions::Mode), "tt:WideDynamicMode"))
					continue;
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &(a->tt__WideDynamicRangeOptions::Level), "tt:FloatRange"))
				{	soap_flag_Level1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__WideDynamicRangeOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRangeOptions, 0, sizeof(tt__WideDynamicRangeOptions), 0, soap_copy_tt__WideDynamicRangeOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__WideDynamicRangeOptions::Mode.size() < 1 || soap_flag_Level1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__WideDynamicRangeOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__WideDynamicRangeOptions);
	if (this->soap_out(soap, tag?tag:"tt:WideDynamicRangeOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WideDynamicRangeOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WideDynamicRangeOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__WideDynamicRangeOptions * SOAP_FMAC4 soap_get_tt__WideDynamicRangeOptions(struct soap *soap, tt__WideDynamicRangeOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRangeOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__WideDynamicRangeOptions * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRangeOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WideDynamicRangeOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__WideDynamicRangeOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__WideDynamicRangeOptions);
		if (size)
			*size = sizeof(tt__WideDynamicRangeOptions);
		((tt__WideDynamicRangeOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__WideDynamicRangeOptions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__WideDynamicRangeOptions);
		for (int i = 0; i < n; i++)
			((tt__WideDynamicRangeOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__WideDynamicRangeOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__WideDynamicRangeOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__WideDynamicRangeOptions %p -> %p\n", q, p));
	*(tt__WideDynamicRangeOptions*)p = *(tt__WideDynamicRangeOptions*)q;
}

void tt__ImagingOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ImagingOptions::BacklightCompensation = NULL;
	this->tt__ImagingOptions::Brightness = NULL;
	this->tt__ImagingOptions::ColorSaturation = NULL;
	this->tt__ImagingOptions::Contrast = NULL;
	this->tt__ImagingOptions::Exposure = NULL;
	this->tt__ImagingOptions::Focus = NULL;
	soap_default_std__vectorTemplateOftt__IrCutFilterMode(soap, &this->tt__ImagingOptions::IrCutFilterModes);
	this->tt__ImagingOptions::Sharpness = NULL;
	this->tt__ImagingOptions::WideDynamicRange = NULL;
	this->tt__ImagingOptions::WhiteBalance = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingOptions::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__ImagingOptions::__anyAttribute);
	/* transient soap skipped */
}

void tt__ImagingOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__BacklightCompensationOptions(soap, &this->tt__ImagingOptions::BacklightCompensation);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions::Brightness);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions::ColorSaturation);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions::Contrast);
	soap_serialize_PointerTott__ExposureOptions(soap, &this->tt__ImagingOptions::Exposure);
	soap_serialize_PointerTott__FocusOptions(soap, &this->tt__ImagingOptions::Focus);
	soap_serialize_std__vectorTemplateOftt__IrCutFilterMode(soap, &this->tt__ImagingOptions::IrCutFilterModes);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions::Sharpness);
	soap_serialize_PointerTott__WideDynamicRangeOptions(soap, &this->tt__ImagingOptions::WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalanceOptions(soap, &this->tt__ImagingOptions::WhiteBalance);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingOptions::__any);
	/* transient soap skipped */
}

int tt__ImagingOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions(struct soap *soap, const char *tag, int id, const tt__ImagingOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ImagingOptions*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions), type))
		return soap->error;
	if (a->tt__ImagingOptions::BacklightCompensation)
	{	if (soap_out_PointerTott__BacklightCompensationOptions(soap, "tt:BacklightCompensation", -1, &a->tt__ImagingOptions::BacklightCompensation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:BacklightCompensation"))
		return soap->error;
	if (a->tt__ImagingOptions::Brightness)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Brightness", -1, &a->tt__ImagingOptions::Brightness, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Brightness"))
		return soap->error;
	if (a->tt__ImagingOptions::ColorSaturation)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:ColorSaturation", -1, &a->tt__ImagingOptions::ColorSaturation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:ColorSaturation"))
		return soap->error;
	if (a->tt__ImagingOptions::Contrast)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Contrast", -1, &a->tt__ImagingOptions::Contrast, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Contrast"))
		return soap->error;
	if (a->tt__ImagingOptions::Exposure)
	{	if (soap_out_PointerTott__ExposureOptions(soap, "tt:Exposure", -1, &a->tt__ImagingOptions::Exposure, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Exposure"))
		return soap->error;
	if (a->tt__ImagingOptions::Focus)
	{	if (soap_out_PointerTott__FocusOptions(soap, "tt:Focus", -1, &a->tt__ImagingOptions::Focus, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Focus"))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IrCutFilterMode(soap, "tt:IrCutFilterModes", -1, &(a->tt__ImagingOptions::IrCutFilterModes), ""))
		return soap->error;
	if (a->tt__ImagingOptions::Sharpness)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Sharpness", -1, &a->tt__ImagingOptions::Sharpness, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Sharpness"))
		return soap->error;
	if (a->tt__ImagingOptions::WideDynamicRange)
	{	if (soap_out_PointerTott__WideDynamicRangeOptions(soap, "tt:WideDynamicRange", -1, &a->tt__ImagingOptions::WideDynamicRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:WideDynamicRange"))
		return soap->error;
	if (a->tt__ImagingOptions::WhiteBalance)
	{	if (soap_out_PointerTott__WhiteBalanceOptions(soap, "tt:WhiteBalance", -1, &a->tt__ImagingOptions::WhiteBalance, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:WhiteBalance"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__ImagingOptions::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ImagingOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingOptions * SOAP_FMAC4 soap_in_tt__ImagingOptions(struct soap *soap, const char *tag, tt__ImagingOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions, sizeof(tt__ImagingOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ImagingOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ImagingOptions *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ImagingOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_BacklightCompensation1 = 1;
	size_t soap_flag_Brightness1 = 1;
	size_t soap_flag_ColorSaturation1 = 1;
	size_t soap_flag_Contrast1 = 1;
	size_t soap_flag_Exposure1 = 1;
	size_t soap_flag_Focus1 = 1;
	size_t soap_flag_Sharpness1 = 1;
	size_t soap_flag_WideDynamicRange1 = 1;
	size_t soap_flag_WhiteBalance1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BacklightCompensationOptions(soap, "tt:BacklightCompensation", &(a->tt__ImagingOptions::BacklightCompensation), "tt:BacklightCompensationOptions"))
				{	soap_flag_BacklightCompensation1--;
					continue;
				}
			if (soap_flag_Brightness1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Brightness", &(a->tt__ImagingOptions::Brightness), "tt:FloatRange"))
				{	soap_flag_Brightness1--;
					continue;
				}
			if (soap_flag_ColorSaturation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:ColorSaturation", &(a->tt__ImagingOptions::ColorSaturation), "tt:FloatRange"))
				{	soap_flag_ColorSaturation1--;
					continue;
				}
			if (soap_flag_Contrast1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Contrast", &(a->tt__ImagingOptions::Contrast), "tt:FloatRange"))
				{	soap_flag_Contrast1--;
					continue;
				}
			if (soap_flag_Exposure1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ExposureOptions(soap, "tt:Exposure", &(a->tt__ImagingOptions::Exposure), "tt:ExposureOptions"))
				{	soap_flag_Exposure1--;
					continue;
				}
			if (soap_flag_Focus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusOptions(soap, "tt:Focus", &(a->tt__ImagingOptions::Focus), "tt:FocusOptions"))
				{	soap_flag_Focus1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftt__IrCutFilterMode(soap, "tt:IrCutFilterModes", &(a->tt__ImagingOptions::IrCutFilterModes), "tt:IrCutFilterMode"))
					continue;
			if (soap_flag_Sharpness1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Sharpness", &(a->tt__ImagingOptions::Sharpness), "tt:FloatRange"))
				{	soap_flag_Sharpness1--;
					continue;
				}
			if (soap_flag_WideDynamicRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WideDynamicRangeOptions(soap, "tt:WideDynamicRange", &(a->tt__ImagingOptions::WideDynamicRange), "tt:WideDynamicRangeOptions"))
				{	soap_flag_WideDynamicRange1--;
					continue;
				}
			if (soap_flag_WhiteBalance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WhiteBalanceOptions(soap, "tt:WhiteBalance", &(a->tt__ImagingOptions::WhiteBalance), "tt:WhiteBalanceOptions"))
				{	soap_flag_WhiteBalance1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__ImagingOptions::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions, 0, sizeof(tt__ImagingOptions), 0, soap_copy_tt__ImagingOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_BacklightCompensation1 > 0 || soap_flag_Brightness1 > 0 || soap_flag_ColorSaturation1 > 0 || soap_flag_Contrast1 > 0 || soap_flag_Exposure1 > 0 || soap_flag_Focus1 > 0 || a->tt__ImagingOptions::IrCutFilterModes.size() < 1 || soap_flag_Sharpness1 > 0 || soap_flag_WideDynamicRange1 > 0 || soap_flag_WhiteBalance1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__ImagingOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ImagingOptions);
	if (this->soap_out(soap, tag?tag:"tt:ImagingOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingOptions * SOAP_FMAC4 soap_get_tt__ImagingOptions(struct soap *soap, tt__ImagingOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ImagingOptions * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ImagingOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ImagingOptions);
		if (size)
			*size = sizeof(tt__ImagingOptions);
		((tt__ImagingOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ImagingOptions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ImagingOptions);
		for (int i = 0; i < n; i++)
			((tt__ImagingOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ImagingOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ImagingOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ImagingOptions %p -> %p\n", q, p));
	*(tt__ImagingOptions*)p = *(tt__ImagingOptions*)q;
}

void tt__BacklightCompensation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__BacklightCompensationMode(soap, &this->tt__BacklightCompensation::Mode);
	soap_default_float(soap, &this->tt__BacklightCompensation::Level);
	/* transient soap skipped */
}

void tt__BacklightCompensation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__BacklightCompensation::Level, SOAP_TYPE_float);
	/* transient soap skipped */
}

int tt__BacklightCompensation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BacklightCompensation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensation(struct soap *soap, const char *tag, int id, const tt__BacklightCompensation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensation), type))
		return soap->error;
	if (soap_out_tt__BacklightCompensationMode(soap, "tt:Mode", -1, &(a->tt__BacklightCompensation::Mode), ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Level", -1, &(a->tt__BacklightCompensation::Level), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__BacklightCompensation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__BacklightCompensation(soap, tag, this, type);
}

SOAP_FMAC3 tt__BacklightCompensation * SOAP_FMAC4 soap_in_tt__BacklightCompensation(struct soap *soap, const char *tag, tt__BacklightCompensation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__BacklightCompensation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensation, sizeof(tt__BacklightCompensation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__BacklightCompensation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__BacklightCompensation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__BacklightCompensationMode(soap, "tt:Mode", &(a->tt__BacklightCompensation::Mode), "tt:BacklightCompensationMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Level", &(a->tt__BacklightCompensation::Level), "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__BacklightCompensation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensation, 0, sizeof(tt__BacklightCompensation), 0, soap_copy_tt__BacklightCompensation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0 || soap_flag_Level1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__BacklightCompensation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__BacklightCompensation);
	if (this->soap_out(soap, tag?tag:"tt:BacklightCompensation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BacklightCompensation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BacklightCompensation(soap, this, tag, type);
}

SOAP_FMAC3 tt__BacklightCompensation * SOAP_FMAC4 soap_get_tt__BacklightCompensation(struct soap *soap, tt__BacklightCompensation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__BacklightCompensation * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__BacklightCompensation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__BacklightCompensation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__BacklightCompensation);
		if (size)
			*size = sizeof(tt__BacklightCompensation);
		((tt__BacklightCompensation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__BacklightCompensation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__BacklightCompensation);
		for (int i = 0; i < n; i++)
			((tt__BacklightCompensation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__BacklightCompensation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__BacklightCompensation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__BacklightCompensation %p -> %p\n", q, p));
	*(tt__BacklightCompensation*)p = *(tt__BacklightCompensation*)q;
}

void tt__WideDynamicRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__WideDynamicMode(soap, &this->tt__WideDynamicRange::Mode);
	soap_default_float(soap, &this->tt__WideDynamicRange::Level);
	/* transient soap skipped */
}

void tt__WideDynamicRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__WideDynamicRange::Level, SOAP_TYPE_float);
	/* transient soap skipped */
}

int tt__WideDynamicRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WideDynamicRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRange(struct soap *soap, const char *tag, int id, const tt__WideDynamicRange *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRange), type))
		return soap->error;
	if (soap_out_tt__WideDynamicMode(soap, "tt:Mode", -1, &(a->tt__WideDynamicRange::Mode), ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Level", -1, &(a->tt__WideDynamicRange::Level), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__WideDynamicRange::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__WideDynamicRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__WideDynamicRange * SOAP_FMAC4 soap_in_tt__WideDynamicRange(struct soap *soap, const char *tag, tt__WideDynamicRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WideDynamicRange *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRange, sizeof(tt__WideDynamicRange), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__WideDynamicRange)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__WideDynamicRange *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__WideDynamicMode(soap, "tt:Mode", &(a->tt__WideDynamicRange::Mode), "tt:WideDynamicMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Level", &(a->tt__WideDynamicRange::Level), "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__WideDynamicRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRange, 0, sizeof(tt__WideDynamicRange), 0, soap_copy_tt__WideDynamicRange);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0 || soap_flag_Level1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__WideDynamicRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__WideDynamicRange);
	if (this->soap_out(soap, tag?tag:"tt:WideDynamicRange", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WideDynamicRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WideDynamicRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__WideDynamicRange * SOAP_FMAC4 soap_get_tt__WideDynamicRange(struct soap *soap, tt__WideDynamicRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__WideDynamicRange * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WideDynamicRange(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__WideDynamicRange, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__WideDynamicRange);
		if (size)
			*size = sizeof(tt__WideDynamicRange);
		((tt__WideDynamicRange*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__WideDynamicRange[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__WideDynamicRange);
		for (int i = 0; i < n; i++)
			((tt__WideDynamicRange*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__WideDynamicRange*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__WideDynamicRange(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__WideDynamicRange %p -> %p\n", q, p));
	*(tt__WideDynamicRange*)p = *(tt__WideDynamicRange*)q;
}

void tt__Exposure::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ExposureMode(soap, &this->tt__Exposure::Mode);
	soap_default_tt__ExposurePriority(soap, &this->tt__Exposure::Priority);
	this->tt__Exposure::Window = NULL;
	soap_default_float(soap, &this->tt__Exposure::MinExposureTime);
	soap_default_float(soap, &this->tt__Exposure::MaxExposureTime);
	soap_default_float(soap, &this->tt__Exposure::MinGain);
	soap_default_float(soap, &this->tt__Exposure::MaxGain);
	soap_default_float(soap, &this->tt__Exposure::MinIris);
	soap_default_float(soap, &this->tt__Exposure::MaxIris);
	soap_default_float(soap, &this->tt__Exposure::ExposureTime);
	soap_default_float(soap, &this->tt__Exposure::Gain);
	soap_default_float(soap, &this->tt__Exposure::Iris);
	/* transient soap skipped */
}

void tt__Exposure::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__Exposure::Priority, SOAP_TYPE_tt__ExposurePriority);
	soap_serialize_PointerTott__Rectangle(soap, &this->tt__Exposure::Window);
	soap_embedded(soap, &this->tt__Exposure::MinExposureTime, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::MaxExposureTime, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::MinGain, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::MaxGain, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::MinIris, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::MaxIris, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::ExposureTime, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::Gain, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::Iris, SOAP_TYPE_float);
	/* transient soap skipped */
}

int tt__Exposure::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Exposure(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Exposure(struct soap *soap, const char *tag, int id, const tt__Exposure *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Exposure), type))
		return soap->error;
	if (soap_out_tt__ExposureMode(soap, "tt:Mode", -1, &(a->tt__Exposure::Mode), ""))
		return soap->error;
	if (soap_out_tt__ExposurePriority(soap, "tt:Priority", -1, &(a->tt__Exposure::Priority), ""))
		return soap->error;
	if (a->tt__Exposure::Window)
	{	if (soap_out_PointerTott__Rectangle(soap, "tt:Window", -1, &a->tt__Exposure::Window, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Window"))
		return soap->error;
	if (soap_out_float(soap, "tt:MinExposureTime", -1, &(a->tt__Exposure::MinExposureTime), ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MaxExposureTime", -1, &(a->tt__Exposure::MaxExposureTime), ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MinGain", -1, &(a->tt__Exposure::MinGain), ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MaxGain", -1, &(a->tt__Exposure::MaxGain), ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MinIris", -1, &(a->tt__Exposure::MinIris), ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MaxIris", -1, &(a->tt__Exposure::MaxIris), ""))
		return soap->error;
	if (soap_out_float(soap, "tt:ExposureTime", -1, &(a->tt__Exposure::ExposureTime), ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Gain", -1, &(a->tt__Exposure::Gain), ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Iris", -1, &(a->tt__Exposure::Iris), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Exposure::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Exposure(soap, tag, this, type);
}

SOAP_FMAC3 tt__Exposure * SOAP_FMAC4 soap_in_tt__Exposure(struct soap *soap, const char *tag, tt__Exposure *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Exposure *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Exposure, sizeof(tt__Exposure), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Exposure)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Exposure *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Priority1 = 1;
	size_t soap_flag_Window1 = 1;
	size_t soap_flag_MinExposureTime1 = 1;
	size_t soap_flag_MaxExposureTime1 = 1;
	size_t soap_flag_MinGain1 = 1;
	size_t soap_flag_MaxGain1 = 1;
	size_t soap_flag_MinIris1 = 1;
	size_t soap_flag_MaxIris1 = 1;
	size_t soap_flag_ExposureTime1 = 1;
	size_t soap_flag_Gain1 = 1;
	size_t soap_flag_Iris1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__ExposureMode(soap, "tt:Mode", &(a->tt__Exposure::Mode), "tt:ExposureMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			if (soap_flag_Priority1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__ExposurePriority(soap, "tt:Priority", &(a->tt__Exposure::Priority), "tt:ExposurePriority"))
				{	soap_flag_Priority1--;
					continue;
				}
			if (soap_flag_Window1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Rectangle(soap, "tt:Window", &(a->tt__Exposure::Window), "tt:Rectangle"))
				{	soap_flag_Window1--;
					continue;
				}
			if (soap_flag_MinExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:MinExposureTime", &(a->tt__Exposure::MinExposureTime), "xsd:float"))
				{	soap_flag_MinExposureTime1--;
					continue;
				}
			if (soap_flag_MaxExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:MaxExposureTime", &(a->tt__Exposure::MaxExposureTime), "xsd:float"))
				{	soap_flag_MaxExposureTime1--;
					continue;
				}
			if (soap_flag_MinGain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:MinGain", &(a->tt__Exposure::MinGain), "xsd:float"))
				{	soap_flag_MinGain1--;
					continue;
				}
			if (soap_flag_MaxGain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:MaxGain", &(a->tt__Exposure::MaxGain), "xsd:float"))
				{	soap_flag_MaxGain1--;
					continue;
				}
			if (soap_flag_MinIris1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:MinIris", &(a->tt__Exposure::MinIris), "xsd:float"))
				{	soap_flag_MinIris1--;
					continue;
				}
			if (soap_flag_MaxIris1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:MaxIris", &(a->tt__Exposure::MaxIris), "xsd:float"))
				{	soap_flag_MaxIris1--;
					continue;
				}
			if (soap_flag_ExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:ExposureTime", &(a->tt__Exposure::ExposureTime), "xsd:float"))
				{	soap_flag_ExposureTime1--;
					continue;
				}
			if (soap_flag_Gain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Gain", &(a->tt__Exposure::Gain), "xsd:float"))
				{	soap_flag_Gain1--;
					continue;
				}
			if (soap_flag_Iris1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Iris", &(a->tt__Exposure::Iris), "xsd:float"))
				{	soap_flag_Iris1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Exposure *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Exposure, 0, sizeof(tt__Exposure), 0, soap_copy_tt__Exposure);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0 || soap_flag_Priority1 > 0 || soap_flag_Window1 > 0 || soap_flag_MinExposureTime1 > 0 || soap_flag_MaxExposureTime1 > 0 || soap_flag_MinGain1 > 0 || soap_flag_MaxGain1 > 0 || soap_flag_MinIris1 > 0 || soap_flag_MaxIris1 > 0 || soap_flag_ExposureTime1 > 0 || soap_flag_Gain1 > 0 || soap_flag_Iris1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Exposure::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Exposure);
	if (this->soap_out(soap, tag?tag:"tt:Exposure", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Exposure::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Exposure(soap, this, tag, type);
}

SOAP_FMAC3 tt__Exposure * SOAP_FMAC4 soap_get_tt__Exposure(struct soap *soap, tt__Exposure *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Exposure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Exposure * SOAP_FMAC2 soap_instantiate_tt__Exposure(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Exposure(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Exposure, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Exposure);
		if (size)
			*size = sizeof(tt__Exposure);
		((tt__Exposure*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Exposure[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Exposure);
		for (int i = 0; i < n; i++)
			((tt__Exposure*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Exposure*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Exposure(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Exposure %p -> %p\n", q, p));
	*(tt__Exposure*)p = *(tt__Exposure*)q;
}

void tt__ImagingSettingsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingSettingsExtension::__any);
	/* transient soap skipped */
}

void tt__ImagingSettingsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingSettingsExtension::__any);
	/* transient soap skipped */
}

int tt__ImagingSettingsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettingsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension(struct soap *soap, const char *tag, int id, const tt__ImagingSettingsExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettingsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__ImagingSettingsExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingSettingsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ImagingSettingsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension(struct soap *soap, const char *tag, tt__ImagingSettingsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingSettingsExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension, sizeof(tt__ImagingSettingsExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ImagingSettingsExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ImagingSettingsExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__ImagingSettingsExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingSettingsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension, 0, sizeof(tt__ImagingSettingsExtension), 0, soap_copy_tt__ImagingSettingsExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ImagingSettingsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ImagingSettingsExtension);
	if (this->soap_out(soap, tag?tag:"tt:ImagingSettingsExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettingsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettingsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension(struct soap *soap, tt__ImagingSettingsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ImagingSettingsExtension * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingSettingsExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ImagingSettingsExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ImagingSettingsExtension);
		if (size)
			*size = sizeof(tt__ImagingSettingsExtension);
		((tt__ImagingSettingsExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ImagingSettingsExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ImagingSettingsExtension);
		for (int i = 0; i < n; i++)
			((tt__ImagingSettingsExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ImagingSettingsExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ImagingSettingsExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ImagingSettingsExtension %p -> %p\n", q, p));
	*(tt__ImagingSettingsExtension*)p = *(tt__ImagingSettingsExtension*)q;
}

void tt__ImagingSettings::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ImagingSettings::BacklightCompensation = NULL;
	this->tt__ImagingSettings::Brightness = NULL;
	this->tt__ImagingSettings::ColorSaturation = NULL;
	this->tt__ImagingSettings::Contrast = NULL;
	this->tt__ImagingSettings::Exposure = NULL;
	this->tt__ImagingSettings::Focus = NULL;
	this->tt__ImagingSettings::IrCutFilter = NULL;
	this->tt__ImagingSettings::Sharpness = NULL;
	this->tt__ImagingSettings::WideDynamicRange = NULL;
	this->tt__ImagingSettings::WhiteBalance = NULL;
	this->tt__ImagingSettings::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__ImagingSettings::__anyAttribute);
	/* transient soap skipped */
}

void tt__ImagingSettings::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__BacklightCompensation(soap, &this->tt__ImagingSettings::BacklightCompensation);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings::Brightness);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings::ColorSaturation);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings::Contrast);
	soap_serialize_PointerTott__Exposure(soap, &this->tt__ImagingSettings::Exposure);
	soap_serialize_PointerTott__FocusConfiguration(soap, &this->tt__ImagingSettings::Focus);
	soap_serialize_PointerTott__IrCutFilterMode(soap, &this->tt__ImagingSettings::IrCutFilter);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings::Sharpness);
	soap_serialize_PointerTott__WideDynamicRange(soap, &this->tt__ImagingSettings::WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalance(soap, &this->tt__ImagingSettings::WhiteBalance);
	soap_serialize_PointerTott__ImagingSettingsExtension(soap, &this->tt__ImagingSettings::Extension);
	/* transient soap skipped */
}

int tt__ImagingSettings::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettings(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettings(struct soap *soap, const char *tag, int id, const tt__ImagingSettings *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ImagingSettings*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettings), type))
		return soap->error;
	if (soap_out_PointerTott__BacklightCompensation(soap, "tt:BacklightCompensation", -1, &(a->tt__ImagingSettings::BacklightCompensation), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Brightness", -1, &(a->tt__ImagingSettings::Brightness), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:ColorSaturation", -1, &(a->tt__ImagingSettings::ColorSaturation), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Contrast", -1, &(a->tt__ImagingSettings::Contrast), ""))
		return soap->error;
	if (soap_out_PointerTott__Exposure(soap, "tt:Exposure", -1, &(a->tt__ImagingSettings::Exposure), ""))
		return soap->error;
	if (soap_out_PointerTott__FocusConfiguration(soap, "tt:Focus", -1, &(a->tt__ImagingSettings::Focus), ""))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", -1, &(a->tt__ImagingSettings::IrCutFilter), ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Sharpness", -1, &(a->tt__ImagingSettings::Sharpness), ""))
		return soap->error;
	if (soap_out_PointerTott__WideDynamicRange(soap, "tt:WideDynamicRange", -1, &(a->tt__ImagingSettings::WideDynamicRange), ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalance(soap, "tt:WhiteBalance", -1, &(a->tt__ImagingSettings::WhiteBalance), ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettingsExtension(soap, "tt:Extension", -1, &(a->tt__ImagingSettings::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingSettings::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ImagingSettings(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettings * SOAP_FMAC4 soap_in_tt__ImagingSettings(struct soap *soap, const char *tag, tt__ImagingSettings *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingSettings *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettings, sizeof(tt__ImagingSettings), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ImagingSettings)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ImagingSettings *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ImagingSettings*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_BacklightCompensation1 = 1;
	size_t soap_flag_Brightness1 = 1;
	size_t soap_flag_ColorSaturation1 = 1;
	size_t soap_flag_Contrast1 = 1;
	size_t soap_flag_Exposure1 = 1;
	size_t soap_flag_Focus1 = 1;
	size_t soap_flag_IrCutFilter1 = 1;
	size_t soap_flag_Sharpness1 = 1;
	size_t soap_flag_WideDynamicRange1 = 1;
	size_t soap_flag_WhiteBalance1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BacklightCompensation(soap, "tt:BacklightCompensation", &(a->tt__ImagingSettings::BacklightCompensation), "tt:BacklightCompensation"))
				{	soap_flag_BacklightCompensation1--;
					continue;
				}
			if (soap_flag_Brightness1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Brightness", &(a->tt__ImagingSettings::Brightness), "xsd:float"))
				{	soap_flag_Brightness1--;
					continue;
				}
			if (soap_flag_ColorSaturation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:ColorSaturation", &(a->tt__ImagingSettings::ColorSaturation), "xsd:float"))
				{	soap_flag_ColorSaturation1--;
					continue;
				}
			if (soap_flag_Contrast1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Contrast", &(a->tt__ImagingSettings::Contrast), "xsd:float"))
				{	soap_flag_Contrast1--;
					continue;
				}
			if (soap_flag_Exposure1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Exposure(soap, "tt:Exposure", &(a->tt__ImagingSettings::Exposure), "tt:Exposure"))
				{	soap_flag_Exposure1--;
					continue;
				}
			if (soap_flag_Focus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusConfiguration(soap, "tt:Focus", &(a->tt__ImagingSettings::Focus), "tt:FocusConfiguration"))
				{	soap_flag_Focus1--;
					continue;
				}
			if (soap_flag_IrCutFilter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", &(a->tt__ImagingSettings::IrCutFilter), "tt:IrCutFilterMode"))
				{	soap_flag_IrCutFilter1--;
					continue;
				}
			if (soap_flag_Sharpness1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Sharpness", &(a->tt__ImagingSettings::Sharpness), "xsd:float"))
				{	soap_flag_Sharpness1--;
					continue;
				}
			if (soap_flag_WideDynamicRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WideDynamicRange(soap, "tt:WideDynamicRange", &(a->tt__ImagingSettings::WideDynamicRange), "tt:WideDynamicRange"))
				{	soap_flag_WideDynamicRange1--;
					continue;
				}
			if (soap_flag_WhiteBalance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WhiteBalance(soap, "tt:WhiteBalance", &(a->tt__ImagingSettings::WhiteBalance), "tt:WhiteBalance"))
				{	soap_flag_WhiteBalance1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingSettingsExtension(soap, "tt:Extension", &(a->tt__ImagingSettings::Extension), "tt:ImagingSettingsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettings, 0, sizeof(tt__ImagingSettings), 0, soap_copy_tt__ImagingSettings);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ImagingSettings::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ImagingSettings);
	if (this->soap_out(soap, tag?tag:"tt:ImagingSettings", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettings::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettings(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettings * SOAP_FMAC4 soap_get_tt__ImagingSettings(struct soap *soap, tt__ImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ImagingSettings * SOAP_FMAC2 soap_instantiate_tt__ImagingSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingSettings(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ImagingSettings, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ImagingSettings);
		if (size)
			*size = sizeof(tt__ImagingSettings);
		((tt__ImagingSettings*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ImagingSettings[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ImagingSettings);
		for (int i = 0; i < n; i++)
			((tt__ImagingSettings*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ImagingSettings*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ImagingSettings(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ImagingSettings %p -> %p\n", q, p));
	*(tt__ImagingSettings*)p = *(tt__ImagingSettings*)q;
}

void tt__FocusConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__AutoFocusMode(soap, &this->tt__FocusConfiguration::AutoFocusMode);
	soap_default_float(soap, &this->tt__FocusConfiguration::DefaultSpeed);
	soap_default_float(soap, &this->tt__FocusConfiguration::NearLimit);
	soap_default_float(soap, &this->tt__FocusConfiguration::FarLimit);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FocusConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__FocusConfiguration::__anyAttribute);
	/* transient soap skipped */
}

void tt__FocusConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__FocusConfiguration::DefaultSpeed, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__FocusConfiguration::NearLimit, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__FocusConfiguration::FarLimit, SOAP_TYPE_float);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FocusConfiguration::__any);
	/* transient soap skipped */
}

int tt__FocusConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusConfiguration(struct soap *soap, const char *tag, int id, const tt__FocusConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__FocusConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusConfiguration), type))
		return soap->error;
	if (soap_out_tt__AutoFocusMode(soap, "tt:AutoFocusMode", -1, &(a->tt__FocusConfiguration::AutoFocusMode), ""))
		return soap->error;
	if (soap_out_float(soap, "tt:DefaultSpeed", -1, &(a->tt__FocusConfiguration::DefaultSpeed), ""))
		return soap->error;
	if (soap_out_float(soap, "tt:NearLimit", -1, &(a->tt__FocusConfiguration::NearLimit), ""))
		return soap->error;
	if (soap_out_float(soap, "tt:FarLimit", -1, &(a->tt__FocusConfiguration::FarLimit), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__FocusConfiguration::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__FocusConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__FocusConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusConfiguration * SOAP_FMAC4 soap_in_tt__FocusConfiguration(struct soap *soap, const char *tag, tt__FocusConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration, sizeof(tt__FocusConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__FocusConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__FocusConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__FocusConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_AutoFocusMode1 = 1;
	size_t soap_flag_DefaultSpeed1 = 1;
	size_t soap_flag_NearLimit1 = 1;
	size_t soap_flag_FarLimit1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoFocusMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__AutoFocusMode(soap, "tt:AutoFocusMode", &(a->tt__FocusConfiguration::AutoFocusMode), "tt:AutoFocusMode"))
				{	soap_flag_AutoFocusMode1--;
					continue;
				}
			if (soap_flag_DefaultSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:DefaultSpeed", &(a->tt__FocusConfiguration::DefaultSpeed), "xsd:float"))
				{	soap_flag_DefaultSpeed1--;
					continue;
				}
			if (soap_flag_NearLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:NearLimit", &(a->tt__FocusConfiguration::NearLimit), "xsd:float"))
				{	soap_flag_NearLimit1--;
					continue;
				}
			if (soap_flag_FarLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:FarLimit", &(a->tt__FocusConfiguration::FarLimit), "xsd:float"))
				{	soap_flag_FarLimit1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__FocusConfiguration::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusConfiguration, 0, sizeof(tt__FocusConfiguration), 0, soap_copy_tt__FocusConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoFocusMode1 > 0 || soap_flag_DefaultSpeed1 > 0 || soap_flag_NearLimit1 > 0 || soap_flag_FarLimit1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__FocusConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__FocusConfiguration);
	if (this->soap_out(soap, tag?tag:"tt:FocusConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusConfiguration * SOAP_FMAC4 soap_get_tt__FocusConfiguration(struct soap *soap, tt__FocusConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__FocusConfiguration * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__FocusConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__FocusConfiguration);
		if (size)
			*size = sizeof(tt__FocusConfiguration);
		((tt__FocusConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__FocusConfiguration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__FocusConfiguration);
		for (int i = 0; i < n; i++)
			((tt__FocusConfiguration*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__FocusConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__FocusConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__FocusConfiguration %p -> %p\n", q, p));
	*(tt__FocusConfiguration*)p = *(tt__FocusConfiguration*)q;
}

void tt__FocusStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_float(soap, &this->tt__FocusStatus::Position);
	soap_default_tt__MoveStatus(soap, &this->tt__FocusStatus::MoveStatus);
	soap_default_std__string(soap, &this->tt__FocusStatus::Error);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FocusStatus::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__FocusStatus::__anyAttribute);
	/* transient soap skipped */
}

void tt__FocusStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__FocusStatus::Position, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__FocusStatus::MoveStatus, SOAP_TYPE_tt__MoveStatus);
	soap_embedded(soap, &this->tt__FocusStatus::Error, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__FocusStatus::Error);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__FocusStatus::__any);
	/* transient soap skipped */
}

int tt__FocusStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusStatus(struct soap *soap, const char *tag, int id, const tt__FocusStatus *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__FocusStatus*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusStatus), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Position", -1, &(a->tt__FocusStatus::Position), ""))
		return soap->error;
	if (soap_out_tt__MoveStatus(soap, "tt:MoveStatus", -1, &(a->tt__FocusStatus::MoveStatus), ""))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Error", -1, &(a->tt__FocusStatus::Error), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__FocusStatus::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__FocusStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__FocusStatus(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusStatus * SOAP_FMAC4 soap_in_tt__FocusStatus(struct soap *soap, const char *tag, tt__FocusStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusStatus, sizeof(tt__FocusStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__FocusStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__FocusStatus *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__FocusStatus*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_MoveStatus1 = 1;
	size_t soap_flag_Error1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Position", &(a->tt__FocusStatus::Position), "xsd:float"))
				{	soap_flag_Position1--;
					continue;
				}
			if (soap_flag_MoveStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__MoveStatus(soap, "tt:MoveStatus", &(a->tt__FocusStatus::MoveStatus), "tt:MoveStatus"))
				{	soap_flag_MoveStatus1--;
					continue;
				}
			if (soap_flag_Error1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tt:Error", &(a->tt__FocusStatus::Error), "xsd:string"))
				{	soap_flag_Error1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__FocusStatus::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusStatus, 0, sizeof(tt__FocusStatus), 0, soap_copy_tt__FocusStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position1 > 0 || soap_flag_MoveStatus1 > 0 || soap_flag_Error1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__FocusStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__FocusStatus);
	if (this->soap_out(soap, tag?tag:"tt:FocusStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusStatus(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusStatus * SOAP_FMAC4 soap_get_tt__FocusStatus(struct soap *soap, tt__FocusStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__FocusStatus * SOAP_FMAC2 soap_instantiate_tt__FocusStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__FocusStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__FocusStatus);
		if (size)
			*size = sizeof(tt__FocusStatus);
		((tt__FocusStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__FocusStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__FocusStatus);
		for (int i = 0; i < n; i++)
			((tt__FocusStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__FocusStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__FocusStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__FocusStatus %p -> %p\n", q, p));
	*(tt__FocusStatus*)p = *(tt__FocusStatus*)q;
}

void tt__ImagingStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ImagingStatus::FocusStatus = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingStatus::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__ImagingStatus::__anyAttribute);
	/* transient soap skipped */
}

void tt__ImagingStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__FocusStatus(soap, &this->tt__ImagingStatus::FocusStatus);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ImagingStatus::__any);
	/* transient soap skipped */
}

int tt__ImagingStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingStatus(struct soap *soap, const char *tag, int id, const tt__ImagingStatus *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ImagingStatus*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingStatus), type))
		return soap->error;
	if (a->tt__ImagingStatus::FocusStatus)
	{	if (soap_out_PointerTott__FocusStatus(soap, "tt:FocusStatus", -1, &a->tt__ImagingStatus::FocusStatus, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:FocusStatus"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__ImagingStatus::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ImagingStatus(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingStatus * SOAP_FMAC4 soap_in_tt__ImagingStatus(struct soap *soap, const char *tag, tt__ImagingStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingStatus, sizeof(tt__ImagingStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ImagingStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ImagingStatus *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ImagingStatus*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_FocusStatus1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FocusStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusStatus(soap, "tt:FocusStatus", &(a->tt__ImagingStatus::FocusStatus), "tt:FocusStatus"))
				{	soap_flag_FocusStatus1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__ImagingStatus::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingStatus, 0, sizeof(tt__ImagingStatus), 0, soap_copy_tt__ImagingStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FocusStatus1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__ImagingStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ImagingStatus);
	if (this->soap_out(soap, tag?tag:"tt:ImagingStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingStatus(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingStatus * SOAP_FMAC4 soap_get_tt__ImagingStatus(struct soap *soap, tt__ImagingStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ImagingStatus * SOAP_FMAC2 soap_instantiate_tt__ImagingStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ImagingStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ImagingStatus);
		if (size)
			*size = sizeof(tt__ImagingStatus);
		((tt__ImagingStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ImagingStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ImagingStatus);
		for (int i = 0; i < n; i++)
			((tt__ImagingStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ImagingStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ImagingStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ImagingStatus %p -> %p\n", q, p));
	*(tt__ImagingStatus*)p = *(tt__ImagingStatus*)q;
}

void tt__PTZMoveStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTZMoveStatus::PanTilt = NULL;
	this->tt__PTZMoveStatus::Zoom = NULL;
	/* transient soap skipped */
}

void tt__PTZMoveStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__MoveStatus(soap, &this->tt__PTZMoveStatus::PanTilt);
	soap_serialize_PointerTott__MoveStatus(soap, &this->tt__PTZMoveStatus::Zoom);
	/* transient soap skipped */
}

int tt__PTZMoveStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZMoveStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZMoveStatus(struct soap *soap, const char *tag, int id, const tt__PTZMoveStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZMoveStatus), type))
		return soap->error;
	if (soap_out_PointerTott__MoveStatus(soap, "tt:PanTilt", -1, &(a->tt__PTZMoveStatus::PanTilt), ""))
		return soap->error;
	if (soap_out_PointerTott__MoveStatus(soap, "tt:Zoom", -1, &(a->tt__PTZMoveStatus::Zoom), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__PTZMoveStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__PTZMoveStatus(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZMoveStatus * SOAP_FMAC4 soap_in_tt__PTZMoveStatus(struct soap *soap, const char *tag, tt__PTZMoveStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZMoveStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZMoveStatus, sizeof(tt__PTZMoveStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__PTZMoveStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__PTZMoveStatus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PanTilt1 = 1;
	size_t soap_flag_Zoom1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MoveStatus(soap, "tt:PanTilt", &(a->tt__PTZMoveStatus::PanTilt), "tt:MoveStatus"))
				{	soap_flag_PanTilt1--;
					continue;
				}
			if (soap_flag_Zoom1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MoveStatus(soap, "tt:Zoom", &(a->tt__PTZMoveStatus::Zoom), "tt:MoveStatus"))
				{	soap_flag_Zoom1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZMoveStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZMoveStatus, 0, sizeof(tt__PTZMoveStatus), 0, soap_copy_tt__PTZMoveStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__PTZMoveStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__PTZMoveStatus);
	if (this->soap_out(soap, tag?tag:"tt:PTZMoveStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZMoveStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZMoveStatus(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZMoveStatus * SOAP_FMAC4 soap_get_tt__PTZMoveStatus(struct soap *soap, tt__PTZMoveStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZMoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__PTZMoveStatus * SOAP_FMAC2 soap_instantiate_tt__PTZMoveStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZMoveStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__PTZMoveStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZMoveStatus);
		if (size)
			*size = sizeof(tt__PTZMoveStatus);
		((tt__PTZMoveStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZMoveStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__PTZMoveStatus);
		for (int i = 0; i < n; i++)
			((tt__PTZMoveStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__PTZMoveStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__PTZMoveStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__PTZMoveStatus %p -> %p\n", q, p));
	*(tt__PTZMoveStatus*)p = *(tt__PTZMoveStatus*)q;
}

void tt__PTZPreset::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTZPreset::Name = NULL;
	this->tt__PTZPreset::PTZPosition = NULL;
	this->tt__PTZPreset::token = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZPreset::__anyAttribute);
	/* transient soap skipped */
}

void tt__PTZPreset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Name(soap, &this->tt__PTZPreset::Name);
	soap_serialize_PointerTott__PTZVector(soap, &this->tt__PTZPreset::PTZPosition);
	/* transient soap skipped */
}

int tt__PTZPreset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPreset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPreset(struct soap *soap, const char *tag, int id, const tt__PTZPreset *a, const char *type)
{
	if (((tt__PTZPreset*)a)->token)
		soap_set_attr(soap, "token", ((tt__PTZPreset*)a)->token->c_str(), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZPreset*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPreset), type))
		return soap->error;
	if (soap_out_PointerTott__Name(soap, "tt:Name", -1, &(a->tt__PTZPreset::Name), ""))
		return soap->error;
	if (soap_out_PointerTott__PTZVector(soap, "tt:PTZPosition", -1, &(a->tt__PTZPreset::PTZPosition), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPreset::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__PTZPreset(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPreset * SOAP_FMAC4 soap_in_tt__PTZPreset(struct soap *soap, const char *tag, tt__PTZPreset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPreset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPreset, sizeof(tt__PTZPreset), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__PTZPreset)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__PTZPreset *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "token", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((tt__PTZPreset*)a)->token = soap_new_std__string(soap, -1);
				((tt__PTZPreset*)a)->token->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZPreset*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_PTZPosition1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTott__Name(soap, "tt:Name", &(a->tt__PTZPreset::Name), "tt:Name"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_PTZPosition1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZVector(soap, "tt:PTZPosition", &(a->tt__PTZPreset::PTZPosition), "tt:PTZVector"))
				{	soap_flag_PTZPosition1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPreset, 0, sizeof(tt__PTZPreset), 0, soap_copy_tt__PTZPreset);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__PTZPreset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__PTZPreset);
	if (this->soap_out(soap, tag?tag:"tt:PTZPreset", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPreset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPreset(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPreset * SOAP_FMAC4 soap_get_tt__PTZPreset(struct soap *soap, tt__PTZPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__PTZPreset * SOAP_FMAC2 soap_instantiate_tt__PTZPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPreset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__PTZPreset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZPreset);
		if (size)
			*size = sizeof(tt__PTZPreset);
		((tt__PTZPreset*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZPreset[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__PTZPreset);
		for (int i = 0; i < n; i++)
			((tt__PTZPreset*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__PTZPreset*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__PTZPreset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__PTZPreset %p -> %p\n", q, p));
	*(tt__PTZPreset*)p = *(tt__PTZPreset*)q;
}

void tt__PTZStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTZStatus::Position = NULL;
	this->tt__PTZStatus::MoveStatus = NULL;
	this->tt__PTZStatus::Error = NULL;
	soap_default_time(soap, &this->tt__PTZStatus::UtcTime);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZStatus::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZStatus::__anyAttribute);
	/* transient soap skipped */
}

void tt__PTZStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__PTZVector(soap, &this->tt__PTZStatus::Position);
	soap_serialize_PointerTott__PTZMoveStatus(soap, &this->tt__PTZStatus::MoveStatus);
	soap_serialize_PointerTostd__string(soap, &this->tt__PTZStatus::Error);
	soap_embedded(soap, &this->tt__PTZStatus::UtcTime, SOAP_TYPE_time);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZStatus::__any);
	/* transient soap skipped */
}

int tt__PTZStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStatus(struct soap *soap, const char *tag, int id, const tt__PTZStatus *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZStatus*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZStatus), type))
		return soap->error;
	if (soap_out_PointerTott__PTZVector(soap, "tt:Position", -1, &(a->tt__PTZStatus::Position), ""))
		return soap->error;
	if (soap_out_PointerTott__PTZMoveStatus(soap, "tt:MoveStatus", -1, &(a->tt__PTZStatus::MoveStatus), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Error", -1, &(a->tt__PTZStatus::Error), ""))
		return soap->error;
	if (soap_out_time(soap, "tt:UtcTime", -1, &(a->tt__PTZStatus::UtcTime), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__PTZStatus::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__PTZStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__PTZStatus(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZStatus * SOAP_FMAC4 soap_in_tt__PTZStatus(struct soap *soap, const char *tag, tt__PTZStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStatus, sizeof(tt__PTZStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__PTZStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__PTZStatus *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZStatus*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_MoveStatus1 = 1;
	size_t soap_flag_Error1 = 1;
	size_t soap_flag_UtcTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZVector(soap, "tt:Position", &(a->tt__PTZStatus::Position), "tt:PTZVector"))
				{	soap_flag_Position1--;
					continue;
				}
			if (soap_flag_MoveStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZMoveStatus(soap, "tt:MoveStatus", &(a->tt__PTZStatus::MoveStatus), "tt:PTZMoveStatus"))
				{	soap_flag_MoveStatus1--;
					continue;
				}
			if (soap_flag_Error1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "tt:Error", &(a->tt__PTZStatus::Error), "xsd:string"))
				{	soap_flag_Error1--;
					continue;
				}
			if (soap_flag_UtcTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "tt:UtcTime", &(a->tt__PTZStatus::UtcTime), "xsd:dateTime"))
				{	soap_flag_UtcTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__PTZStatus::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStatus, 0, sizeof(tt__PTZStatus), 0, soap_copy_tt__PTZStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UtcTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__PTZStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__PTZStatus);
	if (this->soap_out(soap, tag?tag:"tt:PTZStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZStatus(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZStatus * SOAP_FMAC4 soap_get_tt__PTZStatus(struct soap *soap, tt__PTZStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__PTZStatus * SOAP_FMAC2 soap_instantiate_tt__PTZStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__PTZStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZStatus);
		if (size)
			*size = sizeof(tt__PTZStatus);
		((tt__PTZStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__PTZStatus);
		for (int i = 0; i < n; i++)
			((tt__PTZStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__PTZStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__PTZStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__PTZStatus %p -> %p\n", q, p));
	*(tt__PTZStatus*)p = *(tt__PTZStatus*)q;
}

void tt__PTZSpeed::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTZSpeed::PanTilt = NULL;
	this->tt__PTZSpeed::Zoom = NULL;
	/* transient soap skipped */
}

void tt__PTZSpeed::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Vector2D(soap, &this->tt__PTZSpeed::PanTilt);
	soap_serialize_PointerTott__Vector1D(soap, &this->tt__PTZSpeed::Zoom);
	/* transient soap skipped */
}

int tt__PTZSpeed::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZSpeed(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpeed(struct soap *soap, const char *tag, int id, const tt__PTZSpeed *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpeed), type))
		return soap->error;
	if (soap_out_PointerTott__Vector2D(soap, "tt:PanTilt", -1, &(a->tt__PTZSpeed::PanTilt), ""))
		return soap->error;
	if (soap_out_PointerTott__Vector1D(soap, "tt:Zoom", -1, &(a->tt__PTZSpeed::Zoom), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__PTZSpeed::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__PTZSpeed(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZSpeed * SOAP_FMAC4 soap_in_tt__PTZSpeed(struct soap *soap, const char *tag, tt__PTZSpeed *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZSpeed *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpeed, sizeof(tt__PTZSpeed), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__PTZSpeed)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__PTZSpeed *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PanTilt1 = 1;
	size_t soap_flag_Zoom1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector2D(soap, "tt:PanTilt", &(a->tt__PTZSpeed::PanTilt), "tt:Vector2D"))
				{	soap_flag_PanTilt1--;
					continue;
				}
			if (soap_flag_Zoom1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector1D(soap, "tt:Zoom", &(a->tt__PTZSpeed::Zoom), "tt:Vector1D"))
				{	soap_flag_Zoom1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZSpeed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpeed, 0, sizeof(tt__PTZSpeed), 0, soap_copy_tt__PTZSpeed);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__PTZSpeed::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__PTZSpeed);
	if (this->soap_out(soap, tag?tag:"tt:PTZSpeed", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZSpeed::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZSpeed(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZSpeed * SOAP_FMAC4 soap_get_tt__PTZSpeed(struct soap *soap, tt__PTZSpeed *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__PTZSpeed * SOAP_FMAC2 soap_instantiate_tt__PTZSpeed(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZSpeed(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__PTZSpeed, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZSpeed);
		if (size)
			*size = sizeof(tt__PTZSpeed);
		((tt__PTZSpeed*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZSpeed[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__PTZSpeed);
		for (int i = 0; i < n; i++)
			((tt__PTZSpeed*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__PTZSpeed*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__PTZSpeed(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__PTZSpeed %p -> %p\n", q, p));
	*(tt__PTZSpeed*)p = *(tt__PTZSpeed*)q;
}

void tt__PTZVector::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTZVector::PanTilt = NULL;
	this->tt__PTZVector::Zoom = NULL;
	/* transient soap skipped */
}

void tt__PTZVector::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Vector2D(soap, &this->tt__PTZVector::PanTilt);
	soap_serialize_PointerTott__Vector1D(soap, &this->tt__PTZVector::Zoom);
	/* transient soap skipped */
}

int tt__PTZVector::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZVector(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZVector(struct soap *soap, const char *tag, int id, const tt__PTZVector *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZVector), type))
		return soap->error;
	if (soap_out_PointerTott__Vector2D(soap, "tt:PanTilt", -1, &(a->tt__PTZVector::PanTilt), ""))
		return soap->error;
	if (soap_out_PointerTott__Vector1D(soap, "tt:Zoom", -1, &(a->tt__PTZVector::Zoom), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__PTZVector::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__PTZVector(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZVector * SOAP_FMAC4 soap_in_tt__PTZVector(struct soap *soap, const char *tag, tt__PTZVector *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZVector *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZVector, sizeof(tt__PTZVector), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__PTZVector)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__PTZVector *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PanTilt1 = 1;
	size_t soap_flag_Zoom1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector2D(soap, "tt:PanTilt", &(a->tt__PTZVector::PanTilt), "tt:Vector2D"))
				{	soap_flag_PanTilt1--;
					continue;
				}
			if (soap_flag_Zoom1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector1D(soap, "tt:Zoom", &(a->tt__PTZVector::Zoom), "tt:Vector1D"))
				{	soap_flag_Zoom1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZVector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZVector, 0, sizeof(tt__PTZVector), 0, soap_copy_tt__PTZVector);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__PTZVector::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__PTZVector);
	if (this->soap_out(soap, tag?tag:"tt:PTZVector", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZVector::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZVector(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZVector * SOAP_FMAC4 soap_get_tt__PTZVector(struct soap *soap, tt__PTZVector *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZVector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__PTZVector * SOAP_FMAC2 soap_instantiate_tt__PTZVector(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZVector(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__PTZVector, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZVector);
		if (size)
			*size = sizeof(tt__PTZVector);
		((tt__PTZVector*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZVector[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__PTZVector);
		for (int i = 0; i < n; i++)
			((tt__PTZVector*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__PTZVector*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__PTZVector(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__PTZVector %p -> %p\n", q, p));
	*(tt__PTZVector*)p = *(tt__PTZVector*)q;
}

void tt__Vector1D::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_float(soap, &this->tt__Vector1D::x);
	this->tt__Vector1D::space = NULL;
	/* transient soap skipped */
}

void tt__Vector1D::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tt__Vector1D::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Vector1D(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector1D(struct soap *soap, const char *tag, int id, const tt__Vector1D *a, const char *type)
{
	soap_set_attr(soap, "x", soap_float2s(soap, ((tt__Vector1D*)a)->x), 1);
	if (((tt__Vector1D*)a)->space)
		soap_set_attr(soap, "space", ((tt__Vector1D*)a)->space->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Vector1D), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Vector1D::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Vector1D(soap, tag, this, type);
}

SOAP_FMAC3 tt__Vector1D * SOAP_FMAC4 soap_in_tt__Vector1D(struct soap *soap, const char *tag, tt__Vector1D *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Vector1D *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector1D, sizeof(tt__Vector1D), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Vector1D)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Vector1D *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2float(soap, soap_attr_value(soap, "x", 1), &((tt__Vector1D*)a)->x))
		return NULL;
	{	const char *t = soap_attr_value(soap, "space", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((tt__Vector1D*)a)->space = soap_new_std__string(soap, -1);
				((tt__Vector1D*)a)->space->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Vector1D *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector1D, 0, sizeof(tt__Vector1D), 0, soap_copy_tt__Vector1D);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__Vector1D::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Vector1D);
	if (this->soap_out(soap, tag?tag:"tt:Vector1D", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Vector1D::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Vector1D(soap, this, tag, type);
}

SOAP_FMAC3 tt__Vector1D * SOAP_FMAC4 soap_get_tt__Vector1D(struct soap *soap, tt__Vector1D *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector1D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Vector1D * SOAP_FMAC2 soap_instantiate_tt__Vector1D(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Vector1D(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Vector1D, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Vector1D);
		if (size)
			*size = sizeof(tt__Vector1D);
		((tt__Vector1D*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Vector1D[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Vector1D);
		for (int i = 0; i < n; i++)
			((tt__Vector1D*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Vector1D*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Vector1D(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Vector1D %p -> %p\n", q, p));
	*(tt__Vector1D*)p = *(tt__Vector1D*)q;
}

void tt__Vector2D::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_float(soap, &this->tt__Vector2D::x);
	soap_default_float(soap, &this->tt__Vector2D::y);
	this->tt__Vector2D::space = NULL;
	/* transient soap skipped */
}

void tt__Vector2D::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tt__Vector2D::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Vector2D(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector2D(struct soap *soap, const char *tag, int id, const tt__Vector2D *a, const char *type)
{
	soap_set_attr(soap, "x", soap_float2s(soap, ((tt__Vector2D*)a)->x), 1);
	soap_set_attr(soap, "y", soap_float2s(soap, ((tt__Vector2D*)a)->y), 1);
	if (((tt__Vector2D*)a)->space)
		soap_set_attr(soap, "space", ((tt__Vector2D*)a)->space->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Vector2D), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Vector2D::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Vector2D(soap, tag, this, type);
}

SOAP_FMAC3 tt__Vector2D * SOAP_FMAC4 soap_in_tt__Vector2D(struct soap *soap, const char *tag, tt__Vector2D *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Vector2D *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector2D, sizeof(tt__Vector2D), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Vector2D)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Vector2D *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2float(soap, soap_attr_value(soap, "x", 1), &((tt__Vector2D*)a)->x))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "y", 1), &((tt__Vector2D*)a)->y))
		return NULL;
	{	const char *t = soap_attr_value(soap, "space", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((tt__Vector2D*)a)->space = soap_new_std__string(soap, -1);
				((tt__Vector2D*)a)->space->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Vector2D *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector2D, 0, sizeof(tt__Vector2D), 0, soap_copy_tt__Vector2D);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__Vector2D::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Vector2D);
	if (this->soap_out(soap, tag?tag:"tt:Vector2D", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Vector2D::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Vector2D(soap, this, tag, type);
}

SOAP_FMAC3 tt__Vector2D * SOAP_FMAC4 soap_get_tt__Vector2D(struct soap *soap, tt__Vector2D *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector2D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Vector2D * SOAP_FMAC2 soap_instantiate_tt__Vector2D(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Vector2D(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Vector2D, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Vector2D);
		if (size)
			*size = sizeof(tt__Vector2D);
		((tt__Vector2D*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Vector2D[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Vector2D);
		for (int i = 0; i < n; i++)
			((tt__Vector2D*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Vector2D*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Vector2D(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Vector2D %p -> %p\n", q, p));
	*(tt__Vector2D*)p = *(tt__Vector2D*)q;
}

void tt__Space1DDescription::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__Space1DDescription::URI);
	this->tt__Space1DDescription::XRange = NULL;
	/* transient soap skipped */
}

void tt__Space1DDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__Space1DDescription::URI, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__Space1DDescription::URI);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__Space1DDescription::XRange);
	/* transient soap skipped */
}

int tt__Space1DDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Space1DDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Space1DDescription(struct soap *soap, const char *tag, int id, const tt__Space1DDescription *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Space1DDescription), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:URI", -1, &(a->tt__Space1DDescription::URI), ""))
		return soap->error;
	if (a->tt__Space1DDescription::XRange)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:XRange", -1, &a->tt__Space1DDescription::XRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XRange"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Space1DDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Space1DDescription(soap, tag, this, type);
}

SOAP_FMAC3 tt__Space1DDescription * SOAP_FMAC4 soap_in_tt__Space1DDescription(struct soap *soap, const char *tag, tt__Space1DDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Space1DDescription *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Space1DDescription, sizeof(tt__Space1DDescription), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Space1DDescription)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Space1DDescription *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_URI1 = 1;
	size_t soap_flag_XRange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:URI", &(a->tt__Space1DDescription::URI), "xsd:anyURI"))
				{	soap_flag_URI1--;
					continue;
				}
			if (soap_flag_XRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:XRange", &(a->tt__Space1DDescription::XRange), "tt:FloatRange"))
				{	soap_flag_XRange1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Space1DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Space1DDescription, 0, sizeof(tt__Space1DDescription), 0, soap_copy_tt__Space1DDescription);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_URI1 > 0 || soap_flag_XRange1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Space1DDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Space1DDescription);
	if (this->soap_out(soap, tag?tag:"tt:Space1DDescription", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Space1DDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Space1DDescription(soap, this, tag, type);
}

SOAP_FMAC3 tt__Space1DDescription * SOAP_FMAC4 soap_get_tt__Space1DDescription(struct soap *soap, tt__Space1DDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Space1DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Space1DDescription * SOAP_FMAC2 soap_instantiate_tt__Space1DDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Space1DDescription(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Space1DDescription, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Space1DDescription);
		if (size)
			*size = sizeof(tt__Space1DDescription);
		((tt__Space1DDescription*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Space1DDescription[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Space1DDescription);
		for (int i = 0; i < n; i++)
			((tt__Space1DDescription*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Space1DDescription*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Space1DDescription(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Space1DDescription %p -> %p\n", q, p));
	*(tt__Space1DDescription*)p = *(tt__Space1DDescription*)q;
}

void tt__Space2DDescription::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__Space2DDescription::URI);
	this->tt__Space2DDescription::XRange = NULL;
	this->tt__Space2DDescription::YRange = NULL;
	/* transient soap skipped */
}

void tt__Space2DDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__Space2DDescription::URI, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__Space2DDescription::URI);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__Space2DDescription::XRange);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__Space2DDescription::YRange);
	/* transient soap skipped */
}

int tt__Space2DDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Space2DDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Space2DDescription(struct soap *soap, const char *tag, int id, const tt__Space2DDescription *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Space2DDescription), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:URI", -1, &(a->tt__Space2DDescription::URI), ""))
		return soap->error;
	if (a->tt__Space2DDescription::XRange)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:XRange", -1, &a->tt__Space2DDescription::XRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XRange"))
		return soap->error;
	if (a->tt__Space2DDescription::YRange)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:YRange", -1, &a->tt__Space2DDescription::YRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:YRange"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Space2DDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Space2DDescription(soap, tag, this, type);
}

SOAP_FMAC3 tt__Space2DDescription * SOAP_FMAC4 soap_in_tt__Space2DDescription(struct soap *soap, const char *tag, tt__Space2DDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Space2DDescription *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Space2DDescription, sizeof(tt__Space2DDescription), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Space2DDescription)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Space2DDescription *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_URI1 = 1;
	size_t soap_flag_XRange1 = 1;
	size_t soap_flag_YRange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:URI", &(a->tt__Space2DDescription::URI), "xsd:anyURI"))
				{	soap_flag_URI1--;
					continue;
				}
			if (soap_flag_XRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:XRange", &(a->tt__Space2DDescription::XRange), "tt:FloatRange"))
				{	soap_flag_XRange1--;
					continue;
				}
			if (soap_flag_YRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:YRange", &(a->tt__Space2DDescription::YRange), "tt:FloatRange"))
				{	soap_flag_YRange1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Space2DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Space2DDescription, 0, sizeof(tt__Space2DDescription), 0, soap_copy_tt__Space2DDescription);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_URI1 > 0 || soap_flag_XRange1 > 0 || soap_flag_YRange1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Space2DDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Space2DDescription);
	if (this->soap_out(soap, tag?tag:"tt:Space2DDescription", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Space2DDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Space2DDescription(soap, this, tag, type);
}

SOAP_FMAC3 tt__Space2DDescription * SOAP_FMAC4 soap_get_tt__Space2DDescription(struct soap *soap, tt__Space2DDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Space2DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Space2DDescription * SOAP_FMAC2 soap_instantiate_tt__Space2DDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Space2DDescription(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Space2DDescription, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Space2DDescription);
		if (size)
			*size = sizeof(tt__Space2DDescription);
		((tt__Space2DDescription*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Space2DDescription[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Space2DDescription);
		for (int i = 0; i < n; i++)
			((tt__Space2DDescription*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Space2DDescription*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Space2DDescription(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Space2DDescription %p -> %p\n", q, p));
	*(tt__Space2DDescription*)p = *(tt__Space2DDescription*)q;
}

void tt__PTZSpacesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZSpacesExtension::__any);
	/* transient soap skipped */
}

void tt__PTZSpacesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZSpacesExtension::__any);
	/* transient soap skipped */
}

int tt__PTZSpacesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZSpacesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpacesExtension(struct soap *soap, const char *tag, int id, const tt__PTZSpacesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpacesExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__PTZSpacesExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__PTZSpacesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__PTZSpacesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZSpacesExtension * SOAP_FMAC4 soap_in_tt__PTZSpacesExtension(struct soap *soap, const char *tag, tt__PTZSpacesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZSpacesExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpacesExtension, sizeof(tt__PTZSpacesExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__PTZSpacesExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__PTZSpacesExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__PTZSpacesExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZSpacesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpacesExtension, 0, sizeof(tt__PTZSpacesExtension), 0, soap_copy_tt__PTZSpacesExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__PTZSpacesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__PTZSpacesExtension);
	if (this->soap_out(soap, tag?tag:"tt:PTZSpacesExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZSpacesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZSpacesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZSpacesExtension * SOAP_FMAC4 soap_get_tt__PTZSpacesExtension(struct soap *soap, tt__PTZSpacesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpacesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__PTZSpacesExtension * SOAP_FMAC2 soap_instantiate_tt__PTZSpacesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZSpacesExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__PTZSpacesExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZSpacesExtension);
		if (size)
			*size = sizeof(tt__PTZSpacesExtension);
		((tt__PTZSpacesExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZSpacesExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__PTZSpacesExtension);
		for (int i = 0; i < n; i++)
			((tt__PTZSpacesExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__PTZSpacesExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__PTZSpacesExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__PTZSpacesExtension %p -> %p\n", q, p));
	*(tt__PTZSpacesExtension*)p = *(tt__PTZSpacesExtension*)q;
}

void tt__PTZSpaces::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Space2DDescription(soap, &this->tt__PTZSpaces::AbsolutePanTiltPositionSpace);
	soap_default_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::AbsoluteZoomPositionSpace);
	soap_default_std__vectorTemplateOfPointerTott__Space2DDescription(soap, &this->tt__PTZSpaces::RelativePanTiltTranslationSpace);
	soap_default_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::RelativeZoomTranslationSpace);
	soap_default_std__vectorTemplateOfPointerTott__Space2DDescription(soap, &this->tt__PTZSpaces::ContinuousPanTiltVelocitySpace);
	soap_default_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::ContinuousZoomVelocitySpace);
	soap_default_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::PanTiltSpeedSpace);
	soap_default_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::ZoomSpeedSpace);
	this->tt__PTZSpaces::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZSpaces::__anyAttribute);
	/* transient soap skipped */
}

void tt__PTZSpaces::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTott__Space2DDescription(soap, &this->tt__PTZSpaces::AbsolutePanTiltPositionSpace);
	soap_serialize_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::AbsoluteZoomPositionSpace);
	soap_serialize_std__vectorTemplateOfPointerTott__Space2DDescription(soap, &this->tt__PTZSpaces::RelativePanTiltTranslationSpace);
	soap_serialize_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::RelativeZoomTranslationSpace);
	soap_serialize_std__vectorTemplateOfPointerTott__Space2DDescription(soap, &this->tt__PTZSpaces::ContinuousPanTiltVelocitySpace);
	soap_serialize_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::ContinuousZoomVelocitySpace);
	soap_serialize_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::PanTiltSpeedSpace);
	soap_serialize_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::ZoomSpeedSpace);
	soap_serialize_PointerTott__PTZSpacesExtension(soap, &this->tt__PTZSpaces::Extension);
	/* transient soap skipped */
}

int tt__PTZSpaces::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZSpaces(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpaces(struct soap *soap, const char *tag, int id, const tt__PTZSpaces *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZSpaces*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpaces), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space2DDescription(soap, "tt:AbsolutePanTiltPositionSpace", -1, &(a->tt__PTZSpaces::AbsolutePanTiltPositionSpace), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:AbsoluteZoomPositionSpace", -1, &(a->tt__PTZSpaces::AbsoluteZoomPositionSpace), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space2DDescription(soap, "tt:RelativePanTiltTranslationSpace", -1, &(a->tt__PTZSpaces::RelativePanTiltTranslationSpace), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:RelativeZoomTranslationSpace", -1, &(a->tt__PTZSpaces::RelativeZoomTranslationSpace), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space2DDescription(soap, "tt:ContinuousPanTiltVelocitySpace", -1, &(a->tt__PTZSpaces::ContinuousPanTiltVelocitySpace), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:ContinuousZoomVelocitySpace", -1, &(a->tt__PTZSpaces::ContinuousZoomVelocitySpace), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:PanTiltSpeedSpace", -1, &(a->tt__PTZSpaces::PanTiltSpeedSpace), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:ZoomSpeedSpace", -1, &(a->tt__PTZSpaces::ZoomSpeedSpace), ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpacesExtension(soap, "tt:Extension", -1, &(a->tt__PTZSpaces::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__PTZSpaces::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__PTZSpaces(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZSpaces * SOAP_FMAC4 soap_in_tt__PTZSpaces(struct soap *soap, const char *tag, tt__PTZSpaces *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZSpaces *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpaces, sizeof(tt__PTZSpaces), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__PTZSpaces)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__PTZSpaces *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZSpaces*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Space2DDescription(soap, "tt:AbsolutePanTiltPositionSpace", &(a->tt__PTZSpaces::AbsolutePanTiltPositionSpace), "tt:Space2DDescription"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:AbsoluteZoomPositionSpace", &(a->tt__PTZSpaces::AbsoluteZoomPositionSpace), "tt:Space1DDescription"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Space2DDescription(soap, "tt:RelativePanTiltTranslationSpace", &(a->tt__PTZSpaces::RelativePanTiltTranslationSpace), "tt:Space2DDescription"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:RelativeZoomTranslationSpace", &(a->tt__PTZSpaces::RelativeZoomTranslationSpace), "tt:Space1DDescription"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Space2DDescription(soap, "tt:ContinuousPanTiltVelocitySpace", &(a->tt__PTZSpaces::ContinuousPanTiltVelocitySpace), "tt:Space2DDescription"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:ContinuousZoomVelocitySpace", &(a->tt__PTZSpaces::ContinuousZoomVelocitySpace), "tt:Space1DDescription"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:PanTiltSpeedSpace", &(a->tt__PTZSpaces::PanTiltSpeedSpace), "tt:Space1DDescription"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:ZoomSpeedSpace", &(a->tt__PTZSpaces::ZoomSpeedSpace), "tt:Space1DDescription"))
					continue;
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpacesExtension(soap, "tt:Extension", &(a->tt__PTZSpaces::Extension), "tt:PTZSpacesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZSpaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpaces, 0, sizeof(tt__PTZSpaces), 0, soap_copy_tt__PTZSpaces);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__PTZSpaces::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__PTZSpaces);
	if (this->soap_out(soap, tag?tag:"tt:PTZSpaces", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZSpaces::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZSpaces(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZSpaces * SOAP_FMAC4 soap_get_tt__PTZSpaces(struct soap *soap, tt__PTZSpaces *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__PTZSpaces * SOAP_FMAC2 soap_instantiate_tt__PTZSpaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZSpaces(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__PTZSpaces, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZSpaces);
		if (size)
			*size = sizeof(tt__PTZSpaces);
		((tt__PTZSpaces*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZSpaces[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__PTZSpaces);
		for (int i = 0; i < n; i++)
			((tt__PTZSpaces*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__PTZSpaces*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__PTZSpaces(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__PTZSpaces %p -> %p\n", q, p));
	*(tt__PTZSpaces*)p = *(tt__PTZSpaces*)q;
}

void tt__ZoomLimits::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ZoomLimits::Range = NULL;
	/* transient soap skipped */
}

void tt__ZoomLimits::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Space1DDescription(soap, &this->tt__ZoomLimits::Range);
	/* transient soap skipped */
}

int tt__ZoomLimits::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ZoomLimits(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ZoomLimits(struct soap *soap, const char *tag, int id, const tt__ZoomLimits *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ZoomLimits), type))
		return soap->error;
	if (a->tt__ZoomLimits::Range)
	{	if (soap_out_PointerTott__Space1DDescription(soap, "tt:Range", -1, &a->tt__ZoomLimits::Range, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Range"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ZoomLimits::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ZoomLimits(soap, tag, this, type);
}

SOAP_FMAC3 tt__ZoomLimits * SOAP_FMAC4 soap_in_tt__ZoomLimits(struct soap *soap, const char *tag, tt__ZoomLimits *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ZoomLimits *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ZoomLimits, sizeof(tt__ZoomLimits), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ZoomLimits)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ZoomLimits *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Range1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Range1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Space1DDescription(soap, "tt:Range", &(a->tt__ZoomLimits::Range), "tt:Space1DDescription"))
				{	soap_flag_Range1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ZoomLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ZoomLimits, 0, sizeof(tt__ZoomLimits), 0, soap_copy_tt__ZoomLimits);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Range1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__ZoomLimits::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ZoomLimits);
	if (this->soap_out(soap, tag?tag:"tt:ZoomLimits", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ZoomLimits::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ZoomLimits(soap, this, tag, type);
}

SOAP_FMAC3 tt__ZoomLimits * SOAP_FMAC4 soap_get_tt__ZoomLimits(struct soap *soap, tt__ZoomLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ZoomLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ZoomLimits * SOAP_FMAC2 soap_instantiate_tt__ZoomLimits(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ZoomLimits(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ZoomLimits, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ZoomLimits);
		if (size)
			*size = sizeof(tt__ZoomLimits);
		((tt__ZoomLimits*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ZoomLimits[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ZoomLimits);
		for (int i = 0; i < n; i++)
			((tt__ZoomLimits*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ZoomLimits*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ZoomLimits(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ZoomLimits %p -> %p\n", q, p));
	*(tt__ZoomLimits*)p = *(tt__ZoomLimits*)q;
}

void tt__PanTiltLimits::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PanTiltLimits::Range = NULL;
	/* transient soap skipped */
}

void tt__PanTiltLimits::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Space2DDescription(soap, &this->tt__PanTiltLimits::Range);
	/* transient soap skipped */
}

int tt__PanTiltLimits::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PanTiltLimits(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PanTiltLimits(struct soap *soap, const char *tag, int id, const tt__PanTiltLimits *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PanTiltLimits), type))
		return soap->error;
	if (a->tt__PanTiltLimits::Range)
	{	if (soap_out_PointerTott__Space2DDescription(soap, "tt:Range", -1, &a->tt__PanTiltLimits::Range, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Range"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__PanTiltLimits::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__PanTiltLimits(soap, tag, this, type);
}

SOAP_FMAC3 tt__PanTiltLimits * SOAP_FMAC4 soap_in_tt__PanTiltLimits(struct soap *soap, const char *tag, tt__PanTiltLimits *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PanTiltLimits *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PanTiltLimits, sizeof(tt__PanTiltLimits), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__PanTiltLimits)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__PanTiltLimits *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Range1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Range1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Space2DDescription(soap, "tt:Range", &(a->tt__PanTiltLimits::Range), "tt:Space2DDescription"))
				{	soap_flag_Range1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PanTiltLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PanTiltLimits, 0, sizeof(tt__PanTiltLimits), 0, soap_copy_tt__PanTiltLimits);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Range1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__PanTiltLimits::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__PanTiltLimits);
	if (this->soap_out(soap, tag?tag:"tt:PanTiltLimits", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PanTiltLimits::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PanTiltLimits(soap, this, tag, type);
}

SOAP_FMAC3 tt__PanTiltLimits * SOAP_FMAC4 soap_get_tt__PanTiltLimits(struct soap *soap, tt__PanTiltLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PanTiltLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__PanTiltLimits * SOAP_FMAC2 soap_instantiate_tt__PanTiltLimits(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PanTiltLimits(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__PanTiltLimits, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__PanTiltLimits);
		if (size)
			*size = sizeof(tt__PanTiltLimits);
		((tt__PanTiltLimits*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__PanTiltLimits[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__PanTiltLimits);
		for (int i = 0; i < n; i++)
			((tt__PanTiltLimits*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__PanTiltLimits*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__PanTiltLimits(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__PanTiltLimits %p -> %p\n", q, p));
	*(tt__PanTiltLimits*)p = *(tt__PanTiltLimits*)q;
}

void tt__PTZConfigurationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTZConfigurationOptions::Spaces = NULL;
	this->tt__PTZConfigurationOptions::PTZTimeout = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZConfigurationOptions::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZConfigurationOptions::__anyAttribute);
	/* transient soap skipped */
}

void tt__PTZConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__PTZSpaces(soap, &this->tt__PTZConfigurationOptions::Spaces);
	soap_serialize_PointerTott__DurationRange(soap, &this->tt__PTZConfigurationOptions::PTZTimeout);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZConfigurationOptions::__any);
	/* transient soap skipped */
}

int tt__PTZConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__PTZConfigurationOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZConfigurationOptions*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationOptions), type))
		return soap->error;
	if (a->tt__PTZConfigurationOptions::Spaces)
	{	if (soap_out_PointerTott__PTZSpaces(soap, "tt:Spaces", -1, &a->tt__PTZConfigurationOptions::Spaces, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Spaces"))
		return soap->error;
	if (a->tt__PTZConfigurationOptions::PTZTimeout)
	{	if (soap_out_PointerTott__DurationRange(soap, "tt:PTZTimeout", -1, &a->tt__PTZConfigurationOptions::PTZTimeout, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:PTZTimeout"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__PTZConfigurationOptions::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__PTZConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__PTZConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZConfigurationOptions * SOAP_FMAC4 soap_in_tt__PTZConfigurationOptions(struct soap *soap, const char *tag, tt__PTZConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZConfigurationOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationOptions, sizeof(tt__PTZConfigurationOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__PTZConfigurationOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__PTZConfigurationOptions *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZConfigurationOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Spaces1 = 1;
	size_t soap_flag_PTZTimeout1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Spaces1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpaces(soap, "tt:Spaces", &(a->tt__PTZConfigurationOptions::Spaces), "tt:PTZSpaces"))
				{	soap_flag_Spaces1--;
					continue;
				}
			if (soap_flag_PTZTimeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DurationRange(soap, "tt:PTZTimeout", &(a->tt__PTZConfigurationOptions::PTZTimeout), "tt:DurationRange"))
				{	soap_flag_PTZTimeout1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__PTZConfigurationOptions::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationOptions, 0, sizeof(tt__PTZConfigurationOptions), 0, soap_copy_tt__PTZConfigurationOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Spaces1 > 0 || soap_flag_PTZTimeout1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__PTZConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__PTZConfigurationOptions);
	if (this->soap_out(soap, tag?tag:"tt:PTZConfigurationOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZConfigurationOptions * SOAP_FMAC4 soap_get_tt__PTZConfigurationOptions(struct soap *soap, tt__PTZConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__PTZConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZConfigurationOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__PTZConfigurationOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZConfigurationOptions);
		if (size)
			*size = sizeof(tt__PTZConfigurationOptions);
		((tt__PTZConfigurationOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZConfigurationOptions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__PTZConfigurationOptions);
		for (int i = 0; i < n; i++)
			((tt__PTZConfigurationOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__PTZConfigurationOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__PTZConfigurationOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__PTZConfigurationOptions %p -> %p\n", q, p));
	*(tt__PTZConfigurationOptions*)p = *(tt__PTZConfigurationOptions*)q;
}

void tt__PTZConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZConfigurationExtension::__any);
	/* transient soap skipped */
}

void tt__PTZConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZConfigurationExtension::__any);
	/* transient soap skipped */
}

int tt__PTZConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__PTZConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__PTZConfigurationExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__PTZConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__PTZConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZConfigurationExtension * SOAP_FMAC4 soap_in_tt__PTZConfigurationExtension(struct soap *soap, const char *tag, tt__PTZConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZConfigurationExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(tt__PTZConfigurationExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__PTZConfigurationExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__PTZConfigurationExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__PTZConfigurationExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationExtension, 0, sizeof(tt__PTZConfigurationExtension), 0, soap_copy_tt__PTZConfigurationExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__PTZConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__PTZConfigurationExtension);
	if (this->soap_out(soap, tag?tag:"tt:PTZConfigurationExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZConfigurationExtension * SOAP_FMAC4 soap_get_tt__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__PTZConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZConfigurationExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__PTZConfigurationExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZConfigurationExtension);
		if (size)
			*size = sizeof(tt__PTZConfigurationExtension);
		((tt__PTZConfigurationExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZConfigurationExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__PTZConfigurationExtension);
		for (int i = 0; i < n; i++)
			((tt__PTZConfigurationExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__PTZConfigurationExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__PTZConfigurationExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__PTZConfigurationExtension %p -> %p\n", q, p));
	*(tt__PTZConfigurationExtension*)p = *(tt__PTZConfigurationExtension*)q;
}

void tt__PTZConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->tt__PTZConfiguration::NodeToken);
	this->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace = NULL;
	this->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace = NULL;
	this->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace = NULL;
	this->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace = NULL;
	this->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace = NULL;
	this->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace = NULL;
	this->tt__PTZConfiguration::DefaultPTZSpeed = NULL;
	this->tt__PTZConfiguration::DefaultPTZTimeout = NULL;
	this->tt__PTZConfiguration::PanTiltLimits = NULL;
	this->tt__PTZConfiguration::ZoomLimits = NULL;
	this->tt__PTZConfiguration::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZConfiguration::__anyAttribute);
	soap_default_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_default_int(soap, &this->tt__ConfigurationEntity::UseCount);
	soap_default_tt__ReferenceToken(soap, &this->tt__ConfigurationEntity::token);
	/* transient soap skipped */
}

void tt__PTZConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__PTZConfiguration::NodeToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__PTZConfiguration::NodeToken);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace);
	soap_serialize_PointerTott__PTZSpeed(soap, &this->tt__PTZConfiguration::DefaultPTZSpeed);
	soap_serialize_PointerToxsd__duration(soap, &this->tt__PTZConfiguration::DefaultPTZTimeout);
	soap_serialize_PointerTott__PanTiltLimits(soap, &this->tt__PTZConfiguration::PanTiltLimits);
	soap_serialize_PointerTott__ZoomLimits(soap, &this->tt__PTZConfiguration::ZoomLimits);
	soap_serialize_PointerTott__PTZConfigurationExtension(soap, &this->tt__PTZConfiguration::Extension);
	soap_embedded(soap, &this->tt__ConfigurationEntity::Name, SOAP_TYPE_tt__Name);
	soap_serialize_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_embedded(soap, &this->tt__ConfigurationEntity::UseCount, SOAP_TYPE_int);
	/* transient soap skipped */
}

int tt__PTZConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfiguration(struct soap *soap, const char *tag, int id, const tt__PTZConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	if (!((tt__ConfigurationEntity*)a)->token.empty())
		soap_set_attr(soap, "token", ((tt__ConfigurationEntity*)a)->token.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfiguration), "tt:PTZConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &(a->tt__ConfigurationEntity::Name), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &(a->tt__ConfigurationEntity::UseCount), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_tt__ReferenceToken(soap, "tt:NodeToken", -1, &(a->tt__PTZConfiguration::NodeToken), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultAbsolutePantTiltPositionSpace", -1, &(a->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultAbsoluteZoomPositionSpace", -1, &(a->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultRelativePanTiltTranslationSpace", -1, &(a->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultRelativeZoomTranslationSpace", -1, &(a->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultContinuousPanTiltVelocitySpace", -1, &(a->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultContinuousZoomVelocitySpace", -1, &(a->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace), ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tt:DefaultPTZSpeed", -1, &(a->tt__PTZConfiguration::DefaultPTZSpeed), ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tt:DefaultPTZTimeout", -1, &(a->tt__PTZConfiguration::DefaultPTZTimeout), ""))
		return soap->error;
	if (soap_out_PointerTott__PanTiltLimits(soap, "tt:PanTiltLimits", -1, &(a->tt__PTZConfiguration::PanTiltLimits), ""))
		return soap->error;
	if (soap_out_PointerTott__ZoomLimits(soap, "tt:ZoomLimits", -1, &(a->tt__PTZConfiguration::ZoomLimits), ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfigurationExtension(soap, "tt:Extension", -1, &(a->tt__PTZConfiguration::Extension), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__PTZConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZConfiguration * SOAP_FMAC4 soap_in_tt__PTZConfiguration(struct soap *soap, const char *tag, tt__PTZConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfiguration, sizeof(tt__PTZConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__PTZConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__PTZConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	{	const char *t = soap_attr_value(soap, "token", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, 64))
				return NULL;
			((tt__ConfigurationEntity*)a)->token.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_NodeToken1 = 1;
	size_t soap_flag_DefaultAbsolutePantTiltPositionSpace1 = 1;
	size_t soap_flag_DefaultAbsoluteZoomPositionSpace1 = 1;
	size_t soap_flag_DefaultRelativePanTiltTranslationSpace1 = 1;
	size_t soap_flag_DefaultRelativeZoomTranslationSpace1 = 1;
	size_t soap_flag_DefaultContinuousPanTiltVelocitySpace1 = 1;
	size_t soap_flag_DefaultContinuousZoomVelocitySpace1 = 1;
	size_t soap_flag_DefaultPTZSpeed1 = 1;
	size_t soap_flag_DefaultPTZTimeout1 = 1;
	size_t soap_flag_PanTiltLimits1 = 1;
	size_t soap_flag_ZoomLimits1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &(a->tt__ConfigurationEntity::Name), "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &(a->tt__ConfigurationEntity::UseCount), "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_NodeToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:NodeToken", &(a->tt__PTZConfiguration::NodeToken), "tt:ReferenceToken"))
				{	soap_flag_NodeToken1--;
					continue;
				}
			if (soap_flag_DefaultAbsolutePantTiltPositionSpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultAbsolutePantTiltPositionSpace", &(a->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace), "xsd:anyURI"))
				{	soap_flag_DefaultAbsolutePantTiltPositionSpace1--;
					continue;
				}
			if (soap_flag_DefaultAbsoluteZoomPositionSpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultAbsoluteZoomPositionSpace", &(a->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace), "xsd:anyURI"))
				{	soap_flag_DefaultAbsoluteZoomPositionSpace1--;
					continue;
				}
			if (soap_flag_DefaultRelativePanTiltTranslationSpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultRelativePanTiltTranslationSpace", &(a->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace), "xsd:anyURI"))
				{	soap_flag_DefaultRelativePanTiltTranslationSpace1--;
					continue;
				}
			if (soap_flag_DefaultRelativeZoomTranslationSpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultRelativeZoomTranslationSpace", &(a->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace), "xsd:anyURI"))
				{	soap_flag_DefaultRelativeZoomTranslationSpace1--;
					continue;
				}
			if (soap_flag_DefaultContinuousPanTiltVelocitySpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultContinuousPanTiltVelocitySpace", &(a->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace), "xsd:anyURI"))
				{	soap_flag_DefaultContinuousPanTiltVelocitySpace1--;
					continue;
				}
			if (soap_flag_DefaultContinuousZoomVelocitySpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultContinuousZoomVelocitySpace", &(a->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace), "xsd:anyURI"))
				{	soap_flag_DefaultContinuousZoomVelocitySpace1--;
					continue;
				}
			if (soap_flag_DefaultPTZSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpeed(soap, "tt:DefaultPTZSpeed", &(a->tt__PTZConfiguration::DefaultPTZSpeed), "tt:PTZSpeed"))
				{	soap_flag_DefaultPTZSpeed1--;
					continue;
				}
			if (soap_flag_DefaultPTZTimeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "tt:DefaultPTZTimeout", &(a->tt__PTZConfiguration::DefaultPTZTimeout), "xsd:duration"))
				{	soap_flag_DefaultPTZTimeout1--;
					continue;
				}
			if (soap_flag_PanTiltLimits1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PanTiltLimits(soap, "tt:PanTiltLimits", &(a->tt__PTZConfiguration::PanTiltLimits), "tt:PanTiltLimits"))
				{	soap_flag_PanTiltLimits1--;
					continue;
				}
			if (soap_flag_ZoomLimits1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ZoomLimits(soap, "tt:ZoomLimits", &(a->tt__PTZConfiguration::ZoomLimits), "tt:ZoomLimits"))
				{	soap_flag_ZoomLimits1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZConfigurationExtension(soap, "tt:Extension", &(a->tt__PTZConfiguration::Extension), "tt:PTZConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfiguration, 0, sizeof(tt__PTZConfiguration), 0, soap_copy_tt__PTZConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_NodeToken1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__PTZConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__PTZConfiguration);
	if (this->soap_out(soap, tag?tag:"tt:PTZConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZConfiguration * SOAP_FMAC4 soap_get_tt__PTZConfiguration(struct soap *soap, tt__PTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__PTZConfiguration * SOAP_FMAC2 soap_instantiate_tt__PTZConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__PTZConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZConfiguration);
		if (size)
			*size = sizeof(tt__PTZConfiguration);
		((tt__PTZConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZConfiguration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__PTZConfiguration);
		for (int i = 0; i < n; i++)
			((tt__PTZConfiguration*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__PTZConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__PTZConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__PTZConfiguration %p -> %p\n", q, p));
	*(tt__PTZConfiguration*)p = *(tt__PTZConfiguration*)q;
}

void tt__PTZNodeExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZNodeExtension::__any);
	/* transient soap skipped */
}

void tt__PTZNodeExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZNodeExtension::__any);
	/* transient soap skipped */
}

int tt__PTZNodeExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZNodeExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZNodeExtension(struct soap *soap, const char *tag, int id, const tt__PTZNodeExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZNodeExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__PTZNodeExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__PTZNodeExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__PTZNodeExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZNodeExtension * SOAP_FMAC4 soap_in_tt__PTZNodeExtension(struct soap *soap, const char *tag, tt__PTZNodeExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZNodeExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZNodeExtension, sizeof(tt__PTZNodeExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__PTZNodeExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__PTZNodeExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__PTZNodeExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZNodeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZNodeExtension, 0, sizeof(tt__PTZNodeExtension), 0, soap_copy_tt__PTZNodeExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__PTZNodeExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__PTZNodeExtension);
	if (this->soap_out(soap, tag?tag:"tt:PTZNodeExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZNodeExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZNodeExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZNodeExtension * SOAP_FMAC4 soap_get_tt__PTZNodeExtension(struct soap *soap, tt__PTZNodeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZNodeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__PTZNodeExtension * SOAP_FMAC2 soap_instantiate_tt__PTZNodeExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZNodeExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__PTZNodeExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZNodeExtension);
		if (size)
			*size = sizeof(tt__PTZNodeExtension);
		((tt__PTZNodeExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZNodeExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__PTZNodeExtension);
		for (int i = 0; i < n; i++)
			((tt__PTZNodeExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__PTZNodeExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__PTZNodeExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__PTZNodeExtension %p -> %p\n", q, p));
	*(tt__PTZNodeExtension*)p = *(tt__PTZNodeExtension*)q;
}

void tt__PTZNode::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTZNode::Name = NULL;
	this->tt__PTZNode::SupportedPTZSpaces = NULL;
	soap_default_int(soap, &this->tt__PTZNode::MaximumNumberOfPresets);
	soap_default_bool(soap, &this->tt__PTZNode::HomeSupported);
	soap_default_std__vectorTemplateOftt__AuxiliaryData(soap, &this->tt__PTZNode::AuxiliaryCommands);
	this->tt__PTZNode::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZNode::__anyAttribute);
	soap_default_tt__ReferenceToken(soap, &this->tt__DeviceEntity::token);
	/* transient soap skipped */
}

void tt__PTZNode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Name(soap, &this->tt__PTZNode::Name);
	soap_serialize_PointerTott__PTZSpaces(soap, &this->tt__PTZNode::SupportedPTZSpaces);
	soap_embedded(soap, &this->tt__PTZNode::MaximumNumberOfPresets, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__PTZNode::HomeSupported, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOftt__AuxiliaryData(soap, &this->tt__PTZNode::AuxiliaryCommands);
	soap_serialize_PointerTott__PTZNodeExtension(soap, &this->tt__PTZNode::Extension);
	/* transient soap skipped */
}

int tt__PTZNode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZNode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZNode(struct soap *soap, const char *tag, int id, const tt__PTZNode *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZNode*)a)->__anyAttribute, ""))
		return soap->error;
	if (!((tt__DeviceEntity*)a)->token.empty())
		soap_set_attr(soap, "token", ((tt__DeviceEntity*)a)->token.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZNode), "tt:PTZNode"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTott__Name(soap, "tt:Name", -1, &(a->tt__PTZNode::Name), ""))
		return soap->error;
	if (a->tt__PTZNode::SupportedPTZSpaces)
	{	if (soap_out_PointerTott__PTZSpaces(soap, "tt:SupportedPTZSpaces", -1, &a->tt__PTZNode::SupportedPTZSpaces, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SupportedPTZSpaces"))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumNumberOfPresets", -1, &(a->tt__PTZNode::MaximumNumberOfPresets), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:HomeSupported", -1, &(a->tt__PTZNode::HomeSupported), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__AuxiliaryData(soap, "tt:AuxiliaryCommands", -1, &(a->tt__PTZNode::AuxiliaryCommands), ""))
		return soap->error;
	if (soap_out_PointerTott__PTZNodeExtension(soap, "tt:Extension", -1, &(a->tt__PTZNode::Extension), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZNode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__PTZNode(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZNode * SOAP_FMAC4 soap_in_tt__PTZNode(struct soap *soap, const char *tag, tt__PTZNode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZNode *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZNode, sizeof(tt__PTZNode), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__PTZNode)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__PTZNode *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZNode*)a)->__anyAttribute, "xsd:anyAttribute");
	{	const char *t = soap_attr_value(soap, "token", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, 64))
				return NULL;
			((tt__DeviceEntity*)a)->token.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_SupportedPTZSpaces1 = 1;
	size_t soap_flag_MaximumNumberOfPresets1 = 1;
	size_t soap_flag_HomeSupported1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTott__Name(soap, "tt:Name", &(a->tt__PTZNode::Name), "tt:Name"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_SupportedPTZSpaces1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpaces(soap, "tt:SupportedPTZSpaces", &(a->tt__PTZNode::SupportedPTZSpaces), "tt:PTZSpaces"))
				{	soap_flag_SupportedPTZSpaces1--;
					continue;
				}
			if (soap_flag_MaximumNumberOfPresets1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:MaximumNumberOfPresets", &(a->tt__PTZNode::MaximumNumberOfPresets), "xsd:int"))
				{	soap_flag_MaximumNumberOfPresets1--;
					continue;
				}
			if (soap_flag_HomeSupported1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:HomeSupported", &(a->tt__PTZNode::HomeSupported), "xsd:boolean"))
				{	soap_flag_HomeSupported1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftt__AuxiliaryData(soap, "tt:AuxiliaryCommands", &(a->tt__PTZNode::AuxiliaryCommands), "tt:AuxiliaryData"))
					continue;
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZNodeExtension(soap, "tt:Extension", &(a->tt__PTZNode::Extension), "tt:PTZNodeExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZNode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZNode, 0, sizeof(tt__PTZNode), 0, soap_copy_tt__PTZNode);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SupportedPTZSpaces1 > 0 || soap_flag_MaximumNumberOfPresets1 > 0 || soap_flag_HomeSupported1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__PTZNode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__PTZNode);
	if (this->soap_out(soap, tag?tag:"tt:PTZNode", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZNode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZNode(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZNode * SOAP_FMAC4 soap_get_tt__PTZNode(struct soap *soap, tt__PTZNode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__PTZNode * SOAP_FMAC2 soap_instantiate_tt__PTZNode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZNode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__PTZNode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZNode);
		if (size)
			*size = sizeof(tt__PTZNode);
		((tt__PTZNode*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZNode[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__PTZNode);
		for (int i = 0; i < n; i++)
			((tt__PTZNode*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__PTZNode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__PTZNode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__PTZNode %p -> %p\n", q, p));
	*(tt__PTZNode*)p = *(tt__PTZNode*)q;
}

void tt__RelayOutput::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__RelayOutput::Properties = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RelayOutput::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__RelayOutput::__anyAttribute);
	soap_default_tt__ReferenceToken(soap, &this->tt__DeviceEntity::token);
	/* transient soap skipped */
}

void tt__RelayOutput::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__RelayOutputSettings(soap, &this->tt__RelayOutput::Properties);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RelayOutput::__any);
	/* transient soap skipped */
}

int tt__RelayOutput::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RelayOutput(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayOutput(struct soap *soap, const char *tag, int id, const tt__RelayOutput *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__RelayOutput*)a)->__anyAttribute, ""))
		return soap->error;
	if (!((tt__DeviceEntity*)a)->token.empty())
		soap_set_attr(soap, "token", ((tt__DeviceEntity*)a)->token.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayOutput), "tt:RelayOutput"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__RelayOutput::Properties)
	{	if (soap_out_PointerTott__RelayOutputSettings(soap, "tt:Properties", -1, &a->tt__RelayOutput::Properties, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Properties"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__RelayOutput::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RelayOutput::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__RelayOutput(soap, tag, this, type);
}

SOAP_FMAC3 tt__RelayOutput * SOAP_FMAC4 soap_in_tt__RelayOutput(struct soap *soap, const char *tag, tt__RelayOutput *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RelayOutput *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayOutput, sizeof(tt__RelayOutput), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__RelayOutput)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__RelayOutput *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__RelayOutput*)a)->__anyAttribute, "xsd:anyAttribute");
	{	const char *t = soap_attr_value(soap, "token", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, 64))
				return NULL;
			((tt__DeviceEntity*)a)->token.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Properties1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Properties1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RelayOutputSettings(soap, "tt:Properties", &(a->tt__RelayOutput::Properties), "tt:RelayOutputSettings"))
				{	soap_flag_Properties1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__RelayOutput::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RelayOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayOutput, 0, sizeof(tt__RelayOutput), 0, soap_copy_tt__RelayOutput);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Properties1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__RelayOutput::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__RelayOutput);
	if (this->soap_out(soap, tag?tag:"tt:RelayOutput", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RelayOutput::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RelayOutput(soap, this, tag, type);
}

SOAP_FMAC3 tt__RelayOutput * SOAP_FMAC4 soap_get_tt__RelayOutput(struct soap *soap, tt__RelayOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__RelayOutput * SOAP_FMAC2 soap_instantiate_tt__RelayOutput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RelayOutput(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__RelayOutput, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__RelayOutput);
		if (size)
			*size = sizeof(tt__RelayOutput);
		((tt__RelayOutput*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__RelayOutput[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__RelayOutput);
		for (int i = 0; i < n; i++)
			((tt__RelayOutput*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__RelayOutput*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__RelayOutput(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__RelayOutput %p -> %p\n", q, p));
	*(tt__RelayOutput*)p = *(tt__RelayOutput*)q;
}

void tt__RelayOutputSettings::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__RelayMode(soap, &this->tt__RelayOutputSettings::Mode);
	soap_default_xsd__duration(soap, &this->tt__RelayOutputSettings::DelayTime);
	soap_default_tt__RelayIdleState(soap, &this->tt__RelayOutputSettings::IdleState);
	/* transient soap skipped */
}

void tt__RelayOutputSettings::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__RelayOutputSettings::DelayTime, SOAP_TYPE_xsd__duration);
	/* transient soap skipped */
}

int tt__RelayOutputSettings::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RelayOutputSettings(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayOutputSettings(struct soap *soap, const char *tag, int id, const tt__RelayOutputSettings *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayOutputSettings), type))
		return soap->error;
	if (soap_out_tt__RelayMode(soap, "tt:Mode", -1, &(a->tt__RelayOutputSettings::Mode), ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:DelayTime", -1, &(a->tt__RelayOutputSettings::DelayTime), ""))
		return soap->error;
	if (soap_out_tt__RelayIdleState(soap, "tt:IdleState", -1, &(a->tt__RelayOutputSettings::IdleState), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__RelayOutputSettings::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__RelayOutputSettings(soap, tag, this, type);
}

SOAP_FMAC3 tt__RelayOutputSettings * SOAP_FMAC4 soap_in_tt__RelayOutputSettings(struct soap *soap, const char *tag, tt__RelayOutputSettings *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RelayOutputSettings *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayOutputSettings, sizeof(tt__RelayOutputSettings), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__RelayOutputSettings)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__RelayOutputSettings *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_DelayTime1 = 1;
	size_t soap_flag_IdleState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__RelayMode(soap, "tt:Mode", &(a->tt__RelayOutputSettings::Mode), "tt:RelayMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			if (soap_flag_DelayTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tt:DelayTime", &(a->tt__RelayOutputSettings::DelayTime), "xsd:duration"))
				{	soap_flag_DelayTime1--;
					continue;
				}
			if (soap_flag_IdleState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__RelayIdleState(soap, "tt:IdleState", &(a->tt__RelayOutputSettings::IdleState), "tt:RelayIdleState"))
				{	soap_flag_IdleState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RelayOutputSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayOutputSettings, 0, sizeof(tt__RelayOutputSettings), 0, soap_copy_tt__RelayOutputSettings);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0 || soap_flag_DelayTime1 > 0 || soap_flag_IdleState1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__RelayOutputSettings::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__RelayOutputSettings);
	if (this->soap_out(soap, tag?tag:"tt:RelayOutputSettings", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RelayOutputSettings::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RelayOutputSettings(soap, this, tag, type);
}

SOAP_FMAC3 tt__RelayOutputSettings * SOAP_FMAC4 soap_get_tt__RelayOutputSettings(struct soap *soap, tt__RelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__RelayOutputSettings * SOAP_FMAC2 soap_instantiate_tt__RelayOutputSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RelayOutputSettings(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__RelayOutputSettings, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__RelayOutputSettings);
		if (size)
			*size = sizeof(tt__RelayOutputSettings);
		((tt__RelayOutputSettings*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__RelayOutputSettings[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__RelayOutputSettings);
		for (int i = 0; i < n; i++)
			((tt__RelayOutputSettings*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__RelayOutputSettings*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__RelayOutputSettings(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__RelayOutputSettings %p -> %p\n", q, p));
	*(tt__RelayOutputSettings*)p = *(tt__RelayOutputSettings*)q;
}

void tt__CertificateStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__token(soap, &this->tt__CertificateStatus::CertificateID);
	soap_default_bool(soap, &this->tt__CertificateStatus::Status);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__CertificateStatus::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__CertificateStatus::__anyAttribute);
	/* transient soap skipped */
}

void tt__CertificateStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__CertificateStatus::CertificateID, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->tt__CertificateStatus::CertificateID);
	soap_embedded(soap, &this->tt__CertificateStatus::Status, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__CertificateStatus::__any);
	/* transient soap skipped */
}

int tt__CertificateStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CertificateStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateStatus(struct soap *soap, const char *tag, int id, const tt__CertificateStatus *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__CertificateStatus*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateStatus), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, &(a->tt__CertificateStatus::CertificateID), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:Status", -1, &(a->tt__CertificateStatus::Status), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__CertificateStatus::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__CertificateStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__CertificateStatus(soap, tag, this, type);
}

SOAP_FMAC3 tt__CertificateStatus * SOAP_FMAC4 soap_in_tt__CertificateStatus(struct soap *soap, const char *tag, tt__CertificateStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CertificateStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateStatus, sizeof(tt__CertificateStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__CertificateStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__CertificateStatus *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__CertificateStatus*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_Status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:CertificateID", &(a->tt__CertificateStatus::CertificateID), "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:Status", &(a->tt__CertificateStatus::Status), "xsd:boolean"))
				{	soap_flag_Status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__CertificateStatus::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__CertificateStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateStatus, 0, sizeof(tt__CertificateStatus), 0, soap_copy_tt__CertificateStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID1 > 0 || soap_flag_Status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__CertificateStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__CertificateStatus);
	if (this->soap_out(soap, tag?tag:"tt:CertificateStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CertificateStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CertificateStatus(soap, this, tag, type);
}

SOAP_FMAC3 tt__CertificateStatus * SOAP_FMAC4 soap_get_tt__CertificateStatus(struct soap *soap, tt__CertificateStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__CertificateStatus * SOAP_FMAC2 soap_instantiate_tt__CertificateStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CertificateStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__CertificateStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__CertificateStatus);
		if (size)
			*size = sizeof(tt__CertificateStatus);
		((tt__CertificateStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__CertificateStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__CertificateStatus);
		for (int i = 0; i < n; i++)
			((tt__CertificateStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__CertificateStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__CertificateStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__CertificateStatus %p -> %p\n", q, p));
	*(tt__CertificateStatus*)p = *(tt__CertificateStatus*)q;
}

void tt__Certificate::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__token(soap, &this->tt__Certificate::CertificateID);
	this->tt__Certificate::Certificate = NULL;
	/* transient soap skipped */
}

void tt__Certificate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__Certificate::CertificateID, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->tt__Certificate::CertificateID);
	soap_serialize_PointerTott__BinaryData(soap, &this->tt__Certificate::Certificate);
	/* transient soap skipped */
}

int tt__Certificate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Certificate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Certificate(struct soap *soap, const char *tag, int id, const tt__Certificate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Certificate), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, &(a->tt__Certificate::CertificateID), ""))
		return soap->error;
	if (a->tt__Certificate::Certificate)
	{	if (soap_out_PointerTott__BinaryData(soap, "tt:Certificate", -1, &a->tt__Certificate::Certificate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Certificate"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Certificate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Certificate(soap, tag, this, type);
}

SOAP_FMAC3 tt__Certificate * SOAP_FMAC4 soap_in_tt__Certificate(struct soap *soap, const char *tag, tt__Certificate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Certificate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Certificate, sizeof(tt__Certificate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Certificate)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Certificate *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_Certificate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:CertificateID", &(a->tt__Certificate::CertificateID), "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			if (soap_flag_Certificate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BinaryData(soap, "tt:Certificate", &(a->tt__Certificate::Certificate), "tt:BinaryData"))
				{	soap_flag_Certificate1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Certificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Certificate, 0, sizeof(tt__Certificate), 0, soap_copy_tt__Certificate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID1 > 0 || soap_flag_Certificate1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Certificate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Certificate);
	if (this->soap_out(soap, tag?tag:"tt:Certificate", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Certificate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Certificate(soap, this, tag, type);
}

SOAP_FMAC3 tt__Certificate * SOAP_FMAC4 soap_get_tt__Certificate(struct soap *soap, tt__Certificate *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Certificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Certificate * SOAP_FMAC2 soap_instantiate_tt__Certificate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Certificate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Certificate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Certificate);
		if (size)
			*size = sizeof(tt__Certificate);
		((tt__Certificate*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Certificate[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Certificate);
		for (int i = 0; i < n; i++)
			((tt__Certificate*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Certificate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Certificate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Certificate %p -> %p\n", q, p));
	*(tt__Certificate*)p = *(tt__Certificate*)q;
}

void tt__CertificateGenerationParametersExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__CertificateGenerationParametersExtension::__any);
	/* transient soap skipped */
}

void tt__CertificateGenerationParametersExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__CertificateGenerationParametersExtension::__any);
	/* transient soap skipped */
}

int tt__CertificateGenerationParametersExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CertificateGenerationParametersExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateGenerationParametersExtension(struct soap *soap, const char *tag, int id, const tt__CertificateGenerationParametersExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateGenerationParametersExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__CertificateGenerationParametersExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__CertificateGenerationParametersExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__CertificateGenerationParametersExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__CertificateGenerationParametersExtension * SOAP_FMAC4 soap_in_tt__CertificateGenerationParametersExtension(struct soap *soap, const char *tag, tt__CertificateGenerationParametersExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CertificateGenerationParametersExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateGenerationParametersExtension, sizeof(tt__CertificateGenerationParametersExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__CertificateGenerationParametersExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__CertificateGenerationParametersExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__CertificateGenerationParametersExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__CertificateGenerationParametersExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateGenerationParametersExtension, 0, sizeof(tt__CertificateGenerationParametersExtension), 0, soap_copy_tt__CertificateGenerationParametersExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__CertificateGenerationParametersExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__CertificateGenerationParametersExtension);
	if (this->soap_out(soap, tag?tag:"tt:CertificateGenerationParametersExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CertificateGenerationParametersExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CertificateGenerationParametersExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__CertificateGenerationParametersExtension * SOAP_FMAC4 soap_get_tt__CertificateGenerationParametersExtension(struct soap *soap, tt__CertificateGenerationParametersExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateGenerationParametersExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__CertificateGenerationParametersExtension * SOAP_FMAC2 soap_instantiate_tt__CertificateGenerationParametersExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CertificateGenerationParametersExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__CertificateGenerationParametersExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__CertificateGenerationParametersExtension);
		if (size)
			*size = sizeof(tt__CertificateGenerationParametersExtension);
		((tt__CertificateGenerationParametersExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__CertificateGenerationParametersExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__CertificateGenerationParametersExtension);
		for (int i = 0; i < n; i++)
			((tt__CertificateGenerationParametersExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__CertificateGenerationParametersExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__CertificateGenerationParametersExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__CertificateGenerationParametersExtension %p -> %p\n", q, p));
	*(tt__CertificateGenerationParametersExtension*)p = *(tt__CertificateGenerationParametersExtension*)q;
}

void tt__CertificateGenerationParameters::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__CertificateGenerationParameters::CertificateID = NULL;
	this->tt__CertificateGenerationParameters::Subject = NULL;
	this->tt__CertificateGenerationParameters::ValidNotBefore = NULL;
	this->tt__CertificateGenerationParameters::ValidNotAfter = NULL;
	this->tt__CertificateGenerationParameters::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__CertificateGenerationParameters::__anyAttribute);
	/* transient soap skipped */
}

void tt__CertificateGenerationParameters::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__token(soap, &this->tt__CertificateGenerationParameters::CertificateID);
	soap_serialize_PointerTostd__string(soap, &this->tt__CertificateGenerationParameters::Subject);
	soap_serialize_PointerToxsd__token(soap, &this->tt__CertificateGenerationParameters::ValidNotBefore);
	soap_serialize_PointerToxsd__token(soap, &this->tt__CertificateGenerationParameters::ValidNotAfter);
	soap_serialize_PointerTott__CertificateGenerationParametersExtension(soap, &this->tt__CertificateGenerationParameters::Extension);
	/* transient soap skipped */
}

int tt__CertificateGenerationParameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CertificateGenerationParameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateGenerationParameters(struct soap *soap, const char *tag, int id, const tt__CertificateGenerationParameters *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__CertificateGenerationParameters*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateGenerationParameters), type))
		return soap->error;
	if (soap_out_PointerToxsd__token(soap, "tt:CertificateID", -1, &(a->tt__CertificateGenerationParameters::CertificateID), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Subject", -1, &(a->tt__CertificateGenerationParameters::Subject), ""))
		return soap->error;
	if (soap_out_PointerToxsd__token(soap, "tt:ValidNotBefore", -1, &(a->tt__CertificateGenerationParameters::ValidNotBefore), ""))
		return soap->error;
	if (soap_out_PointerToxsd__token(soap, "tt:ValidNotAfter", -1, &(a->tt__CertificateGenerationParameters::ValidNotAfter), ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateGenerationParametersExtension(soap, "tt:Extension", -1, &(a->tt__CertificateGenerationParameters::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__CertificateGenerationParameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__CertificateGenerationParameters(soap, tag, this, type);
}

SOAP_FMAC3 tt__CertificateGenerationParameters * SOAP_FMAC4 soap_in_tt__CertificateGenerationParameters(struct soap *soap, const char *tag, tt__CertificateGenerationParameters *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CertificateGenerationParameters *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateGenerationParameters, sizeof(tt__CertificateGenerationParameters), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__CertificateGenerationParameters)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__CertificateGenerationParameters *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__CertificateGenerationParameters*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_Subject1 = 1;
	size_t soap_flag_ValidNotBefore1 = 1;
	size_t soap_flag_ValidNotAfter1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__token(soap, "tt:CertificateID", &(a->tt__CertificateGenerationParameters::CertificateID), "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			if (soap_flag_Subject1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "tt:Subject", &(a->tt__CertificateGenerationParameters::Subject), "xsd:string"))
				{	soap_flag_Subject1--;
					continue;
				}
			if (soap_flag_ValidNotBefore1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__token(soap, "tt:ValidNotBefore", &(a->tt__CertificateGenerationParameters::ValidNotBefore), "xsd:token"))
				{	soap_flag_ValidNotBefore1--;
					continue;
				}
			if (soap_flag_ValidNotAfter1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__token(soap, "tt:ValidNotAfter", &(a->tt__CertificateGenerationParameters::ValidNotAfter), "xsd:token"))
				{	soap_flag_ValidNotAfter1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__CertificateGenerationParametersExtension(soap, "tt:Extension", &(a->tt__CertificateGenerationParameters::Extension), "tt:CertificateGenerationParametersExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__CertificateGenerationParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateGenerationParameters, 0, sizeof(tt__CertificateGenerationParameters), 0, soap_copy_tt__CertificateGenerationParameters);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__CertificateGenerationParameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__CertificateGenerationParameters);
	if (this->soap_out(soap, tag?tag:"tt:CertificateGenerationParameters", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CertificateGenerationParameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CertificateGenerationParameters(soap, this, tag, type);
}

SOAP_FMAC3 tt__CertificateGenerationParameters * SOAP_FMAC4 soap_get_tt__CertificateGenerationParameters(struct soap *soap, tt__CertificateGenerationParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateGenerationParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__CertificateGenerationParameters * SOAP_FMAC2 soap_instantiate_tt__CertificateGenerationParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CertificateGenerationParameters(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__CertificateGenerationParameters, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__CertificateGenerationParameters);
		if (size)
			*size = sizeof(tt__CertificateGenerationParameters);
		((tt__CertificateGenerationParameters*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__CertificateGenerationParameters[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__CertificateGenerationParameters);
		for (int i = 0; i < n; i++)
			((tt__CertificateGenerationParameters*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__CertificateGenerationParameters*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__CertificateGenerationParameters(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__CertificateGenerationParameters %p -> %p\n", q, p));
	*(tt__CertificateGenerationParameters*)p = *(tt__CertificateGenerationParameters*)q;
}

void tt__UserExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__UserExtension::__any);
	/* transient soap skipped */
}

void tt__UserExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__UserExtension::__any);
	/* transient soap skipped */
}

int tt__UserExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__UserExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__UserExtension(struct soap *soap, const char *tag, int id, const tt__UserExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__UserExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__UserExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__UserExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__UserExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__UserExtension * SOAP_FMAC4 soap_in_tt__UserExtension(struct soap *soap, const char *tag, tt__UserExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__UserExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__UserExtension, sizeof(tt__UserExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__UserExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__UserExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__UserExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__UserExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__UserExtension, 0, sizeof(tt__UserExtension), 0, soap_copy_tt__UserExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__UserExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__UserExtension);
	if (this->soap_out(soap, tag?tag:"tt:UserExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__UserExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__UserExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__UserExtension * SOAP_FMAC4 soap_get_tt__UserExtension(struct soap *soap, tt__UserExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__UserExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__UserExtension * SOAP_FMAC2 soap_instantiate_tt__UserExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__UserExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__UserExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__UserExtension);
		if (size)
			*size = sizeof(tt__UserExtension);
		((tt__UserExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__UserExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__UserExtension);
		for (int i = 0; i < n; i++)
			((tt__UserExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__UserExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__UserExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__UserExtension %p -> %p\n", q, p));
	*(tt__UserExtension*)p = *(tt__UserExtension*)q;
}

void tt__User::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->tt__User::Username);
	this->tt__User::Password = NULL;
	soap_default_tt__UserLevel(soap, &this->tt__User::UserLevel);
	this->tt__User::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__User::__anyAttribute);
	/* transient soap skipped */
}

void tt__User::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__User::Username, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__User::Username);
	soap_serialize_PointerTostd__string(soap, &this->tt__User::Password);
	soap_serialize_PointerTott__UserExtension(soap, &this->tt__User::Extension);
	/* transient soap skipped */
}

int tt__User::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__User(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__User(struct soap *soap, const char *tag, int id, const tt__User *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__User*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__User), type))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Username", -1, &(a->tt__User::Username), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Password", -1, &(a->tt__User::Password), ""))
		return soap->error;
	if (soap_out_tt__UserLevel(soap, "tt:UserLevel", -1, &(a->tt__User::UserLevel), ""))
		return soap->error;
	if (soap_out_PointerTott__UserExtension(soap, "tt:Extension", -1, &(a->tt__User::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__User::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__User(soap, tag, this, type);
}

SOAP_FMAC3 tt__User * SOAP_FMAC4 soap_in_tt__User(struct soap *soap, const char *tag, tt__User *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__User *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__User, sizeof(tt__User), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__User)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__User *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__User*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Username1 = 1;
	size_t soap_flag_Password1 = 1;
	size_t soap_flag_UserLevel1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tt:Username", &(a->tt__User::Username), "xsd:string"))
				{	soap_flag_Username1--;
					continue;
				}
			if (soap_flag_Password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "tt:Password", &(a->tt__User::Password), "xsd:string"))
				{	soap_flag_Password1--;
					continue;
				}
			if (soap_flag_UserLevel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__UserLevel(soap, "tt:UserLevel", &(a->tt__User::UserLevel), "tt:UserLevel"))
				{	soap_flag_UserLevel1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__UserExtension(soap, "tt:Extension", &(a->tt__User::Extension), "tt:UserExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__User *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__User, 0, sizeof(tt__User), 0, soap_copy_tt__User);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Username1 > 0 || soap_flag_UserLevel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__User::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__User);
	if (this->soap_out(soap, tag?tag:"tt:User", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__User::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__User(soap, this, tag, type);
}

SOAP_FMAC3 tt__User * SOAP_FMAC4 soap_get_tt__User(struct soap *soap, tt__User *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__User(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__User * SOAP_FMAC2 soap_instantiate_tt__User(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__User(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__User, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__User);
		if (size)
			*size = sizeof(tt__User);
		((tt__User*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__User[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__User);
		for (int i = 0; i < n; i++)
			((tt__User*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__User*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__User(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__User %p -> %p\n", q, p));
	*(tt__User*)p = *(tt__User*)q;
}

void tt__TimeZone::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__token(soap, &this->tt__TimeZone::TZ);
	/* transient soap skipped */
}

void tt__TimeZone::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__TimeZone::TZ, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->tt__TimeZone::TZ);
	/* transient soap skipped */
}

int tt__TimeZone::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__TimeZone(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TimeZone(struct soap *soap, const char *tag, int id, const tt__TimeZone *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TimeZone), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:TZ", -1, &(a->tt__TimeZone::TZ), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__TimeZone::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__TimeZone(soap, tag, this, type);
}

SOAP_FMAC3 tt__TimeZone * SOAP_FMAC4 soap_in_tt__TimeZone(struct soap *soap, const char *tag, tt__TimeZone *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__TimeZone *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TimeZone, sizeof(tt__TimeZone), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__TimeZone)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__TimeZone *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TZ1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TZ1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:TZ", &(a->tt__TimeZone::TZ), "xsd:token"))
				{	soap_flag_TZ1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__TimeZone *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TimeZone, 0, sizeof(tt__TimeZone), 0, soap_copy_tt__TimeZone);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TZ1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__TimeZone::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__TimeZone);
	if (this->soap_out(soap, tag?tag:"tt:TimeZone", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__TimeZone::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__TimeZone(soap, this, tag, type);
}

SOAP_FMAC3 tt__TimeZone * SOAP_FMAC4 soap_get_tt__TimeZone(struct soap *soap, tt__TimeZone *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TimeZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__TimeZone * SOAP_FMAC2 soap_instantiate_tt__TimeZone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__TimeZone(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__TimeZone, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__TimeZone);
		if (size)
			*size = sizeof(tt__TimeZone);
		((tt__TimeZone*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__TimeZone[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__TimeZone);
		for (int i = 0; i < n; i++)
			((tt__TimeZone*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__TimeZone*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__TimeZone(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__TimeZone %p -> %p\n", q, p));
	*(tt__TimeZone*)p = *(tt__TimeZone*)q;
}

void tt__Time::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tt__Time::Hour);
	soap_default_int(soap, &this->tt__Time::Minute);
	soap_default_int(soap, &this->tt__Time::Second);
	/* transient soap skipped */
}

void tt__Time::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__Time::Hour, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__Time::Minute, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__Time::Second, SOAP_TYPE_int);
	/* transient soap skipped */
}

int tt__Time::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Time(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Time(struct soap *soap, const char *tag, int id, const tt__Time *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Time), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Hour", -1, &(a->tt__Time::Hour), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Minute", -1, &(a->tt__Time::Minute), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Second", -1, &(a->tt__Time::Second), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Time::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Time(soap, tag, this, type);
}

SOAP_FMAC3 tt__Time * SOAP_FMAC4 soap_in_tt__Time(struct soap *soap, const char *tag, tt__Time *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Time *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Time, sizeof(tt__Time), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Time)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Time *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Hour1 = 1;
	size_t soap_flag_Minute1 = 1;
	size_t soap_flag_Second1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Hour1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Hour", &(a->tt__Time::Hour), "xsd:int"))
				{	soap_flag_Hour1--;
					continue;
				}
			if (soap_flag_Minute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Minute", &(a->tt__Time::Minute), "xsd:int"))
				{	soap_flag_Minute1--;
					continue;
				}
			if (soap_flag_Second1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Second", &(a->tt__Time::Second), "xsd:int"))
				{	soap_flag_Second1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Time *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Time, 0, sizeof(tt__Time), 0, soap_copy_tt__Time);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Hour1 > 0 || soap_flag_Minute1 > 0 || soap_flag_Second1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Time::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Time);
	if (this->soap_out(soap, tag?tag:"tt:Time", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Time::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Time(soap, this, tag, type);
}

SOAP_FMAC3 tt__Time * SOAP_FMAC4 soap_get_tt__Time(struct soap *soap, tt__Time *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Time * SOAP_FMAC2 soap_instantiate_tt__Time(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Time(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Time, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Time);
		if (size)
			*size = sizeof(tt__Time);
		((tt__Time*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Time[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Time);
		for (int i = 0; i < n; i++)
			((tt__Time*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Time*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Time(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Time %p -> %p\n", q, p));
	*(tt__Time*)p = *(tt__Time*)q;
}

void tt__Date::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tt__Date::Year);
	soap_default_int(soap, &this->tt__Date::Month);
	soap_default_int(soap, &this->tt__Date::Day);
	/* transient soap skipped */
}

void tt__Date::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__Date::Year, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__Date::Month, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__Date::Day, SOAP_TYPE_int);
	/* transient soap skipped */
}

int tt__Date::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Date(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Date(struct soap *soap, const char *tag, int id, const tt__Date *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Date), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Year", -1, &(a->tt__Date::Year), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Month", -1, &(a->tt__Date::Month), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Day", -1, &(a->tt__Date::Day), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Date::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Date(soap, tag, this, type);
}

SOAP_FMAC3 tt__Date * SOAP_FMAC4 soap_in_tt__Date(struct soap *soap, const char *tag, tt__Date *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Date *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Date, sizeof(tt__Date), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Date)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Date *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Year1 = 1;
	size_t soap_flag_Month1 = 1;
	size_t soap_flag_Day1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Year1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Year", &(a->tt__Date::Year), "xsd:int"))
				{	soap_flag_Year1--;
					continue;
				}
			if (soap_flag_Month1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Month", &(a->tt__Date::Month), "xsd:int"))
				{	soap_flag_Month1--;
					continue;
				}
			if (soap_flag_Day1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Day", &(a->tt__Date::Day), "xsd:int"))
				{	soap_flag_Day1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Date *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Date, 0, sizeof(tt__Date), 0, soap_copy_tt__Date);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Year1 > 0 || soap_flag_Month1 > 0 || soap_flag_Day1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Date::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Date);
	if (this->soap_out(soap, tag?tag:"tt:Date", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Date::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Date(soap, this, tag, type);
}

SOAP_FMAC3 tt__Date * SOAP_FMAC4 soap_get_tt__Date(struct soap *soap, tt__Date *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Date * SOAP_FMAC2 soap_instantiate_tt__Date(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Date(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Date, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Date);
		if (size)
			*size = sizeof(tt__Date);
		((tt__Date*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Date[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Date);
		for (int i = 0; i < n; i++)
			((tt__Date*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Date*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Date(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Date %p -> %p\n", q, p));
	*(tt__Date*)p = *(tt__Date*)q;
}

void tt__DateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__DateTime::Time = NULL;
	this->tt__DateTime::Date = NULL;
	/* transient soap skipped */
}

void tt__DateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Time(soap, &this->tt__DateTime::Time);
	soap_serialize_PointerTott__Date(soap, &this->tt__DateTime::Date);
	/* transient soap skipped */
}

int tt__DateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DateTime(struct soap *soap, const char *tag, int id, const tt__DateTime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DateTime), type))
		return soap->error;
	if (a->tt__DateTime::Time)
	{	if (soap_out_PointerTott__Time(soap, "tt:Time", -1, &a->tt__DateTime::Time, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Time"))
		return soap->error;
	if (a->tt__DateTime::Date)
	{	if (soap_out_PointerTott__Date(soap, "tt:Date", -1, &a->tt__DateTime::Date, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Date"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__DateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__DateTime(soap, tag, this, type);
}

SOAP_FMAC3 tt__DateTime * SOAP_FMAC4 soap_in_tt__DateTime(struct soap *soap, const char *tag, tt__DateTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DateTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DateTime, sizeof(tt__DateTime), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__DateTime)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__DateTime *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Time1 = 1;
	size_t soap_flag_Date1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Time1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Time(soap, "tt:Time", &(a->tt__DateTime::Time), "tt:Time"))
				{	soap_flag_Time1--;
					continue;
				}
			if (soap_flag_Date1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Date(soap, "tt:Date", &(a->tt__DateTime::Date), "tt:Date"))
				{	soap_flag_Date1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__DateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DateTime, 0, sizeof(tt__DateTime), 0, soap_copy_tt__DateTime);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Time1 > 0 || soap_flag_Date1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__DateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__DateTime);
	if (this->soap_out(soap, tag?tag:"tt:DateTime", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DateTime(soap, this, tag, type);
}

SOAP_FMAC3 tt__DateTime * SOAP_FMAC4 soap_get_tt__DateTime(struct soap *soap, tt__DateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__DateTime * SOAP_FMAC2 soap_instantiate_tt__DateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DateTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__DateTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__DateTime);
		if (size)
			*size = sizeof(tt__DateTime);
		((tt__DateTime*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__DateTime[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__DateTime);
		for (int i = 0; i < n; i++)
			((tt__DateTime*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__DateTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__DateTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__DateTime %p -> %p\n", q, p));
	*(tt__DateTime*)p = *(tt__DateTime*)q;
}

void tt__SystemDateTimeExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SystemDateTimeExtension::__any);
	/* transient soap skipped */
}

void tt__SystemDateTimeExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SystemDateTimeExtension::__any);
	/* transient soap skipped */
}

int tt__SystemDateTimeExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemDateTimeExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemDateTimeExtension(struct soap *soap, const char *tag, int id, const tt__SystemDateTimeExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemDateTimeExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__SystemDateTimeExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__SystemDateTimeExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__SystemDateTimeExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemDateTimeExtension * SOAP_FMAC4 soap_in_tt__SystemDateTimeExtension(struct soap *soap, const char *tag, tt__SystemDateTimeExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemDateTimeExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemDateTimeExtension, sizeof(tt__SystemDateTimeExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__SystemDateTimeExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__SystemDateTimeExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__SystemDateTimeExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SystemDateTimeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemDateTimeExtension, 0, sizeof(tt__SystemDateTimeExtension), 0, soap_copy_tt__SystemDateTimeExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__SystemDateTimeExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__SystemDateTimeExtension);
	if (this->soap_out(soap, tag?tag:"tt:SystemDateTimeExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemDateTimeExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemDateTimeExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemDateTimeExtension * SOAP_FMAC4 soap_get_tt__SystemDateTimeExtension(struct soap *soap, tt__SystemDateTimeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemDateTimeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__SystemDateTimeExtension * SOAP_FMAC2 soap_instantiate_tt__SystemDateTimeExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemDateTimeExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__SystemDateTimeExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__SystemDateTimeExtension);
		if (size)
			*size = sizeof(tt__SystemDateTimeExtension);
		((tt__SystemDateTimeExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__SystemDateTimeExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__SystemDateTimeExtension);
		for (int i = 0; i < n; i++)
			((tt__SystemDateTimeExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__SystemDateTimeExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__SystemDateTimeExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__SystemDateTimeExtension %p -> %p\n", q, p));
	*(tt__SystemDateTimeExtension*)p = *(tt__SystemDateTimeExtension*)q;
}

void tt__SystemDateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__SetDateTimeType(soap, &this->tt__SystemDateTime::DateTimeType);
	soap_default_bool(soap, &this->tt__SystemDateTime::DaylightSavings);
	this->tt__SystemDateTime::TimeZone = NULL;
	this->tt__SystemDateTime::UTCDateTime = NULL;
	this->tt__SystemDateTime::LocalDateTime = NULL;
	this->tt__SystemDateTime::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__SystemDateTime::__anyAttribute);
	/* transient soap skipped */
}

void tt__SystemDateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__SystemDateTime::DaylightSavings, SOAP_TYPE_bool);
	soap_serialize_PointerTott__TimeZone(soap, &this->tt__SystemDateTime::TimeZone);
	soap_serialize_PointerTott__DateTime(soap, &this->tt__SystemDateTime::UTCDateTime);
	soap_serialize_PointerTott__DateTime(soap, &this->tt__SystemDateTime::LocalDateTime);
	soap_serialize_PointerTott__SystemDateTimeExtension(soap, &this->tt__SystemDateTime::Extension);
	/* transient soap skipped */
}

int tt__SystemDateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemDateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemDateTime(struct soap *soap, const char *tag, int id, const tt__SystemDateTime *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__SystemDateTime*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemDateTime), type))
		return soap->error;
	if (soap_out_tt__SetDateTimeType(soap, "tt:DateTimeType", -1, &(a->tt__SystemDateTime::DateTimeType), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:DaylightSavings", -1, &(a->tt__SystemDateTime::DaylightSavings), ""))
		return soap->error;
	if (soap_out_PointerTott__TimeZone(soap, "tt:TimeZone", -1, &(a->tt__SystemDateTime::TimeZone), ""))
		return soap->error;
	if (soap_out_PointerTott__DateTime(soap, "tt:UTCDateTime", -1, &(a->tt__SystemDateTime::UTCDateTime), ""))
		return soap->error;
	if (soap_out_PointerTott__DateTime(soap, "tt:LocalDateTime", -1, &(a->tt__SystemDateTime::LocalDateTime), ""))
		return soap->error;
	if (soap_out_PointerTott__SystemDateTimeExtension(soap, "tt:Extension", -1, &(a->tt__SystemDateTime::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__SystemDateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__SystemDateTime(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemDateTime * SOAP_FMAC4 soap_in_tt__SystemDateTime(struct soap *soap, const char *tag, tt__SystemDateTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemDateTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemDateTime, sizeof(tt__SystemDateTime), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__SystemDateTime)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__SystemDateTime *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__SystemDateTime*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_DateTimeType1 = 1;
	size_t soap_flag_DaylightSavings1 = 1;
	size_t soap_flag_TimeZone1 = 1;
	size_t soap_flag_UTCDateTime1 = 1;
	size_t soap_flag_LocalDateTime1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DateTimeType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__SetDateTimeType(soap, "tt:DateTimeType", &(a->tt__SystemDateTime::DateTimeType), "tt:SetDateTimeType"))
				{	soap_flag_DateTimeType1--;
					continue;
				}
			if (soap_flag_DaylightSavings1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:DaylightSavings", &(a->tt__SystemDateTime::DaylightSavings), "xsd:boolean"))
				{	soap_flag_DaylightSavings1--;
					continue;
				}
			if (soap_flag_TimeZone1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__TimeZone(soap, "tt:TimeZone", &(a->tt__SystemDateTime::TimeZone), "tt:TimeZone"))
				{	soap_flag_TimeZone1--;
					continue;
				}
			if (soap_flag_UTCDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DateTime(soap, "tt:UTCDateTime", &(a->tt__SystemDateTime::UTCDateTime), "tt:DateTime"))
				{	soap_flag_UTCDateTime1--;
					continue;
				}
			if (soap_flag_LocalDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DateTime(soap, "tt:LocalDateTime", &(a->tt__SystemDateTime::LocalDateTime), "tt:DateTime"))
				{	soap_flag_LocalDateTime1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SystemDateTimeExtension(soap, "tt:Extension", &(a->tt__SystemDateTime::Extension), "tt:SystemDateTimeExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SystemDateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemDateTime, 0, sizeof(tt__SystemDateTime), 0, soap_copy_tt__SystemDateTime);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DateTimeType1 > 0 || soap_flag_DaylightSavings1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__SystemDateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__SystemDateTime);
	if (this->soap_out(soap, tag?tag:"tt:SystemDateTime", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemDateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemDateTime(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemDateTime * SOAP_FMAC4 soap_get_tt__SystemDateTime(struct soap *soap, tt__SystemDateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemDateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__SystemDateTime * SOAP_FMAC2 soap_instantiate_tt__SystemDateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemDateTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__SystemDateTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__SystemDateTime);
		if (size)
			*size = sizeof(tt__SystemDateTime);
		((tt__SystemDateTime*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__SystemDateTime[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__SystemDateTime);
		for (int i = 0; i < n; i++)
			((tt__SystemDateTime*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__SystemDateTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__SystemDateTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__SystemDateTime %p -> %p\n", q, p));
	*(tt__SystemDateTime*)p = *(tt__SystemDateTime*)q;
}

void tt__BackupFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->tt__BackupFile::Name);
	this->tt__BackupFile::Data = NULL;
	/* transient soap skipped */
}

void tt__BackupFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__BackupFile::Name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__BackupFile::Name);
	soap_serialize_PointerTott__AttachmentData(soap, &this->tt__BackupFile::Data);
	/* transient soap skipped */
}

int tt__BackupFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BackupFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BackupFile(struct soap *soap, const char *tag, int id, const tt__BackupFile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BackupFile), type))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Name", -1, &(a->tt__BackupFile::Name), ""))
		return soap->error;
	if (a->tt__BackupFile::Data)
	{	if (soap_out_PointerTott__AttachmentData(soap, "tt:Data", -1, &a->tt__BackupFile::Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Data"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__BackupFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__BackupFile(soap, tag, this, type);
}

SOAP_FMAC3 tt__BackupFile * SOAP_FMAC4 soap_in_tt__BackupFile(struct soap *soap, const char *tag, tt__BackupFile *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__BackupFile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BackupFile, sizeof(tt__BackupFile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__BackupFile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__BackupFile *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "tt:Name", &(a->tt__BackupFile::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AttachmentData(soap, "tt:Data", &(a->tt__BackupFile::Data), "tt:AttachmentData"))
				{	soap_flag_Data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__BackupFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BackupFile, 0, sizeof(tt__BackupFile), 0, soap_copy_tt__BackupFile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || soap_flag_Data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__BackupFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__BackupFile);
	if (this->soap_out(soap, tag?tag:"tt:BackupFile", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BackupFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BackupFile(soap, this, tag, type);
}

SOAP_FMAC3 tt__BackupFile * SOAP_FMAC4 soap_get_tt__BackupFile(struct soap *soap, tt__BackupFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BackupFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__BackupFile * SOAP_FMAC2 soap_instantiate_tt__BackupFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__BackupFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__BackupFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__BackupFile);
		if (size)
			*size = sizeof(tt__BackupFile);
		((tt__BackupFile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__BackupFile[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__BackupFile);
		for (int i = 0; i < n; i++)
			((tt__BackupFile*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__BackupFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__BackupFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__BackupFile %p -> %p\n", q, p));
	*(tt__BackupFile*)p = *(tt__BackupFile*)q;
}

void tt__AttachmentData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__xop__Include(soap, &this->tt__AttachmentData::xop__Include);
	soap_default_string(soap, &this->tt__AttachmentData::xmime__contentType);
	/* transient soap skipped */
}

void tt__AttachmentData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__xop__Include(soap, &this->tt__AttachmentData::xop__Include);
	/* transient soap skipped */
}

int tt__AttachmentData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AttachmentData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AttachmentData(struct soap *soap, const char *tag, int id, const tt__AttachmentData *a, const char *type)
{
	if (((tt__AttachmentData*)a)->xmime__contentType)
		soap_set_attr(soap, "xmime:contentType", ((tt__AttachmentData*)a)->xmime__contentType, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AttachmentData), type))
		return soap->error;
	if (soap_out__xop__Include(soap, "xop:Include", -1, &(a->tt__AttachmentData::xop__Include), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__AttachmentData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__AttachmentData(soap, tag, this, type);
}

SOAP_FMAC3 tt__AttachmentData * SOAP_FMAC4 soap_in_tt__AttachmentData(struct soap *soap, const char *tag, tt__AttachmentData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AttachmentData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AttachmentData, sizeof(tt__AttachmentData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__AttachmentData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__AttachmentData *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "xmime:contentType", 0), &((tt__AttachmentData*)a)->xmime__contentType, -1, -1))
		return NULL;
	size_t soap_flag_xop__Include1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xop__Include1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__xop__Include(soap, "xop:Include", &(a->tt__AttachmentData::xop__Include), ""))
				{	soap_flag_xop__Include1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AttachmentData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AttachmentData, 0, sizeof(tt__AttachmentData), 0, soap_copy_tt__AttachmentData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_xop__Include1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__AttachmentData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__AttachmentData);
	if (this->soap_out(soap, tag?tag:"tt:AttachmentData", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AttachmentData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AttachmentData(soap, this, tag, type);
}

SOAP_FMAC3 tt__AttachmentData * SOAP_FMAC4 soap_get_tt__AttachmentData(struct soap *soap, tt__AttachmentData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AttachmentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__AttachmentData * SOAP_FMAC2 soap_instantiate_tt__AttachmentData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AttachmentData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__AttachmentData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__AttachmentData);
		if (size)
			*size = sizeof(tt__AttachmentData);
		((tt__AttachmentData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__AttachmentData[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__AttachmentData);
		for (int i = 0; i < n; i++)
			((tt__AttachmentData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__AttachmentData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__AttachmentData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__AttachmentData %p -> %p\n", q, p));
	*(tt__AttachmentData*)p = *(tt__AttachmentData*)q;
}

void tt__BinaryData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__BinaryData::Data.xsd__base64Binary::soap_default(soap);
	soap_default_string(soap, &this->tt__BinaryData::xmime__contentType);
	/* transient soap skipped */
}

void tt__BinaryData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	this->tt__BinaryData::Data.soap_serialize(soap);
	/* transient soap skipped */
}

int tt__BinaryData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BinaryData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BinaryData(struct soap *soap, const char *tag, int id, const tt__BinaryData *a, const char *type)
{
	if (((tt__BinaryData*)a)->xmime__contentType)
		soap_set_attr(soap, "xmime:contentType", ((tt__BinaryData*)a)->xmime__contentType, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BinaryData), type))
		return soap->error;
	if ((a->tt__BinaryData::Data).soap_out(soap, "tt:Data", -1, ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__BinaryData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__BinaryData(soap, tag, this, type);
}

SOAP_FMAC3 tt__BinaryData * SOAP_FMAC4 soap_in_tt__BinaryData(struct soap *soap, const char *tag, tt__BinaryData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__BinaryData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BinaryData, sizeof(tt__BinaryData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__BinaryData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__BinaryData *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "xmime:contentType", 0), &((tt__BinaryData*)a)->xmime__contentType, -1, -1))
		return NULL;
	size_t soap_flag_Data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->tt__BinaryData::Data).soap_in(soap, "tt:Data", "xsd:base64Binary"))
				{	soap_flag_Data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__BinaryData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BinaryData, 0, sizeof(tt__BinaryData), 0, soap_copy_tt__BinaryData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__BinaryData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__BinaryData);
	if (this->soap_out(soap, tag?tag:"tt:BinaryData", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BinaryData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BinaryData(soap, this, tag, type);
}

SOAP_FMAC3 tt__BinaryData * SOAP_FMAC4 soap_get_tt__BinaryData(struct soap *soap, tt__BinaryData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BinaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__BinaryData * SOAP_FMAC2 soap_instantiate_tt__BinaryData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__BinaryData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__BinaryData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__BinaryData);
		if (size)
			*size = sizeof(tt__BinaryData);
		((tt__BinaryData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__BinaryData[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__BinaryData);
		for (int i = 0; i < n; i++)
			((tt__BinaryData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__BinaryData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__BinaryData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__BinaryData %p -> %p\n", q, p));
	*(tt__BinaryData*)p = *(tt__BinaryData*)q;
}

void tt__SupportInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__SupportInformation::Binary = NULL;
	this->tt__SupportInformation::String = NULL;
	/* transient soap skipped */
}

void tt__SupportInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AttachmentData(soap, &this->tt__SupportInformation::Binary);
	soap_serialize_PointerTostd__string(soap, &this->tt__SupportInformation::String);
	/* transient soap skipped */
}

int tt__SupportInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SupportInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportInformation(struct soap *soap, const char *tag, int id, const tt__SupportInformation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportInformation), type))
		return soap->error;
	if (soap_out_PointerTott__AttachmentData(soap, "tt:Binary", -1, &(a->tt__SupportInformation::Binary), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:String", -1, &(a->tt__SupportInformation::String), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__SupportInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__SupportInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__SupportInformation * SOAP_FMAC4 soap_in_tt__SupportInformation(struct soap *soap, const char *tag, tt__SupportInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SupportInformation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportInformation, sizeof(tt__SupportInformation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__SupportInformation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__SupportInformation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Binary1 = 1;
	size_t soap_flag_String1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Binary1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AttachmentData(soap, "tt:Binary", &(a->tt__SupportInformation::Binary), "tt:AttachmentData"))
				{	soap_flag_Binary1--;
					continue;
				}
			if (soap_flag_String1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "tt:String", &(a->tt__SupportInformation::String), "xsd:string"))
				{	soap_flag_String1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SupportInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportInformation, 0, sizeof(tt__SupportInformation), 0, soap_copy_tt__SupportInformation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__SupportInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__SupportInformation);
	if (this->soap_out(soap, tag?tag:"tt:SupportInformation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SupportInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SupportInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__SupportInformation * SOAP_FMAC4 soap_get_tt__SupportInformation(struct soap *soap, tt__SupportInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__SupportInformation * SOAP_FMAC2 soap_instantiate_tt__SupportInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SupportInformation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__SupportInformation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__SupportInformation);
		if (size)
			*size = sizeof(tt__SupportInformation);
		((tt__SupportInformation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__SupportInformation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__SupportInformation);
		for (int i = 0; i < n; i++)
			((tt__SupportInformation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__SupportInformation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__SupportInformation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__SupportInformation %p -> %p\n", q, p));
	*(tt__SupportInformation*)p = *(tt__SupportInformation*)q;
}

void tt__SystemLog::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__SystemLog::Binary = NULL;
	this->tt__SystemLog::String = NULL;
	/* transient soap skipped */
}

void tt__SystemLog::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AttachmentData(soap, &this->tt__SystemLog::Binary);
	soap_serialize_PointerTostd__string(soap, &this->tt__SystemLog::String);
	/* transient soap skipped */
}

int tt__SystemLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLog(struct soap *soap, const char *tag, int id, const tt__SystemLog *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLog), type))
		return soap->error;
	if (soap_out_PointerTott__AttachmentData(soap, "tt:Binary", -1, &(a->tt__SystemLog::Binary), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:String", -1, &(a->tt__SystemLog::String), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__SystemLog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__SystemLog(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemLog * SOAP_FMAC4 soap_in_tt__SystemLog(struct soap *soap, const char *tag, tt__SystemLog *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemLog *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLog, sizeof(tt__SystemLog), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__SystemLog)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__SystemLog *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Binary1 = 1;
	size_t soap_flag_String1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Binary1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AttachmentData(soap, "tt:Binary", &(a->tt__SystemLog::Binary), "tt:AttachmentData"))
				{	soap_flag_Binary1--;
					continue;
				}
			if (soap_flag_String1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "tt:String", &(a->tt__SystemLog::String), "xsd:string"))
				{	soap_flag_String1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SystemLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLog, 0, sizeof(tt__SystemLog), 0, soap_copy_tt__SystemLog);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__SystemLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__SystemLog);
	if (this->soap_out(soap, tag?tag:"tt:SystemLog", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemLog(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemLog * SOAP_FMAC4 soap_get_tt__SystemLog(struct soap *soap, tt__SystemLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__SystemLog * SOAP_FMAC2 soap_instantiate_tt__SystemLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__SystemLog, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__SystemLog);
		if (size)
			*size = sizeof(tt__SystemLog);
		((tt__SystemLog*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__SystemLog[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__SystemLog);
		for (int i = 0; i < n; i++)
			((tt__SystemLog*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__SystemLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__SystemLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__SystemLog %p -> %p\n", q, p));
	*(tt__SystemLog*)p = *(tt__SystemLog*)q;
}

void tt__PTZCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__PTZCapabilities::XAddr);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZCapabilities::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZCapabilities::__anyAttribute);
	/* transient soap skipped */
}

void tt__PTZCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__PTZCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__PTZCapabilities::XAddr);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZCapabilities::__any);
	/* transient soap skipped */
}

int tt__PTZCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZCapabilities(struct soap *soap, const char *tag, int id, const tt__PTZCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &(a->tt__PTZCapabilities::XAddr), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__PTZCapabilities::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__PTZCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__PTZCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZCapabilities * SOAP_FMAC4 soap_in_tt__PTZCapabilities(struct soap *soap, const char *tag, tt__PTZCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZCapabilities *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZCapabilities, sizeof(tt__PTZCapabilities), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__PTZCapabilities)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__PTZCapabilities *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_XAddr1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:XAddr", &(a->tt__PTZCapabilities::XAddr), "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__PTZCapabilities::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZCapabilities, 0, sizeof(tt__PTZCapabilities), 0, soap_copy_tt__PTZCapabilities);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__PTZCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__PTZCapabilities);
	if (this->soap_out(soap, tag?tag:"tt:PTZCapabilities", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZCapabilities * SOAP_FMAC4 soap_get_tt__PTZCapabilities(struct soap *soap, tt__PTZCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__PTZCapabilities * SOAP_FMAC2 soap_instantiate_tt__PTZCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZCapabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__PTZCapabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZCapabilities);
		if (size)
			*size = sizeof(tt__PTZCapabilities);
		((tt__PTZCapabilities*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZCapabilities[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__PTZCapabilities);
		for (int i = 0; i < n; i++)
			((tt__PTZCapabilities*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__PTZCapabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__PTZCapabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__PTZCapabilities %p -> %p\n", q, p));
	*(tt__PTZCapabilities*)p = *(tt__PTZCapabilities*)q;
}

void tt__ImagingCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__ImagingCapabilities::XAddr);
	soap_default_xsd__anyAttribute(soap, &this->tt__ImagingCapabilities::__anyAttribute);
	/* transient soap skipped */
}

void tt__ImagingCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__ImagingCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__ImagingCapabilities::XAddr);
	/* transient soap skipped */
}

int tt__ImagingCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingCapabilities(struct soap *soap, const char *tag, int id, const tt__ImagingCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ImagingCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &(a->tt__ImagingCapabilities::XAddr), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ImagingCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingCapabilities * SOAP_FMAC4 soap_in_tt__ImagingCapabilities(struct soap *soap, const char *tag, tt__ImagingCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingCapabilities *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingCapabilities, sizeof(tt__ImagingCapabilities), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ImagingCapabilities)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ImagingCapabilities *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ImagingCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_XAddr1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:XAddr", &(a->tt__ImagingCapabilities::XAddr), "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingCapabilities, 0, sizeof(tt__ImagingCapabilities), 0, soap_copy_tt__ImagingCapabilities);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__ImagingCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ImagingCapabilities);
	if (this->soap_out(soap, tag?tag:"tt:ImagingCapabilities", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingCapabilities * SOAP_FMAC4 soap_get_tt__ImagingCapabilities(struct soap *soap, tt__ImagingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ImagingCapabilities * SOAP_FMAC2 soap_instantiate_tt__ImagingCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingCapabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ImagingCapabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ImagingCapabilities);
		if (size)
			*size = sizeof(tt__ImagingCapabilities);
		((tt__ImagingCapabilities*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ImagingCapabilities[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ImagingCapabilities);
		for (int i = 0; i < n; i++)
			((tt__ImagingCapabilities*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ImagingCapabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ImagingCapabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ImagingCapabilities %p -> %p\n", q, p));
	*(tt__ImagingCapabilities*)p = *(tt__ImagingCapabilities*)q;
}

void tt__OnvifVersion::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tt__OnvifVersion::Major);
	soap_default_int(soap, &this->tt__OnvifVersion::Minor);
	/* transient soap skipped */
}

void tt__OnvifVersion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__OnvifVersion::Major, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__OnvifVersion::Minor, SOAP_TYPE_int);
	/* transient soap skipped */
}

int tt__OnvifVersion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OnvifVersion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OnvifVersion(struct soap *soap, const char *tag, int id, const tt__OnvifVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OnvifVersion), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Major", -1, &(a->tt__OnvifVersion::Major), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Minor", -1, &(a->tt__OnvifVersion::Minor), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__OnvifVersion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__OnvifVersion(soap, tag, this, type);
}

SOAP_FMAC3 tt__OnvifVersion * SOAP_FMAC4 soap_in_tt__OnvifVersion(struct soap *soap, const char *tag, tt__OnvifVersion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OnvifVersion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OnvifVersion, sizeof(tt__OnvifVersion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__OnvifVersion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__OnvifVersion *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Major1 = 1;
	size_t soap_flag_Minor1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Major1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Major", &(a->tt__OnvifVersion::Major), "xsd:int"))
				{	soap_flag_Major1--;
					continue;
				}
			if (soap_flag_Minor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Minor", &(a->tt__OnvifVersion::Minor), "xsd:int"))
				{	soap_flag_Minor1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__OnvifVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OnvifVersion, 0, sizeof(tt__OnvifVersion), 0, soap_copy_tt__OnvifVersion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Major1 > 0 || soap_flag_Minor1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__OnvifVersion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__OnvifVersion);
	if (this->soap_out(soap, tag?tag:"tt:OnvifVersion", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OnvifVersion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OnvifVersion(soap, this, tag, type);
}

SOAP_FMAC3 tt__OnvifVersion * SOAP_FMAC4 soap_get_tt__OnvifVersion(struct soap *soap, tt__OnvifVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OnvifVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__OnvifVersion * SOAP_FMAC2 soap_instantiate_tt__OnvifVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OnvifVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__OnvifVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__OnvifVersion);
		if (size)
			*size = sizeof(tt__OnvifVersion);
		((tt__OnvifVersion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__OnvifVersion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__OnvifVersion);
		for (int i = 0; i < n; i++)
			((tt__OnvifVersion*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__OnvifVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__OnvifVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__OnvifVersion %p -> %p\n", q, p));
	*(tt__OnvifVersion*)p = *(tt__OnvifVersion*)q;
}

void tt__SystemCapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SystemCapabilitiesExtension::__any);
	/* transient soap skipped */
}

void tt__SystemCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SystemCapabilitiesExtension::__any);
	/* transient soap skipped */
}

int tt__SystemCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__SystemCapabilitiesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__SystemCapabilitiesExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__SystemCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__SystemCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__SystemCapabilitiesExtension(struct soap *soap, const char *tag, tt__SystemCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemCapabilitiesExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension, sizeof(tt__SystemCapabilitiesExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__SystemCapabilitiesExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__SystemCapabilitiesExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__SystemCapabilitiesExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SystemCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilitiesExtension, 0, sizeof(tt__SystemCapabilitiesExtension), 0, soap_copy_tt__SystemCapabilitiesExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__SystemCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__SystemCapabilitiesExtension);
	if (this->soap_out(soap, tag?tag:"tt:SystemCapabilitiesExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__SystemCapabilitiesExtension(struct soap *soap, tt__SystemCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__SystemCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemCapabilitiesExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__SystemCapabilitiesExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__SystemCapabilitiesExtension);
		if (size)
			*size = sizeof(tt__SystemCapabilitiesExtension);
		((tt__SystemCapabilitiesExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__SystemCapabilitiesExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__SystemCapabilitiesExtension);
		for (int i = 0; i < n; i++)
			((tt__SystemCapabilitiesExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__SystemCapabilitiesExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__SystemCapabilitiesExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__SystemCapabilitiesExtension %p -> %p\n", q, p));
	*(tt__SystemCapabilitiesExtension*)p = *(tt__SystemCapabilitiesExtension*)q;
}

void tt__SystemCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__SystemCapabilities::DiscoveryResolve);
	soap_default_bool(soap, &this->tt__SystemCapabilities::DiscoveryBye);
	soap_default_bool(soap, &this->tt__SystemCapabilities::RemoteDiscovery);
	soap_default_bool(soap, &this->tt__SystemCapabilities::SystemBackup);
	soap_default_bool(soap, &this->tt__SystemCapabilities::SystemLogging);
	soap_default_bool(soap, &this->tt__SystemCapabilities::FirmwareUpgrade);
	soap_default_std__vectorTemplateOfPointerTott__OnvifVersion(soap, &this->tt__SystemCapabilities::SupportedVersions);
	this->tt__SystemCapabilities::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__SystemCapabilities::__anyAttribute);
	/* transient soap skipped */
}

void tt__SystemCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__SystemCapabilities::DiscoveryResolve, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SystemCapabilities::DiscoveryBye, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SystemCapabilities::RemoteDiscovery, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SystemCapabilities::SystemBackup, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SystemCapabilities::SystemLogging, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SystemCapabilities::FirmwareUpgrade, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfPointerTott__OnvifVersion(soap, &this->tt__SystemCapabilities::SupportedVersions);
	soap_serialize_PointerTott__SystemCapabilitiesExtension(soap, &this->tt__SystemCapabilities::Extension);
	/* transient soap skipped */
}

int tt__SystemCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilities(struct soap *soap, const char *tag, int id, const tt__SystemCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__SystemCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemCapabilities), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:DiscoveryResolve", -1, &(a->tt__SystemCapabilities::DiscoveryResolve), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:DiscoveryBye", -1, &(a->tt__SystemCapabilities::DiscoveryBye), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RemoteDiscovery", -1, &(a->tt__SystemCapabilities::RemoteDiscovery), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:SystemBackup", -1, &(a->tt__SystemCapabilities::SystemBackup), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:SystemLogging", -1, &(a->tt__SystemCapabilities::SystemLogging), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:FirmwareUpgrade", -1, &(a->tt__SystemCapabilities::FirmwareUpgrade), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__OnvifVersion(soap, "tt:SupportedVersions", -1, &(a->tt__SystemCapabilities::SupportedVersions), ""))
		return soap->error;
	if (soap_out_PointerTott__SystemCapabilitiesExtension(soap, "tt:Extension", -1, &(a->tt__SystemCapabilities::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__SystemCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__SystemCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemCapabilities * SOAP_FMAC4 soap_in_tt__SystemCapabilities(struct soap *soap, const char *tag, tt__SystemCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemCapabilities *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilities, sizeof(tt__SystemCapabilities), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__SystemCapabilities)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__SystemCapabilities *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__SystemCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_DiscoveryResolve1 = 1;
	size_t soap_flag_DiscoveryBye1 = 1;
	size_t soap_flag_RemoteDiscovery1 = 1;
	size_t soap_flag_SystemBackup1 = 1;
	size_t soap_flag_SystemLogging1 = 1;
	size_t soap_flag_FirmwareUpgrade1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiscoveryResolve1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:DiscoveryResolve", &(a->tt__SystemCapabilities::DiscoveryResolve), "xsd:boolean"))
				{	soap_flag_DiscoveryResolve1--;
					continue;
				}
			if (soap_flag_DiscoveryBye1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:DiscoveryBye", &(a->tt__SystemCapabilities::DiscoveryBye), "xsd:boolean"))
				{	soap_flag_DiscoveryBye1--;
					continue;
				}
			if (soap_flag_RemoteDiscovery1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:RemoteDiscovery", &(a->tt__SystemCapabilities::RemoteDiscovery), "xsd:boolean"))
				{	soap_flag_RemoteDiscovery1--;
					continue;
				}
			if (soap_flag_SystemBackup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:SystemBackup", &(a->tt__SystemCapabilities::SystemBackup), "xsd:boolean"))
				{	soap_flag_SystemBackup1--;
					continue;
				}
			if (soap_flag_SystemLogging1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:SystemLogging", &(a->tt__SystemCapabilities::SystemLogging), "xsd:boolean"))
				{	soap_flag_SystemLogging1--;
					continue;
				}
			if (soap_flag_FirmwareUpgrade1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:FirmwareUpgrade", &(a->tt__SystemCapabilities::FirmwareUpgrade), "xsd:boolean"))
				{	soap_flag_FirmwareUpgrade1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__OnvifVersion(soap, "tt:SupportedVersions", &(a->tt__SystemCapabilities::SupportedVersions), "tt:OnvifVersion"))
					continue;
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SystemCapabilitiesExtension(soap, "tt:Extension", &(a->tt__SystemCapabilities::Extension), "tt:SystemCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SystemCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilities, 0, sizeof(tt__SystemCapabilities), 0, soap_copy_tt__SystemCapabilities);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DiscoveryResolve1 > 0 || soap_flag_DiscoveryBye1 > 0 || soap_flag_RemoteDiscovery1 > 0 || soap_flag_SystemBackup1 > 0 || soap_flag_SystemLogging1 > 0 || soap_flag_FirmwareUpgrade1 > 0 || a->tt__SystemCapabilities::SupportedVersions.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__SystemCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__SystemCapabilities);
	if (this->soap_out(soap, tag?tag:"tt:SystemCapabilities", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemCapabilities * SOAP_FMAC4 soap_get_tt__SystemCapabilities(struct soap *soap, tt__SystemCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__SystemCapabilities * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemCapabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__SystemCapabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__SystemCapabilities);
		if (size)
			*size = sizeof(tt__SystemCapabilities);
		((tt__SystemCapabilities*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__SystemCapabilities[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__SystemCapabilities);
		for (int i = 0; i < n; i++)
			((tt__SystemCapabilities*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__SystemCapabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__SystemCapabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__SystemCapabilities %p -> %p\n", q, p));
	*(tt__SystemCapabilities*)p = *(tt__SystemCapabilities*)q;
}

void tt__StorageCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__StorageCapabilities::XAddr);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__StorageCapabilities::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__StorageCapabilities::__anyAttribute);
	/* transient soap skipped */
}

void tt__StorageCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__StorageCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__StorageCapabilities::XAddr);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__StorageCapabilities::__any);
	/* transient soap skipped */
}

int tt__StorageCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__StorageCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StorageCapabilities(struct soap *soap, const char *tag, int id, const tt__StorageCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__StorageCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__StorageCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &(a->tt__StorageCapabilities::XAddr), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__StorageCapabilities::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__StorageCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__StorageCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__StorageCapabilities * SOAP_FMAC4 soap_in_tt__StorageCapabilities(struct soap *soap, const char *tag, tt__StorageCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__StorageCapabilities *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StorageCapabilities, sizeof(tt__StorageCapabilities), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__StorageCapabilities)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__StorageCapabilities *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__StorageCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_XAddr1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:XAddr", &(a->tt__StorageCapabilities::XAddr), "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__StorageCapabilities::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__StorageCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__StorageCapabilities, 0, sizeof(tt__StorageCapabilities), 0, soap_copy_tt__StorageCapabilities);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__StorageCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__StorageCapabilities);
	if (this->soap_out(soap, tag?tag:"tt:StorageCapabilities", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__StorageCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__StorageCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__StorageCapabilities * SOAP_FMAC4 soap_get_tt__StorageCapabilities(struct soap *soap, tt__StorageCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StorageCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__StorageCapabilities * SOAP_FMAC2 soap_instantiate_tt__StorageCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__StorageCapabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__StorageCapabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__StorageCapabilities);
		if (size)
			*size = sizeof(tt__StorageCapabilities);
		((tt__StorageCapabilities*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__StorageCapabilities[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__StorageCapabilities);
		for (int i = 0; i < n; i++)
			((tt__StorageCapabilities*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__StorageCapabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__StorageCapabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__StorageCapabilities %p -> %p\n", q, p));
	*(tt__StorageCapabilities*)p = *(tt__StorageCapabilities*)q;
}

void tt__SecurityCapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__SecurityCapabilitiesExtension::TLS1_x002e0);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SecurityCapabilitiesExtension::__any);
	/* transient soap skipped */
}

void tt__SecurityCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__SecurityCapabilitiesExtension::TLS1_x002e0, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SecurityCapabilitiesExtension::__any);
	/* transient soap skipped */
}

int tt__SecurityCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SecurityCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__SecurityCapabilitiesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:TLS1.0", -1, &(a->tt__SecurityCapabilitiesExtension::TLS1_x002e0), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__SecurityCapabilitiesExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__SecurityCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__SecurityCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, tt__SecurityCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SecurityCapabilitiesExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension, sizeof(tt__SecurityCapabilitiesExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__SecurityCapabilitiesExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__SecurityCapabilitiesExtension *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TLS1_x002e01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLS1_x002e01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:TLS1.0", &(a->tt__SecurityCapabilitiesExtension::TLS1_x002e0), "xsd:boolean"))
				{	soap_flag_TLS1_x002e01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__SecurityCapabilitiesExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SecurityCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilitiesExtension, 0, sizeof(tt__SecurityCapabilitiesExtension), 0, soap_copy_tt__SecurityCapabilitiesExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TLS1_x002e01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__SecurityCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__SecurityCapabilitiesExtension);
	if (this->soap_out(soap, tag?tag:"tt:SecurityCapabilitiesExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SecurityCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SecurityCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__SecurityCapabilitiesExtension(struct soap *soap, tt__SecurityCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SecurityCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__SecurityCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SecurityCapabilitiesExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__SecurityCapabilitiesExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__SecurityCapabilitiesExtension);
		if (size)
			*size = sizeof(tt__SecurityCapabilitiesExtension);
		((tt__SecurityCapabilitiesExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__SecurityCapabilitiesExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__SecurityCapabilitiesExtension);
		for (int i = 0; i < n; i++)
			((tt__SecurityCapabilitiesExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__SecurityCapabilitiesExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__SecurityCapabilitiesExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__SecurityCapabilitiesExtension %p -> %p\n", q, p));
	*(tt__SecurityCapabilitiesExtension*)p = *(tt__SecurityCapabilitiesExtension*)q;
}

void tt__SecurityCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__SecurityCapabilities::TLS1_x002e1);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::TLS1_x002e2);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::OnboardKeyGeneration);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::AccessPolicyConfig);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::X_x002e509Token);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::SAMLToken);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::KerberosToken);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::RELToken);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SecurityCapabilities::__any);
	this->tt__SecurityCapabilities::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__SecurityCapabilities::__anyAttribute);
	/* transient soap skipped */
}

void tt__SecurityCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__SecurityCapabilities::TLS1_x002e1, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::TLS1_x002e2, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::OnboardKeyGeneration, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::AccessPolicyConfig, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::X_x002e509Token, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::SAMLToken, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::KerberosToken, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::RELToken, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__SecurityCapabilities::__any);
	soap_serialize_PointerTott__SecurityCapabilitiesExtension(soap, &this->tt__SecurityCapabilities::Extension);
	/* transient soap skipped */
}

int tt__SecurityCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SecurityCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SecurityCapabilities(struct soap *soap, const char *tag, int id, const tt__SecurityCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__SecurityCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SecurityCapabilities), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:TLS1.1", -1, &(a->tt__SecurityCapabilities::TLS1_x002e1), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:TLS1.2", -1, &(a->tt__SecurityCapabilities::TLS1_x002e2), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:OnboardKeyGeneration", -1, &(a->tt__SecurityCapabilities::OnboardKeyGeneration), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:AccessPolicyConfig", -1, &(a->tt__SecurityCapabilities::AccessPolicyConfig), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:X.509Token", -1, &(a->tt__SecurityCapabilities::X_x002e509Token), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:SAMLToken", -1, &(a->tt__SecurityCapabilities::SAMLToken), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:KerberosToken", -1, &(a->tt__SecurityCapabilities::KerberosToken), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RELToken", -1, &(a->tt__SecurityCapabilities::RELToken), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__SecurityCapabilities::__any), ""))
		return soap->error;
	if (soap_out_PointerTott__SecurityCapabilitiesExtension(soap, "tt:Extension", -1, &(a->tt__SecurityCapabilities::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__SecurityCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__SecurityCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__SecurityCapabilities * SOAP_FMAC4 soap_in_tt__SecurityCapabilities(struct soap *soap, const char *tag, tt__SecurityCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SecurityCapabilities *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilities, sizeof(tt__SecurityCapabilities), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__SecurityCapabilities)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__SecurityCapabilities *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__SecurityCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_TLS1_x002e11 = 1;
	size_t soap_flag_TLS1_x002e21 = 1;
	size_t soap_flag_OnboardKeyGeneration1 = 1;
	size_t soap_flag_AccessPolicyConfig1 = 1;
	size_t soap_flag_X_x002e509Token1 = 1;
	size_t soap_flag_SAMLToken1 = 1;
	size_t soap_flag_KerberosToken1 = 1;
	size_t soap_flag_RELToken1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLS1_x002e11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:TLS1.1", &(a->tt__SecurityCapabilities::TLS1_x002e1), "xsd:boolean"))
				{	soap_flag_TLS1_x002e11--;
					continue;
				}
			if (soap_flag_TLS1_x002e21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:TLS1.2", &(a->tt__SecurityCapabilities::TLS1_x002e2), "xsd:boolean"))
				{	soap_flag_TLS1_x002e21--;
					continue;
				}
			if (soap_flag_OnboardKeyGeneration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:OnboardKeyGeneration", &(a->tt__SecurityCapabilities::OnboardKeyGeneration), "xsd:boolean"))
				{	soap_flag_OnboardKeyGeneration1--;
					continue;
				}
			if (soap_flag_AccessPolicyConfig1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:AccessPolicyConfig", &(a->tt__SecurityCapabilities::AccessPolicyConfig), "xsd:boolean"))
				{	soap_flag_AccessPolicyConfig1--;
					continue;
				}
			if (soap_flag_X_x002e509Token1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:X.509Token", &(a->tt__SecurityCapabilities::X_x002e509Token), "xsd:boolean"))
				{	soap_flag_X_x002e509Token1--;
					continue;
				}
			if (soap_flag_SAMLToken1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:SAMLToken", &(a->tt__SecurityCapabilities::SAMLToken), "xsd:boolean"))
				{	soap_flag_SAMLToken1--;
					continue;
				}
			if (soap_flag_KerberosToken1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:KerberosToken", &(a->tt__SecurityCapabilities::KerberosToken), "xsd:boolean"))
				{	soap_flag_KerberosToken1--;
					continue;
				}
			if (soap_flag_RELToken1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:RELToken", &(a->tt__SecurityCapabilities::RELToken), "xsd:boolean"))
				{	soap_flag_RELToken1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SecurityCapabilitiesExtension(soap, "tt:Extension", &(a->tt__SecurityCapabilities::Extension), "tt:SecurityCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__SecurityCapabilities::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SecurityCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilities, 0, sizeof(tt__SecurityCapabilities), 0, soap_copy_tt__SecurityCapabilities);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TLS1_x002e11 > 0 || soap_flag_TLS1_x002e21 > 0 || soap_flag_OnboardKeyGeneration1 > 0 || soap_flag_AccessPolicyConfig1 > 0 || soap_flag_X_x002e509Token1 > 0 || soap_flag_SAMLToken1 > 0 || soap_flag_KerberosToken1 > 0 || soap_flag_RELToken1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__SecurityCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__SecurityCapabilities);
	if (this->soap_out(soap, tag?tag:"tt:SecurityCapabilities", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SecurityCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SecurityCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__SecurityCapabilities * SOAP_FMAC4 soap_get_tt__SecurityCapabilities(struct soap *soap, tt__SecurityCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__SecurityCapabilities * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SecurityCapabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__SecurityCapabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__SecurityCapabilities);
		if (size)
			*size = sizeof(tt__SecurityCapabilities);
		((tt__SecurityCapabilities*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__SecurityCapabilities[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__SecurityCapabilities);
		for (int i = 0; i < n; i++)
			((tt__SecurityCapabilities*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__SecurityCapabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__SecurityCapabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__SecurityCapabilities %p -> %p\n", q, p));
	*(tt__SecurityCapabilities*)p = *(tt__SecurityCapabilities*)q;
}

void tt__NetworkCapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkCapabilitiesExtension::__any);
	/* transient soap skipped */
}

void tt__NetworkCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkCapabilitiesExtension::__any);
	/* transient soap skipped */
}

int tt__NetworkCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__NetworkCapabilitiesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__NetworkCapabilitiesExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__NetworkCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, tt__NetworkCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkCapabilitiesExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension, sizeof(tt__NetworkCapabilitiesExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__NetworkCapabilitiesExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__NetworkCapabilitiesExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__NetworkCapabilitiesExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilitiesExtension, 0, sizeof(tt__NetworkCapabilitiesExtension), 0, soap_copy_tt__NetworkCapabilitiesExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__NetworkCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__NetworkCapabilitiesExtension);
	if (this->soap_out(soap, tag?tag:"tt:NetworkCapabilitiesExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__NetworkCapabilitiesExtension(struct soap *soap, tt__NetworkCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__NetworkCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkCapabilitiesExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__NetworkCapabilitiesExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkCapabilitiesExtension);
		if (size)
			*size = sizeof(tt__NetworkCapabilitiesExtension);
		((tt__NetworkCapabilitiesExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkCapabilitiesExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__NetworkCapabilitiesExtension);
		for (int i = 0; i < n; i++)
			((tt__NetworkCapabilitiesExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__NetworkCapabilitiesExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__NetworkCapabilitiesExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__NetworkCapabilitiesExtension %p -> %p\n", q, p));
	*(tt__NetworkCapabilitiesExtension*)p = *(tt__NetworkCapabilitiesExtension*)q;
}

void tt__NetworkCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__NetworkCapabilities::IPFilter = NULL;
	this->tt__NetworkCapabilities::ZeroConfiguration = NULL;
	this->tt__NetworkCapabilities::IPVersion6 = NULL;
	this->tt__NetworkCapabilities::DynDNS = NULL;
	this->tt__NetworkCapabilities::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__NetworkCapabilities::__anyAttribute);
	/* transient soap skipped */
}

void tt__NetworkCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobool(soap, &this->tt__NetworkCapabilities::IPFilter);
	soap_serialize_PointerTobool(soap, &this->tt__NetworkCapabilities::ZeroConfiguration);
	soap_serialize_PointerTobool(soap, &this->tt__NetworkCapabilities::IPVersion6);
	soap_serialize_PointerTobool(soap, &this->tt__NetworkCapabilities::DynDNS);
	soap_serialize_PointerTott__NetworkCapabilitiesExtension(soap, &this->tt__NetworkCapabilities::Extension);
	/* transient soap skipped */
}

int tt__NetworkCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkCapabilities(struct soap *soap, const char *tag, int id, const tt__NetworkCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__NetworkCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkCapabilities), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:IPFilter", -1, &(a->tt__NetworkCapabilities::IPFilter), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:ZeroConfiguration", -1, &(a->tt__NetworkCapabilities::ZeroConfiguration), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:IPVersion6", -1, &(a->tt__NetworkCapabilities::IPVersion6), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:DynDNS", -1, &(a->tt__NetworkCapabilities::DynDNS), ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkCapabilitiesExtension(soap, "tt:Extension", -1, &(a->tt__NetworkCapabilities::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__NetworkCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkCapabilities * SOAP_FMAC4 soap_in_tt__NetworkCapabilities(struct soap *soap, const char *tag, tt__NetworkCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkCapabilities *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilities, sizeof(tt__NetworkCapabilities), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__NetworkCapabilities)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__NetworkCapabilities *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__NetworkCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_IPFilter1 = 1;
	size_t soap_flag_ZeroConfiguration1 = 1;
	size_t soap_flag_IPVersion61 = 1;
	size_t soap_flag_DynDNS1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPFilter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "tt:IPFilter", &(a->tt__NetworkCapabilities::IPFilter), "xsd:boolean"))
				{	soap_flag_IPFilter1--;
					continue;
				}
			if (soap_flag_ZeroConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "tt:ZeroConfiguration", &(a->tt__NetworkCapabilities::ZeroConfiguration), "xsd:boolean"))
				{	soap_flag_ZeroConfiguration1--;
					continue;
				}
			if (soap_flag_IPVersion61 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "tt:IPVersion6", &(a->tt__NetworkCapabilities::IPVersion6), "xsd:boolean"))
				{	soap_flag_IPVersion61--;
					continue;
				}
			if (soap_flag_DynDNS1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "tt:DynDNS", &(a->tt__NetworkCapabilities::DynDNS), "xsd:boolean"))
				{	soap_flag_DynDNS1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkCapabilitiesExtension(soap, "tt:Extension", &(a->tt__NetworkCapabilities::Extension), "tt:NetworkCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilities, 0, sizeof(tt__NetworkCapabilities), 0, soap_copy_tt__NetworkCapabilities);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__NetworkCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__NetworkCapabilities);
	if (this->soap_out(soap, tag?tag:"tt:NetworkCapabilities", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkCapabilities * SOAP_FMAC4 soap_get_tt__NetworkCapabilities(struct soap *soap, tt__NetworkCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__NetworkCapabilities * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkCapabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__NetworkCapabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkCapabilities);
		if (size)
			*size = sizeof(tt__NetworkCapabilities);
		((tt__NetworkCapabilities*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkCapabilities[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__NetworkCapabilities);
		for (int i = 0; i < n; i++)
			((tt__NetworkCapabilities*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__NetworkCapabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__NetworkCapabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__NetworkCapabilities %p -> %p\n", q, p));
	*(tt__NetworkCapabilities*)p = *(tt__NetworkCapabilities*)q;
}

void tt__ProfileCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tt__ProfileCapabilities::MaximumNumberOfProfiles);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ProfileCapabilities::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__ProfileCapabilities::__anyAttribute);
	/* transient soap skipped */
}

void tt__ProfileCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__ProfileCapabilities::MaximumNumberOfProfiles, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ProfileCapabilities::__any);
	/* transient soap skipped */
}

int tt__ProfileCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ProfileCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileCapabilities(struct soap *soap, const char *tag, int id, const tt__ProfileCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__ProfileCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileCapabilities), type))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumNumberOfProfiles", -1, &(a->tt__ProfileCapabilities::MaximumNumberOfProfiles), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__ProfileCapabilities::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ProfileCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ProfileCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__ProfileCapabilities * SOAP_FMAC4 soap_in_tt__ProfileCapabilities(struct soap *soap, const char *tag, tt__ProfileCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ProfileCapabilities *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileCapabilities, sizeof(tt__ProfileCapabilities), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ProfileCapabilities)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ProfileCapabilities *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__ProfileCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_MaximumNumberOfProfiles1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumberOfProfiles1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:MaximumNumberOfProfiles", &(a->tt__ProfileCapabilities::MaximumNumberOfProfiles), "xsd:int"))
				{	soap_flag_MaximumNumberOfProfiles1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__ProfileCapabilities::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ProfileCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileCapabilities, 0, sizeof(tt__ProfileCapabilities), 0, soap_copy_tt__ProfileCapabilities);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaximumNumberOfProfiles1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__ProfileCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ProfileCapabilities);
	if (this->soap_out(soap, tag?tag:"tt:ProfileCapabilities", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ProfileCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ProfileCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__ProfileCapabilities * SOAP_FMAC4 soap_get_tt__ProfileCapabilities(struct soap *soap, tt__ProfileCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ProfileCapabilities * SOAP_FMAC2 soap_instantiate_tt__ProfileCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ProfileCapabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ProfileCapabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ProfileCapabilities);
		if (size)
			*size = sizeof(tt__ProfileCapabilities);
		((tt__ProfileCapabilities*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ProfileCapabilities[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ProfileCapabilities);
		for (int i = 0; i < n; i++)
			((tt__ProfileCapabilities*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ProfileCapabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ProfileCapabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ProfileCapabilities %p -> %p\n", q, p));
	*(tt__ProfileCapabilities*)p = *(tt__ProfileCapabilities*)q;
}

void tt__RealTimeStreamingCapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RealTimeStreamingCapabilitiesExtension::__any);
	/* transient soap skipped */
}

void tt__RealTimeStreamingCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__RealTimeStreamingCapabilitiesExtension::__any);
	/* transient soap skipped */
}

int tt__RealTimeStreamingCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__RealTimeStreamingCapabilitiesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__RealTimeStreamingCapabilitiesExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__RealTimeStreamingCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, tt__RealTimeStreamingCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RealTimeStreamingCapabilitiesExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, sizeof(tt__RealTimeStreamingCapabilitiesExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__RealTimeStreamingCapabilitiesExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__RealTimeStreamingCapabilitiesExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RealTimeStreamingCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, 0, sizeof(tt__RealTimeStreamingCapabilitiesExtension), 0, soap_copy_tt__RealTimeStreamingCapabilitiesExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__RealTimeStreamingCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension);
	if (this->soap_out(soap, tag?tag:"tt:RealTimeStreamingCapabilitiesExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RealTimeStreamingCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RealTimeStreamingCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, tt__RealTimeStreamingCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RealTimeStreamingCapabilitiesExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__RealTimeStreamingCapabilitiesExtension);
		if (size)
			*size = sizeof(tt__RealTimeStreamingCapabilitiesExtension);
		((tt__RealTimeStreamingCapabilitiesExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__RealTimeStreamingCapabilitiesExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__RealTimeStreamingCapabilitiesExtension);
		for (int i = 0; i < n; i++)
			((tt__RealTimeStreamingCapabilitiesExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__RealTimeStreamingCapabilitiesExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__RealTimeStreamingCapabilitiesExtension %p -> %p\n", q, p));
	*(tt__RealTimeStreamingCapabilitiesExtension*)p = *(tt__RealTimeStreamingCapabilitiesExtension*)q;
}

void tt__RealTimeStreamingCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__RealTimeStreamingCapabilities::RTPMulticast = NULL;
	this->tt__RealTimeStreamingCapabilities::RTP_USCORETCP = NULL;
	this->tt__RealTimeStreamingCapabilities::RTP_USCORERTSP_USCORETCP = NULL;
	this->tt__RealTimeStreamingCapabilities::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__RealTimeStreamingCapabilities::__anyAttribute);
	/* transient soap skipped */
}

void tt__RealTimeStreamingCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobool(soap, &this->tt__RealTimeStreamingCapabilities::RTPMulticast);
	soap_serialize_PointerTobool(soap, &this->tt__RealTimeStreamingCapabilities::RTP_USCORETCP);
	soap_serialize_PointerTobool(soap, &this->tt__RealTimeStreamingCapabilities::RTP_USCORERTSP_USCORETCP);
	soap_serialize_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, &this->tt__RealTimeStreamingCapabilities::Extension);
	/* transient soap skipped */
}

int tt__RealTimeStreamingCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RealTimeStreamingCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, int id, const tt__RealTimeStreamingCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__RealTimeStreamingCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilities), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:RTPMulticast", -1, &(a->tt__RealTimeStreamingCapabilities::RTPMulticast), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:RTP_TCP", -1, &(a->tt__RealTimeStreamingCapabilities::RTP_USCORETCP), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:RTP_RTSP_TCP", -1, &(a->tt__RealTimeStreamingCapabilities::RTP_USCORERTSP_USCORETCP), ""))
		return soap->error;
	if (soap_out_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, "tt:Extension", -1, &(a->tt__RealTimeStreamingCapabilities::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__RealTimeStreamingCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__RealTimeStreamingCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilities * SOAP_FMAC4 soap_in_tt__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, tt__RealTimeStreamingCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RealTimeStreamingCapabilities *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(tt__RealTimeStreamingCapabilities), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__RealTimeStreamingCapabilities)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__RealTimeStreamingCapabilities *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__RealTimeStreamingCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_RTPMulticast1 = 1;
	size_t soap_flag_RTP_USCORETCP1 = 1;
	size_t soap_flag_RTP_USCORERTSP_USCORETCP1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RTPMulticast1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "tt:RTPMulticast", &(a->tt__RealTimeStreamingCapabilities::RTPMulticast), "xsd:boolean"))
				{	soap_flag_RTPMulticast1--;
					continue;
				}
			if (soap_flag_RTP_USCORETCP1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "tt:RTP_TCP", &(a->tt__RealTimeStreamingCapabilities::RTP_USCORETCP), "xsd:boolean"))
				{	soap_flag_RTP_USCORETCP1--;
					continue;
				}
			if (soap_flag_RTP_USCORERTSP_USCORETCP1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "tt:RTP_RTSP_TCP", &(a->tt__RealTimeStreamingCapabilities::RTP_USCORERTSP_USCORETCP), "xsd:boolean"))
				{	soap_flag_RTP_USCORERTSP_USCORETCP1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, "tt:Extension", &(a->tt__RealTimeStreamingCapabilities::Extension), "tt:RealTimeStreamingCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RealTimeStreamingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RealTimeStreamingCapabilities, 0, sizeof(tt__RealTimeStreamingCapabilities), 0, soap_copy_tt__RealTimeStreamingCapabilities);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__RealTimeStreamingCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__RealTimeStreamingCapabilities);
	if (this->soap_out(soap, tag?tag:"tt:RealTimeStreamingCapabilities", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RealTimeStreamingCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RealTimeStreamingCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilities * SOAP_FMAC4 soap_get_tt__RealTimeStreamingCapabilities(struct soap *soap, tt__RealTimeStreamingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RealTimeStreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__RealTimeStreamingCapabilities * SOAP_FMAC2 soap_instantiate_tt__RealTimeStreamingCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RealTimeStreamingCapabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__RealTimeStreamingCapabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__RealTimeStreamingCapabilities);
		if (size)
			*size = sizeof(tt__RealTimeStreamingCapabilities);
		((tt__RealTimeStreamingCapabilities*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__RealTimeStreamingCapabilities[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__RealTimeStreamingCapabilities);
		for (int i = 0; i < n; i++)
			((tt__RealTimeStreamingCapabilities*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__RealTimeStreamingCapabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__RealTimeStreamingCapabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__RealTimeStreamingCapabilities %p -> %p\n", q, p));
	*(tt__RealTimeStreamingCapabilities*)p = *(tt__RealTimeStreamingCapabilities*)q;
}

void tt__MediaCapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__MediaCapabilitiesExtension::ProfileCapabilities = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MediaCapabilitiesExtension::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__MediaCapabilitiesExtension::__anyAttribute);
	/* transient soap skipped */
}

void tt__MediaCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ProfileCapabilities(soap, &this->tt__MediaCapabilitiesExtension::ProfileCapabilities);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MediaCapabilitiesExtension::__any);
	/* transient soap skipped */
}

int tt__MediaCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MediaCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__MediaCapabilitiesExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__MediaCapabilitiesExtension*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaCapabilitiesExtension), type))
		return soap->error;
	if (a->tt__MediaCapabilitiesExtension::ProfileCapabilities)
	{	if (soap_out_PointerTott__ProfileCapabilities(soap, "tt:ProfileCapabilities", -1, &a->tt__MediaCapabilitiesExtension::ProfileCapabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:ProfileCapabilities"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__MediaCapabilitiesExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__MediaCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__MediaCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__MediaCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__MediaCapabilitiesExtension(struct soap *soap, const char *tag, tt__MediaCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MediaCapabilitiesExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(tt__MediaCapabilitiesExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__MediaCapabilitiesExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__MediaCapabilitiesExtension *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__MediaCapabilitiesExtension*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_ProfileCapabilities1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileCapabilities1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ProfileCapabilities(soap, "tt:ProfileCapabilities", &(a->tt__MediaCapabilitiesExtension::ProfileCapabilities), "tt:ProfileCapabilities"))
				{	soap_flag_ProfileCapabilities1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__MediaCapabilitiesExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MediaCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaCapabilitiesExtension, 0, sizeof(tt__MediaCapabilitiesExtension), 0, soap_copy_tt__MediaCapabilitiesExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileCapabilities1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__MediaCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__MediaCapabilitiesExtension);
	if (this->soap_out(soap, tag?tag:"tt:MediaCapabilitiesExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MediaCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MediaCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__MediaCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__MediaCapabilitiesExtension(struct soap *soap, tt__MediaCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__MediaCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__MediaCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MediaCapabilitiesExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__MediaCapabilitiesExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__MediaCapabilitiesExtension);
		if (size)
			*size = sizeof(tt__MediaCapabilitiesExtension);
		((tt__MediaCapabilitiesExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__MediaCapabilitiesExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__MediaCapabilitiesExtension);
		for (int i = 0; i < n; i++)
			((tt__MediaCapabilitiesExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__MediaCapabilitiesExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__MediaCapabilitiesExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__MediaCapabilitiesExtension %p -> %p\n", q, p));
	*(tt__MediaCapabilitiesExtension*)p = *(tt__MediaCapabilitiesExtension*)q;
}

void tt__MediaCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__MediaCapabilities::XAddr);
	this->tt__MediaCapabilities::StreamingCapabilities = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MediaCapabilities::__any);
	this->tt__MediaCapabilities::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__MediaCapabilities::__anyAttribute);
	/* transient soap skipped */
}

void tt__MediaCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__MediaCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__MediaCapabilities::XAddr);
	soap_serialize_PointerTott__RealTimeStreamingCapabilities(soap, &this->tt__MediaCapabilities::StreamingCapabilities);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MediaCapabilities::__any);
	soap_serialize_PointerTott__MediaCapabilitiesExtension(soap, &this->tt__MediaCapabilities::Extension);
	/* transient soap skipped */
}

int tt__MediaCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MediaCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaCapabilities(struct soap *soap, const char *tag, int id, const tt__MediaCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__MediaCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &(a->tt__MediaCapabilities::XAddr), ""))
		return soap->error;
	if (a->tt__MediaCapabilities::StreamingCapabilities)
	{	if (soap_out_PointerTott__RealTimeStreamingCapabilities(soap, "tt:StreamingCapabilities", -1, &a->tt__MediaCapabilities::StreamingCapabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:StreamingCapabilities"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__MediaCapabilities::__any), ""))
		return soap->error;
	if (soap_out_PointerTott__MediaCapabilitiesExtension(soap, "tt:Extension", -1, &(a->tt__MediaCapabilities::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__MediaCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__MediaCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__MediaCapabilities * SOAP_FMAC4 soap_in_tt__MediaCapabilities(struct soap *soap, const char *tag, tt__MediaCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MediaCapabilities *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaCapabilities, sizeof(tt__MediaCapabilities), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__MediaCapabilities)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__MediaCapabilities *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__MediaCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_StreamingCapabilities1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:XAddr", &(a->tt__MediaCapabilities::XAddr), "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			if (soap_flag_StreamingCapabilities1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RealTimeStreamingCapabilities(soap, "tt:StreamingCapabilities", &(a->tt__MediaCapabilities::StreamingCapabilities), "tt:RealTimeStreamingCapabilities"))
				{	soap_flag_StreamingCapabilities1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MediaCapabilitiesExtension(soap, "tt:Extension", &(a->tt__MediaCapabilities::Extension), "tt:MediaCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__MediaCapabilities::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MediaCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaCapabilities, 0, sizeof(tt__MediaCapabilities), 0, soap_copy_tt__MediaCapabilities);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0 || soap_flag_StreamingCapabilities1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__MediaCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__MediaCapabilities);
	if (this->soap_out(soap, tag?tag:"tt:MediaCapabilities", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MediaCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MediaCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__MediaCapabilities * SOAP_FMAC4 soap_get_tt__MediaCapabilities(struct soap *soap, tt__MediaCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__MediaCapabilities * SOAP_FMAC2 soap_instantiate_tt__MediaCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MediaCapabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__MediaCapabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__MediaCapabilities);
		if (size)
			*size = sizeof(tt__MediaCapabilities);
		((tt__MediaCapabilities*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__MediaCapabilities[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__MediaCapabilities);
		for (int i = 0; i < n; i++)
			((tt__MediaCapabilities*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__MediaCapabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__MediaCapabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__MediaCapabilities %p -> %p\n", q, p));
	*(tt__MediaCapabilities*)p = *(tt__MediaCapabilities*)q;
}

void tt__IOCapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__IOCapabilitiesExtension::__any);
	/* transient soap skipped */
}

void tt__IOCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__IOCapabilitiesExtension::__any);
	/* transient soap skipped */
}

int tt__IOCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IOCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IOCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__IOCapabilitiesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IOCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__IOCapabilitiesExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__IOCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__IOCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__IOCapabilitiesExtension(struct soap *soap, const char *tag, tt__IOCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IOCapabilitiesExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilitiesExtension, sizeof(tt__IOCapabilitiesExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__IOCapabilitiesExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__IOCapabilitiesExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__IOCapabilitiesExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IOCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IOCapabilitiesExtension, 0, sizeof(tt__IOCapabilitiesExtension), 0, soap_copy_tt__IOCapabilitiesExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__IOCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__IOCapabilitiesExtension);
	if (this->soap_out(soap, tag?tag:"tt:IOCapabilitiesExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IOCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IOCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__IOCapabilitiesExtension(struct soap *soap, tt__IOCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IOCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__IOCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__IOCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IOCapabilitiesExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__IOCapabilitiesExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__IOCapabilitiesExtension);
		if (size)
			*size = sizeof(tt__IOCapabilitiesExtension);
		((tt__IOCapabilitiesExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__IOCapabilitiesExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__IOCapabilitiesExtension);
		for (int i = 0; i < n; i++)
			((tt__IOCapabilitiesExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__IOCapabilitiesExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__IOCapabilitiesExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__IOCapabilitiesExtension %p -> %p\n", q, p));
	*(tt__IOCapabilitiesExtension*)p = *(tt__IOCapabilitiesExtension*)q;
}

void tt__IOCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__IOCapabilities::InputConnectors = NULL;
	this->tt__IOCapabilities::RelayOutputs = NULL;
	this->tt__IOCapabilities::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__IOCapabilities::__anyAttribute);
	/* transient soap skipped */
}

void tt__IOCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &this->tt__IOCapabilities::InputConnectors);
	soap_serialize_PointerToint(soap, &this->tt__IOCapabilities::RelayOutputs);
	soap_serialize_PointerTott__IOCapabilitiesExtension(soap, &this->tt__IOCapabilities::Extension);
	/* transient soap skipped */
}

int tt__IOCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IOCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IOCapabilities(struct soap *soap, const char *tag, int id, const tt__IOCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__IOCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IOCapabilities), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:InputConnectors", -1, &(a->tt__IOCapabilities::InputConnectors), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:RelayOutputs", -1, &(a->tt__IOCapabilities::RelayOutputs), ""))
		return soap->error;
	if (soap_out_PointerTott__IOCapabilitiesExtension(soap, "tt:Extension", -1, &(a->tt__IOCapabilities::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__IOCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__IOCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__IOCapabilities * SOAP_FMAC4 soap_in_tt__IOCapabilities(struct soap *soap, const char *tag, tt__IOCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IOCapabilities *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilities, sizeof(tt__IOCapabilities), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__IOCapabilities)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__IOCapabilities *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__IOCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_InputConnectors1 = 1;
	size_t soap_flag_RelayOutputs1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InputConnectors1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:InputConnectors", &(a->tt__IOCapabilities::InputConnectors), "xsd:int"))
				{	soap_flag_InputConnectors1--;
					continue;
				}
			if (soap_flag_RelayOutputs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:RelayOutputs", &(a->tt__IOCapabilities::RelayOutputs), "xsd:int"))
				{	soap_flag_RelayOutputs1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IOCapabilitiesExtension(soap, "tt:Extension", &(a->tt__IOCapabilities::Extension), "tt:IOCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IOCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IOCapabilities, 0, sizeof(tt__IOCapabilities), 0, soap_copy_tt__IOCapabilities);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__IOCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__IOCapabilities);
	if (this->soap_out(soap, tag?tag:"tt:IOCapabilities", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IOCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IOCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__IOCapabilities * SOAP_FMAC4 soap_get_tt__IOCapabilities(struct soap *soap, tt__IOCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__IOCapabilities * SOAP_FMAC2 soap_instantiate_tt__IOCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IOCapabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__IOCapabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__IOCapabilities);
		if (size)
			*size = sizeof(tt__IOCapabilities);
		((tt__IOCapabilities*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__IOCapabilities[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__IOCapabilities);
		for (int i = 0; i < n; i++)
			((tt__IOCapabilities*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__IOCapabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__IOCapabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__IOCapabilities %p -> %p\n", q, p));
	*(tt__IOCapabilities*)p = *(tt__IOCapabilities*)q;
}

void tt__EventCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__EventCapabilities::XAddr);
	soap_default_bool(soap, &this->tt__EventCapabilities::WSSubscriptionPolicySupport);
	soap_default_bool(soap, &this->tt__EventCapabilities::WSPullPointSupport);
	soap_default_bool(soap, &this->tt__EventCapabilities::WSPausableSubscriptionManagerInterfaceSupport);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__EventCapabilities::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__EventCapabilities::__anyAttribute);
	/* transient soap skipped */
}

void tt__EventCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__EventCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__EventCapabilities::XAddr);
	soap_embedded(soap, &this->tt__EventCapabilities::WSSubscriptionPolicySupport, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__EventCapabilities::WSPullPointSupport, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__EventCapabilities::WSPausableSubscriptionManagerInterfaceSupport, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__EventCapabilities::__any);
	/* transient soap skipped */
}

int tt__EventCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EventCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventCapabilities(struct soap *soap, const char *tag, int id, const tt__EventCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__EventCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &(a->tt__EventCapabilities::XAddr), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:WSSubscriptionPolicySupport", -1, &(a->tt__EventCapabilities::WSSubscriptionPolicySupport), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:WSPullPointSupport", -1, &(a->tt__EventCapabilities::WSPullPointSupport), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:WSPausableSubscriptionManagerInterfaceSupport", -1, &(a->tt__EventCapabilities::WSPausableSubscriptionManagerInterfaceSupport), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__EventCapabilities::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__EventCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__EventCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__EventCapabilities * SOAP_FMAC4 soap_in_tt__EventCapabilities(struct soap *soap, const char *tag, tt__EventCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EventCapabilities *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventCapabilities, sizeof(tt__EventCapabilities), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__EventCapabilities)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__EventCapabilities *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__EventCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_WSSubscriptionPolicySupport1 = 1;
	size_t soap_flag_WSPullPointSupport1 = 1;
	size_t soap_flag_WSPausableSubscriptionManagerInterfaceSupport1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:XAddr", &(a->tt__EventCapabilities::XAddr), "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			if (soap_flag_WSSubscriptionPolicySupport1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:WSSubscriptionPolicySupport", &(a->tt__EventCapabilities::WSSubscriptionPolicySupport), "xsd:boolean"))
				{	soap_flag_WSSubscriptionPolicySupport1--;
					continue;
				}
			if (soap_flag_WSPullPointSupport1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:WSPullPointSupport", &(a->tt__EventCapabilities::WSPullPointSupport), "xsd:boolean"))
				{	soap_flag_WSPullPointSupport1--;
					continue;
				}
			if (soap_flag_WSPausableSubscriptionManagerInterfaceSupport1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:WSPausableSubscriptionManagerInterfaceSupport", &(a->tt__EventCapabilities::WSPausableSubscriptionManagerInterfaceSupport), "xsd:boolean"))
				{	soap_flag_WSPausableSubscriptionManagerInterfaceSupport1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__EventCapabilities::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__EventCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventCapabilities, 0, sizeof(tt__EventCapabilities), 0, soap_copy_tt__EventCapabilities);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0 || soap_flag_WSSubscriptionPolicySupport1 > 0 || soap_flag_WSPullPointSupport1 > 0 || soap_flag_WSPausableSubscriptionManagerInterfaceSupport1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__EventCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__EventCapabilities);
	if (this->soap_out(soap, tag?tag:"tt:EventCapabilities", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EventCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EventCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__EventCapabilities * SOAP_FMAC4 soap_get_tt__EventCapabilities(struct soap *soap, tt__EventCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__EventCapabilities * SOAP_FMAC2 soap_instantiate_tt__EventCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EventCapabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__EventCapabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__EventCapabilities);
		if (size)
			*size = sizeof(tt__EventCapabilities);
		((tt__EventCapabilities*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__EventCapabilities[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__EventCapabilities);
		for (int i = 0; i < n; i++)
			((tt__EventCapabilities*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__EventCapabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__EventCapabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__EventCapabilities %p -> %p\n", q, p));
	*(tt__EventCapabilities*)p = *(tt__EventCapabilities*)q;
}

void tt__DeviceCapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DeviceCapabilitiesExtension::__any);
	/* transient soap skipped */
}

void tt__DeviceCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DeviceCapabilitiesExtension::__any);
	/* transient soap skipped */
}

int tt__DeviceCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DeviceCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__DeviceCapabilitiesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__DeviceCapabilitiesExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__DeviceCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__DeviceCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__DeviceCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, tt__DeviceCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DeviceCapabilitiesExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceCapabilitiesExtension, sizeof(tt__DeviceCapabilitiesExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__DeviceCapabilitiesExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__DeviceCapabilitiesExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__DeviceCapabilitiesExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__DeviceCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceCapabilitiesExtension, 0, sizeof(tt__DeviceCapabilitiesExtension), 0, soap_copy_tt__DeviceCapabilitiesExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__DeviceCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__DeviceCapabilitiesExtension);
	if (this->soap_out(soap, tag?tag:"tt:DeviceCapabilitiesExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DeviceCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DeviceCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__DeviceCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__DeviceCapabilitiesExtension(struct soap *soap, tt__DeviceCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__DeviceCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__DeviceCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DeviceCapabilitiesExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__DeviceCapabilitiesExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__DeviceCapabilitiesExtension);
		if (size)
			*size = sizeof(tt__DeviceCapabilitiesExtension);
		((tt__DeviceCapabilitiesExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__DeviceCapabilitiesExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__DeviceCapabilitiesExtension);
		for (int i = 0; i < n; i++)
			((tt__DeviceCapabilitiesExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__DeviceCapabilitiesExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__DeviceCapabilitiesExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__DeviceCapabilitiesExtension %p -> %p\n", q, p));
	*(tt__DeviceCapabilitiesExtension*)p = *(tt__DeviceCapabilitiesExtension*)q;
}

void tt__DeviceCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__DeviceCapabilities::XAddr);
	this->tt__DeviceCapabilities::Network = NULL;
	this->tt__DeviceCapabilities::System = NULL;
	this->tt__DeviceCapabilities::IO = NULL;
	this->tt__DeviceCapabilities::Security = NULL;
	this->tt__DeviceCapabilities::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__DeviceCapabilities::__anyAttribute);
	/* transient soap skipped */
}

void tt__DeviceCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__DeviceCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__DeviceCapabilities::XAddr);
	soap_serialize_PointerTott__NetworkCapabilities(soap, &this->tt__DeviceCapabilities::Network);
	soap_serialize_PointerTott__SystemCapabilities(soap, &this->tt__DeviceCapabilities::System);
	soap_serialize_PointerTott__IOCapabilities(soap, &this->tt__DeviceCapabilities::IO);
	soap_serialize_PointerTott__SecurityCapabilities(soap, &this->tt__DeviceCapabilities::Security);
	soap_serialize_PointerTott__DeviceCapabilitiesExtension(soap, &this->tt__DeviceCapabilities::Extension);
	/* transient soap skipped */
}

int tt__DeviceCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DeviceCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceCapabilities(struct soap *soap, const char *tag, int id, const tt__DeviceCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__DeviceCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &(a->tt__DeviceCapabilities::XAddr), ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkCapabilities(soap, "tt:Network", -1, &(a->tt__DeviceCapabilities::Network), ""))
		return soap->error;
	if (soap_out_PointerTott__SystemCapabilities(soap, "tt:System", -1, &(a->tt__DeviceCapabilities::System), ""))
		return soap->error;
	if (soap_out_PointerTott__IOCapabilities(soap, "tt:IO", -1, &(a->tt__DeviceCapabilities::IO), ""))
		return soap->error;
	if (soap_out_PointerTott__SecurityCapabilities(soap, "tt:Security", -1, &(a->tt__DeviceCapabilities::Security), ""))
		return soap->error;
	if (soap_out_PointerTott__DeviceCapabilitiesExtension(soap, "tt:Extension", -1, &(a->tt__DeviceCapabilities::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__DeviceCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__DeviceCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__DeviceCapabilities * SOAP_FMAC4 soap_in_tt__DeviceCapabilities(struct soap *soap, const char *tag, tt__DeviceCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DeviceCapabilities *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceCapabilities, sizeof(tt__DeviceCapabilities), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__DeviceCapabilities)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__DeviceCapabilities *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__DeviceCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_Network1 = 1;
	size_t soap_flag_System1 = 1;
	size_t soap_flag_IO1 = 1;
	size_t soap_flag_Security1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:XAddr", &(a->tt__DeviceCapabilities::XAddr), "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			if (soap_flag_Network1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkCapabilities(soap, "tt:Network", &(a->tt__DeviceCapabilities::Network), "tt:NetworkCapabilities"))
				{	soap_flag_Network1--;
					continue;
				}
			if (soap_flag_System1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SystemCapabilities(soap, "tt:System", &(a->tt__DeviceCapabilities::System), "tt:SystemCapabilities"))
				{	soap_flag_System1--;
					continue;
				}
			if (soap_flag_IO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IOCapabilities(soap, "tt:IO", &(a->tt__DeviceCapabilities::IO), "tt:IOCapabilities"))
				{	soap_flag_IO1--;
					continue;
				}
			if (soap_flag_Security1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SecurityCapabilities(soap, "tt:Security", &(a->tt__DeviceCapabilities::Security), "tt:SecurityCapabilities"))
				{	soap_flag_Security1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DeviceCapabilitiesExtension(soap, "tt:Extension", &(a->tt__DeviceCapabilities::Extension), "tt:DeviceCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__DeviceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceCapabilities, 0, sizeof(tt__DeviceCapabilities), 0, soap_copy_tt__DeviceCapabilities);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__DeviceCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__DeviceCapabilities);
	if (this->soap_out(soap, tag?tag:"tt:DeviceCapabilities", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DeviceCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DeviceCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__DeviceCapabilities * SOAP_FMAC4 soap_get_tt__DeviceCapabilities(struct soap *soap, tt__DeviceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__DeviceCapabilities * SOAP_FMAC2 soap_instantiate_tt__DeviceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DeviceCapabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__DeviceCapabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__DeviceCapabilities);
		if (size)
			*size = sizeof(tt__DeviceCapabilities);
		((tt__DeviceCapabilities*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__DeviceCapabilities[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__DeviceCapabilities);
		for (int i = 0; i < n; i++)
			((tt__DeviceCapabilities*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__DeviceCapabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__DeviceCapabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__DeviceCapabilities %p -> %p\n", q, p));
	*(tt__DeviceCapabilities*)p = *(tt__DeviceCapabilities*)q;
}

void tt__AnalyticsCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__AnalyticsCapabilities::XAddr);
	soap_default_bool(soap, &this->tt__AnalyticsCapabilities::RuleSupport);
	soap_default_bool(soap, &this->tt__AnalyticsCapabilities::AnalyticsModuleSupport);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsCapabilities::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AnalyticsCapabilities::__anyAttribute);
	/* transient soap skipped */
}

void tt__AnalyticsCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__AnalyticsCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__AnalyticsCapabilities::XAddr);
	soap_embedded(soap, &this->tt__AnalyticsCapabilities::RuleSupport, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__AnalyticsCapabilities::AnalyticsModuleSupport, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AnalyticsCapabilities::__any);
	/* transient soap skipped */
}

int tt__AnalyticsCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsCapabilities(struct soap *soap, const char *tag, int id, const tt__AnalyticsCapabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AnalyticsCapabilities*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &(a->tt__AnalyticsCapabilities::XAddr), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RuleSupport", -1, &(a->tt__AnalyticsCapabilities::RuleSupport), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:AnalyticsModuleSupport", -1, &(a->tt__AnalyticsCapabilities::AnalyticsModuleSupport), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__AnalyticsCapabilities::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__AnalyticsCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsCapabilities * SOAP_FMAC4 soap_in_tt__AnalyticsCapabilities(struct soap *soap, const char *tag, tt__AnalyticsCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsCapabilities *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsCapabilities, sizeof(tt__AnalyticsCapabilities), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__AnalyticsCapabilities)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__AnalyticsCapabilities *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AnalyticsCapabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_RuleSupport1 = 1;
	size_t soap_flag_AnalyticsModuleSupport1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:XAddr", &(a->tt__AnalyticsCapabilities::XAddr), "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			if (soap_flag_RuleSupport1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:RuleSupport", &(a->tt__AnalyticsCapabilities::RuleSupport), "xsd:boolean"))
				{	soap_flag_RuleSupport1--;
					continue;
				}
			if (soap_flag_AnalyticsModuleSupport1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:AnalyticsModuleSupport", &(a->tt__AnalyticsCapabilities::AnalyticsModuleSupport), "xsd:boolean"))
				{	soap_flag_AnalyticsModuleSupport1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__AnalyticsCapabilities::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AnalyticsCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsCapabilities, 0, sizeof(tt__AnalyticsCapabilities), 0, soap_copy_tt__AnalyticsCapabilities);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0 || soap_flag_RuleSupport1 > 0 || soap_flag_AnalyticsModuleSupport1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__AnalyticsCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__AnalyticsCapabilities);
	if (this->soap_out(soap, tag?tag:"tt:AnalyticsCapabilities", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsCapabilities * SOAP_FMAC4 soap_get_tt__AnalyticsCapabilities(struct soap *soap, tt__AnalyticsCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__AnalyticsCapabilities * SOAP_FMAC2 soap_instantiate_tt__AnalyticsCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsCapabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__AnalyticsCapabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__AnalyticsCapabilities);
		if (size)
			*size = sizeof(tt__AnalyticsCapabilities);
		((tt__AnalyticsCapabilities*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__AnalyticsCapabilities[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__AnalyticsCapabilities);
		for (int i = 0; i < n; i++)
			((tt__AnalyticsCapabilities*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__AnalyticsCapabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__AnalyticsCapabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__AnalyticsCapabilities %p -> %p\n", q, p));
	*(tt__AnalyticsCapabilities*)p = *(tt__AnalyticsCapabilities*)q;
}

void tt__CapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__CapabilitiesExtension::__any);
	/* transient soap skipped */
}

void tt__CapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__CapabilitiesExtension::__any);
	/* transient soap skipped */
}

int tt__CapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__CapabilitiesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CapabilitiesExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__CapabilitiesExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__CapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__CapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__CapabilitiesExtension * SOAP_FMAC4 soap_in_tt__CapabilitiesExtension(struct soap *soap, const char *tag, tt__CapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CapabilitiesExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilitiesExtension, sizeof(tt__CapabilitiesExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__CapabilitiesExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__CapabilitiesExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__CapabilitiesExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__CapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CapabilitiesExtension, 0, sizeof(tt__CapabilitiesExtension), 0, soap_copy_tt__CapabilitiesExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__CapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__CapabilitiesExtension);
	if (this->soap_out(soap, tag?tag:"tt:CapabilitiesExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__CapabilitiesExtension * SOAP_FMAC4 soap_get_tt__CapabilitiesExtension(struct soap *soap, tt__CapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__CapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__CapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CapabilitiesExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__CapabilitiesExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__CapabilitiesExtension);
		if (size)
			*size = sizeof(tt__CapabilitiesExtension);
		((tt__CapabilitiesExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__CapabilitiesExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__CapabilitiesExtension);
		for (int i = 0; i < n; i++)
			((tt__CapabilitiesExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__CapabilitiesExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__CapabilitiesExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__CapabilitiesExtension %p -> %p\n", q, p));
	*(tt__CapabilitiesExtension*)p = *(tt__CapabilitiesExtension*)q;
}

void tt__Capabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__Capabilities::Analytics = NULL;
	this->tt__Capabilities::Device = NULL;
	this->tt__Capabilities::Events = NULL;
	this->tt__Capabilities::Imaging = NULL;
	this->tt__Capabilities::Media = NULL;
	this->tt__Capabilities::PTZ = NULL;
	this->tt__Capabilities::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__Capabilities::__anyAttribute);
	/* transient soap skipped */
}

void tt__Capabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AnalyticsCapabilities(soap, &this->tt__Capabilities::Analytics);
	soap_serialize_PointerTott__DeviceCapabilities(soap, &this->tt__Capabilities::Device);
	soap_serialize_PointerTott__EventCapabilities(soap, &this->tt__Capabilities::Events);
	soap_serialize_PointerTott__ImagingCapabilities(soap, &this->tt__Capabilities::Imaging);
	soap_serialize_PointerTott__MediaCapabilities(soap, &this->tt__Capabilities::Media);
	soap_serialize_PointerTott__PTZCapabilities(soap, &this->tt__Capabilities::PTZ);
	soap_serialize_PointerTott__CapabilitiesExtension(soap, &this->tt__Capabilities::Extension);
	/* transient soap skipped */
}

int tt__Capabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Capabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Capabilities(struct soap *soap, const char *tag, int id, const tt__Capabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Capabilities*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Capabilities), type))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsCapabilities(soap, "tt:Analytics", -1, &(a->tt__Capabilities::Analytics), ""))
		return soap->error;
	if (soap_out_PointerTott__DeviceCapabilities(soap, "tt:Device", -1, &(a->tt__Capabilities::Device), ""))
		return soap->error;
	if (soap_out_PointerTott__EventCapabilities(soap, "tt:Events", -1, &(a->tt__Capabilities::Events), ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingCapabilities(soap, "tt:Imaging", -1, &(a->tt__Capabilities::Imaging), ""))
		return soap->error;
	if (soap_out_PointerTott__MediaCapabilities(soap, "tt:Media", -1, &(a->tt__Capabilities::Media), ""))
		return soap->error;
	if (soap_out_PointerTott__PTZCapabilities(soap, "tt:PTZ", -1, &(a->tt__Capabilities::PTZ), ""))
		return soap->error;
	if (soap_out_PointerTott__CapabilitiesExtension(soap, "tt:Extension", -1, &(a->tt__Capabilities::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Capabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Capabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__Capabilities * SOAP_FMAC4 soap_in_tt__Capabilities(struct soap *soap, const char *tag, tt__Capabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Capabilities *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Capabilities, sizeof(tt__Capabilities), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Capabilities)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Capabilities *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Capabilities*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Analytics1 = 1;
	size_t soap_flag_Device1 = 1;
	size_t soap_flag_Events1 = 1;
	size_t soap_flag_Imaging1 = 1;
	size_t soap_flag_Media1 = 1;
	size_t soap_flag_PTZ1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Analytics1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsCapabilities(soap, "tt:Analytics", &(a->tt__Capabilities::Analytics), "tt:AnalyticsCapabilities"))
				{	soap_flag_Analytics1--;
					continue;
				}
			if (soap_flag_Device1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DeviceCapabilities(soap, "tt:Device", &(a->tt__Capabilities::Device), "tt:DeviceCapabilities"))
				{	soap_flag_Device1--;
					continue;
				}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__EventCapabilities(soap, "tt:Events", &(a->tt__Capabilities::Events), "tt:EventCapabilities"))
				{	soap_flag_Events1--;
					continue;
				}
			if (soap_flag_Imaging1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingCapabilities(soap, "tt:Imaging", &(a->tt__Capabilities::Imaging), "tt:ImagingCapabilities"))
				{	soap_flag_Imaging1--;
					continue;
				}
			if (soap_flag_Media1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MediaCapabilities(soap, "tt:Media", &(a->tt__Capabilities::Media), "tt:MediaCapabilities"))
				{	soap_flag_Media1--;
					continue;
				}
			if (soap_flag_PTZ1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZCapabilities(soap, "tt:PTZ", &(a->tt__Capabilities::PTZ), "tt:PTZCapabilities"))
				{	soap_flag_PTZ1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__CapabilitiesExtension(soap, "tt:Extension", &(a->tt__Capabilities::Extension), "tt:CapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Capabilities, 0, sizeof(tt__Capabilities), 0, soap_copy_tt__Capabilities);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__Capabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Capabilities);
	if (this->soap_out(soap, tag?tag:"tt:Capabilities", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Capabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Capabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__Capabilities * SOAP_FMAC4 soap_get_tt__Capabilities(struct soap *soap, tt__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Capabilities * SOAP_FMAC2 soap_instantiate_tt__Capabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Capabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Capabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Capabilities);
		if (size)
			*size = sizeof(tt__Capabilities);
		((tt__Capabilities*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Capabilities[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Capabilities);
		for (int i = 0; i < n; i++)
			((tt__Capabilities*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Capabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Capabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Capabilities %p -> %p\n", q, p));
	*(tt__Capabilities*)p = *(tt__Capabilities*)q;
}

void tt__IPAddressFilterExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__IPAddressFilterExtension::__any);
	/* transient soap skipped */
}

void tt__IPAddressFilterExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__IPAddressFilterExtension::__any);
	/* transient soap skipped */
}

int tt__IPAddressFilterExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPAddressFilterExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddressFilterExtension(struct soap *soap, const char *tag, int id, const tt__IPAddressFilterExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddressFilterExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__IPAddressFilterExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__IPAddressFilterExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__IPAddressFilterExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPAddressFilterExtension * SOAP_FMAC4 soap_in_tt__IPAddressFilterExtension(struct soap *soap, const char *tag, tt__IPAddressFilterExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPAddressFilterExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilterExtension, sizeof(tt__IPAddressFilterExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__IPAddressFilterExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__IPAddressFilterExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__IPAddressFilterExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IPAddressFilterExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddressFilterExtension, 0, sizeof(tt__IPAddressFilterExtension), 0, soap_copy_tt__IPAddressFilterExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__IPAddressFilterExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__IPAddressFilterExtension);
	if (this->soap_out(soap, tag?tag:"tt:IPAddressFilterExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPAddressFilterExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPAddressFilterExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPAddressFilterExtension * SOAP_FMAC4 soap_get_tt__IPAddressFilterExtension(struct soap *soap, tt__IPAddressFilterExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddressFilterExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__IPAddressFilterExtension * SOAP_FMAC2 soap_instantiate_tt__IPAddressFilterExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPAddressFilterExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__IPAddressFilterExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__IPAddressFilterExtension);
		if (size)
			*size = sizeof(tt__IPAddressFilterExtension);
		((tt__IPAddressFilterExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__IPAddressFilterExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__IPAddressFilterExtension);
		for (int i = 0; i < n; i++)
			((tt__IPAddressFilterExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__IPAddressFilterExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__IPAddressFilterExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__IPAddressFilterExtension %p -> %p\n", q, p));
	*(tt__IPAddressFilterExtension*)p = *(tt__IPAddressFilterExtension*)q;
}

void tt__IPAddressFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__IPAddressFilterType(soap, &this->tt__IPAddressFilter::Type);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPAddressFilter::IPv4Address);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPAddressFilter::IPv6Address);
	this->tt__IPAddressFilter::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__IPAddressFilter::__anyAttribute);
	/* transient soap skipped */
}

void tt__IPAddressFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPAddressFilter::IPv4Address);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPAddressFilter::IPv6Address);
	soap_serialize_PointerTott__IPAddressFilterExtension(soap, &this->tt__IPAddressFilter::Extension);
	/* transient soap skipped */
}

int tt__IPAddressFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPAddressFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddressFilter(struct soap *soap, const char *tag, int id, const tt__IPAddressFilter *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__IPAddressFilter*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddressFilter), type))
		return soap->error;
	if (soap_out_tt__IPAddressFilterType(soap, "tt:Type", -1, &(a->tt__IPAddressFilter::Type), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:IPv4Address", -1, &(a->tt__IPAddressFilter::IPv4Address), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:IPv6Address", -1, &(a->tt__IPAddressFilter::IPv6Address), ""))
		return soap->error;
	if (soap_out_PointerTott__IPAddressFilterExtension(soap, "tt:Extension", -1, &(a->tt__IPAddressFilter::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__IPAddressFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__IPAddressFilter(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPAddressFilter * SOAP_FMAC4 soap_in_tt__IPAddressFilter(struct soap *soap, const char *tag, tt__IPAddressFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPAddressFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilter, sizeof(tt__IPAddressFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__IPAddressFilter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__IPAddressFilter *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__IPAddressFilter*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__IPAddressFilterType(soap, "tt:Type", &(a->tt__IPAddressFilter::Type), "tt:IPAddressFilterType"))
				{	soap_flag_Type1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:IPv4Address", &(a->tt__IPAddressFilter::IPv4Address), "tt:PrefixedIPv4Address"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:IPv6Address", &(a->tt__IPAddressFilter::IPv6Address), "tt:PrefixedIPv6Address"))
					continue;
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPAddressFilterExtension(soap, "tt:Extension", &(a->tt__IPAddressFilter::Extension), "tt:IPAddressFilterExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddressFilter, 0, sizeof(tt__IPAddressFilter), 0, soap_copy_tt__IPAddressFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__IPAddressFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__IPAddressFilter);
	if (this->soap_out(soap, tag?tag:"tt:IPAddressFilter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPAddressFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPAddressFilter(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPAddressFilter * SOAP_FMAC4 soap_get_tt__IPAddressFilter(struct soap *soap, tt__IPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__IPAddressFilter * SOAP_FMAC2 soap_instantiate_tt__IPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPAddressFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__IPAddressFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__IPAddressFilter);
		if (size)
			*size = sizeof(tt__IPAddressFilter);
		((tt__IPAddressFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__IPAddressFilter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__IPAddressFilter);
		for (int i = 0; i < n; i++)
			((tt__IPAddressFilter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__IPAddressFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__IPAddressFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__IPAddressFilter %p -> %p\n", q, p));
	*(tt__IPAddressFilter*)p = *(tt__IPAddressFilter*)q;
}

void tt__NetworkZeroConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkZeroConfigurationExtension::__any);
	/* transient soap skipped */
}

void tt__NetworkZeroConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkZeroConfigurationExtension::__any);
	/* transient soap skipped */
}

int tt__NetworkZeroConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkZeroConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__NetworkZeroConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__NetworkZeroConfigurationExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkZeroConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__NetworkZeroConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension * SOAP_FMAC4 soap_in_tt__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, tt__NetworkZeroConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkZeroConfigurationExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, sizeof(tt__NetworkZeroConfigurationExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__NetworkZeroConfigurationExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__NetworkZeroConfigurationExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__NetworkZeroConfigurationExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkZeroConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, 0, sizeof(tt__NetworkZeroConfigurationExtension), 0, soap_copy_tt__NetworkZeroConfigurationExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__NetworkZeroConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__NetworkZeroConfigurationExtension);
	if (this->soap_out(soap, tag?tag:"tt:NetworkZeroConfigurationExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkZeroConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkZeroConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension * SOAP_FMAC4 soap_get_tt__NetworkZeroConfigurationExtension(struct soap *soap, tt__NetworkZeroConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkZeroConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__NetworkZeroConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkZeroConfigurationExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkZeroConfigurationExtension);
		if (size)
			*size = sizeof(tt__NetworkZeroConfigurationExtension);
		((tt__NetworkZeroConfigurationExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkZeroConfigurationExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__NetworkZeroConfigurationExtension);
		for (int i = 0; i < n; i++)
			((tt__NetworkZeroConfigurationExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__NetworkZeroConfigurationExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__NetworkZeroConfigurationExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__NetworkZeroConfigurationExtension %p -> %p\n", q, p));
	*(tt__NetworkZeroConfigurationExtension*)p = *(tt__NetworkZeroConfigurationExtension*)q;
}

void tt__NetworkZeroConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->tt__NetworkZeroConfiguration::InterfaceToken);
	soap_default_bool(soap, &this->tt__NetworkZeroConfiguration::Enabled);
	soap_default_std__vectorTemplateOftt__IPv4Address(soap, &this->tt__NetworkZeroConfiguration::Addresses);
	this->tt__NetworkZeroConfiguration::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__NetworkZeroConfiguration::__anyAttribute);
	/* transient soap skipped */
}

void tt__NetworkZeroConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__NetworkZeroConfiguration::InterfaceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__NetworkZeroConfiguration::InterfaceToken);
	soap_embedded(soap, &this->tt__NetworkZeroConfiguration::Enabled, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOftt__IPv4Address(soap, &this->tt__NetworkZeroConfiguration::Addresses);
	soap_serialize_PointerTott__NetworkZeroConfigurationExtension(soap, &this->tt__NetworkZeroConfiguration::Extension);
	/* transient soap skipped */
}

int tt__NetworkZeroConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkZeroConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkZeroConfiguration(struct soap *soap, const char *tag, int id, const tt__NetworkZeroConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__NetworkZeroConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkZeroConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:InterfaceToken", -1, &(a->tt__NetworkZeroConfiguration::InterfaceToken), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:Enabled", -1, &(a->tt__NetworkZeroConfiguration::Enabled), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IPv4Address(soap, "tt:Addresses", -1, &(a->tt__NetworkZeroConfiguration::Addresses), ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkZeroConfigurationExtension(soap, "tt:Extension", -1, &(a->tt__NetworkZeroConfiguration::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkZeroConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__NetworkZeroConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkZeroConfiguration * SOAP_FMAC4 soap_in_tt__NetworkZeroConfiguration(struct soap *soap, const char *tag, tt__NetworkZeroConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkZeroConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkZeroConfiguration, sizeof(tt__NetworkZeroConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__NetworkZeroConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__NetworkZeroConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__NetworkZeroConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_InterfaceToken1 = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:InterfaceToken", &(a->tt__NetworkZeroConfiguration::InterfaceToken), "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken1--;
					continue;
				}
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:Enabled", &(a->tt__NetworkZeroConfiguration::Enabled), "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftt__IPv4Address(soap, "tt:Addresses", &(a->tt__NetworkZeroConfiguration::Addresses), "tt:IPv4Address"))
					continue;
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkZeroConfigurationExtension(soap, "tt:Extension", &(a->tt__NetworkZeroConfiguration::Extension), "tt:NetworkZeroConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkZeroConfiguration, 0, sizeof(tt__NetworkZeroConfiguration), 0, soap_copy_tt__NetworkZeroConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken1 > 0 || soap_flag_Enabled1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__NetworkZeroConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__NetworkZeroConfiguration);
	if (this->soap_out(soap, tag?tag:"tt:NetworkZeroConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkZeroConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkZeroConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkZeroConfiguration * SOAP_FMAC4 soap_get_tt__NetworkZeroConfiguration(struct soap *soap, tt__NetworkZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__NetworkZeroConfiguration * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkZeroConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__NetworkZeroConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkZeroConfiguration);
		if (size)
			*size = sizeof(tt__NetworkZeroConfiguration);
		((tt__NetworkZeroConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkZeroConfiguration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__NetworkZeroConfiguration);
		for (int i = 0; i < n; i++)
			((tt__NetworkZeroConfiguration*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__NetworkZeroConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__NetworkZeroConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__NetworkZeroConfiguration %p -> %p\n", q, p));
	*(tt__NetworkZeroConfiguration*)p = *(tt__NetworkZeroConfiguration*)q;
}

void tt__NetworkGateway::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__IPv4Address(soap, &this->tt__NetworkGateway::IPv4Address);
	soap_default_std__vectorTemplateOftt__IPv6Address(soap, &this->tt__NetworkGateway::IPv6Address);
	/* transient soap skipped */
}

void tt__NetworkGateway::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOftt__IPv4Address(soap, &this->tt__NetworkGateway::IPv4Address);
	soap_serialize_std__vectorTemplateOftt__IPv6Address(soap, &this->tt__NetworkGateway::IPv6Address);
	/* transient soap skipped */
}

int tt__NetworkGateway::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkGateway(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkGateway(struct soap *soap, const char *tag, int id, const tt__NetworkGateway *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkGateway), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IPv4Address(soap, "tt:IPv4Address", -1, &(a->tt__NetworkGateway::IPv4Address), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IPv6Address(soap, "tt:IPv6Address", -1, &(a->tt__NetworkGateway::IPv6Address), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkGateway::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__NetworkGateway(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkGateway * SOAP_FMAC4 soap_in_tt__NetworkGateway(struct soap *soap, const char *tag, tt__NetworkGateway *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkGateway *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkGateway, sizeof(tt__NetworkGateway), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__NetworkGateway)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__NetworkGateway *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftt__IPv4Address(soap, "tt:IPv4Address", &(a->tt__NetworkGateway::IPv4Address), "tt:IPv4Address"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftt__IPv6Address(soap, "tt:IPv6Address", &(a->tt__NetworkGateway::IPv6Address), "tt:IPv6Address"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkGateway, 0, sizeof(tt__NetworkGateway), 0, soap_copy_tt__NetworkGateway);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__NetworkGateway::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__NetworkGateway);
	if (this->soap_out(soap, tag?tag:"tt:NetworkGateway", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkGateway::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkGateway(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkGateway * SOAP_FMAC4 soap_get_tt__NetworkGateway(struct soap *soap, tt__NetworkGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__NetworkGateway * SOAP_FMAC2 soap_instantiate_tt__NetworkGateway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkGateway(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__NetworkGateway, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkGateway);
		if (size)
			*size = sizeof(tt__NetworkGateway);
		((tt__NetworkGateway*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkGateway[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__NetworkGateway);
		for (int i = 0; i < n; i++)
			((tt__NetworkGateway*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__NetworkGateway*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__NetworkGateway(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__NetworkGateway %p -> %p\n", q, p));
	*(tt__NetworkGateway*)p = *(tt__NetworkGateway*)q;
}

void tt__IPv4NetworkInterfaceSetConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__IPv4NetworkInterfaceSetConfiguration::Enabled = NULL;
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4NetworkInterfaceSetConfiguration::Manual);
	this->tt__IPv4NetworkInterfaceSetConfiguration::DHCP = NULL;
	/* transient soap skipped */
}

void tt__IPv4NetworkInterfaceSetConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobool(soap, &this->tt__IPv4NetworkInterfaceSetConfiguration::Enabled);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4NetworkInterfaceSetConfiguration::Manual);
	soap_serialize_PointerTobool(soap, &this->tt__IPv4NetworkInterfaceSetConfiguration::DHCP);
	/* transient soap skipped */
}

int tt__IPv4NetworkInterfaceSetConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const tt__IPv4NetworkInterfaceSetConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Enabled", -1, &(a->tt__IPv4NetworkInterfaceSetConfiguration::Enabled), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:Manual", -1, &(a->tt__IPv4NetworkInterfaceSetConfiguration::Manual), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:DHCP", -1, &(a->tt__IPv4NetworkInterfaceSetConfiguration::DHCP), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__IPv4NetworkInterfaceSetConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, tt__IPv4NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv4NetworkInterfaceSetConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, sizeof(tt__IPv4NetworkInterfaceSetConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__IPv4NetworkInterfaceSetConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_DHCP1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "tt:Enabled", &(a->tt__IPv4NetworkInterfaceSetConfiguration::Enabled), "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:Manual", &(a->tt__IPv4NetworkInterfaceSetConfiguration::Manual), "tt:PrefixedIPv4Address"))
					continue;
			if (soap_flag_DHCP1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "tt:DHCP", &(a->tt__IPv4NetworkInterfaceSetConfiguration::DHCP), "xsd:boolean"))
				{	soap_flag_DHCP1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IPv4NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, 0, sizeof(tt__IPv4NetworkInterfaceSetConfiguration), 0, soap_copy_tt__IPv4NetworkInterfaceSetConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__IPv4NetworkInterfaceSetConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration);
	if (this->soap_out(soap, tag?tag:"tt:IPv4NetworkInterfaceSetConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv4NetworkInterfaceSetConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv4NetworkInterfaceSetConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv4NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv4NetworkInterfaceSetConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__IPv4NetworkInterfaceSetConfiguration);
		if (size)
			*size = sizeof(tt__IPv4NetworkInterfaceSetConfiguration);
		((tt__IPv4NetworkInterfaceSetConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__IPv4NetworkInterfaceSetConfiguration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__IPv4NetworkInterfaceSetConfiguration);
		for (int i = 0; i < n; i++)
			((tt__IPv4NetworkInterfaceSetConfiguration*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__IPv4NetworkInterfaceSetConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__IPv4NetworkInterfaceSetConfiguration %p -> %p\n", q, p));
	*(tt__IPv4NetworkInterfaceSetConfiguration*)p = *(tt__IPv4NetworkInterfaceSetConfiguration*)q;
}

void tt__IPv6NetworkInterfaceSetConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__IPv6NetworkInterfaceSetConfiguration::Enabled = NULL;
	this->tt__IPv6NetworkInterfaceSetConfiguration::AcceptRouterAdvert = NULL;
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6NetworkInterfaceSetConfiguration::Manual);
	this->tt__IPv6NetworkInterfaceSetConfiguration::DHCP = NULL;
	/* transient soap skipped */
}

void tt__IPv6NetworkInterfaceSetConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobool(soap, &this->tt__IPv6NetworkInterfaceSetConfiguration::Enabled);
	soap_serialize_PointerTobool(soap, &this->tt__IPv6NetworkInterfaceSetConfiguration::AcceptRouterAdvert);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6NetworkInterfaceSetConfiguration::Manual);
	soap_serialize_PointerTott__IPv6DHCPConfiguration(soap, &this->tt__IPv6NetworkInterfaceSetConfiguration::DHCP);
	/* transient soap skipped */
}

int tt__IPv6NetworkInterfaceSetConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const tt__IPv6NetworkInterfaceSetConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Enabled", -1, &(a->tt__IPv6NetworkInterfaceSetConfiguration::Enabled), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:AcceptRouterAdvert", -1, &(a->tt__IPv6NetworkInterfaceSetConfiguration::AcceptRouterAdvert), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:Manual", -1, &(a->tt__IPv6NetworkInterfaceSetConfiguration::Manual), ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6DHCPConfiguration(soap, "tt:DHCP", -1, &(a->tt__IPv6NetworkInterfaceSetConfiguration::DHCP), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__IPv6NetworkInterfaceSetConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, tt__IPv6NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv6NetworkInterfaceSetConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, sizeof(tt__IPv6NetworkInterfaceSetConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__IPv6NetworkInterfaceSetConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_AcceptRouterAdvert1 = 1;
	size_t soap_flag_DHCP1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "tt:Enabled", &(a->tt__IPv6NetworkInterfaceSetConfiguration::Enabled), "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			if (soap_flag_AcceptRouterAdvert1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "tt:AcceptRouterAdvert", &(a->tt__IPv6NetworkInterfaceSetConfiguration::AcceptRouterAdvert), "xsd:boolean"))
				{	soap_flag_AcceptRouterAdvert1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:Manual", &(a->tt__IPv6NetworkInterfaceSetConfiguration::Manual), "tt:PrefixedIPv6Address"))
					continue;
			if (soap_flag_DHCP1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv6DHCPConfiguration(soap, "tt:DHCP", &(a->tt__IPv6NetworkInterfaceSetConfiguration::DHCP), "tt:IPv6DHCPConfiguration"))
				{	soap_flag_DHCP1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IPv6NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, 0, sizeof(tt__IPv6NetworkInterfaceSetConfiguration), 0, soap_copy_tt__IPv6NetworkInterfaceSetConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__IPv6NetworkInterfaceSetConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration);
	if (this->soap_out(soap, tag?tag:"tt:IPv6NetworkInterfaceSetConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv6NetworkInterfaceSetConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv6NetworkInterfaceSetConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv6NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv6NetworkInterfaceSetConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__IPv6NetworkInterfaceSetConfiguration);
		if (size)
			*size = sizeof(tt__IPv6NetworkInterfaceSetConfiguration);
		((tt__IPv6NetworkInterfaceSetConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__IPv6NetworkInterfaceSetConfiguration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__IPv6NetworkInterfaceSetConfiguration);
		for (int i = 0; i < n; i++)
			((tt__IPv6NetworkInterfaceSetConfiguration*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__IPv6NetworkInterfaceSetConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__IPv6NetworkInterfaceSetConfiguration %p -> %p\n", q, p));
	*(tt__IPv6NetworkInterfaceSetConfiguration*)p = *(tt__IPv6NetworkInterfaceSetConfiguration*)q;
}

void tt__NetworkInterfaceSetConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkInterfaceSetConfigurationExtension::__any);
	/* transient soap skipped */
}

void tt__NetworkInterfaceSetConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkInterfaceSetConfigurationExtension::__any);
	/* transient soap skipped */
}

int tt__NetworkInterfaceSetConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceSetConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__NetworkInterfaceSetConfigurationExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceSetConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC4 soap_in_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, tt__NetworkInterfaceSetConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceSetConfigurationExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, sizeof(tt__NetworkInterfaceSetConfigurationExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__NetworkInterfaceSetConfigurationExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__NetworkInterfaceSetConfigurationExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceSetConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, 0, sizeof(tt__NetworkInterfaceSetConfigurationExtension), 0, soap_copy_tt__NetworkInterfaceSetConfigurationExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__NetworkInterfaceSetConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension);
	if (this->soap_out(soap, tag?tag:"tt:NetworkInterfaceSetConfigurationExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceSetConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceSetConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC4 soap_get_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkInterfaceSetConfigurationExtension);
		if (size)
			*size = sizeof(tt__NetworkInterfaceSetConfigurationExtension);
		((tt__NetworkInterfaceSetConfigurationExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkInterfaceSetConfigurationExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__NetworkInterfaceSetConfigurationExtension);
		for (int i = 0; i < n; i++)
			((tt__NetworkInterfaceSetConfigurationExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__NetworkInterfaceSetConfigurationExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__NetworkInterfaceSetConfigurationExtension %p -> %p\n", q, p));
	*(tt__NetworkInterfaceSetConfigurationExtension*)p = *(tt__NetworkInterfaceSetConfigurationExtension*)q;
}

void tt__NetworkInterfaceSetConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__NetworkInterfaceSetConfiguration::Enabled = NULL;
	this->tt__NetworkInterfaceSetConfiguration::Link = NULL;
	this->tt__NetworkInterfaceSetConfiguration::MTU = NULL;
	this->tt__NetworkInterfaceSetConfiguration::IPv4 = NULL;
	this->tt__NetworkInterfaceSetConfiguration::IPv6 = NULL;
	this->tt__NetworkInterfaceSetConfiguration::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__NetworkInterfaceSetConfiguration::__anyAttribute);
	/* transient soap skipped */
}

void tt__NetworkInterfaceSetConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobool(soap, &this->tt__NetworkInterfaceSetConfiguration::Enabled);
	soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, &this->tt__NetworkInterfaceSetConfiguration::Link);
	soap_serialize_PointerToint(soap, &this->tt__NetworkInterfaceSetConfiguration::MTU);
	soap_serialize_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, &this->tt__NetworkInterfaceSetConfiguration::IPv4);
	soap_serialize_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, &this->tt__NetworkInterfaceSetConfiguration::IPv6);
	soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, &this->tt__NetworkInterfaceSetConfiguration::Extension);
	/* transient soap skipped */
}

int tt__NetworkInterfaceSetConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceSetConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceSetConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__NetworkInterfaceSetConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Enabled", -1, &(a->tt__NetworkInterfaceSetConfiguration::Enabled), ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:Link", -1, &(a->tt__NetworkInterfaceSetConfiguration::Link), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:MTU", -1, &(a->tt__NetworkInterfaceSetConfiguration::MTU), ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, "tt:IPv4", -1, &(a->tt__NetworkInterfaceSetConfiguration::IPv4), ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, "tt:IPv6", -1, &(a->tt__NetworkInterfaceSetConfiguration::IPv6), ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, "tt:Extension", -1, &(a->tt__NetworkInterfaceSetConfiguration::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceSetConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__NetworkInterfaceSetConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, tt__NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceSetConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, sizeof(tt__NetworkInterfaceSetConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__NetworkInterfaceSetConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__NetworkInterfaceSetConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__NetworkInterfaceSetConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Link1 = 1;
	size_t soap_flag_MTU1 = 1;
	size_t soap_flag_IPv41 = 1;
	size_t soap_flag_IPv61 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "tt:Enabled", &(a->tt__NetworkInterfaceSetConfiguration::Enabled), "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			if (soap_flag_Link1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:Link", &(a->tt__NetworkInterfaceSetConfiguration::Link), "tt:NetworkInterfaceConnectionSetting"))
				{	soap_flag_Link1--;
					continue;
				}
			if (soap_flag_MTU1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:MTU", &(a->tt__NetworkInterfaceSetConfiguration::MTU), "xsd:int"))
				{	soap_flag_MTU1--;
					continue;
				}
			if (soap_flag_IPv41 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, "tt:IPv4", &(a->tt__NetworkInterfaceSetConfiguration::IPv4), "tt:IPv4NetworkInterfaceSetConfiguration"))
				{	soap_flag_IPv41--;
					continue;
				}
			if (soap_flag_IPv61 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, "tt:IPv6", &(a->tt__NetworkInterfaceSetConfiguration::IPv6), "tt:IPv6NetworkInterfaceSetConfiguration"))
				{	soap_flag_IPv61--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, "tt:Extension", &(a->tt__NetworkInterfaceSetConfiguration::Extension), "tt:NetworkInterfaceSetConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, 0, sizeof(tt__NetworkInterfaceSetConfiguration), 0, soap_copy_tt__NetworkInterfaceSetConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__NetworkInterfaceSetConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration);
	if (this->soap_out(soap, tag?tag:"tt:NetworkInterfaceSetConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceSetConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceSetConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_tt__NetworkInterfaceSetConfiguration(struct soap *soap, tt__NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceSetConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkInterfaceSetConfiguration);
		if (size)
			*size = sizeof(tt__NetworkInterfaceSetConfiguration);
		((tt__NetworkInterfaceSetConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkInterfaceSetConfiguration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__NetworkInterfaceSetConfiguration);
		for (int i = 0; i < n; i++)
			((tt__NetworkInterfaceSetConfiguration*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__NetworkInterfaceSetConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__NetworkInterfaceSetConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__NetworkInterfaceSetConfiguration %p -> %p\n", q, p));
	*(tt__NetworkInterfaceSetConfiguration*)p = *(tt__NetworkInterfaceSetConfiguration*)q;
}

void tt__DynamicDNSInformationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DynamicDNSInformationExtension::__any);
	/* transient soap skipped */
}

void tt__DynamicDNSInformationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DynamicDNSInformationExtension::__any);
	/* transient soap skipped */
}

int tt__DynamicDNSInformationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DynamicDNSInformationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DynamicDNSInformationExtension(struct soap *soap, const char *tag, int id, const tt__DynamicDNSInformationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DynamicDNSInformationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__DynamicDNSInformationExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__DynamicDNSInformationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__DynamicDNSInformationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__DynamicDNSInformationExtension * SOAP_FMAC4 soap_in_tt__DynamicDNSInformationExtension(struct soap *soap, const char *tag, tt__DynamicDNSInformationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DynamicDNSInformationExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSInformationExtension, sizeof(tt__DynamicDNSInformationExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__DynamicDNSInformationExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__DynamicDNSInformationExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__DynamicDNSInformationExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__DynamicDNSInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DynamicDNSInformationExtension, 0, sizeof(tt__DynamicDNSInformationExtension), 0, soap_copy_tt__DynamicDNSInformationExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__DynamicDNSInformationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__DynamicDNSInformationExtension);
	if (this->soap_out(soap, tag?tag:"tt:DynamicDNSInformationExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DynamicDNSInformationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DynamicDNSInformationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__DynamicDNSInformationExtension * SOAP_FMAC4 soap_get_tt__DynamicDNSInformationExtension(struct soap *soap, tt__DynamicDNSInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DynamicDNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__DynamicDNSInformationExtension * SOAP_FMAC2 soap_instantiate_tt__DynamicDNSInformationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DynamicDNSInformationExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__DynamicDNSInformationExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__DynamicDNSInformationExtension);
		if (size)
			*size = sizeof(tt__DynamicDNSInformationExtension);
		((tt__DynamicDNSInformationExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__DynamicDNSInformationExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__DynamicDNSInformationExtension);
		for (int i = 0; i < n; i++)
			((tt__DynamicDNSInformationExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__DynamicDNSInformationExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__DynamicDNSInformationExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__DynamicDNSInformationExtension %p -> %p\n", q, p));
	*(tt__DynamicDNSInformationExtension*)p = *(tt__DynamicDNSInformationExtension*)q;
}

void tt__DynamicDNSInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__DynamicDNSType(soap, &this->tt__DynamicDNSInformation::Type);
	this->tt__DynamicDNSInformation::Name = NULL;
	this->tt__DynamicDNSInformation::TTL = NULL;
	this->tt__DynamicDNSInformation::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__DynamicDNSInformation::__anyAttribute);
	/* transient soap skipped */
}

void tt__DynamicDNSInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__DNSName(soap, &this->tt__DynamicDNSInformation::Name);
	soap_serialize_PointerToxsd__duration(soap, &this->tt__DynamicDNSInformation::TTL);
	soap_serialize_PointerTott__DynamicDNSInformationExtension(soap, &this->tt__DynamicDNSInformation::Extension);
	/* transient soap skipped */
}

int tt__DynamicDNSInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DynamicDNSInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DynamicDNSInformation(struct soap *soap, const char *tag, int id, const tt__DynamicDNSInformation *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__DynamicDNSInformation*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DynamicDNSInformation), type))
		return soap->error;
	if (soap_out_tt__DynamicDNSType(soap, "tt:Type", -1, &(a->tt__DynamicDNSInformation::Type), ""))
		return soap->error;
	if (soap_out_PointerTott__DNSName(soap, "tt:Name", -1, &(a->tt__DynamicDNSInformation::Name), ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tt:TTL", -1, &(a->tt__DynamicDNSInformation::TTL), ""))
		return soap->error;
	if (soap_out_PointerTott__DynamicDNSInformationExtension(soap, "tt:Extension", -1, &(a->tt__DynamicDNSInformation::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__DynamicDNSInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__DynamicDNSInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__DynamicDNSInformation * SOAP_FMAC4 soap_in_tt__DynamicDNSInformation(struct soap *soap, const char *tag, tt__DynamicDNSInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DynamicDNSInformation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSInformation, sizeof(tt__DynamicDNSInformation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__DynamicDNSInformation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__DynamicDNSInformation *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__DynamicDNSInformation*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_TTL1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__DynamicDNSType(soap, "tt:Type", &(a->tt__DynamicDNSInformation::Type), "tt:DynamicDNSType"))
				{	soap_flag_Type1--;
					continue;
				}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTott__DNSName(soap, "tt:Name", &(a->tt__DynamicDNSInformation::Name), "tt:DNSName"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_TTL1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "tt:TTL", &(a->tt__DynamicDNSInformation::TTL), "xsd:duration"))
				{	soap_flag_TTL1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DynamicDNSInformationExtension(soap, "tt:Extension", &(a->tt__DynamicDNSInformation::Extension), "tt:DynamicDNSInformationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__DynamicDNSInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DynamicDNSInformation, 0, sizeof(tt__DynamicDNSInformation), 0, soap_copy_tt__DynamicDNSInformation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__DynamicDNSInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__DynamicDNSInformation);
	if (this->soap_out(soap, tag?tag:"tt:DynamicDNSInformation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DynamicDNSInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DynamicDNSInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__DynamicDNSInformation * SOAP_FMAC4 soap_get_tt__DynamicDNSInformation(struct soap *soap, tt__DynamicDNSInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DynamicDNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__DynamicDNSInformation * SOAP_FMAC2 soap_instantiate_tt__DynamicDNSInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DynamicDNSInformation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__DynamicDNSInformation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__DynamicDNSInformation);
		if (size)
			*size = sizeof(tt__DynamicDNSInformation);
		((tt__DynamicDNSInformation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__DynamicDNSInformation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__DynamicDNSInformation);
		for (int i = 0; i < n; i++)
			((tt__DynamicDNSInformation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__DynamicDNSInformation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__DynamicDNSInformation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__DynamicDNSInformation %p -> %p\n", q, p));
	*(tt__DynamicDNSInformation*)p = *(tt__DynamicDNSInformation*)q;
}

void tt__NTPInformationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NTPInformationExtension::__any);
	/* transient soap skipped */
}

void tt__NTPInformationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NTPInformationExtension::__any);
	/* transient soap skipped */
}

int tt__NTPInformationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NTPInformationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NTPInformationExtension(struct soap *soap, const char *tag, int id, const tt__NTPInformationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NTPInformationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__NTPInformationExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__NTPInformationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__NTPInformationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NTPInformationExtension * SOAP_FMAC4 soap_in_tt__NTPInformationExtension(struct soap *soap, const char *tag, tt__NTPInformationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NTPInformationExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NTPInformationExtension, sizeof(tt__NTPInformationExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__NTPInformationExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__NTPInformationExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__NTPInformationExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NTPInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NTPInformationExtension, 0, sizeof(tt__NTPInformationExtension), 0, soap_copy_tt__NTPInformationExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__NTPInformationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__NTPInformationExtension);
	if (this->soap_out(soap, tag?tag:"tt:NTPInformationExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NTPInformationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NTPInformationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NTPInformationExtension * SOAP_FMAC4 soap_get_tt__NTPInformationExtension(struct soap *soap, tt__NTPInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NTPInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__NTPInformationExtension * SOAP_FMAC2 soap_instantiate_tt__NTPInformationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NTPInformationExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__NTPInformationExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__NTPInformationExtension);
		if (size)
			*size = sizeof(tt__NTPInformationExtension);
		((tt__NTPInformationExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__NTPInformationExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__NTPInformationExtension);
		for (int i = 0; i < n; i++)
			((tt__NTPInformationExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__NTPInformationExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__NTPInformationExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__NTPInformationExtension %p -> %p\n", q, p));
	*(tt__NTPInformationExtension*)p = *(tt__NTPInformationExtension*)q;
}

void tt__NTPInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__NTPInformation::FromDHCP);
	soap_default_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->tt__NTPInformation::NTPFromDHCP);
	soap_default_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->tt__NTPInformation::NTPManual);
	this->tt__NTPInformation::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__NTPInformation::__anyAttribute);
	/* transient soap skipped */
}

void tt__NTPInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__NTPInformation::FromDHCP, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->tt__NTPInformation::NTPFromDHCP);
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->tt__NTPInformation::NTPManual);
	soap_serialize_PointerTott__NTPInformationExtension(soap, &this->tt__NTPInformation::Extension);
	/* transient soap skipped */
}

int tt__NTPInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NTPInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NTPInformation(struct soap *soap, const char *tag, int id, const tt__NTPInformation *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__NTPInformation*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NTPInformation), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:FromDHCP", -1, &(a->tt__NTPInformation::FromDHCP), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tt:NTPFromDHCP", -1, &(a->tt__NTPInformation::NTPFromDHCP), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tt:NTPManual", -1, &(a->tt__NTPInformation::NTPManual), ""))
		return soap->error;
	if (soap_out_PointerTott__NTPInformationExtension(soap, "tt:Extension", -1, &(a->tt__NTPInformation::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__NTPInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__NTPInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__NTPInformation * SOAP_FMAC4 soap_in_tt__NTPInformation(struct soap *soap, const char *tag, tt__NTPInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NTPInformation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NTPInformation, sizeof(tt__NTPInformation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__NTPInformation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__NTPInformation *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__NTPInformation*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_FromDHCP1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:FromDHCP", &(a->tt__NTPInformation::FromDHCP), "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tt:NTPFromDHCP", &(a->tt__NTPInformation::NTPFromDHCP), "tt:NetworkHost"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tt:NTPManual", &(a->tt__NTPInformation::NTPManual), "tt:NetworkHost"))
					continue;
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NTPInformationExtension(soap, "tt:Extension", &(a->tt__NTPInformation::Extension), "tt:NTPInformationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NTPInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NTPInformation, 0, sizeof(tt__NTPInformation), 0, soap_copy_tt__NTPInformation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__NTPInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__NTPInformation);
	if (this->soap_out(soap, tag?tag:"tt:NTPInformation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NTPInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NTPInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__NTPInformation * SOAP_FMAC4 soap_get_tt__NTPInformation(struct soap *soap, tt__NTPInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NTPInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__NTPInformation * SOAP_FMAC2 soap_instantiate_tt__NTPInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NTPInformation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__NTPInformation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__NTPInformation);
		if (size)
			*size = sizeof(tt__NTPInformation);
		((tt__NTPInformation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__NTPInformation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__NTPInformation);
		for (int i = 0; i < n; i++)
			((tt__NTPInformation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__NTPInformation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__NTPInformation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__NTPInformation %p -> %p\n", q, p));
	*(tt__NTPInformation*)p = *(tt__NTPInformation*)q;
}

void tt__DNSInformationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DNSInformationExtension::__any);
	/* transient soap skipped */
}

void tt__DNSInformationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__DNSInformationExtension::__any);
	/* transient soap skipped */
}

int tt__DNSInformationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DNSInformationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DNSInformationExtension(struct soap *soap, const char *tag, int id, const tt__DNSInformationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DNSInformationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__DNSInformationExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__DNSInformationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__DNSInformationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__DNSInformationExtension * SOAP_FMAC4 soap_in_tt__DNSInformationExtension(struct soap *soap, const char *tag, tt__DNSInformationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DNSInformationExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DNSInformationExtension, sizeof(tt__DNSInformationExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__DNSInformationExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__DNSInformationExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__DNSInformationExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__DNSInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DNSInformationExtension, 0, sizeof(tt__DNSInformationExtension), 0, soap_copy_tt__DNSInformationExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__DNSInformationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__DNSInformationExtension);
	if (this->soap_out(soap, tag?tag:"tt:DNSInformationExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DNSInformationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DNSInformationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__DNSInformationExtension * SOAP_FMAC4 soap_get_tt__DNSInformationExtension(struct soap *soap, tt__DNSInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__DNSInformationExtension * SOAP_FMAC2 soap_instantiate_tt__DNSInformationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DNSInformationExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__DNSInformationExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__DNSInformationExtension);
		if (size)
			*size = sizeof(tt__DNSInformationExtension);
		((tt__DNSInformationExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__DNSInformationExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__DNSInformationExtension);
		for (int i = 0; i < n; i++)
			((tt__DNSInformationExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__DNSInformationExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__DNSInformationExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__DNSInformationExtension %p -> %p\n", q, p));
	*(tt__DNSInformationExtension*)p = *(tt__DNSInformationExtension*)q;
}

void tt__DNSInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__DNSInformation::FromDHCP);
	soap_default_std__vectorTemplateOfxsd__token(soap, &this->tt__DNSInformation::SearchDomain);
	soap_default_std__vectorTemplateOfPointerTott__IPAddress(soap, &this->tt__DNSInformation::DNSFromDHCP);
	soap_default_std__vectorTemplateOfPointerTott__IPAddress(soap, &this->tt__DNSInformation::DNSManual);
	this->tt__DNSInformation::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__DNSInformation::__anyAttribute);
	/* transient soap skipped */
}

void tt__DNSInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__DNSInformation::FromDHCP, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__token(soap, &this->tt__DNSInformation::SearchDomain);
	soap_serialize_std__vectorTemplateOfPointerTott__IPAddress(soap, &this->tt__DNSInformation::DNSFromDHCP);
	soap_serialize_std__vectorTemplateOfPointerTott__IPAddress(soap, &this->tt__DNSInformation::DNSManual);
	soap_serialize_PointerTott__DNSInformationExtension(soap, &this->tt__DNSInformation::Extension);
	/* transient soap skipped */
}

int tt__DNSInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DNSInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DNSInformation(struct soap *soap, const char *tag, int id, const tt__DNSInformation *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__DNSInformation*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DNSInformation), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:FromDHCP", -1, &(a->tt__DNSInformation::FromDHCP), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__token(soap, "tt:SearchDomain", -1, &(a->tt__DNSInformation::SearchDomain), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__IPAddress(soap, "tt:DNSFromDHCP", -1, &(a->tt__DNSInformation::DNSFromDHCP), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__IPAddress(soap, "tt:DNSManual", -1, &(a->tt__DNSInformation::DNSManual), ""))
		return soap->error;
	if (soap_out_PointerTott__DNSInformationExtension(soap, "tt:Extension", -1, &(a->tt__DNSInformation::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__DNSInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__DNSInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__DNSInformation * SOAP_FMAC4 soap_in_tt__DNSInformation(struct soap *soap, const char *tag, tt__DNSInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DNSInformation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DNSInformation, sizeof(tt__DNSInformation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__DNSInformation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__DNSInformation *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__DNSInformation*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_FromDHCP1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:FromDHCP", &(a->tt__DNSInformation::FromDHCP), "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__token(soap, "tt:SearchDomain", &(a->tt__DNSInformation::SearchDomain), "xsd:token"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__IPAddress(soap, "tt:DNSFromDHCP", &(a->tt__DNSInformation::DNSFromDHCP), "tt:IPAddress"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__IPAddress(soap, "tt:DNSManual", &(a->tt__DNSInformation::DNSManual), "tt:IPAddress"))
					continue;
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DNSInformationExtension(soap, "tt:Extension", &(a->tt__DNSInformation::Extension), "tt:DNSInformationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__DNSInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DNSInformation, 0, sizeof(tt__DNSInformation), 0, soap_copy_tt__DNSInformation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__DNSInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__DNSInformation);
	if (this->soap_out(soap, tag?tag:"tt:DNSInformation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DNSInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DNSInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__DNSInformation * SOAP_FMAC4 soap_get_tt__DNSInformation(struct soap *soap, tt__DNSInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__DNSInformation * SOAP_FMAC2 soap_instantiate_tt__DNSInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DNSInformation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__DNSInformation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__DNSInformation);
		if (size)
			*size = sizeof(tt__DNSInformation);
		((tt__DNSInformation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__DNSInformation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__DNSInformation);
		for (int i = 0; i < n; i++)
			((tt__DNSInformation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__DNSInformation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__DNSInformation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__DNSInformation %p -> %p\n", q, p));
	*(tt__DNSInformation*)p = *(tt__DNSInformation*)q;
}

void tt__HostnameInformationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__HostnameInformationExtension::__any);
	/* transient soap skipped */
}

void tt__HostnameInformationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__HostnameInformationExtension::__any);
	/* transient soap skipped */
}

int tt__HostnameInformationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__HostnameInformationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__HostnameInformationExtension(struct soap *soap, const char *tag, int id, const tt__HostnameInformationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__HostnameInformationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__HostnameInformationExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__HostnameInformationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__HostnameInformationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__HostnameInformationExtension * SOAP_FMAC4 soap_in_tt__HostnameInformationExtension(struct soap *soap, const char *tag, tt__HostnameInformationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__HostnameInformationExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__HostnameInformationExtension, sizeof(tt__HostnameInformationExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__HostnameInformationExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__HostnameInformationExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__HostnameInformationExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__HostnameInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__HostnameInformationExtension, 0, sizeof(tt__HostnameInformationExtension), 0, soap_copy_tt__HostnameInformationExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__HostnameInformationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__HostnameInformationExtension);
	if (this->soap_out(soap, tag?tag:"tt:HostnameInformationExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__HostnameInformationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__HostnameInformationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__HostnameInformationExtension * SOAP_FMAC4 soap_get_tt__HostnameInformationExtension(struct soap *soap, tt__HostnameInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__HostnameInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__HostnameInformationExtension * SOAP_FMAC2 soap_instantiate_tt__HostnameInformationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__HostnameInformationExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__HostnameInformationExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__HostnameInformationExtension);
		if (size)
			*size = sizeof(tt__HostnameInformationExtension);
		((tt__HostnameInformationExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__HostnameInformationExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__HostnameInformationExtension);
		for (int i = 0; i < n; i++)
			((tt__HostnameInformationExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__HostnameInformationExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__HostnameInformationExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__HostnameInformationExtension %p -> %p\n", q, p));
	*(tt__HostnameInformationExtension*)p = *(tt__HostnameInformationExtension*)q;
}

void tt__HostnameInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__HostnameInformation::FromDHCP);
	this->tt__HostnameInformation::Name = NULL;
	this->tt__HostnameInformation::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__HostnameInformation::__anyAttribute);
	/* transient soap skipped */
}

void tt__HostnameInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__HostnameInformation::FromDHCP, SOAP_TYPE_bool);
	soap_serialize_PointerToxsd__token(soap, &this->tt__HostnameInformation::Name);
	soap_serialize_PointerTott__HostnameInformationExtension(soap, &this->tt__HostnameInformation::Extension);
	/* transient soap skipped */
}

int tt__HostnameInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__HostnameInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__HostnameInformation(struct soap *soap, const char *tag, int id, const tt__HostnameInformation *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__HostnameInformation*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__HostnameInformation), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:FromDHCP", -1, &(a->tt__HostnameInformation::FromDHCP), ""))
		return soap->error;
	if (soap_out_PointerToxsd__token(soap, "tt:Name", -1, &(a->tt__HostnameInformation::Name), ""))
		return soap->error;
	if (soap_out_PointerTott__HostnameInformationExtension(soap, "tt:Extension", -1, &(a->tt__HostnameInformation::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__HostnameInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__HostnameInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__HostnameInformation * SOAP_FMAC4 soap_in_tt__HostnameInformation(struct soap *soap, const char *tag, tt__HostnameInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__HostnameInformation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__HostnameInformation, sizeof(tt__HostnameInformation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__HostnameInformation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__HostnameInformation *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__HostnameInformation*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_FromDHCP1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:FromDHCP", &(a->tt__HostnameInformation::FromDHCP), "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__token(soap, "tt:Name", &(a->tt__HostnameInformation::Name), "xsd:token"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__HostnameInformationExtension(soap, "tt:Extension", &(a->tt__HostnameInformation::Extension), "tt:HostnameInformationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__HostnameInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__HostnameInformation, 0, sizeof(tt__HostnameInformation), 0, soap_copy_tt__HostnameInformation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__HostnameInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__HostnameInformation);
	if (this->soap_out(soap, tag?tag:"tt:HostnameInformation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__HostnameInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__HostnameInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__HostnameInformation * SOAP_FMAC4 soap_get_tt__HostnameInformation(struct soap *soap, tt__HostnameInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__HostnameInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__HostnameInformation * SOAP_FMAC2 soap_instantiate_tt__HostnameInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__HostnameInformation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__HostnameInformation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__HostnameInformation);
		if (size)
			*size = sizeof(tt__HostnameInformation);
		((tt__HostnameInformation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__HostnameInformation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__HostnameInformation);
		for (int i = 0; i < n; i++)
			((tt__HostnameInformation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__HostnameInformation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__HostnameInformation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__HostnameInformation %p -> %p\n", q, p));
	*(tt__HostnameInformation*)p = *(tt__HostnameInformation*)q;
}

void tt__PrefixedIPv6Address::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__IPv6Address(soap, &this->tt__PrefixedIPv6Address::Address);
	soap_default_int(soap, &this->tt__PrefixedIPv6Address::PrefixLength);
	/* transient soap skipped */
}

void tt__PrefixedIPv6Address::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__PrefixedIPv6Address::Address, SOAP_TYPE_tt__IPv6Address);
	soap_serialize_tt__IPv6Address(soap, &this->tt__PrefixedIPv6Address::Address);
	soap_embedded(soap, &this->tt__PrefixedIPv6Address::PrefixLength, SOAP_TYPE_int);
	/* transient soap skipped */
}

int tt__PrefixedIPv6Address::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PrefixedIPv6Address(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PrefixedIPv6Address(struct soap *soap, const char *tag, int id, const tt__PrefixedIPv6Address *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PrefixedIPv6Address), type))
		return soap->error;
	if (soap_out_tt__IPv6Address(soap, "tt:Address", -1, &(a->tt__PrefixedIPv6Address::Address), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:PrefixLength", -1, &(a->tt__PrefixedIPv6Address::PrefixLength), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__PrefixedIPv6Address::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__PrefixedIPv6Address(soap, tag, this, type);
}

SOAP_FMAC3 tt__PrefixedIPv6Address * SOAP_FMAC4 soap_in_tt__PrefixedIPv6Address(struct soap *soap, const char *tag, tt__PrefixedIPv6Address *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PrefixedIPv6Address *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PrefixedIPv6Address, sizeof(tt__PrefixedIPv6Address), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__PrefixedIPv6Address)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__PrefixedIPv6Address *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Address1 = 1;
	size_t soap_flag_PrefixLength1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__IPv6Address(soap, "tt:Address", &(a->tt__PrefixedIPv6Address::Address), "tt:IPv6Address"))
				{	soap_flag_Address1--;
					continue;
				}
			if (soap_flag_PrefixLength1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:PrefixLength", &(a->tt__PrefixedIPv6Address::PrefixLength), "xsd:int"))
				{	soap_flag_PrefixLength1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PrefixedIPv6Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PrefixedIPv6Address, 0, sizeof(tt__PrefixedIPv6Address), 0, soap_copy_tt__PrefixedIPv6Address);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address1 > 0 || soap_flag_PrefixLength1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__PrefixedIPv6Address::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__PrefixedIPv6Address);
	if (this->soap_out(soap, tag?tag:"tt:PrefixedIPv6Address", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PrefixedIPv6Address::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PrefixedIPv6Address(soap, this, tag, type);
}

SOAP_FMAC3 tt__PrefixedIPv6Address * SOAP_FMAC4 soap_get_tt__PrefixedIPv6Address(struct soap *soap, tt__PrefixedIPv6Address *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PrefixedIPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__PrefixedIPv6Address * SOAP_FMAC2 soap_instantiate_tt__PrefixedIPv6Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PrefixedIPv6Address(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__PrefixedIPv6Address, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__PrefixedIPv6Address);
		if (size)
			*size = sizeof(tt__PrefixedIPv6Address);
		((tt__PrefixedIPv6Address*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__PrefixedIPv6Address[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__PrefixedIPv6Address);
		for (int i = 0; i < n; i++)
			((tt__PrefixedIPv6Address*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__PrefixedIPv6Address*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__PrefixedIPv6Address(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__PrefixedIPv6Address %p -> %p\n", q, p));
	*(tt__PrefixedIPv6Address*)p = *(tt__PrefixedIPv6Address*)q;
}

void tt__PrefixedIPv4Address::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__IPv4Address(soap, &this->tt__PrefixedIPv4Address::Address);
	soap_default_int(soap, &this->tt__PrefixedIPv4Address::PrefixLength);
	/* transient soap skipped */
}

void tt__PrefixedIPv4Address::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__PrefixedIPv4Address::Address, SOAP_TYPE_tt__IPv4Address);
	soap_serialize_tt__IPv4Address(soap, &this->tt__PrefixedIPv4Address::Address);
	soap_embedded(soap, &this->tt__PrefixedIPv4Address::PrefixLength, SOAP_TYPE_int);
	/* transient soap skipped */
}

int tt__PrefixedIPv4Address::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PrefixedIPv4Address(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PrefixedIPv4Address(struct soap *soap, const char *tag, int id, const tt__PrefixedIPv4Address *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PrefixedIPv4Address), type))
		return soap->error;
	if (soap_out_tt__IPv4Address(soap, "tt:Address", -1, &(a->tt__PrefixedIPv4Address::Address), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:PrefixLength", -1, &(a->tt__PrefixedIPv4Address::PrefixLength), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__PrefixedIPv4Address::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__PrefixedIPv4Address(soap, tag, this, type);
}

SOAP_FMAC3 tt__PrefixedIPv4Address * SOAP_FMAC4 soap_in_tt__PrefixedIPv4Address(struct soap *soap, const char *tag, tt__PrefixedIPv4Address *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PrefixedIPv4Address *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PrefixedIPv4Address, sizeof(tt__PrefixedIPv4Address), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__PrefixedIPv4Address)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__PrefixedIPv4Address *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Address1 = 1;
	size_t soap_flag_PrefixLength1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__IPv4Address(soap, "tt:Address", &(a->tt__PrefixedIPv4Address::Address), "tt:IPv4Address"))
				{	soap_flag_Address1--;
					continue;
				}
			if (soap_flag_PrefixLength1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:PrefixLength", &(a->tt__PrefixedIPv4Address::PrefixLength), "xsd:int"))
				{	soap_flag_PrefixLength1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PrefixedIPv4Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PrefixedIPv4Address, 0, sizeof(tt__PrefixedIPv4Address), 0, soap_copy_tt__PrefixedIPv4Address);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address1 > 0 || soap_flag_PrefixLength1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__PrefixedIPv4Address::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__PrefixedIPv4Address);
	if (this->soap_out(soap, tag?tag:"tt:PrefixedIPv4Address", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PrefixedIPv4Address::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PrefixedIPv4Address(soap, this, tag, type);
}

SOAP_FMAC3 tt__PrefixedIPv4Address * SOAP_FMAC4 soap_get_tt__PrefixedIPv4Address(struct soap *soap, tt__PrefixedIPv4Address *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PrefixedIPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__PrefixedIPv4Address * SOAP_FMAC2 soap_instantiate_tt__PrefixedIPv4Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PrefixedIPv4Address(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__PrefixedIPv4Address, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__PrefixedIPv4Address);
		if (size)
			*size = sizeof(tt__PrefixedIPv4Address);
		((tt__PrefixedIPv4Address*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__PrefixedIPv4Address[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__PrefixedIPv4Address);
		for (int i = 0; i < n; i++)
			((tt__PrefixedIPv4Address*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__PrefixedIPv4Address*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__PrefixedIPv4Address(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__PrefixedIPv4Address %p -> %p\n", q, p));
	*(tt__PrefixedIPv4Address*)p = *(tt__PrefixedIPv4Address*)q;
}

void tt__IPAddress::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__IPType(soap, &this->tt__IPAddress::Type);
	this->tt__IPAddress::IPv4Address = NULL;
	this->tt__IPAddress::IPv6Address = NULL;
	/* transient soap skipped */
}

void tt__IPAddress::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IPv4Address(soap, &this->tt__IPAddress::IPv4Address);
	soap_serialize_PointerTott__IPv6Address(soap, &this->tt__IPAddress::IPv6Address);
	/* transient soap skipped */
}

int tt__IPAddress::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPAddress(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddress(struct soap *soap, const char *tag, int id, const tt__IPAddress *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddress), type))
		return soap->error;
	if (soap_out_tt__IPType(soap, "tt:Type", -1, &(a->tt__IPAddress::Type), ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4Address(soap, "tt:IPv4Address", -1, &(a->tt__IPAddress::IPv4Address), ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6Address(soap, "tt:IPv6Address", -1, &(a->tt__IPAddress::IPv6Address), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__IPAddress::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__IPAddress(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPAddress * SOAP_FMAC4 soap_in_tt__IPAddress(struct soap *soap, const char *tag, tt__IPAddress *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPAddress *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddress, sizeof(tt__IPAddress), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__IPAddress)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__IPAddress *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_IPv4Address1 = 1;
	size_t soap_flag_IPv6Address1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__IPType(soap, "tt:Type", &(a->tt__IPAddress::Type), "tt:IPType"))
				{	soap_flag_Type1--;
					continue;
				}
			if (soap_flag_IPv4Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTott__IPv4Address(soap, "tt:IPv4Address", &(a->tt__IPAddress::IPv4Address), "tt:IPv4Address"))
				{	soap_flag_IPv4Address1--;
					continue;
				}
			if (soap_flag_IPv6Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTott__IPv6Address(soap, "tt:IPv6Address", &(a->tt__IPAddress::IPv6Address), "tt:IPv6Address"))
				{	soap_flag_IPv6Address1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IPAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddress, 0, sizeof(tt__IPAddress), 0, soap_copy_tt__IPAddress);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__IPAddress::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__IPAddress);
	if (this->soap_out(soap, tag?tag:"tt:IPAddress", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPAddress::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPAddress(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPAddress * SOAP_FMAC4 soap_get_tt__IPAddress(struct soap *soap, tt__IPAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__IPAddress * SOAP_FMAC2 soap_instantiate_tt__IPAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPAddress(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__IPAddress, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__IPAddress);
		if (size)
			*size = sizeof(tt__IPAddress);
		((tt__IPAddress*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__IPAddress[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__IPAddress);
		for (int i = 0; i < n; i++)
			((tt__IPAddress*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__IPAddress*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__IPAddress(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__IPAddress %p -> %p\n", q, p));
	*(tt__IPAddress*)p = *(tt__IPAddress*)q;
}

void tt__NetworkHostExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkHostExtension::__any);
	/* transient soap skipped */
}

void tt__NetworkHostExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkHostExtension::__any);
	/* transient soap skipped */
}

int tt__NetworkHostExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkHostExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkHostExtension(struct soap *soap, const char *tag, int id, const tt__NetworkHostExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkHostExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__NetworkHostExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkHostExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__NetworkHostExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkHostExtension * SOAP_FMAC4 soap_in_tt__NetworkHostExtension(struct soap *soap, const char *tag, tt__NetworkHostExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkHostExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHostExtension, sizeof(tt__NetworkHostExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__NetworkHostExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__NetworkHostExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__NetworkHostExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkHostExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHostExtension, 0, sizeof(tt__NetworkHostExtension), 0, soap_copy_tt__NetworkHostExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__NetworkHostExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__NetworkHostExtension);
	if (this->soap_out(soap, tag?tag:"tt:NetworkHostExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkHostExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkHostExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkHostExtension * SOAP_FMAC4 soap_get_tt__NetworkHostExtension(struct soap *soap, tt__NetworkHostExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkHostExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__NetworkHostExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkHostExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkHostExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__NetworkHostExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkHostExtension);
		if (size)
			*size = sizeof(tt__NetworkHostExtension);
		((tt__NetworkHostExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkHostExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__NetworkHostExtension);
		for (int i = 0; i < n; i++)
			((tt__NetworkHostExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__NetworkHostExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__NetworkHostExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__NetworkHostExtension %p -> %p\n", q, p));
	*(tt__NetworkHostExtension*)p = *(tt__NetworkHostExtension*)q;
}

void tt__NetworkHost::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__NetworkHostType(soap, &this->tt__NetworkHost::Type);
	this->tt__NetworkHost::IPv4Address = NULL;
	this->tt__NetworkHost::IPv6Address = NULL;
	this->tt__NetworkHost::DNSname = NULL;
	this->tt__NetworkHost::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__NetworkHost::__anyAttribute);
	/* transient soap skipped */
}

void tt__NetworkHost::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IPv4Address(soap, &this->tt__NetworkHost::IPv4Address);
	soap_serialize_PointerTott__IPv6Address(soap, &this->tt__NetworkHost::IPv6Address);
	soap_serialize_PointerTott__DNSName(soap, &this->tt__NetworkHost::DNSname);
	soap_serialize_PointerTott__NetworkHostExtension(soap, &this->tt__NetworkHost::Extension);
	/* transient soap skipped */
}

int tt__NetworkHost::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkHost(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkHost(struct soap *soap, const char *tag, int id, const tt__NetworkHost *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__NetworkHost*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkHost), type))
		return soap->error;
	if (soap_out_tt__NetworkHostType(soap, "tt:Type", -1, &(a->tt__NetworkHost::Type), ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4Address(soap, "tt:IPv4Address", -1, &(a->tt__NetworkHost::IPv4Address), ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6Address(soap, "tt:IPv6Address", -1, &(a->tt__NetworkHost::IPv6Address), ""))
		return soap->error;
	if (soap_out_PointerTott__DNSName(soap, "tt:DNSname", -1, &(a->tt__NetworkHost::DNSname), ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkHostExtension(soap, "tt:Extension", -1, &(a->tt__NetworkHost::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkHost::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__NetworkHost(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkHost * SOAP_FMAC4 soap_in_tt__NetworkHost(struct soap *soap, const char *tag, tt__NetworkHost *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkHost *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHost, sizeof(tt__NetworkHost), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__NetworkHost)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__NetworkHost *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__NetworkHost*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_IPv4Address1 = 1;
	size_t soap_flag_IPv6Address1 = 1;
	size_t soap_flag_DNSname1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__NetworkHostType(soap, "tt:Type", &(a->tt__NetworkHost::Type), "tt:NetworkHostType"))
				{	soap_flag_Type1--;
					continue;
				}
			if (soap_flag_IPv4Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTott__IPv4Address(soap, "tt:IPv4Address", &(a->tt__NetworkHost::IPv4Address), "tt:IPv4Address"))
				{	soap_flag_IPv4Address1--;
					continue;
				}
			if (soap_flag_IPv6Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTott__IPv6Address(soap, "tt:IPv6Address", &(a->tt__NetworkHost::IPv6Address), "tt:IPv6Address"))
				{	soap_flag_IPv6Address1--;
					continue;
				}
			if (soap_flag_DNSname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTott__DNSName(soap, "tt:DNSname", &(a->tt__NetworkHost::DNSname), "tt:DNSName"))
				{	soap_flag_DNSname1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkHostExtension(soap, "tt:Extension", &(a->tt__NetworkHost::Extension), "tt:NetworkHostExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkHost *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHost, 0, sizeof(tt__NetworkHost), 0, soap_copy_tt__NetworkHost);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__NetworkHost::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__NetworkHost);
	if (this->soap_out(soap, tag?tag:"tt:NetworkHost", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkHost::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkHost(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkHost * SOAP_FMAC4 soap_get_tt__NetworkHost(struct soap *soap, tt__NetworkHost *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkHost(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__NetworkHost * SOAP_FMAC2 soap_instantiate_tt__NetworkHost(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkHost(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__NetworkHost, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkHost);
		if (size)
			*size = sizeof(tt__NetworkHost);
		((tt__NetworkHost*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkHost[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__NetworkHost);
		for (int i = 0; i < n; i++)
			((tt__NetworkHost*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__NetworkHost*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__NetworkHost(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__NetworkHost %p -> %p\n", q, p));
	*(tt__NetworkHost*)p = *(tt__NetworkHost*)q;
}

void tt__NetworkProtocolExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkProtocolExtension::__any);
	/* transient soap skipped */
}

void tt__NetworkProtocolExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkProtocolExtension::__any);
	/* transient soap skipped */
}

int tt__NetworkProtocolExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkProtocolExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkProtocolExtension(struct soap *soap, const char *tag, int id, const tt__NetworkProtocolExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkProtocolExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__NetworkProtocolExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkProtocolExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__NetworkProtocolExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkProtocolExtension * SOAP_FMAC4 soap_in_tt__NetworkProtocolExtension(struct soap *soap, const char *tag, tt__NetworkProtocolExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkProtocolExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocolExtension, sizeof(tt__NetworkProtocolExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__NetworkProtocolExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__NetworkProtocolExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__NetworkProtocolExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkProtocolExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkProtocolExtension, 0, sizeof(tt__NetworkProtocolExtension), 0, soap_copy_tt__NetworkProtocolExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__NetworkProtocolExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__NetworkProtocolExtension);
	if (this->soap_out(soap, tag?tag:"tt:NetworkProtocolExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkProtocolExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkProtocolExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkProtocolExtension * SOAP_FMAC4 soap_get_tt__NetworkProtocolExtension(struct soap *soap, tt__NetworkProtocolExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkProtocolExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__NetworkProtocolExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkProtocolExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkProtocolExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__NetworkProtocolExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkProtocolExtension);
		if (size)
			*size = sizeof(tt__NetworkProtocolExtension);
		((tt__NetworkProtocolExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkProtocolExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__NetworkProtocolExtension);
		for (int i = 0; i < n; i++)
			((tt__NetworkProtocolExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__NetworkProtocolExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__NetworkProtocolExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__NetworkProtocolExtension %p -> %p\n", q, p));
	*(tt__NetworkProtocolExtension*)p = *(tt__NetworkProtocolExtension*)q;
}

void tt__NetworkProtocol::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__NetworkProtocolType(soap, &this->tt__NetworkProtocol::Name);
	soap_default_bool(soap, &this->tt__NetworkProtocol::Enabled);
	soap_default_std__vectorTemplateOfint(soap, &this->tt__NetworkProtocol::Port);
	this->tt__NetworkProtocol::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__NetworkProtocol::__anyAttribute);
	/* transient soap skipped */
}

void tt__NetworkProtocol::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__NetworkProtocol::Enabled, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfint(soap, &this->tt__NetworkProtocol::Port);
	soap_serialize_PointerTott__NetworkProtocolExtension(soap, &this->tt__NetworkProtocol::Extension);
	/* transient soap skipped */
}

int tt__NetworkProtocol::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkProtocol(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkProtocol(struct soap *soap, const char *tag, int id, const tt__NetworkProtocol *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__NetworkProtocol*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkProtocol), type))
		return soap->error;
	if (soap_out_tt__NetworkProtocolType(soap, "tt:Name", -1, &(a->tt__NetworkProtocol::Name), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:Enabled", -1, &(a->tt__NetworkProtocol::Enabled), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "tt:Port", -1, &(a->tt__NetworkProtocol::Port), ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkProtocolExtension(soap, "tt:Extension", -1, &(a->tt__NetworkProtocol::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkProtocol::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__NetworkProtocol(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkProtocol * SOAP_FMAC4 soap_in_tt__NetworkProtocol(struct soap *soap, const char *tag, tt__NetworkProtocol *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkProtocol *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocol, sizeof(tt__NetworkProtocol), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__NetworkProtocol)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__NetworkProtocol *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__NetworkProtocol*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__NetworkProtocolType(soap, "tt:Name", &(a->tt__NetworkProtocol::Name), "tt:NetworkProtocolType"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:Enabled", &(a->tt__NetworkProtocol::Enabled), "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "tt:Port", &(a->tt__NetworkProtocol::Port), "xsd:int"))
					continue;
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkProtocolExtension(soap, "tt:Extension", &(a->tt__NetworkProtocol::Extension), "tt:NetworkProtocolExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkProtocol, 0, sizeof(tt__NetworkProtocol), 0, soap_copy_tt__NetworkProtocol);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || soap_flag_Enabled1 > 0 || a->tt__NetworkProtocol::Port.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__NetworkProtocol::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__NetworkProtocol);
	if (this->soap_out(soap, tag?tag:"tt:NetworkProtocol", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkProtocol::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkProtocol(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkProtocol * SOAP_FMAC4 soap_get_tt__NetworkProtocol(struct soap *soap, tt__NetworkProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__NetworkProtocol * SOAP_FMAC2 soap_instantiate_tt__NetworkProtocol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkProtocol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__NetworkProtocol, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkProtocol);
		if (size)
			*size = sizeof(tt__NetworkProtocol);
		((tt__NetworkProtocol*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkProtocol[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__NetworkProtocol);
		for (int i = 0; i < n; i++)
			((tt__NetworkProtocol*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__NetworkProtocol*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__NetworkProtocol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__NetworkProtocol %p -> %p\n", q, p));
	*(tt__NetworkProtocol*)p = *(tt__NetworkProtocol*)q;
}

void tt__IPv6ConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__IPv6ConfigurationExtension::__any);
	/* transient soap skipped */
}

void tt__IPv6ConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__IPv6ConfigurationExtension::__any);
	/* transient soap skipped */
}

int tt__IPv6ConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv6ConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6ConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__IPv6ConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6ConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__IPv6ConfigurationExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__IPv6ConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__IPv6ConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv6ConfigurationExtension * SOAP_FMAC4 soap_in_tt__IPv6ConfigurationExtension(struct soap *soap, const char *tag, tt__IPv6ConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv6ConfigurationExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6ConfigurationExtension, sizeof(tt__IPv6ConfigurationExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__IPv6ConfigurationExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__IPv6ConfigurationExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__IPv6ConfigurationExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IPv6ConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6ConfigurationExtension, 0, sizeof(tt__IPv6ConfigurationExtension), 0, soap_copy_tt__IPv6ConfigurationExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__IPv6ConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__IPv6ConfigurationExtension);
	if (this->soap_out(soap, tag?tag:"tt:IPv6ConfigurationExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv6ConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv6ConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv6ConfigurationExtension * SOAP_FMAC4 soap_get_tt__IPv6ConfigurationExtension(struct soap *soap, tt__IPv6ConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6ConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__IPv6ConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__IPv6ConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv6ConfigurationExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__IPv6ConfigurationExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__IPv6ConfigurationExtension);
		if (size)
			*size = sizeof(tt__IPv6ConfigurationExtension);
		((tt__IPv6ConfigurationExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__IPv6ConfigurationExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__IPv6ConfigurationExtension);
		for (int i = 0; i < n; i++)
			((tt__IPv6ConfigurationExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__IPv6ConfigurationExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__IPv6ConfigurationExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__IPv6ConfigurationExtension %p -> %p\n", q, p));
	*(tt__IPv6ConfigurationExtension*)p = *(tt__IPv6ConfigurationExtension*)q;
}

void tt__IPv6Configuration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__IPv6Configuration::AcceptRouterAdvert = NULL;
	soap_default_tt__IPv6DHCPConfiguration(soap, &this->tt__IPv6Configuration::DHCP);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::Manual);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::LinkLocal);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::FromDHCP);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::FromRA);
	this->tt__IPv6Configuration::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__IPv6Configuration::__anyAttribute);
	/* transient soap skipped */
}

void tt__IPv6Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobool(soap, &this->tt__IPv6Configuration::AcceptRouterAdvert);
	soap_embedded(soap, &this->tt__IPv6Configuration::DHCP, SOAP_TYPE_tt__IPv6DHCPConfiguration);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::Manual);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::LinkLocal);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::FromDHCP);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::FromRA);
	soap_serialize_PointerTott__IPv6ConfigurationExtension(soap, &this->tt__IPv6Configuration::Extension);
	/* transient soap skipped */
}

int tt__IPv6Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv6Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6Configuration(struct soap *soap, const char *tag, int id, const tt__IPv6Configuration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__IPv6Configuration*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6Configuration), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:AcceptRouterAdvert", -1, &(a->tt__IPv6Configuration::AcceptRouterAdvert), ""))
		return soap->error;
	if (soap_out_tt__IPv6DHCPConfiguration(soap, "tt:DHCP", -1, &(a->tt__IPv6Configuration::DHCP), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:Manual", -1, &(a->tt__IPv6Configuration::Manual), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:LinkLocal", -1, &(a->tt__IPv6Configuration::LinkLocal), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:FromDHCP", -1, &(a->tt__IPv6Configuration::FromDHCP), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:FromRA", -1, &(a->tt__IPv6Configuration::FromRA), ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6ConfigurationExtension(soap, "tt:Extension", -1, &(a->tt__IPv6Configuration::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__IPv6Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__IPv6Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv6Configuration * SOAP_FMAC4 soap_in_tt__IPv6Configuration(struct soap *soap, const char *tag, tt__IPv6Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv6Configuration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6Configuration, sizeof(tt__IPv6Configuration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__IPv6Configuration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__IPv6Configuration *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__IPv6Configuration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_AcceptRouterAdvert1 = 1;
	size_t soap_flag_DHCP1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AcceptRouterAdvert1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "tt:AcceptRouterAdvert", &(a->tt__IPv6Configuration::AcceptRouterAdvert), "xsd:boolean"))
				{	soap_flag_AcceptRouterAdvert1--;
					continue;
				}
			if (soap_flag_DHCP1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__IPv6DHCPConfiguration(soap, "tt:DHCP", &(a->tt__IPv6Configuration::DHCP), "tt:IPv6DHCPConfiguration"))
				{	soap_flag_DHCP1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:Manual", &(a->tt__IPv6Configuration::Manual), "tt:PrefixedIPv6Address"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:LinkLocal", &(a->tt__IPv6Configuration::LinkLocal), "tt:PrefixedIPv6Address"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:FromDHCP", &(a->tt__IPv6Configuration::FromDHCP), "tt:PrefixedIPv6Address"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:FromRA", &(a->tt__IPv6Configuration::FromRA), "tt:PrefixedIPv6Address"))
					continue;
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv6ConfigurationExtension(soap, "tt:Extension", &(a->tt__IPv6Configuration::Extension), "tt:IPv6ConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IPv6Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6Configuration, 0, sizeof(tt__IPv6Configuration), 0, soap_copy_tt__IPv6Configuration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DHCP1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__IPv6Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__IPv6Configuration);
	if (this->soap_out(soap, tag?tag:"tt:IPv6Configuration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv6Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv6Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv6Configuration * SOAP_FMAC4 soap_get_tt__IPv6Configuration(struct soap *soap, tt__IPv6Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__IPv6Configuration * SOAP_FMAC2 soap_instantiate_tt__IPv6Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv6Configuration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__IPv6Configuration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__IPv6Configuration);
		if (size)
			*size = sizeof(tt__IPv6Configuration);
		((tt__IPv6Configuration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__IPv6Configuration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__IPv6Configuration);
		for (int i = 0; i < n; i++)
			((tt__IPv6Configuration*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__IPv6Configuration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__IPv6Configuration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__IPv6Configuration %p -> %p\n", q, p));
	*(tt__IPv6Configuration*)p = *(tt__IPv6Configuration*)q;
}

void tt__IPv4Configuration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4Configuration::Manual);
	this->tt__IPv4Configuration::LinkLocal = NULL;
	this->tt__IPv4Configuration::FromDHCP = NULL;
	soap_default_bool(soap, &this->tt__IPv4Configuration::DHCP);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__IPv4Configuration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__IPv4Configuration::__anyAttribute);
	/* transient soap skipped */
}

void tt__IPv4Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4Configuration::Manual);
	soap_serialize_PointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4Configuration::LinkLocal);
	soap_serialize_PointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4Configuration::FromDHCP);
	soap_embedded(soap, &this->tt__IPv4Configuration::DHCP, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__IPv4Configuration::__any);
	/* transient soap skipped */
}

int tt__IPv4Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv4Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4Configuration(struct soap *soap, const char *tag, int id, const tt__IPv4Configuration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__IPv4Configuration*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv4Configuration), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:Manual", -1, &(a->tt__IPv4Configuration::Manual), ""))
		return soap->error;
	if (soap_out_PointerTott__PrefixedIPv4Address(soap, "tt:LinkLocal", -1, &(a->tt__IPv4Configuration::LinkLocal), ""))
		return soap->error;
	if (soap_out_PointerTott__PrefixedIPv4Address(soap, "tt:FromDHCP", -1, &(a->tt__IPv4Configuration::FromDHCP), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:DHCP", -1, &(a->tt__IPv4Configuration::DHCP), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__IPv4Configuration::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__IPv4Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__IPv4Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv4Configuration * SOAP_FMAC4 soap_in_tt__IPv4Configuration(struct soap *soap, const char *tag, tt__IPv4Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv4Configuration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4Configuration, sizeof(tt__IPv4Configuration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__IPv4Configuration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__IPv4Configuration *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__IPv4Configuration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_LinkLocal1 = 1;
	size_t soap_flag_FromDHCP1 = 1;
	size_t soap_flag_DHCP1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:Manual", &(a->tt__IPv4Configuration::Manual), "tt:PrefixedIPv4Address"))
					continue;
			if (soap_flag_LinkLocal1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PrefixedIPv4Address(soap, "tt:LinkLocal", &(a->tt__IPv4Configuration::LinkLocal), "tt:PrefixedIPv4Address"))
				{	soap_flag_LinkLocal1--;
					continue;
				}
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PrefixedIPv4Address(soap, "tt:FromDHCP", &(a->tt__IPv4Configuration::FromDHCP), "tt:PrefixedIPv4Address"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			if (soap_flag_DHCP1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:DHCP", &(a->tt__IPv4Configuration::DHCP), "xsd:boolean"))
				{	soap_flag_DHCP1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__IPv4Configuration::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IPv4Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4Configuration, 0, sizeof(tt__IPv4Configuration), 0, soap_copy_tt__IPv4Configuration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DHCP1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__IPv4Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__IPv4Configuration);
	if (this->soap_out(soap, tag?tag:"tt:IPv4Configuration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv4Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv4Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv4Configuration * SOAP_FMAC4 soap_get_tt__IPv4Configuration(struct soap *soap, tt__IPv4Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__IPv4Configuration * SOAP_FMAC2 soap_instantiate_tt__IPv4Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv4Configuration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__IPv4Configuration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__IPv4Configuration);
		if (size)
			*size = sizeof(tt__IPv4Configuration);
		((tt__IPv4Configuration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__IPv4Configuration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__IPv4Configuration);
		for (int i = 0; i < n; i++)
			((tt__IPv4Configuration*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__IPv4Configuration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__IPv4Configuration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__IPv4Configuration %p -> %p\n", q, p));
	*(tt__IPv4Configuration*)p = *(tt__IPv4Configuration*)q;
}

void tt__IPv4NetworkInterface::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__IPv4NetworkInterface::Enabled);
	this->tt__IPv4NetworkInterface::Config = NULL;
	/* transient soap skipped */
}

void tt__IPv4NetworkInterface::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__IPv4NetworkInterface::Enabled, SOAP_TYPE_bool);
	soap_serialize_PointerTott__IPv4Configuration(soap, &this->tt__IPv4NetworkInterface::Config);
	/* transient soap skipped */
}

int tt__IPv4NetworkInterface::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv4NetworkInterface(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4NetworkInterface(struct soap *soap, const char *tag, int id, const tt__IPv4NetworkInterface *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv4NetworkInterface), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:Enabled", -1, &(a->tt__IPv4NetworkInterface::Enabled), ""))
		return soap->error;
	if (a->tt__IPv4NetworkInterface::Config)
	{	if (soap_out_PointerTott__IPv4Configuration(soap, "tt:Config", -1, &a->tt__IPv4NetworkInterface::Config, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Config"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__IPv4NetworkInterface::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__IPv4NetworkInterface(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv4NetworkInterface * SOAP_FMAC4 soap_in_tt__IPv4NetworkInterface(struct soap *soap, const char *tag, tt__IPv4NetworkInterface *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv4NetworkInterface *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(tt__IPv4NetworkInterface), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__IPv4NetworkInterface)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__IPv4NetworkInterface *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Config1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:Enabled", &(a->tt__IPv4NetworkInterface::Enabled), "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			if (soap_flag_Config1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv4Configuration(soap, "tt:Config", &(a->tt__IPv4NetworkInterface::Config), "tt:IPv4Configuration"))
				{	soap_flag_Config1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IPv4NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4NetworkInterface, 0, sizeof(tt__IPv4NetworkInterface), 0, soap_copy_tt__IPv4NetworkInterface);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled1 > 0 || soap_flag_Config1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__IPv4NetworkInterface::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__IPv4NetworkInterface);
	if (this->soap_out(soap, tag?tag:"tt:IPv4NetworkInterface", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv4NetworkInterface::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv4NetworkInterface(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv4NetworkInterface * SOAP_FMAC4 soap_get_tt__IPv4NetworkInterface(struct soap *soap, tt__IPv4NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__IPv4NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__IPv4NetworkInterface(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv4NetworkInterface(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__IPv4NetworkInterface, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__IPv4NetworkInterface);
		if (size)
			*size = sizeof(tt__IPv4NetworkInterface);
		((tt__IPv4NetworkInterface*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__IPv4NetworkInterface[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__IPv4NetworkInterface);
		for (int i = 0; i < n; i++)
			((tt__IPv4NetworkInterface*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__IPv4NetworkInterface*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__IPv4NetworkInterface(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__IPv4NetworkInterface %p -> %p\n", q, p));
	*(tt__IPv4NetworkInterface*)p = *(tt__IPv4NetworkInterface*)q;
}

void tt__IPv6NetworkInterface::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__IPv6NetworkInterface::Enabled);
	this->tt__IPv6NetworkInterface::Config = NULL;
	/* transient soap skipped */
}

void tt__IPv6NetworkInterface::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__IPv6NetworkInterface::Enabled, SOAP_TYPE_bool);
	soap_serialize_PointerTott__IPv6Configuration(soap, &this->tt__IPv6NetworkInterface::Config);
	/* transient soap skipped */
}

int tt__IPv6NetworkInterface::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv6NetworkInterface(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6NetworkInterface(struct soap *soap, const char *tag, int id, const tt__IPv6NetworkInterface *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6NetworkInterface), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:Enabled", -1, &(a->tt__IPv6NetworkInterface::Enabled), ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6Configuration(soap, "tt:Config", -1, &(a->tt__IPv6NetworkInterface::Config), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__IPv6NetworkInterface::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__IPv6NetworkInterface(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv6NetworkInterface * SOAP_FMAC4 soap_in_tt__IPv6NetworkInterface(struct soap *soap, const char *tag, tt__IPv6NetworkInterface *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv6NetworkInterface *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(tt__IPv6NetworkInterface), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__IPv6NetworkInterface)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__IPv6NetworkInterface *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Config1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:Enabled", &(a->tt__IPv6NetworkInterface::Enabled), "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			if (soap_flag_Config1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv6Configuration(soap, "tt:Config", &(a->tt__IPv6NetworkInterface::Config), "tt:IPv6Configuration"))
				{	soap_flag_Config1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IPv6NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6NetworkInterface, 0, sizeof(tt__IPv6NetworkInterface), 0, soap_copy_tt__IPv6NetworkInterface);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__IPv6NetworkInterface::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__IPv6NetworkInterface);
	if (this->soap_out(soap, tag?tag:"tt:IPv6NetworkInterface", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv6NetworkInterface::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv6NetworkInterface(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv6NetworkInterface * SOAP_FMAC4 soap_get_tt__IPv6NetworkInterface(struct soap *soap, tt__IPv6NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__IPv6NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__IPv6NetworkInterface(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv6NetworkInterface(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__IPv6NetworkInterface, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__IPv6NetworkInterface);
		if (size)
			*size = sizeof(tt__IPv6NetworkInterface);
		((tt__IPv6NetworkInterface*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__IPv6NetworkInterface[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__IPv6NetworkInterface);
		for (int i = 0; i < n; i++)
			((tt__IPv6NetworkInterface*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__IPv6NetworkInterface*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__IPv6NetworkInterface(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__IPv6NetworkInterface %p -> %p\n", q, p));
	*(tt__IPv6NetworkInterface*)p = *(tt__IPv6NetworkInterface*)q;
}

void tt__NetworkInterfaceInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__NetworkInterfaceInfo::Name = NULL;
	soap_default_tt__HwAddress(soap, &this->tt__NetworkInterfaceInfo::HwAddress);
	this->tt__NetworkInterfaceInfo::MTU = NULL;
	/* transient soap skipped */
}

void tt__NetworkInterfaceInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tt__NetworkInterfaceInfo::Name);
	soap_serialize_tt__HwAddress(soap, &this->tt__NetworkInterfaceInfo::HwAddress);
	soap_serialize_PointerToint(soap, &this->tt__NetworkInterfaceInfo::MTU);
	/* transient soap skipped */
}

int tt__NetworkInterfaceInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceInfo(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Name", -1, &(a->tt__NetworkInterfaceInfo::Name), ""))
		return soap->error;
	if (soap_out_tt__HwAddress(soap, "tt:HwAddress", -1, &(a->tt__NetworkInterfaceInfo::HwAddress), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:MTU", -1, &(a->tt__NetworkInterfaceInfo::MTU), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__NetworkInterfaceInfo(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceInfo * SOAP_FMAC4 soap_in_tt__NetworkInterfaceInfo(struct soap *soap, const char *tag, tt__NetworkInterfaceInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(tt__NetworkInterfaceInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__NetworkInterfaceInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__NetworkInterfaceInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_HwAddress1 = 1;
	size_t soap_flag_MTU1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "tt:Name", &(a->tt__NetworkInterfaceInfo::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_HwAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__HwAddress(soap, "tt:HwAddress", &(a->tt__NetworkInterfaceInfo::HwAddress), "tt:HwAddress"))
				{	soap_flag_HwAddress1--;
					continue;
				}
			if (soap_flag_MTU1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:MTU", &(a->tt__NetworkInterfaceInfo::MTU), "xsd:int"))
				{	soap_flag_MTU1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceInfo, 0, sizeof(tt__NetworkInterfaceInfo), 0, soap_copy_tt__NetworkInterfaceInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_HwAddress1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__NetworkInterfaceInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceInfo);
	if (this->soap_out(soap, tag?tag:"tt:NetworkInterfaceInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceInfo(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceInfo * SOAP_FMAC4 soap_get_tt__NetworkInterfaceInfo(struct soap *soap, tt__NetworkInterfaceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__NetworkInterfaceInfo * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__NetworkInterfaceInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkInterfaceInfo);
		if (size)
			*size = sizeof(tt__NetworkInterfaceInfo);
		((tt__NetworkInterfaceInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkInterfaceInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__NetworkInterfaceInfo);
		for (int i = 0; i < n; i++)
			((tt__NetworkInterfaceInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__NetworkInterfaceInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__NetworkInterfaceInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__NetworkInterfaceInfo %p -> %p\n", q, p));
	*(tt__NetworkInterfaceInfo*)p = *(tt__NetworkInterfaceInfo*)q;
}

void tt__NetworkInterfaceConnectionSetting::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__NetworkInterfaceConnectionSetting::AutoNegotiation);
	soap_default_int(soap, &this->tt__NetworkInterfaceConnectionSetting::Speed);
	soap_default_tt__Duplex(soap, &this->tt__NetworkInterfaceConnectionSetting::Duplex);
	/* transient soap skipped */
}

void tt__NetworkInterfaceConnectionSetting::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__NetworkInterfaceConnectionSetting::AutoNegotiation, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__NetworkInterfaceConnectionSetting::Speed, SOAP_TYPE_int);
	/* transient soap skipped */
}

int tt__NetworkInterfaceConnectionSetting::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceConnectionSetting(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceConnectionSetting *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:AutoNegotiation", -1, &(a->tt__NetworkInterfaceConnectionSetting::AutoNegotiation), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Speed", -1, &(a->tt__NetworkInterfaceConnectionSetting::Speed), ""))
		return soap->error;
	if (soap_out_tt__Duplex(soap, "tt:Duplex", -1, &(a->tt__NetworkInterfaceConnectionSetting::Duplex), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceConnectionSetting::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__NetworkInterfaceConnectionSetting(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceConnectionSetting * SOAP_FMAC4 soap_in_tt__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, tt__NetworkInterfaceConnectionSetting *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceConnectionSetting *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, sizeof(tt__NetworkInterfaceConnectionSetting), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__NetworkInterfaceConnectionSetting)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__NetworkInterfaceConnectionSetting *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AutoNegotiation1 = 1;
	size_t soap_flag_Speed1 = 1;
	size_t soap_flag_Duplex1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoNegotiation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:AutoNegotiation", &(a->tt__NetworkInterfaceConnectionSetting::AutoNegotiation), "xsd:boolean"))
				{	soap_flag_AutoNegotiation1--;
					continue;
				}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Speed", &(a->tt__NetworkInterfaceConnectionSetting::Speed), "xsd:int"))
				{	soap_flag_Speed1--;
					continue;
				}
			if (soap_flag_Duplex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__Duplex(soap, "tt:Duplex", &(a->tt__NetworkInterfaceConnectionSetting::Duplex), "tt:Duplex"))
				{	soap_flag_Duplex1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceConnectionSetting *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, 0, sizeof(tt__NetworkInterfaceConnectionSetting), 0, soap_copy_tt__NetworkInterfaceConnectionSetting);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoNegotiation1 > 0 || soap_flag_Speed1 > 0 || soap_flag_Duplex1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__NetworkInterfaceConnectionSetting::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting);
	if (this->soap_out(soap, tag?tag:"tt:NetworkInterfaceConnectionSetting", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceConnectionSetting::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceConnectionSetting(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceConnectionSetting * SOAP_FMAC4 soap_get_tt__NetworkInterfaceConnectionSetting(struct soap *soap, tt__NetworkInterfaceConnectionSetting *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceConnectionSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__NetworkInterfaceConnectionSetting * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceConnectionSetting(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceConnectionSetting(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkInterfaceConnectionSetting);
		if (size)
			*size = sizeof(tt__NetworkInterfaceConnectionSetting);
		((tt__NetworkInterfaceConnectionSetting*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkInterfaceConnectionSetting[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__NetworkInterfaceConnectionSetting);
		for (int i = 0; i < n; i++)
			((tt__NetworkInterfaceConnectionSetting*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__NetworkInterfaceConnectionSetting*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__NetworkInterfaceConnectionSetting(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__NetworkInterfaceConnectionSetting %p -> %p\n", q, p));
	*(tt__NetworkInterfaceConnectionSetting*)p = *(tt__NetworkInterfaceConnectionSetting*)q;
}

void tt__NetworkInterfaceLink::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__NetworkInterfaceLink::AdminSettings = NULL;
	this->tt__NetworkInterfaceLink::OperSettings = NULL;
	soap_default_tt__IANA_IfTypes(soap, &this->tt__NetworkInterfaceLink::InterfaceType);
	/* transient soap skipped */
}

void tt__NetworkInterfaceLink::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, &this->tt__NetworkInterfaceLink::AdminSettings);
	soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, &this->tt__NetworkInterfaceLink::OperSettings);
	/* transient soap skipped */
}

int tt__NetworkInterfaceLink::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceLink(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceLink(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceLink *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceLink), type))
		return soap->error;
	if (a->tt__NetworkInterfaceLink::AdminSettings)
	{	if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:AdminSettings", -1, &a->tt__NetworkInterfaceLink::AdminSettings, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:AdminSettings"))
		return soap->error;
	if (a->tt__NetworkInterfaceLink::OperSettings)
	{	if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:OperSettings", -1, &a->tt__NetworkInterfaceLink::OperSettings, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:OperSettings"))
		return soap->error;
	if (soap_out_tt__IANA_IfTypes(soap, "tt:InterfaceType", -1, &(a->tt__NetworkInterfaceLink::InterfaceType), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceLink::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__NetworkInterfaceLink(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceLink * SOAP_FMAC4 soap_in_tt__NetworkInterfaceLink(struct soap *soap, const char *tag, tt__NetworkInterfaceLink *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceLink *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(tt__NetworkInterfaceLink), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__NetworkInterfaceLink)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__NetworkInterfaceLink *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AdminSettings1 = 1;
	size_t soap_flag_OperSettings1 = 1;
	size_t soap_flag_InterfaceType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AdminSettings1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:AdminSettings", &(a->tt__NetworkInterfaceLink::AdminSettings), "tt:NetworkInterfaceConnectionSetting"))
				{	soap_flag_AdminSettings1--;
					continue;
				}
			if (soap_flag_OperSettings1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:OperSettings", &(a->tt__NetworkInterfaceLink::OperSettings), "tt:NetworkInterfaceConnectionSetting"))
				{	soap_flag_OperSettings1--;
					continue;
				}
			if (soap_flag_InterfaceType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__IANA_IfTypes(soap, "tt:InterfaceType", &(a->tt__NetworkInterfaceLink::InterfaceType), "tt:IANA-IfTypes"))
				{	soap_flag_InterfaceType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceLink, 0, sizeof(tt__NetworkInterfaceLink), 0, soap_copy_tt__NetworkInterfaceLink);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AdminSettings1 > 0 || soap_flag_OperSettings1 > 0 || soap_flag_InterfaceType1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__NetworkInterfaceLink::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceLink);
	if (this->soap_out(soap, tag?tag:"tt:NetworkInterfaceLink", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceLink::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceLink(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceLink * SOAP_FMAC4 soap_get_tt__NetworkInterfaceLink(struct soap *soap, tt__NetworkInterfaceLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__NetworkInterfaceLink * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceLink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__NetworkInterfaceLink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkInterfaceLink);
		if (size)
			*size = sizeof(tt__NetworkInterfaceLink);
		((tt__NetworkInterfaceLink*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkInterfaceLink[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__NetworkInterfaceLink);
		for (int i = 0; i < n; i++)
			((tt__NetworkInterfaceLink*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__NetworkInterfaceLink*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__NetworkInterfaceLink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__NetworkInterfaceLink %p -> %p\n", q, p));
	*(tt__NetworkInterfaceLink*)p = *(tt__NetworkInterfaceLink*)q;
}

void tt__NetworkInterfaceExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkInterfaceExtension::__any);
	/* transient soap skipped */
}

void tt__NetworkInterfaceExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__NetworkInterfaceExtension::__any);
	/* transient soap skipped */
}

int tt__NetworkInterfaceExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceExtension(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__NetworkInterfaceExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__NetworkInterfaceExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension * SOAP_FMAC4 soap_in_tt__NetworkInterfaceExtension(struct soap *soap, const char *tag, tt__NetworkInterfaceExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(tt__NetworkInterfaceExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__NetworkInterfaceExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__NetworkInterfaceExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__NetworkInterfaceExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceExtension, 0, sizeof(tt__NetworkInterfaceExtension), 0, soap_copy_tt__NetworkInterfaceExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__NetworkInterfaceExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceExtension);
	if (this->soap_out(soap, tag?tag:"tt:NetworkInterfaceExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension * SOAP_FMAC4 soap_get_tt__NetworkInterfaceExtension(struct soap *soap, tt__NetworkInterfaceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__NetworkInterfaceExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__NetworkInterfaceExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkInterfaceExtension);
		if (size)
			*size = sizeof(tt__NetworkInterfaceExtension);
		((tt__NetworkInterfaceExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkInterfaceExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__NetworkInterfaceExtension);
		for (int i = 0; i < n; i++)
			((tt__NetworkInterfaceExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__NetworkInterfaceExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__NetworkInterfaceExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__NetworkInterfaceExtension %p -> %p\n", q, p));
	*(tt__NetworkInterfaceExtension*)p = *(tt__NetworkInterfaceExtension*)q;
}

void tt__NetworkInterface::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__NetworkInterface::Enabled);
	this->tt__NetworkInterface::Info = NULL;
	this->tt__NetworkInterface::Link = NULL;
	this->tt__NetworkInterface::IPv4 = NULL;
	this->tt__NetworkInterface::IPv6 = NULL;
	this->tt__NetworkInterface::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__NetworkInterface::__anyAttribute);
	soap_default_tt__ReferenceToken(soap, &this->tt__DeviceEntity::token);
	/* transient soap skipped */
}

void tt__NetworkInterface::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__NetworkInterface::Enabled, SOAP_TYPE_bool);
	soap_serialize_PointerTott__NetworkInterfaceInfo(soap, &this->tt__NetworkInterface::Info);
	soap_serialize_PointerTott__NetworkInterfaceLink(soap, &this->tt__NetworkInterface::Link);
	soap_serialize_PointerTott__IPv4NetworkInterface(soap, &this->tt__NetworkInterface::IPv4);
	soap_serialize_PointerTott__IPv6NetworkInterface(soap, &this->tt__NetworkInterface::IPv6);
	soap_serialize_PointerTott__NetworkInterfaceExtension(soap, &this->tt__NetworkInterface::Extension);
	/* transient soap skipped */
}

int tt__NetworkInterface::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterface(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterface(struct soap *soap, const char *tag, int id, const tt__NetworkInterface *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__NetworkInterface*)a)->__anyAttribute, ""))
		return soap->error;
	if (!((tt__DeviceEntity*)a)->token.empty())
		soap_set_attr(soap, "token", ((tt__DeviceEntity*)a)->token.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterface), "tt:NetworkInterface"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "tt:Enabled", -1, &(a->tt__NetworkInterface::Enabled), ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceInfo(soap, "tt:Info", -1, &(a->tt__NetworkInterface::Info), ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceLink(soap, "tt:Link", -1, &(a->tt__NetworkInterface::Link), ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4NetworkInterface(soap, "tt:IPv4", -1, &(a->tt__NetworkInterface::IPv4), ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6NetworkInterface(soap, "tt:IPv6", -1, &(a->tt__NetworkInterface::IPv6), ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceExtension(soap, "tt:Extension", -1, &(a->tt__NetworkInterface::Extension), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterface::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__NetworkInterface(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterface * SOAP_FMAC4 soap_in_tt__NetworkInterface(struct soap *soap, const char *tag, tt__NetworkInterface *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterface *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterface, sizeof(tt__NetworkInterface), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__NetworkInterface)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__NetworkInterface *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__NetworkInterface*)a)->__anyAttribute, "xsd:anyAttribute");
	{	const char *t = soap_attr_value(soap, "token", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, 64))
				return NULL;
			((tt__DeviceEntity*)a)->token.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Info1 = 1;
	size_t soap_flag_Link1 = 1;
	size_t soap_flag_IPv41 = 1;
	size_t soap_flag_IPv61 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:Enabled", &(a->tt__NetworkInterface::Enabled), "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			if (soap_flag_Info1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceInfo(soap, "tt:Info", &(a->tt__NetworkInterface::Info), "tt:NetworkInterfaceInfo"))
				{	soap_flag_Info1--;
					continue;
				}
			if (soap_flag_Link1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceLink(soap, "tt:Link", &(a->tt__NetworkInterface::Link), "tt:NetworkInterfaceLink"))
				{	soap_flag_Link1--;
					continue;
				}
			if (soap_flag_IPv41 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv4NetworkInterface(soap, "tt:IPv4", &(a->tt__NetworkInterface::IPv4), "tt:IPv4NetworkInterface"))
				{	soap_flag_IPv41--;
					continue;
				}
			if (soap_flag_IPv61 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv6NetworkInterface(soap, "tt:IPv6", &(a->tt__NetworkInterface::IPv6), "tt:IPv6NetworkInterface"))
				{	soap_flag_IPv61--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceExtension(soap, "tt:Extension", &(a->tt__NetworkInterface::Extension), "tt:NetworkInterfaceExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterface, 0, sizeof(tt__NetworkInterface), 0, soap_copy_tt__NetworkInterface);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__NetworkInterface::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterface);
	if (this->soap_out(soap, tag?tag:"tt:NetworkInterface", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterface::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterface(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterface * SOAP_FMAC4 soap_get_tt__NetworkInterface(struct soap *soap, tt__NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__NetworkInterface(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterface(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__NetworkInterface, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkInterface);
		if (size)
			*size = sizeof(tt__NetworkInterface);
		((tt__NetworkInterface*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__NetworkInterface[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__NetworkInterface);
		for (int i = 0; i < n; i++)
			((tt__NetworkInterface*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__NetworkInterface*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__NetworkInterface(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__NetworkInterface %p -> %p\n", q, p));
	*(tt__NetworkInterface*)p = *(tt__NetworkInterface*)q;
}

void tt__Scope::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ScopeDefinition(soap, &this->tt__Scope::ScopeDef);
	soap_default_xsd__anyURI(soap, &this->tt__Scope::ScopeItem);
	/* transient soap skipped */
}

void tt__Scope::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__Scope::ScopeItem, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__Scope::ScopeItem);
	/* transient soap skipped */
}

int tt__Scope::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Scope(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Scope(struct soap *soap, const char *tag, int id, const tt__Scope *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Scope), type))
		return soap->error;
	if (soap_out_tt__ScopeDefinition(soap, "tt:ScopeDef", -1, &(a->tt__Scope::ScopeDef), ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:ScopeItem", -1, &(a->tt__Scope::ScopeItem), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Scope::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Scope(soap, tag, this, type);
}

SOAP_FMAC3 tt__Scope * SOAP_FMAC4 soap_in_tt__Scope(struct soap *soap, const char *tag, tt__Scope *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Scope *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Scope, sizeof(tt__Scope), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Scope)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Scope *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ScopeDef1 = 1;
	size_t soap_flag_ScopeItem1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ScopeDef1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__ScopeDefinition(soap, "tt:ScopeDef", &(a->tt__Scope::ScopeDef), "tt:ScopeDefinition"))
				{	soap_flag_ScopeDef1--;
					continue;
				}
			if (soap_flag_ScopeItem1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:ScopeItem", &(a->tt__Scope::ScopeItem), "xsd:anyURI"))
				{	soap_flag_ScopeItem1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Scope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Scope, 0, sizeof(tt__Scope), 0, soap_copy_tt__Scope);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ScopeDef1 > 0 || soap_flag_ScopeItem1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Scope::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Scope);
	if (this->soap_out(soap, tag?tag:"tt:Scope", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Scope::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Scope(soap, this, tag, type);
}

SOAP_FMAC3 tt__Scope * SOAP_FMAC4 soap_get_tt__Scope(struct soap *soap, tt__Scope *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Scope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Scope * SOAP_FMAC2 soap_instantiate_tt__Scope(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Scope(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Scope, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Scope);
		if (size)
			*size = sizeof(tt__Scope);
		((tt__Scope*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Scope[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Scope);
		for (int i = 0; i < n; i++)
			((tt__Scope*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Scope*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Scope(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Scope %p -> %p\n", q, p));
	*(tt__Scope*)p = *(tt__Scope*)q;
}

void tt__MediaUri::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__MediaUri::Uri);
	soap_default_bool(soap, &this->tt__MediaUri::InvalidAfterConnect);
	soap_default_bool(soap, &this->tt__MediaUri::InvalidAfterReboot);
	soap_default_xsd__duration(soap, &this->tt__MediaUri::Timeout);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MediaUri::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__MediaUri::__anyAttribute);
	/* transient soap skipped */
}

void tt__MediaUri::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__MediaUri::Uri, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__MediaUri::Uri);
	soap_embedded(soap, &this->tt__MediaUri::InvalidAfterConnect, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__MediaUri::InvalidAfterReboot, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__MediaUri::Timeout, SOAP_TYPE_xsd__duration);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MediaUri::__any);
	/* transient soap skipped */
}

int tt__MediaUri::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MediaUri(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaUri(struct soap *soap, const char *tag, int id, const tt__MediaUri *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__MediaUri*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaUri), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:Uri", -1, &(a->tt__MediaUri::Uri), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:InvalidAfterConnect", -1, &(a->tt__MediaUri::InvalidAfterConnect), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:InvalidAfterReboot", -1, &(a->tt__MediaUri::InvalidAfterReboot), ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:Timeout", -1, &(a->tt__MediaUri::Timeout), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__MediaUri::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__MediaUri::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__MediaUri(soap, tag, this, type);
}

SOAP_FMAC3 tt__MediaUri * SOAP_FMAC4 soap_in_tt__MediaUri(struct soap *soap, const char *tag, tt__MediaUri *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MediaUri *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaUri, sizeof(tt__MediaUri), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__MediaUri)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__MediaUri *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__MediaUri*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Uri1 = 1;
	size_t soap_flag_InvalidAfterConnect1 = 1;
	size_t soap_flag_InvalidAfterReboot1 = 1;
	size_t soap_flag_Timeout1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Uri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:Uri", &(a->tt__MediaUri::Uri), "xsd:anyURI"))
				{	soap_flag_Uri1--;
					continue;
				}
			if (soap_flag_InvalidAfterConnect1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:InvalidAfterConnect", &(a->tt__MediaUri::InvalidAfterConnect), "xsd:boolean"))
				{	soap_flag_InvalidAfterConnect1--;
					continue;
				}
			if (soap_flag_InvalidAfterReboot1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:InvalidAfterReboot", &(a->tt__MediaUri::InvalidAfterReboot), "xsd:boolean"))
				{	soap_flag_InvalidAfterReboot1--;
					continue;
				}
			if (soap_flag_Timeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tt:Timeout", &(a->tt__MediaUri::Timeout), "xsd:duration"))
				{	soap_flag_Timeout1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__MediaUri::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MediaUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaUri, 0, sizeof(tt__MediaUri), 0, soap_copy_tt__MediaUri);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Uri1 > 0 || soap_flag_InvalidAfterConnect1 > 0 || soap_flag_InvalidAfterReboot1 > 0 || soap_flag_Timeout1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__MediaUri::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__MediaUri);
	if (this->soap_out(soap, tag?tag:"tt:MediaUri", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MediaUri::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MediaUri(soap, this, tag, type);
}

SOAP_FMAC3 tt__MediaUri * SOAP_FMAC4 soap_get_tt__MediaUri(struct soap *soap, tt__MediaUri *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__MediaUri * SOAP_FMAC2 soap_instantiate_tt__MediaUri(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MediaUri(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__MediaUri, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__MediaUri);
		if (size)
			*size = sizeof(tt__MediaUri);
		((tt__MediaUri*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__MediaUri[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__MediaUri);
		for (int i = 0; i < n; i++)
			((tt__MediaUri*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__MediaUri*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__MediaUri(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__MediaUri %p -> %p\n", q, p));
	*(tt__MediaUri*)p = *(tt__MediaUri*)q;
}

void tt__Transport::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__TransportProtocol(soap, &this->tt__Transport::Protocol);
	this->tt__Transport::Tunnel = NULL;
	/* transient soap skipped */
}

void tt__Transport::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Transport(soap, &this->tt__Transport::Tunnel);
	/* transient soap skipped */
}

int tt__Transport::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Transport(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Transport(struct soap *soap, const char *tag, int id, const tt__Transport *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Transport), type))
		return soap->error;
	if (soap_out_tt__TransportProtocol(soap, "tt:Protocol", -1, &(a->tt__Transport::Protocol), ""))
		return soap->error;
	if (soap_out_PointerTott__Transport(soap, "tt:Tunnel", -1, &(a->tt__Transport::Tunnel), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Transport::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Transport(soap, tag, this, type);
}

SOAP_FMAC3 tt__Transport * SOAP_FMAC4 soap_in_tt__Transport(struct soap *soap, const char *tag, tt__Transport *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Transport *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Transport, sizeof(tt__Transport), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Transport)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Transport *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Protocol1 = 1;
	size_t soap_flag_Tunnel1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Protocol1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__TransportProtocol(soap, "tt:Protocol", &(a->tt__Transport::Protocol), "tt:TransportProtocol"))
				{	soap_flag_Protocol1--;
					continue;
				}
			if (soap_flag_Tunnel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Transport(soap, "tt:Tunnel", &(a->tt__Transport::Tunnel), "tt:Transport"))
				{	soap_flag_Tunnel1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Transport *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Transport, 0, sizeof(tt__Transport), 0, soap_copy_tt__Transport);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Protocol1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Transport::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Transport);
	if (this->soap_out(soap, tag?tag:"tt:Transport", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Transport::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Transport(soap, this, tag, type);
}

SOAP_FMAC3 tt__Transport * SOAP_FMAC4 soap_get_tt__Transport(struct soap *soap, tt__Transport *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Transport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Transport * SOAP_FMAC2 soap_instantiate_tt__Transport(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Transport(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Transport, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Transport);
		if (size)
			*size = sizeof(tt__Transport);
		((tt__Transport*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Transport[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Transport);
		for (int i = 0; i < n; i++)
			((tt__Transport*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Transport*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Transport(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Transport %p -> %p\n", q, p));
	*(tt__Transport*)p = *(tt__Transport*)q;
}

void tt__StreamSetup::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__StreamType(soap, &this->tt__StreamSetup::Stream);
	this->tt__StreamSetup::Transport = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__StreamSetup::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__StreamSetup::__anyAttribute);
	/* transient soap skipped */
}

void tt__StreamSetup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Transport(soap, &this->tt__StreamSetup::Transport);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__StreamSetup::__any);
	/* transient soap skipped */
}

int tt__StreamSetup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__StreamSetup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StreamSetup(struct soap *soap, const char *tag, int id, const tt__StreamSetup *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__StreamSetup*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__StreamSetup), type))
		return soap->error;
	if (soap_out_tt__StreamType(soap, "tt:Stream", -1, &(a->tt__StreamSetup::Stream), ""))
		return soap->error;
	if (a->tt__StreamSetup::Transport)
	{	if (soap_out_PointerTott__Transport(soap, "tt:Transport", -1, &a->tt__StreamSetup::Transport, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Transport"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__StreamSetup::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__StreamSetup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__StreamSetup(soap, tag, this, type);
}

SOAP_FMAC3 tt__StreamSetup * SOAP_FMAC4 soap_in_tt__StreamSetup(struct soap *soap, const char *tag, tt__StreamSetup *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__StreamSetup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StreamSetup, sizeof(tt__StreamSetup), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__StreamSetup)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__StreamSetup *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__StreamSetup*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Stream1 = 1;
	size_t soap_flag_Transport1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Stream1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__StreamType(soap, "tt:Stream", &(a->tt__StreamSetup::Stream), "tt:StreamType"))
				{	soap_flag_Stream1--;
					continue;
				}
			if (soap_flag_Transport1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Transport(soap, "tt:Transport", &(a->tt__StreamSetup::Transport), "tt:Transport"))
				{	soap_flag_Transport1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__StreamSetup::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__StreamSetup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__StreamSetup, 0, sizeof(tt__StreamSetup), 0, soap_copy_tt__StreamSetup);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Stream1 > 0 || soap_flag_Transport1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__StreamSetup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__StreamSetup);
	if (this->soap_out(soap, tag?tag:"tt:StreamSetup", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__StreamSetup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__StreamSetup(soap, this, tag, type);
}

SOAP_FMAC3 tt__StreamSetup * SOAP_FMAC4 soap_get_tt__StreamSetup(struct soap *soap, tt__StreamSetup *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StreamSetup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__StreamSetup * SOAP_FMAC2 soap_instantiate_tt__StreamSetup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__StreamSetup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__StreamSetup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__StreamSetup);
		if (size)
			*size = sizeof(tt__StreamSetup);
		((tt__StreamSetup*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__StreamSetup[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__StreamSetup);
		for (int i = 0; i < n; i++)
			((tt__StreamSetup*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__StreamSetup*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__StreamSetup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__StreamSetup %p -> %p\n", q, p));
	*(tt__StreamSetup*)p = *(tt__StreamSetup*)q;
}

void tt__MulticastConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__MulticastConfiguration::Address = NULL;
	soap_default_int(soap, &this->tt__MulticastConfiguration::Port);
	soap_default_int(soap, &this->tt__MulticastConfiguration::TTL);
	soap_default_bool(soap, &this->tt__MulticastConfiguration::AutoStart);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MulticastConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__MulticastConfiguration::__anyAttribute);
	/* transient soap skipped */
}

void tt__MulticastConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IPAddress(soap, &this->tt__MulticastConfiguration::Address);
	soap_embedded(soap, &this->tt__MulticastConfiguration::Port, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__MulticastConfiguration::TTL, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__MulticastConfiguration::AutoStart, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MulticastConfiguration::__any);
	/* transient soap skipped */
}

int tt__MulticastConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MulticastConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MulticastConfiguration(struct soap *soap, const char *tag, int id, const tt__MulticastConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__MulticastConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MulticastConfiguration), type))
		return soap->error;
	if (a->tt__MulticastConfiguration::Address)
	{	if (soap_out_PointerTott__IPAddress(soap, "tt:Address", -1, &a->tt__MulticastConfiguration::Address, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Address"))
		return soap->error;
	if (soap_out_int(soap, "tt:Port", -1, &(a->tt__MulticastConfiguration::Port), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:TTL", -1, &(a->tt__MulticastConfiguration::TTL), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:AutoStart", -1, &(a->tt__MulticastConfiguration::AutoStart), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__MulticastConfiguration::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__MulticastConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__MulticastConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__MulticastConfiguration * SOAP_FMAC4 soap_in_tt__MulticastConfiguration(struct soap *soap, const char *tag, tt__MulticastConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MulticastConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MulticastConfiguration, sizeof(tt__MulticastConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__MulticastConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__MulticastConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__MulticastConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Address1 = 1;
	size_t soap_flag_Port1 = 1;
	size_t soap_flag_TTL1 = 1;
	size_t soap_flag_AutoStart1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPAddress(soap, "tt:Address", &(a->tt__MulticastConfiguration::Address), "tt:IPAddress"))
				{	soap_flag_Address1--;
					continue;
				}
			if (soap_flag_Port1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Port", &(a->tt__MulticastConfiguration::Port), "xsd:int"))
				{	soap_flag_Port1--;
					continue;
				}
			if (soap_flag_TTL1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:TTL", &(a->tt__MulticastConfiguration::TTL), "xsd:int"))
				{	soap_flag_TTL1--;
					continue;
				}
			if (soap_flag_AutoStart1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:AutoStart", &(a->tt__MulticastConfiguration::AutoStart), "xsd:boolean"))
				{	soap_flag_AutoStart1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__MulticastConfiguration::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MulticastConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MulticastConfiguration, 0, sizeof(tt__MulticastConfiguration), 0, soap_copy_tt__MulticastConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address1 > 0 || soap_flag_Port1 > 0 || soap_flag_TTL1 > 0 || soap_flag_AutoStart1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__MulticastConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__MulticastConfiguration);
	if (this->soap_out(soap, tag?tag:"tt:MulticastConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MulticastConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MulticastConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__MulticastConfiguration * SOAP_FMAC4 soap_get_tt__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MulticastConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__MulticastConfiguration * SOAP_FMAC2 soap_instantiate_tt__MulticastConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MulticastConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__MulticastConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__MulticastConfiguration);
		if (size)
			*size = sizeof(tt__MulticastConfiguration);
		((tt__MulticastConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__MulticastConfiguration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__MulticastConfiguration);
		for (int i = 0; i < n; i++)
			((tt__MulticastConfiguration*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__MulticastConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__MulticastConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__MulticastConfiguration %p -> %p\n", q, p));
	*(tt__MulticastConfiguration*)p = *(tt__MulticastConfiguration*)q;
}

void tt__PTZStatusFilterOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__PTZStatusFilterOptions::PanTiltStatusSupported);
	soap_default_bool(soap, &this->tt__PTZStatusFilterOptions::ZoomStatusSupported);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZStatusFilterOptions::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZStatusFilterOptions::__anyAttribute);
	/* transient soap skipped */
}

void tt__PTZStatusFilterOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__PTZStatusFilterOptions::PanTiltStatusSupported, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__PTZStatusFilterOptions::ZoomStatusSupported, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__PTZStatusFilterOptions::__any);
	/* transient soap skipped */
}

int tt__PTZStatusFilterOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZStatusFilterOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStatusFilterOptions(struct soap *soap, const char *tag, int id, const tt__PTZStatusFilterOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZStatusFilterOptions*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZStatusFilterOptions), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:PanTiltStatusSupported", -1, &(a->tt__PTZStatusFilterOptions::PanTiltStatusSupported), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:ZoomStatusSupported", -1, &(a->tt__PTZStatusFilterOptions::ZoomStatusSupported), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__PTZStatusFilterOptions::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__PTZStatusFilterOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__PTZStatusFilterOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZStatusFilterOptions * SOAP_FMAC4 soap_in_tt__PTZStatusFilterOptions(struct soap *soap, const char *tag, tt__PTZStatusFilterOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZStatusFilterOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStatusFilterOptions, sizeof(tt__PTZStatusFilterOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__PTZStatusFilterOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__PTZStatusFilterOptions *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZStatusFilterOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_PanTiltStatusSupported1 = 1;
	size_t soap_flag_ZoomStatusSupported1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTiltStatusSupported1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:PanTiltStatusSupported", &(a->tt__PTZStatusFilterOptions::PanTiltStatusSupported), "xsd:boolean"))
				{	soap_flag_PanTiltStatusSupported1--;
					continue;
				}
			if (soap_flag_ZoomStatusSupported1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:ZoomStatusSupported", &(a->tt__PTZStatusFilterOptions::ZoomStatusSupported), "xsd:boolean"))
				{	soap_flag_ZoomStatusSupported1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__PTZStatusFilterOptions::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZStatusFilterOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStatusFilterOptions, 0, sizeof(tt__PTZStatusFilterOptions), 0, soap_copy_tt__PTZStatusFilterOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PanTiltStatusSupported1 > 0 || soap_flag_ZoomStatusSupported1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__PTZStatusFilterOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__PTZStatusFilterOptions);
	if (this->soap_out(soap, tag?tag:"tt:PTZStatusFilterOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZStatusFilterOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZStatusFilterOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZStatusFilterOptions * SOAP_FMAC4 soap_get_tt__PTZStatusFilterOptions(struct soap *soap, tt__PTZStatusFilterOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStatusFilterOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__PTZStatusFilterOptions * SOAP_FMAC2 soap_instantiate_tt__PTZStatusFilterOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZStatusFilterOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__PTZStatusFilterOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZStatusFilterOptions);
		if (size)
			*size = sizeof(tt__PTZStatusFilterOptions);
		((tt__PTZStatusFilterOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZStatusFilterOptions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__PTZStatusFilterOptions);
		for (int i = 0; i < n; i++)
			((tt__PTZStatusFilterOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__PTZStatusFilterOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__PTZStatusFilterOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__PTZStatusFilterOptions %p -> %p\n", q, p));
	*(tt__PTZStatusFilterOptions*)p = *(tt__PTZStatusFilterOptions*)q;
}

void tt__MetadataConfigurationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__MetadataConfigurationOptions::PTZStatusFilterOptions = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MetadataConfigurationOptions::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__MetadataConfigurationOptions::__anyAttribute);
	/* transient soap skipped */
}

void tt__MetadataConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__PTZStatusFilterOptions(soap, &this->tt__MetadataConfigurationOptions::PTZStatusFilterOptions);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MetadataConfigurationOptions::__any);
	/* transient soap skipped */
}

int tt__MetadataConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MetadataConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__MetadataConfigurationOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__MetadataConfigurationOptions*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataConfigurationOptions), type))
		return soap->error;
	if (a->tt__MetadataConfigurationOptions::PTZStatusFilterOptions)
	{	if (soap_out_PointerTott__PTZStatusFilterOptions(soap, "tt:PTZStatusFilterOptions", -1, &a->tt__MetadataConfigurationOptions::PTZStatusFilterOptions, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:PTZStatusFilterOptions"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__MetadataConfigurationOptions::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__MetadataConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__MetadataConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__MetadataConfigurationOptions * SOAP_FMAC4 soap_in_tt__MetadataConfigurationOptions(struct soap *soap, const char *tag, tt__MetadataConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MetadataConfigurationOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfigurationOptions, sizeof(tt__MetadataConfigurationOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__MetadataConfigurationOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__MetadataConfigurationOptions *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__MetadataConfigurationOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_PTZStatusFilterOptions1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZStatusFilterOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZStatusFilterOptions(soap, "tt:PTZStatusFilterOptions", &(a->tt__MetadataConfigurationOptions::PTZStatusFilterOptions), "tt:PTZStatusFilterOptions"))
				{	soap_flag_PTZStatusFilterOptions1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__MetadataConfigurationOptions::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MetadataConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfigurationOptions, 0, sizeof(tt__MetadataConfigurationOptions), 0, soap_copy_tt__MetadataConfigurationOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PTZStatusFilterOptions1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__MetadataConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__MetadataConfigurationOptions);
	if (this->soap_out(soap, tag?tag:"tt:MetadataConfigurationOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MetadataConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MetadataConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__MetadataConfigurationOptions * SOAP_FMAC4 soap_get_tt__MetadataConfigurationOptions(struct soap *soap, tt__MetadataConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__MetadataConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MetadataConfigurationOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__MetadataConfigurationOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__MetadataConfigurationOptions);
		if (size)
			*size = sizeof(tt__MetadataConfigurationOptions);
		((tt__MetadataConfigurationOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__MetadataConfigurationOptions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__MetadataConfigurationOptions);
		for (int i = 0; i < n; i++)
			((tt__MetadataConfigurationOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__MetadataConfigurationOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__MetadataConfigurationOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__MetadataConfigurationOptions %p -> %p\n", q, p));
	*(tt__MetadataConfigurationOptions*)p = *(tt__MetadataConfigurationOptions*)q;
}

void tt__EventSubscription::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__EventSubscription::Filter = NULL;
	this->tt__EventSubscription::SubscriptionPolicy = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__EventSubscription::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__EventSubscription::__anyAttribute);
	/* transient soap skipped */
}

void tt__EventSubscription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTowsnb__FilterType(soap, &this->tt__EventSubscription::Filter);
	soap_serialize_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, &this->tt__EventSubscription::SubscriptionPolicy);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__EventSubscription::__any);
	/* transient soap skipped */
}

int tt__EventSubscription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EventSubscription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventSubscription(struct soap *soap, const char *tag, int id, const tt__EventSubscription *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__EventSubscription*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventSubscription), type))
		return soap->error;
	if (soap_out_PointerTowsnb__FilterType(soap, "tt:Filter", -1, &(a->tt__EventSubscription::Filter), ""))
		return soap->error;
	if (soap_out_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, "tt:SubscriptionPolicy", -1, &(a->tt__EventSubscription::SubscriptionPolicy), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__EventSubscription::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__EventSubscription::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__EventSubscription(soap, tag, this, type);
}

SOAP_FMAC3 tt__EventSubscription * SOAP_FMAC4 soap_in_tt__EventSubscription(struct soap *soap, const char *tag, tt__EventSubscription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EventSubscription *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventSubscription, sizeof(tt__EventSubscription), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__EventSubscription)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__EventSubscription *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__EventSubscription*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Filter1 = 1;
	size_t soap_flag_SubscriptionPolicy1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Filter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnb__FilterType(soap, "tt:Filter", &(a->tt__EventSubscription::Filter), "wsnb:FilterType"))
				{	soap_flag_Filter1--;
					continue;
				}
			if (soap_flag_SubscriptionPolicy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, "tt:SubscriptionPolicy", &(a->tt__EventSubscription::SubscriptionPolicy), ""))
				{	soap_flag_SubscriptionPolicy1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__EventSubscription::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__EventSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventSubscription, 0, sizeof(tt__EventSubscription), 0, soap_copy_tt__EventSubscription);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__EventSubscription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__EventSubscription);
	if (this->soap_out(soap, tag?tag:"tt:EventSubscription", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EventSubscription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EventSubscription(soap, this, tag, type);
}

SOAP_FMAC3 tt__EventSubscription * SOAP_FMAC4 soap_get_tt__EventSubscription(struct soap *soap, tt__EventSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__EventSubscription * SOAP_FMAC2 soap_instantiate_tt__EventSubscription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EventSubscription(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__EventSubscription, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__EventSubscription);
		if (size)
			*size = sizeof(tt__EventSubscription);
		((tt__EventSubscription*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__EventSubscription[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__EventSubscription);
		for (int i = 0; i < n; i++)
			((tt__EventSubscription*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__EventSubscription*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__EventSubscription(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__EventSubscription %p -> %p\n", q, p));
	*(tt__EventSubscription*)p = *(tt__EventSubscription*)q;
}

void tt__PTZFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__PTZFilter::Status);
	soap_default_bool(soap, &this->tt__PTZFilter::Position);
	soap_default_xsd__anyAttribute(soap, &this->tt__PTZFilter::__anyAttribute);
	/* transient soap skipped */
}

void tt__PTZFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__PTZFilter::Status, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__PTZFilter::Position, SOAP_TYPE_bool);
	/* transient soap skipped */
}

int tt__PTZFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZFilter(struct soap *soap, const char *tag, int id, const tt__PTZFilter *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__PTZFilter*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZFilter), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:Status", -1, &(a->tt__PTZFilter::Status), ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:Position", -1, &(a->tt__PTZFilter::Position), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__PTZFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__PTZFilter(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZFilter * SOAP_FMAC4 soap_in_tt__PTZFilter(struct soap *soap, const char *tag, tt__PTZFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZFilter, sizeof(tt__PTZFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__PTZFilter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__PTZFilter *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__PTZFilter*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Status1 = 1;
	size_t soap_flag_Position1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:Status", &(a->tt__PTZFilter::Status), "xsd:boolean"))
				{	soap_flag_Status1--;
					continue;
				}
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tt:Position", &(a->tt__PTZFilter::Position), "xsd:boolean"))
				{	soap_flag_Position1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZFilter, 0, sizeof(tt__PTZFilter), 0, soap_copy_tt__PTZFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status1 > 0 || soap_flag_Position1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__PTZFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__PTZFilter);
	if (this->soap_out(soap, tag?tag:"tt:PTZFilter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZFilter(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZFilter * SOAP_FMAC4 soap_get_tt__PTZFilter(struct soap *soap, tt__PTZFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__PTZFilter * SOAP_FMAC2 soap_instantiate_tt__PTZFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__PTZFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZFilter);
		if (size)
			*size = sizeof(tt__PTZFilter);
		((tt__PTZFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__PTZFilter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__PTZFilter);
		for (int i = 0; i < n; i++)
			((tt__PTZFilter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__PTZFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__PTZFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__PTZFilter %p -> %p\n", q, p));
	*(tt__PTZFilter*)p = *(tt__PTZFilter*)q;
}

void tt__MetadataConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__MetadataConfiguration::PTZStatus = NULL;
	this->tt__MetadataConfiguration::Events = NULL;
	this->tt__MetadataConfiguration::Analytics = NULL;
	this->tt__MetadataConfiguration::Multicast = NULL;
	soap_default_xsd__duration(soap, &this->tt__MetadataConfiguration::SessionTimeout);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MetadataConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__MetadataConfiguration::__anyAttribute);
	soap_default_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_default_int(soap, &this->tt__ConfigurationEntity::UseCount);
	soap_default_tt__ReferenceToken(soap, &this->tt__ConfigurationEntity::token);
	/* transient soap skipped */
}

void tt__MetadataConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__PTZFilter(soap, &this->tt__MetadataConfiguration::PTZStatus);
	soap_serialize_PointerTott__EventSubscription(soap, &this->tt__MetadataConfiguration::Events);
	soap_serialize_PointerTobool(soap, &this->tt__MetadataConfiguration::Analytics);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &this->tt__MetadataConfiguration::Multicast);
	soap_embedded(soap, &this->tt__MetadataConfiguration::SessionTimeout, SOAP_TYPE_xsd__duration);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__MetadataConfiguration::__any);
	soap_embedded(soap, &this->tt__ConfigurationEntity::Name, SOAP_TYPE_tt__Name);
	soap_serialize_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_embedded(soap, &this->tt__ConfigurationEntity::UseCount, SOAP_TYPE_int);
	/* transient soap skipped */
}

int tt__MetadataConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MetadataConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfiguration(struct soap *soap, const char *tag, int id, const tt__MetadataConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__MetadataConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	if (!((tt__ConfigurationEntity*)a)->token.empty())
		soap_set_attr(soap, "token", ((tt__ConfigurationEntity*)a)->token.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataConfiguration), "tt:MetadataConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &(a->tt__ConfigurationEntity::Name), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &(a->tt__ConfigurationEntity::UseCount), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTott__PTZFilter(soap, "tt:PTZStatus", -1, &(a->tt__MetadataConfiguration::PTZStatus), ""))
		return soap->error;
	if (soap_out_PointerTott__EventSubscription(soap, "tt:Events", -1, &(a->tt__MetadataConfiguration::Events), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Analytics", -1, &(a->tt__MetadataConfiguration::Analytics), ""))
		return soap->error;
	if (a->tt__MetadataConfiguration::Multicast)
	{	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->tt__MetadataConfiguration::Multicast, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Multicast"))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:SessionTimeout", -1, &(a->tt__MetadataConfiguration::SessionTimeout), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__MetadataConfiguration::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MetadataConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__MetadataConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__MetadataConfiguration * SOAP_FMAC4 soap_in_tt__MetadataConfiguration(struct soap *soap, const char *tag, tt__MetadataConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MetadataConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfiguration, sizeof(tt__MetadataConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__MetadataConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__MetadataConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__MetadataConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	{	const char *t = soap_attr_value(soap, "token", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, 64))
				return NULL;
			((tt__ConfigurationEntity*)a)->token.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_PTZStatus1 = 1;
	size_t soap_flag_Events1 = 1;
	size_t soap_flag_Analytics1 = 1;
	size_t soap_flag_Multicast1 = 1;
	size_t soap_flag_SessionTimeout1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &(a->tt__ConfigurationEntity::Name), "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &(a->tt__ConfigurationEntity::UseCount), "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_PTZStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZFilter(soap, "tt:PTZStatus", &(a->tt__MetadataConfiguration::PTZStatus), "tt:PTZFilter"))
				{	soap_flag_PTZStatus1--;
					continue;
				}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__EventSubscription(soap, "tt:Events", &(a->tt__MetadataConfiguration::Events), "tt:EventSubscription"))
				{	soap_flag_Events1--;
					continue;
				}
			if (soap_flag_Analytics1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "tt:Analytics", &(a->tt__MetadataConfiguration::Analytics), "xsd:boolean"))
				{	soap_flag_Analytics1--;
					continue;
				}
			if (soap_flag_Multicast1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &(a->tt__MetadataConfiguration::Multicast), "tt:MulticastConfiguration"))
				{	soap_flag_Multicast1--;
					continue;
				}
			if (soap_flag_SessionTimeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tt:SessionTimeout", &(a->tt__MetadataConfiguration::SessionTimeout), "xsd:duration"))
				{	soap_flag_SessionTimeout1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__MetadataConfiguration::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MetadataConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfiguration, 0, sizeof(tt__MetadataConfiguration), 0, soap_copy_tt__MetadataConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_Multicast1 > 0 || soap_flag_SessionTimeout1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__MetadataConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__MetadataConfiguration);
	if (this->soap_out(soap, tag?tag:"tt:MetadataConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MetadataConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MetadataConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__MetadataConfiguration * SOAP_FMAC4 soap_get_tt__MetadataConfiguration(struct soap *soap, tt__MetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__MetadataConfiguration * SOAP_FMAC2 soap_instantiate_tt__MetadataConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MetadataConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__MetadataConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__MetadataConfiguration);
		if (size)
			*size = sizeof(tt__MetadataConfiguration);
		((tt__MetadataConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__MetadataConfiguration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__MetadataConfiguration);
		for (int i = 0; i < n; i++)
			((tt__MetadataConfiguration*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__MetadataConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__MetadataConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__MetadataConfiguration %p -> %p\n", q, p));
	*(tt__MetadataConfiguration*)p = *(tt__MetadataConfiguration*)q;
}

void tt__VideoAnalyticsConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration = NULL;
	this->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoAnalyticsConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__VideoAnalyticsConfiguration::__anyAttribute);
	soap_default_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_default_int(soap, &this->tt__ConfigurationEntity::UseCount);
	soap_default_tt__ReferenceToken(soap, &this->tt__ConfigurationEntity::token);
	/* transient soap skipped */
}

void tt__VideoAnalyticsConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AnalyticsEngineConfiguration(soap, &this->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration);
	soap_serialize_PointerTott__RuleEngineConfiguration(soap, &this->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoAnalyticsConfiguration::__any);
	soap_embedded(soap, &this->tt__ConfigurationEntity::Name, SOAP_TYPE_tt__Name);
	soap_serialize_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_embedded(soap, &this->tt__ConfigurationEntity::UseCount, SOAP_TYPE_int);
	/* transient soap skipped */
}

int tt__VideoAnalyticsConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoAnalyticsConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const tt__VideoAnalyticsConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__VideoAnalyticsConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	if (!((tt__ConfigurationEntity*)a)->token.empty())
		soap_set_attr(soap, "token", ((tt__ConfigurationEntity*)a)->token.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoAnalyticsConfiguration), "tt:VideoAnalyticsConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &(a->tt__ConfigurationEntity::Name), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &(a->tt__ConfigurationEntity::UseCount), ""))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration)
	{	if (soap_out_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", -1, &a->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:AnalyticsEngineConfiguration"))
		return soap->error;
	if (a->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration)
	{	if (soap_out_PointerTott__RuleEngineConfiguration(soap, "tt:RuleEngineConfiguration", -1, &a->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:RuleEngineConfiguration"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__VideoAnalyticsConfiguration::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoAnalyticsConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoAnalyticsConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoAnalyticsConfiguration * SOAP_FMAC4 soap_in_tt__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, tt__VideoAnalyticsConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoAnalyticsConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoAnalyticsConfiguration, sizeof(tt__VideoAnalyticsConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoAnalyticsConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoAnalyticsConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__VideoAnalyticsConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	{	const char *t = soap_attr_value(soap, "token", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, 64))
				return NULL;
			((tt__ConfigurationEntity*)a)->token.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_AnalyticsEngineConfiguration1 = 1;
	size_t soap_flag_RuleEngineConfiguration1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &(a->tt__ConfigurationEntity::Name), "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &(a->tt__ConfigurationEntity::UseCount), "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_AnalyticsEngineConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", &(a->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration), "tt:AnalyticsEngineConfiguration"))
				{	soap_flag_AnalyticsEngineConfiguration1--;
					continue;
				}
			if (soap_flag_RuleEngineConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RuleEngineConfiguration(soap, "tt:RuleEngineConfiguration", &(a->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration), "tt:RuleEngineConfiguration"))
				{	soap_flag_RuleEngineConfiguration1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__VideoAnalyticsConfiguration::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoAnalyticsConfiguration, 0, sizeof(tt__VideoAnalyticsConfiguration), 0, soap_copy_tt__VideoAnalyticsConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_AnalyticsEngineConfiguration1 > 0 || soap_flag_RuleEngineConfiguration1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__VideoAnalyticsConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoAnalyticsConfiguration);
	if (this->soap_out(soap, tag?tag:"tt:VideoAnalyticsConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoAnalyticsConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoAnalyticsConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoAnalyticsConfiguration * SOAP_FMAC4 soap_get_tt__VideoAnalyticsConfiguration(struct soap *soap, tt__VideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoAnalyticsConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoAnalyticsConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoAnalyticsConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoAnalyticsConfiguration);
		if (size)
			*size = sizeof(tt__VideoAnalyticsConfiguration);
		((tt__VideoAnalyticsConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoAnalyticsConfiguration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__VideoAnalyticsConfiguration);
		for (int i = 0; i < n; i++)
			((tt__VideoAnalyticsConfiguration*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__VideoAnalyticsConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoAnalyticsConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoAnalyticsConfiguration %p -> %p\n", q, p));
	*(tt__VideoAnalyticsConfiguration*)p = *(tt__VideoAnalyticsConfiguration*)q;
}

void tt__AudioEncoderConfigurationOption::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__AudioEncoding(soap, &this->tt__AudioEncoderConfigurationOption::Encoding);
	this->tt__AudioEncoderConfigurationOption::BitrateList = NULL;
	this->tt__AudioEncoderConfigurationOption::SampleRateList = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioEncoderConfigurationOption::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioEncoderConfigurationOption::__anyAttribute);
	/* transient soap skipped */
}

void tt__AudioEncoderConfigurationOption::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IntList(soap, &this->tt__AudioEncoderConfigurationOption::BitrateList);
	soap_serialize_PointerTott__IntList(soap, &this->tt__AudioEncoderConfigurationOption::SampleRateList);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioEncoderConfigurationOption::__any);
	/* transient soap skipped */
}

int tt__AudioEncoderConfigurationOption::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioEncoderConfigurationOption(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, int id, const tt__AudioEncoderConfigurationOption *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioEncoderConfigurationOption*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOption), type))
		return soap->error;
	if (soap_out_tt__AudioEncoding(soap, "tt:Encoding", -1, &(a->tt__AudioEncoderConfigurationOption::Encoding), ""))
		return soap->error;
	if (a->tt__AudioEncoderConfigurationOption::BitrateList)
	{	if (soap_out_PointerTott__IntList(soap, "tt:BitrateList", -1, &a->tt__AudioEncoderConfigurationOption::BitrateList, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:BitrateList"))
		return soap->error;
	if (a->tt__AudioEncoderConfigurationOption::SampleRateList)
	{	if (soap_out_PointerTott__IntList(soap, "tt:SampleRateList", -1, &a->tt__AudioEncoderConfigurationOption::SampleRateList, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SampleRateList"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__AudioEncoderConfigurationOption::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__AudioEncoderConfigurationOption::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__AudioEncoderConfigurationOption(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOption * SOAP_FMAC4 soap_in_tt__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, tt__AudioEncoderConfigurationOption *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioEncoderConfigurationOption *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOption, sizeof(tt__AudioEncoderConfigurationOption), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__AudioEncoderConfigurationOption)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__AudioEncoderConfigurationOption *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioEncoderConfigurationOption*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Encoding1 = 1;
	size_t soap_flag_BitrateList1 = 1;
	size_t soap_flag_SampleRateList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Encoding1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__AudioEncoding(soap, "tt:Encoding", &(a->tt__AudioEncoderConfigurationOption::Encoding), "tt:AudioEncoding"))
				{	soap_flag_Encoding1--;
					continue;
				}
			if (soap_flag_BitrateList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:BitrateList", &(a->tt__AudioEncoderConfigurationOption::BitrateList), "tt:IntList"))
				{	soap_flag_BitrateList1--;
					continue;
				}
			if (soap_flag_SampleRateList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:SampleRateList", &(a->tt__AudioEncoderConfigurationOption::SampleRateList), "tt:IntList"))
				{	soap_flag_SampleRateList1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__AudioEncoderConfigurationOption::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioEncoderConfigurationOption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfigurationOption, 0, sizeof(tt__AudioEncoderConfigurationOption), 0, soap_copy_tt__AudioEncoderConfigurationOption);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Encoding1 > 0 || soap_flag_BitrateList1 > 0 || soap_flag_SampleRateList1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__AudioEncoderConfigurationOption::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__AudioEncoderConfigurationOption);
	if (this->soap_out(soap, tag?tag:"tt:AudioEncoderConfigurationOption", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioEncoderConfigurationOption::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioEncoderConfigurationOption(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOption * SOAP_FMAC4 soap_get_tt__AudioEncoderConfigurationOption(struct soap *soap, tt__AudioEncoderConfigurationOption *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoderConfigurationOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__AudioEncoderConfigurationOption * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfigurationOption(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioEncoderConfigurationOption(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__AudioEncoderConfigurationOption, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__AudioEncoderConfigurationOption);
		if (size)
			*size = sizeof(tt__AudioEncoderConfigurationOption);
		((tt__AudioEncoderConfigurationOption*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__AudioEncoderConfigurationOption[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__AudioEncoderConfigurationOption);
		for (int i = 0; i < n; i++)
			((tt__AudioEncoderConfigurationOption*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__AudioEncoderConfigurationOption*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__AudioEncoderConfigurationOption(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__AudioEncoderConfigurationOption %p -> %p\n", q, p));
	*(tt__AudioEncoderConfigurationOption*)p = *(tt__AudioEncoderConfigurationOption*)q;
}

void tt__AudioEncoderConfigurationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(soap, &this->tt__AudioEncoderConfigurationOptions::Options);
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioEncoderConfigurationOptions::__anyAttribute);
	/* transient soap skipped */
}

void tt__AudioEncoderConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(soap, &this->tt__AudioEncoderConfigurationOptions::Options);
	/* transient soap skipped */
}

int tt__AudioEncoderConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioEncoderConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__AudioEncoderConfigurationOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioEncoderConfigurationOptions*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(soap, "tt:Options", -1, &(a->tt__AudioEncoderConfigurationOptions::Options), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__AudioEncoderConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__AudioEncoderConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, tt__AudioEncoderConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioEncoderConfigurationOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, sizeof(tt__AudioEncoderConfigurationOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__AudioEncoderConfigurationOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__AudioEncoderConfigurationOptions *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioEncoderConfigurationOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(soap, "tt:Options", &(a->tt__AudioEncoderConfigurationOptions::Options), "tt:AudioEncoderConfigurationOption"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, 0, sizeof(tt__AudioEncoderConfigurationOptions), 0, soap_copy_tt__AudioEncoderConfigurationOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__AudioEncoderConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__AudioEncoderConfigurationOptions);
	if (this->soap_out(soap, tag?tag:"tt:AudioEncoderConfigurationOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioEncoderConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioEncoderConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioEncoderConfigurationOptions(struct soap *soap, tt__AudioEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__AudioEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioEncoderConfigurationOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__AudioEncoderConfigurationOptions);
		if (size)
			*size = sizeof(tt__AudioEncoderConfigurationOptions);
		((tt__AudioEncoderConfigurationOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__AudioEncoderConfigurationOptions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__AudioEncoderConfigurationOptions);
		for (int i = 0; i < n; i++)
			((tt__AudioEncoderConfigurationOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__AudioEncoderConfigurationOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__AudioEncoderConfigurationOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__AudioEncoderConfigurationOptions %p -> %p\n", q, p));
	*(tt__AudioEncoderConfigurationOptions*)p = *(tt__AudioEncoderConfigurationOptions*)q;
}

void tt__AudioEncoderConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__AudioEncoding(soap, &this->tt__AudioEncoderConfiguration::Encoding);
	soap_default_int(soap, &this->tt__AudioEncoderConfiguration::Bitrate);
	soap_default_int(soap, &this->tt__AudioEncoderConfiguration::SampleRate);
	this->tt__AudioEncoderConfiguration::Multicast = NULL;
	soap_default_xsd__duration(soap, &this->tt__AudioEncoderConfiguration::SessionTimeout);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioEncoderConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioEncoderConfiguration::__anyAttribute);
	soap_default_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_default_int(soap, &this->tt__ConfigurationEntity::UseCount);
	soap_default_tt__ReferenceToken(soap, &this->tt__ConfigurationEntity::token);
	/* transient soap skipped */
}

void tt__AudioEncoderConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__AudioEncoderConfiguration::Bitrate, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__AudioEncoderConfiguration::SampleRate, SOAP_TYPE_int);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &this->tt__AudioEncoderConfiguration::Multicast);
	soap_embedded(soap, &this->tt__AudioEncoderConfiguration::SessionTimeout, SOAP_TYPE_xsd__duration);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioEncoderConfiguration::__any);
	soap_embedded(soap, &this->tt__ConfigurationEntity::Name, SOAP_TYPE_tt__Name);
	soap_serialize_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_embedded(soap, &this->tt__ConfigurationEntity::UseCount, SOAP_TYPE_int);
	/* transient soap skipped */
}

int tt__AudioEncoderConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioEncoderConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const tt__AudioEncoderConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioEncoderConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	if (!((tt__ConfigurationEntity*)a)->token.empty())
		soap_set_attr(soap, "token", ((tt__ConfigurationEntity*)a)->token.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoderConfiguration), "tt:AudioEncoderConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &(a->tt__ConfigurationEntity::Name), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &(a->tt__ConfigurationEntity::UseCount), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_tt__AudioEncoding(soap, "tt:Encoding", -1, &(a->tt__AudioEncoderConfiguration::Encoding), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Bitrate", -1, &(a->tt__AudioEncoderConfiguration::Bitrate), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:SampleRate", -1, &(a->tt__AudioEncoderConfiguration::SampleRate), ""))
		return soap->error;
	if (a->tt__AudioEncoderConfiguration::Multicast)
	{	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->tt__AudioEncoderConfiguration::Multicast, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Multicast"))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:SessionTimeout", -1, &(a->tt__AudioEncoderConfiguration::SessionTimeout), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__AudioEncoderConfiguration::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioEncoderConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__AudioEncoderConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioEncoderConfiguration * SOAP_FMAC4 soap_in_tt__AudioEncoderConfiguration(struct soap *soap, const char *tag, tt__AudioEncoderConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioEncoderConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfiguration, sizeof(tt__AudioEncoderConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__AudioEncoderConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__AudioEncoderConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioEncoderConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	{	const char *t = soap_attr_value(soap, "token", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, 64))
				return NULL;
			((tt__ConfigurationEntity*)a)->token.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_Encoding1 = 1;
	size_t soap_flag_Bitrate1 = 1;
	size_t soap_flag_SampleRate1 = 1;
	size_t soap_flag_Multicast1 = 1;
	size_t soap_flag_SessionTimeout1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &(a->tt__ConfigurationEntity::Name), "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &(a->tt__ConfigurationEntity::UseCount), "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_Encoding1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__AudioEncoding(soap, "tt:Encoding", &(a->tt__AudioEncoderConfiguration::Encoding), "tt:AudioEncoding"))
				{	soap_flag_Encoding1--;
					continue;
				}
			if (soap_flag_Bitrate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Bitrate", &(a->tt__AudioEncoderConfiguration::Bitrate), "xsd:int"))
				{	soap_flag_Bitrate1--;
					continue;
				}
			if (soap_flag_SampleRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:SampleRate", &(a->tt__AudioEncoderConfiguration::SampleRate), "xsd:int"))
				{	soap_flag_SampleRate1--;
					continue;
				}
			if (soap_flag_Multicast1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &(a->tt__AudioEncoderConfiguration::Multicast), "tt:MulticastConfiguration"))
				{	soap_flag_Multicast1--;
					continue;
				}
			if (soap_flag_SessionTimeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tt:SessionTimeout", &(a->tt__AudioEncoderConfiguration::SessionTimeout), "xsd:duration"))
				{	soap_flag_SessionTimeout1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__AudioEncoderConfiguration::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfiguration, 0, sizeof(tt__AudioEncoderConfiguration), 0, soap_copy_tt__AudioEncoderConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_Encoding1 > 0 || soap_flag_Bitrate1 > 0 || soap_flag_SampleRate1 > 0 || soap_flag_Multicast1 > 0 || soap_flag_SessionTimeout1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__AudioEncoderConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__AudioEncoderConfiguration);
	if (this->soap_out(soap, tag?tag:"tt:AudioEncoderConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioEncoderConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioEncoderConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioEncoderConfiguration * SOAP_FMAC4 soap_get_tt__AudioEncoderConfiguration(struct soap *soap, tt__AudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__AudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioEncoderConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__AudioEncoderConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__AudioEncoderConfiguration);
		if (size)
			*size = sizeof(tt__AudioEncoderConfiguration);
		((tt__AudioEncoderConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__AudioEncoderConfiguration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__AudioEncoderConfiguration);
		for (int i = 0; i < n; i++)
			((tt__AudioEncoderConfiguration*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__AudioEncoderConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__AudioEncoderConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__AudioEncoderConfiguration %p -> %p\n", q, p));
	*(tt__AudioEncoderConfiguration*)p = *(tt__AudioEncoderConfiguration*)q;
}

void tt__AudioSourceOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioSourceOptionsExtension::__any);
	/* transient soap skipped */
}

void tt__AudioSourceOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioSourceOptionsExtension::__any);
	/* transient soap skipped */
}

int tt__AudioSourceOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioSourceOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceOptionsExtension(struct soap *soap, const char *tag, int id, const tt__AudioSourceOptionsExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSourceOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__AudioSourceOptionsExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__AudioSourceOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__AudioSourceOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioSourceOptionsExtension * SOAP_FMAC4 soap_in_tt__AudioSourceOptionsExtension(struct soap *soap, const char *tag, tt__AudioSourceOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioSourceOptionsExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceOptionsExtension, sizeof(tt__AudioSourceOptionsExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__AudioSourceOptionsExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__AudioSourceOptionsExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__AudioSourceOptionsExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioSourceOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceOptionsExtension, 0, sizeof(tt__AudioSourceOptionsExtension), 0, soap_copy_tt__AudioSourceOptionsExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__AudioSourceOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__AudioSourceOptionsExtension);
	if (this->soap_out(soap, tag?tag:"tt:AudioSourceOptionsExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioSourceOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioSourceOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioSourceOptionsExtension * SOAP_FMAC4 soap_get_tt__AudioSourceOptionsExtension(struct soap *soap, tt__AudioSourceOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSourceOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__AudioSourceOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__AudioSourceOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioSourceOptionsExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__AudioSourceOptionsExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__AudioSourceOptionsExtension);
		if (size)
			*size = sizeof(tt__AudioSourceOptionsExtension);
		((tt__AudioSourceOptionsExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__AudioSourceOptionsExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__AudioSourceOptionsExtension);
		for (int i = 0; i < n; i++)
			((tt__AudioSourceOptionsExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__AudioSourceOptionsExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__AudioSourceOptionsExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__AudioSourceOptionsExtension %p -> %p\n", q, p));
	*(tt__AudioSourceOptionsExtension*)p = *(tt__AudioSourceOptionsExtension*)q;
}

void tt__AudioSourceConfigurationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__AudioSourceConfigurationOptions::InputTokensAvailable);
	this->tt__AudioSourceConfigurationOptions::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioSourceConfigurationOptions::__anyAttribute);
	/* transient soap skipped */
}

void tt__AudioSourceConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__AudioSourceConfigurationOptions::InputTokensAvailable);
	soap_serialize_PointerTott__AudioSourceOptionsExtension(soap, &this->tt__AudioSourceConfigurationOptions::Extension);
	/* transient soap skipped */
}

int tt__AudioSourceConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioSourceConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__AudioSourceConfigurationOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioSourceConfigurationOptions*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSourceConfigurationOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ReferenceToken(soap, "tt:InputTokensAvailable", -1, &(a->tt__AudioSourceConfigurationOptions::InputTokensAvailable), ""))
		return soap->error;
	if (soap_out_PointerTott__AudioSourceOptionsExtension(soap, "tt:Extension", -1, &(a->tt__AudioSourceConfigurationOptions::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__AudioSourceConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__AudioSourceConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioSourceConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, tt__AudioSourceConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioSourceConfigurationOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceConfigurationOptions, sizeof(tt__AudioSourceConfigurationOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__AudioSourceConfigurationOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__AudioSourceConfigurationOptions *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioSourceConfigurationOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftt__ReferenceToken(soap, "tt:InputTokensAvailable", &(a->tt__AudioSourceConfigurationOptions::InputTokensAvailable), "tt:ReferenceToken"))
					continue;
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioSourceOptionsExtension(soap, "tt:Extension", &(a->tt__AudioSourceConfigurationOptions::Extension), "tt:AudioSourceOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceConfigurationOptions, 0, sizeof(tt__AudioSourceConfigurationOptions), 0, soap_copy_tt__AudioSourceConfigurationOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__AudioSourceConfigurationOptions::InputTokensAvailable.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__AudioSourceConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__AudioSourceConfigurationOptions);
	if (this->soap_out(soap, tag?tag:"tt:AudioSourceConfigurationOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioSourceConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioSourceConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioSourceConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioSourceConfigurationOptions(struct soap *soap, tt__AudioSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__AudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioSourceConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioSourceConfigurationOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__AudioSourceConfigurationOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__AudioSourceConfigurationOptions);
		if (size)
			*size = sizeof(tt__AudioSourceConfigurationOptions);
		((tt__AudioSourceConfigurationOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__AudioSourceConfigurationOptions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__AudioSourceConfigurationOptions);
		for (int i = 0; i < n; i++)
			((tt__AudioSourceConfigurationOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__AudioSourceConfigurationOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__AudioSourceConfigurationOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__AudioSourceConfigurationOptions %p -> %p\n", q, p));
	*(tt__AudioSourceConfigurationOptions*)p = *(tt__AudioSourceConfigurationOptions*)q;
}

void tt__AudioSourceConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->tt__AudioSourceConfiguration::SourceToken);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioSourceConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioSourceConfiguration::__anyAttribute);
	soap_default_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_default_int(soap, &this->tt__ConfigurationEntity::UseCount);
	soap_default_tt__ReferenceToken(soap, &this->tt__ConfigurationEntity::token);
	/* transient soap skipped */
}

void tt__AudioSourceConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__AudioSourceConfiguration::SourceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__AudioSourceConfiguration::SourceToken);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioSourceConfiguration::__any);
	soap_embedded(soap, &this->tt__ConfigurationEntity::Name, SOAP_TYPE_tt__Name);
	soap_serialize_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_embedded(soap, &this->tt__ConfigurationEntity::UseCount, SOAP_TYPE_int);
	/* transient soap skipped */
}

int tt__AudioSourceConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioSourceConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceConfiguration(struct soap *soap, const char *tag, int id, const tt__AudioSourceConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioSourceConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	if (!((tt__ConfigurationEntity*)a)->token.empty())
		soap_set_attr(soap, "token", ((tt__ConfigurationEntity*)a)->token.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSourceConfiguration), "tt:AudioSourceConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &(a->tt__ConfigurationEntity::Name), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &(a->tt__ConfigurationEntity::UseCount), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_tt__ReferenceToken(soap, "tt:SourceToken", -1, &(a->tt__AudioSourceConfiguration::SourceToken), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__AudioSourceConfiguration::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioSourceConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__AudioSourceConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioSourceConfiguration * SOAP_FMAC4 soap_in_tt__AudioSourceConfiguration(struct soap *soap, const char *tag, tt__AudioSourceConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioSourceConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(tt__AudioSourceConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__AudioSourceConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__AudioSourceConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioSourceConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	{	const char *t = soap_attr_value(soap, "token", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, 64))
				return NULL;
			((tt__ConfigurationEntity*)a)->token.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_SourceToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &(a->tt__ConfigurationEntity::Name), "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &(a->tt__ConfigurationEntity::UseCount), "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_SourceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:SourceToken", &(a->tt__AudioSourceConfiguration::SourceToken), "tt:ReferenceToken"))
				{	soap_flag_SourceToken1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__AudioSourceConfiguration::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceConfiguration, 0, sizeof(tt__AudioSourceConfiguration), 0, soap_copy_tt__AudioSourceConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_SourceToken1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__AudioSourceConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__AudioSourceConfiguration);
	if (this->soap_out(soap, tag?tag:"tt:AudioSourceConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioSourceConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioSourceConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioSourceConfiguration * SOAP_FMAC4 soap_get_tt__AudioSourceConfiguration(struct soap *soap, tt__AudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__AudioSourceConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioSourceConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__AudioSourceConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__AudioSourceConfiguration);
		if (size)
			*size = sizeof(tt__AudioSourceConfiguration);
		((tt__AudioSourceConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__AudioSourceConfiguration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__AudioSourceConfiguration);
		for (int i = 0; i < n; i++)
			((tt__AudioSourceConfiguration*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__AudioSourceConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__AudioSourceConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__AudioSourceConfiguration %p -> %p\n", q, p));
	*(tt__AudioSourceConfiguration*)p = *(tt__AudioSourceConfiguration*)q;
}

void tt__H264Options::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__H264Options::ResolutionsAvailable);
	this->tt__H264Options::GovLengthRange = NULL;
	this->tt__H264Options::FrameRateRange = NULL;
	this->tt__H264Options::EncodingIntervalRange = NULL;
	soap_default_std__vectorTemplateOftt__H264Profile(soap, &this->tt__H264Options::H264ProfilesSupported);
	/* transient soap skipped */
}

void tt__H264Options::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__H264Options::ResolutionsAvailable);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__H264Options::GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__H264Options::FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__H264Options::EncodingIntervalRange);
	soap_serialize_std__vectorTemplateOftt__H264Profile(soap, &this->tt__H264Options::H264ProfilesSupported);
	/* transient soap skipped */
}

int tt__H264Options::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__H264Options(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Options(struct soap *soap, const char *tag, int id, const tt__H264Options *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Options), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, &(a->tt__H264Options::ResolutionsAvailable), ""))
		return soap->error;
	if (a->tt__H264Options::GovLengthRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->tt__H264Options::GovLengthRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:GovLengthRange"))
		return soap->error;
	if (a->tt__H264Options::FrameRateRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->tt__H264Options::FrameRateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:FrameRateRange"))
		return soap->error;
	if (a->tt__H264Options::EncodingIntervalRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->tt__H264Options::EncodingIntervalRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__H264Profile(soap, "tt:H264ProfilesSupported", -1, &(a->tt__H264Options::H264ProfilesSupported), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__H264Options::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__H264Options(soap, tag, this, type);
}

SOAP_FMAC3 tt__H264Options * SOAP_FMAC4 soap_in_tt__H264Options(struct soap *soap, const char *tag, tt__H264Options *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__H264Options *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Options, sizeof(tt__H264Options), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__H264Options)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__H264Options *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GovLengthRange1 = 1;
	size_t soap_flag_FrameRateRange1 = 1;
	size_t soap_flag_EncodingIntervalRange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", &(a->tt__H264Options::ResolutionsAvailable), "tt:VideoResolution"))
					continue;
			if (soap_flag_GovLengthRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &(a->tt__H264Options::GovLengthRange), "tt:IntRange"))
				{	soap_flag_GovLengthRange1--;
					continue;
				}
			if (soap_flag_FrameRateRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &(a->tt__H264Options::FrameRateRange), "tt:IntRange"))
				{	soap_flag_FrameRateRange1--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &(a->tt__H264Options::EncodingIntervalRange), "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftt__H264Profile(soap, "tt:H264ProfilesSupported", &(a->tt__H264Options::H264ProfilesSupported), "tt:H264Profile"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__H264Options *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Options, 0, sizeof(tt__H264Options), 0, soap_copy_tt__H264Options);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__H264Options::ResolutionsAvailable.size() < 1 || soap_flag_GovLengthRange1 > 0 || soap_flag_FrameRateRange1 > 0 || soap_flag_EncodingIntervalRange1 > 0 || a->tt__H264Options::H264ProfilesSupported.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__H264Options::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__H264Options);
	if (this->soap_out(soap, tag?tag:"tt:H264Options", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__H264Options::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__H264Options(soap, this, tag, type);
}

SOAP_FMAC3 tt__H264Options * SOAP_FMAC4 soap_get_tt__H264Options(struct soap *soap, tt__H264Options *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__H264Options * SOAP_FMAC2 soap_instantiate_tt__H264Options(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__H264Options(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__H264Options, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__H264Options);
		if (size)
			*size = sizeof(tt__H264Options);
		((tt__H264Options*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__H264Options[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__H264Options);
		for (int i = 0; i < n; i++)
			((tt__H264Options*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__H264Options*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__H264Options(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__H264Options %p -> %p\n", q, p));
	*(tt__H264Options*)p = *(tt__H264Options*)q;
}

void tt__Mpeg4Options::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__Mpeg4Options::ResolutionsAvailable);
	this->tt__Mpeg4Options::GovLengthRange = NULL;
	this->tt__Mpeg4Options::FrameRateRange = NULL;
	this->tt__Mpeg4Options::EncodingIntervalRange = NULL;
	soap_default_std__vectorTemplateOftt__Mpeg4Profile(soap, &this->tt__Mpeg4Options::Mpeg4ProfilesSupported);
	/* transient soap skipped */
}

void tt__Mpeg4Options::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__Mpeg4Options::ResolutionsAvailable);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__Mpeg4Options::GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__Mpeg4Options::FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__Mpeg4Options::EncodingIntervalRange);
	soap_serialize_std__vectorTemplateOftt__Mpeg4Profile(soap, &this->tt__Mpeg4Options::Mpeg4ProfilesSupported);
	/* transient soap skipped */
}

int tt__Mpeg4Options::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Mpeg4Options(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Options(struct soap *soap, const char *tag, int id, const tt__Mpeg4Options *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Options), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, &(a->tt__Mpeg4Options::ResolutionsAvailable), ""))
		return soap->error;
	if (a->tt__Mpeg4Options::GovLengthRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->tt__Mpeg4Options::GovLengthRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:GovLengthRange"))
		return soap->error;
	if (a->tt__Mpeg4Options::FrameRateRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->tt__Mpeg4Options::FrameRateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:FrameRateRange"))
		return soap->error;
	if (a->tt__Mpeg4Options::EncodingIntervalRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->tt__Mpeg4Options::EncodingIntervalRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", -1, &(a->tt__Mpeg4Options::Mpeg4ProfilesSupported), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Mpeg4Options::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Mpeg4Options(soap, tag, this, type);
}

SOAP_FMAC3 tt__Mpeg4Options * SOAP_FMAC4 soap_in_tt__Mpeg4Options(struct soap *soap, const char *tag, tt__Mpeg4Options *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Mpeg4Options *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Options, sizeof(tt__Mpeg4Options), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Mpeg4Options)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Mpeg4Options *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GovLengthRange1 = 1;
	size_t soap_flag_FrameRateRange1 = 1;
	size_t soap_flag_EncodingIntervalRange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", &(a->tt__Mpeg4Options::ResolutionsAvailable), "tt:VideoResolution"))
					continue;
			if (soap_flag_GovLengthRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &(a->tt__Mpeg4Options::GovLengthRange), "tt:IntRange"))
				{	soap_flag_GovLengthRange1--;
					continue;
				}
			if (soap_flag_FrameRateRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &(a->tt__Mpeg4Options::FrameRateRange), "tt:IntRange"))
				{	soap_flag_FrameRateRange1--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &(a->tt__Mpeg4Options::EncodingIntervalRange), "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", &(a->tt__Mpeg4Options::Mpeg4ProfilesSupported), "tt:Mpeg4Profile"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Mpeg4Options *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Options, 0, sizeof(tt__Mpeg4Options), 0, soap_copy_tt__Mpeg4Options);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__Mpeg4Options::ResolutionsAvailable.size() < 1 || soap_flag_GovLengthRange1 > 0 || soap_flag_FrameRateRange1 > 0 || soap_flag_EncodingIntervalRange1 > 0 || a->tt__Mpeg4Options::Mpeg4ProfilesSupported.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Mpeg4Options::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Mpeg4Options);
	if (this->soap_out(soap, tag?tag:"tt:Mpeg4Options", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Mpeg4Options::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Mpeg4Options(soap, this, tag, type);
}

SOAP_FMAC3 tt__Mpeg4Options * SOAP_FMAC4 soap_get_tt__Mpeg4Options(struct soap *soap, tt__Mpeg4Options *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Mpeg4Options * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Options(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Mpeg4Options(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Mpeg4Options, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Mpeg4Options);
		if (size)
			*size = sizeof(tt__Mpeg4Options);
		((tt__Mpeg4Options*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Mpeg4Options[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Mpeg4Options);
		for (int i = 0; i < n; i++)
			((tt__Mpeg4Options*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Mpeg4Options*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Mpeg4Options(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Mpeg4Options %p -> %p\n", q, p));
	*(tt__Mpeg4Options*)p = *(tt__Mpeg4Options*)q;
}

void tt__JpegOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__JpegOptions::ResolutionsAvailable);
	this->tt__JpegOptions::FrameRateRange = NULL;
	this->tt__JpegOptions::EncodingIntervalRange = NULL;
	/* transient soap skipped */
}

void tt__JpegOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__JpegOptions::ResolutionsAvailable);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__JpegOptions::FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__JpegOptions::EncodingIntervalRange);
	/* transient soap skipped */
}

int tt__JpegOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__JpegOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__JpegOptions(struct soap *soap, const char *tag, int id, const tt__JpegOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__JpegOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, &(a->tt__JpegOptions::ResolutionsAvailable), ""))
		return soap->error;
	if (a->tt__JpegOptions::FrameRateRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->tt__JpegOptions::FrameRateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:FrameRateRange"))
		return soap->error;
	if (a->tt__JpegOptions::EncodingIntervalRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->tt__JpegOptions::EncodingIntervalRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__JpegOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__JpegOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__JpegOptions * SOAP_FMAC4 soap_in_tt__JpegOptions(struct soap *soap, const char *tag, tt__JpegOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__JpegOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__JpegOptions, sizeof(tt__JpegOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__JpegOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__JpegOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_FrameRateRange1 = 1;
	size_t soap_flag_EncodingIntervalRange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", &(a->tt__JpegOptions::ResolutionsAvailable), "tt:VideoResolution"))
					continue;
			if (soap_flag_FrameRateRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &(a->tt__JpegOptions::FrameRateRange), "tt:IntRange"))
				{	soap_flag_FrameRateRange1--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &(a->tt__JpegOptions::EncodingIntervalRange), "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__JpegOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__JpegOptions, 0, sizeof(tt__JpegOptions), 0, soap_copy_tt__JpegOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__JpegOptions::ResolutionsAvailable.size() < 1 || soap_flag_FrameRateRange1 > 0 || soap_flag_EncodingIntervalRange1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__JpegOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__JpegOptions);
	if (this->soap_out(soap, tag?tag:"tt:JpegOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__JpegOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__JpegOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__JpegOptions * SOAP_FMAC4 soap_get_tt__JpegOptions(struct soap *soap, tt__JpegOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__JpegOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__JpegOptions * SOAP_FMAC2 soap_instantiate_tt__JpegOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__JpegOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__JpegOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__JpegOptions);
		if (size)
			*size = sizeof(tt__JpegOptions);
		((tt__JpegOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__JpegOptions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__JpegOptions);
		for (int i = 0; i < n; i++)
			((tt__JpegOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__JpegOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__JpegOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__JpegOptions %p -> %p\n", q, p));
	*(tt__JpegOptions*)p = *(tt__JpegOptions*)q;
}

void tt__VideoEncoderOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoEncoderOptionsExtension::__any);
	/* transient soap skipped */
}

void tt__VideoEncoderOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoEncoderOptionsExtension::__any);
	/* transient soap skipped */
}

int tt__VideoEncoderOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoEncoderOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, int id, const tt__VideoEncoderOptionsExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__VideoEncoderOptionsExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__VideoEncoderOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoEncoderOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoEncoderOptionsExtension * SOAP_FMAC4 soap_in_tt__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, tt__VideoEncoderOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoEncoderOptionsExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension, sizeof(tt__VideoEncoderOptionsExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoEncoderOptionsExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoEncoderOptionsExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__VideoEncoderOptionsExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoEncoderOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderOptionsExtension, 0, sizeof(tt__VideoEncoderOptionsExtension), 0, soap_copy_tt__VideoEncoderOptionsExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__VideoEncoderOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoEncoderOptionsExtension);
	if (this->soap_out(soap, tag?tag:"tt:VideoEncoderOptionsExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoEncoderOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoEncoderOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoEncoderOptionsExtension * SOAP_FMAC4 soap_get_tt__VideoEncoderOptionsExtension(struct soap *soap, tt__VideoEncoderOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoEncoderOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoEncoderOptionsExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoEncoderOptionsExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoEncoderOptionsExtension);
		if (size)
			*size = sizeof(tt__VideoEncoderOptionsExtension);
		((tt__VideoEncoderOptionsExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoEncoderOptionsExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__VideoEncoderOptionsExtension);
		for (int i = 0; i < n; i++)
			((tt__VideoEncoderOptionsExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__VideoEncoderOptionsExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoEncoderOptionsExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoEncoderOptionsExtension %p -> %p\n", q, p));
	*(tt__VideoEncoderOptionsExtension*)p = *(tt__VideoEncoderOptionsExtension*)q;
}

void tt__VideoEncoderConfigurationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__VideoEncoderConfigurationOptions::QualityRange = NULL;
	this->tt__VideoEncoderConfigurationOptions::JPEG = NULL;
	this->tt__VideoEncoderConfigurationOptions::MPEG4 = NULL;
	this->tt__VideoEncoderConfigurationOptions::H264 = NULL;
	this->tt__VideoEncoderConfigurationOptions::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__VideoEncoderConfigurationOptions::__anyAttribute);
	/* transient soap skipped */
}

void tt__VideoEncoderConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IntRange(soap, &this->tt__VideoEncoderConfigurationOptions::QualityRange);
	soap_serialize_PointerTott__JpegOptions(soap, &this->tt__VideoEncoderConfigurationOptions::JPEG);
	soap_serialize_PointerTott__Mpeg4Options(soap, &this->tt__VideoEncoderConfigurationOptions::MPEG4);
	soap_serialize_PointerTott__H264Options(soap, &this->tt__VideoEncoderConfigurationOptions::H264);
	soap_serialize_PointerTott__VideoEncoderOptionsExtension(soap, &this->tt__VideoEncoderConfigurationOptions::Extension);
	/* transient soap skipped */
}

int tt__VideoEncoderConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoEncoderConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__VideoEncoderConfigurationOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__VideoEncoderConfigurationOptions*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions), type))
		return soap->error;
	if (a->tt__VideoEncoderConfigurationOptions::QualityRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:QualityRange", -1, &a->tt__VideoEncoderConfigurationOptions::QualityRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:QualityRange"))
		return soap->error;
	if (soap_out_PointerTott__JpegOptions(soap, "tt:JPEG", -1, &(a->tt__VideoEncoderConfigurationOptions::JPEG), ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4Options(soap, "tt:MPEG4", -1, &(a->tt__VideoEncoderConfigurationOptions::MPEG4), ""))
		return soap->error;
	if (soap_out_PointerTott__H264Options(soap, "tt:H264", -1, &(a->tt__VideoEncoderConfigurationOptions::H264), ""))
		return soap->error;
	if (soap_out_PointerTott__VideoEncoderOptionsExtension(soap, "tt:Extension", -1, &(a->tt__VideoEncoderConfigurationOptions::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__VideoEncoderConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoEncoderConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoEncoderConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, tt__VideoEncoderConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoEncoderConfigurationOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, sizeof(tt__VideoEncoderConfigurationOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoEncoderConfigurationOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoEncoderConfigurationOptions *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__VideoEncoderConfigurationOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_QualityRange1 = 1;
	size_t soap_flag_JPEG1 = 1;
	size_t soap_flag_MPEG41 = 1;
	size_t soap_flag_H2641 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QualityRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:QualityRange", &(a->tt__VideoEncoderConfigurationOptions::QualityRange), "tt:IntRange"))
				{	soap_flag_QualityRange1--;
					continue;
				}
			if (soap_flag_JPEG1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__JpegOptions(soap, "tt:JPEG", &(a->tt__VideoEncoderConfigurationOptions::JPEG), "tt:JpegOptions"))
				{	soap_flag_JPEG1--;
					continue;
				}
			if (soap_flag_MPEG41 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Mpeg4Options(soap, "tt:MPEG4", &(a->tt__VideoEncoderConfigurationOptions::MPEG4), "tt:Mpeg4Options"))
				{	soap_flag_MPEG41--;
					continue;
				}
			if (soap_flag_H2641 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__H264Options(soap, "tt:H264", &(a->tt__VideoEncoderConfigurationOptions::H264), "tt:H264Options"))
				{	soap_flag_H2641--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoEncoderOptionsExtension(soap, "tt:Extension", &(a->tt__VideoEncoderConfigurationOptions::Extension), "tt:VideoEncoderOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, 0, sizeof(tt__VideoEncoderConfigurationOptions), 0, soap_copy_tt__VideoEncoderConfigurationOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_QualityRange1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__VideoEncoderConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoEncoderConfigurationOptions);
	if (this->soap_out(soap, tag?tag:"tt:VideoEncoderConfigurationOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoEncoderConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoEncoderConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoEncoderConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoEncoderConfigurationOptions(struct soap *soap, tt__VideoEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoEncoderConfigurationOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoEncoderConfigurationOptions);
		if (size)
			*size = sizeof(tt__VideoEncoderConfigurationOptions);
		((tt__VideoEncoderConfigurationOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoEncoderConfigurationOptions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__VideoEncoderConfigurationOptions);
		for (int i = 0; i < n; i++)
			((tt__VideoEncoderConfigurationOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__VideoEncoderConfigurationOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoEncoderConfigurationOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoEncoderConfigurationOptions %p -> %p\n", q, p));
	*(tt__VideoEncoderConfigurationOptions*)p = *(tt__VideoEncoderConfigurationOptions*)q;
}

void tt__H264Configuration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tt__H264Configuration::GovLength);
	soap_default_tt__H264Profile(soap, &this->tt__H264Configuration::H264Profile);
	/* transient soap skipped */
}

void tt__H264Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__H264Configuration::GovLength, SOAP_TYPE_int);
	/* transient soap skipped */
}

int tt__H264Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__H264Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Configuration(struct soap *soap, const char *tag, int id, const tt__H264Configuration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Configuration), type))
		return soap->error;
	if (soap_out_int(soap, "tt:GovLength", -1, &(a->tt__H264Configuration::GovLength), ""))
		return soap->error;
	if (soap_out_tt__H264Profile(soap, "tt:H264Profile", -1, &(a->tt__H264Configuration::H264Profile), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__H264Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__H264Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__H264Configuration * SOAP_FMAC4 soap_in_tt__H264Configuration(struct soap *soap, const char *tag, tt__H264Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__H264Configuration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Configuration, sizeof(tt__H264Configuration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__H264Configuration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__H264Configuration *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GovLength1 = 1;
	size_t soap_flag_H264Profile1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GovLength1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:GovLength", &(a->tt__H264Configuration::GovLength), "xsd:int"))
				{	soap_flag_GovLength1--;
					continue;
				}
			if (soap_flag_H264Profile1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__H264Profile(soap, "tt:H264Profile", &(a->tt__H264Configuration::H264Profile), "tt:H264Profile"))
				{	soap_flag_H264Profile1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__H264Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Configuration, 0, sizeof(tt__H264Configuration), 0, soap_copy_tt__H264Configuration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GovLength1 > 0 || soap_flag_H264Profile1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__H264Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__H264Configuration);
	if (this->soap_out(soap, tag?tag:"tt:H264Configuration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__H264Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__H264Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__H264Configuration * SOAP_FMAC4 soap_get_tt__H264Configuration(struct soap *soap, tt__H264Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__H264Configuration * SOAP_FMAC2 soap_instantiate_tt__H264Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__H264Configuration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__H264Configuration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__H264Configuration);
		if (size)
			*size = sizeof(tt__H264Configuration);
		((tt__H264Configuration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__H264Configuration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__H264Configuration);
		for (int i = 0; i < n; i++)
			((tt__H264Configuration*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__H264Configuration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__H264Configuration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__H264Configuration %p -> %p\n", q, p));
	*(tt__H264Configuration*)p = *(tt__H264Configuration*)q;
}

void tt__Mpeg4Configuration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tt__Mpeg4Configuration::GovLength);
	soap_default_tt__Mpeg4Profile(soap, &this->tt__Mpeg4Configuration::Mpeg4Profile);
	/* transient soap skipped */
}

void tt__Mpeg4Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__Mpeg4Configuration::GovLength, SOAP_TYPE_int);
	/* transient soap skipped */
}

int tt__Mpeg4Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Mpeg4Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Configuration(struct soap *soap, const char *tag, int id, const tt__Mpeg4Configuration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Configuration), type))
		return soap->error;
	if (soap_out_int(soap, "tt:GovLength", -1, &(a->tt__Mpeg4Configuration::GovLength), ""))
		return soap->error;
	if (soap_out_tt__Mpeg4Profile(soap, "tt:Mpeg4Profile", -1, &(a->tt__Mpeg4Configuration::Mpeg4Profile), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Mpeg4Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Mpeg4Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__Mpeg4Configuration * SOAP_FMAC4 soap_in_tt__Mpeg4Configuration(struct soap *soap, const char *tag, tt__Mpeg4Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Mpeg4Configuration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(tt__Mpeg4Configuration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Mpeg4Configuration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Mpeg4Configuration *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GovLength1 = 1;
	size_t soap_flag_Mpeg4Profile1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GovLength1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:GovLength", &(a->tt__Mpeg4Configuration::GovLength), "xsd:int"))
				{	soap_flag_GovLength1--;
					continue;
				}
			if (soap_flag_Mpeg4Profile1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__Mpeg4Profile(soap, "tt:Mpeg4Profile", &(a->tt__Mpeg4Configuration::Mpeg4Profile), "tt:Mpeg4Profile"))
				{	soap_flag_Mpeg4Profile1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Mpeg4Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Configuration, 0, sizeof(tt__Mpeg4Configuration), 0, soap_copy_tt__Mpeg4Configuration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GovLength1 > 0 || soap_flag_Mpeg4Profile1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Mpeg4Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Mpeg4Configuration);
	if (this->soap_out(soap, tag?tag:"tt:Mpeg4Configuration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Mpeg4Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Mpeg4Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__Mpeg4Configuration * SOAP_FMAC4 soap_get_tt__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Mpeg4Configuration * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Mpeg4Configuration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Mpeg4Configuration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Mpeg4Configuration);
		if (size)
			*size = sizeof(tt__Mpeg4Configuration);
		((tt__Mpeg4Configuration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Mpeg4Configuration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Mpeg4Configuration);
		for (int i = 0; i < n; i++)
			((tt__Mpeg4Configuration*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Mpeg4Configuration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Mpeg4Configuration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Mpeg4Configuration %p -> %p\n", q, p));
	*(tt__Mpeg4Configuration*)p = *(tt__Mpeg4Configuration*)q;
}

void tt__VideoRateControl::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tt__VideoRateControl::FrameRateLimit);
	soap_default_int(soap, &this->tt__VideoRateControl::EncodingInterval);
	soap_default_int(soap, &this->tt__VideoRateControl::BitrateLimit);
	/* transient soap skipped */
}

void tt__VideoRateControl::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__VideoRateControl::FrameRateLimit, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__VideoRateControl::EncodingInterval, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__VideoRateControl::BitrateLimit, SOAP_TYPE_int);
	/* transient soap skipped */
}

int tt__VideoRateControl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoRateControl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoRateControl(struct soap *soap, const char *tag, int id, const tt__VideoRateControl *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoRateControl), type))
		return soap->error;
	if (soap_out_int(soap, "tt:FrameRateLimit", -1, &(a->tt__VideoRateControl::FrameRateLimit), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:EncodingInterval", -1, &(a->tt__VideoRateControl::EncodingInterval), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:BitrateLimit", -1, &(a->tt__VideoRateControl::BitrateLimit), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__VideoRateControl::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoRateControl(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoRateControl * SOAP_FMAC4 soap_in_tt__VideoRateControl(struct soap *soap, const char *tag, tt__VideoRateControl *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoRateControl *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoRateControl, sizeof(tt__VideoRateControl), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoRateControl)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoRateControl *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_FrameRateLimit1 = 1;
	size_t soap_flag_EncodingInterval1 = 1;
	size_t soap_flag_BitrateLimit1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FrameRateLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:FrameRateLimit", &(a->tt__VideoRateControl::FrameRateLimit), "xsd:int"))
				{	soap_flag_FrameRateLimit1--;
					continue;
				}
			if (soap_flag_EncodingInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:EncodingInterval", &(a->tt__VideoRateControl::EncodingInterval), "xsd:int"))
				{	soap_flag_EncodingInterval1--;
					continue;
				}
			if (soap_flag_BitrateLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:BitrateLimit", &(a->tt__VideoRateControl::BitrateLimit), "xsd:int"))
				{	soap_flag_BitrateLimit1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoRateControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoRateControl, 0, sizeof(tt__VideoRateControl), 0, soap_copy_tt__VideoRateControl);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FrameRateLimit1 > 0 || soap_flag_EncodingInterval1 > 0 || soap_flag_BitrateLimit1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__VideoRateControl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoRateControl);
	if (this->soap_out(soap, tag?tag:"tt:VideoRateControl", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoRateControl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoRateControl(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoRateControl * SOAP_FMAC4 soap_get_tt__VideoRateControl(struct soap *soap, tt__VideoRateControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoRateControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoRateControl * SOAP_FMAC2 soap_instantiate_tt__VideoRateControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoRateControl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoRateControl, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoRateControl);
		if (size)
			*size = sizeof(tt__VideoRateControl);
		((tt__VideoRateControl*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoRateControl[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__VideoRateControl);
		for (int i = 0; i < n; i++)
			((tt__VideoRateControl*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__VideoRateControl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoRateControl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoRateControl %p -> %p\n", q, p));
	*(tt__VideoRateControl*)p = *(tt__VideoRateControl*)q;
}

void tt__VideoResolution::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tt__VideoResolution::Width);
	soap_default_int(soap, &this->tt__VideoResolution::Height);
	/* transient soap skipped */
}

void tt__VideoResolution::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__VideoResolution::Width, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__VideoResolution::Height, SOAP_TYPE_int);
	/* transient soap skipped */
}

int tt__VideoResolution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoResolution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoResolution(struct soap *soap, const char *tag, int id, const tt__VideoResolution *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoResolution), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Width", -1, &(a->tt__VideoResolution::Width), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Height", -1, &(a->tt__VideoResolution::Height), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__VideoResolution::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoResolution(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoResolution * SOAP_FMAC4 soap_in_tt__VideoResolution(struct soap *soap, const char *tag, tt__VideoResolution *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoResolution *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoResolution, sizeof(tt__VideoResolution), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoResolution)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoResolution *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Width1 = 1;
	size_t soap_flag_Height1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Width1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Width", &(a->tt__VideoResolution::Width), "xsd:int"))
				{	soap_flag_Width1--;
					continue;
				}
			if (soap_flag_Height1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Height", &(a->tt__VideoResolution::Height), "xsd:int"))
				{	soap_flag_Height1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoResolution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoResolution, 0, sizeof(tt__VideoResolution), 0, soap_copy_tt__VideoResolution);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Width1 > 0 || soap_flag_Height1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__VideoResolution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoResolution);
	if (this->soap_out(soap, tag?tag:"tt:VideoResolution", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoResolution::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoResolution(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoResolution * SOAP_FMAC4 soap_get_tt__VideoResolution(struct soap *soap, tt__VideoResolution *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoResolution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoResolution * SOAP_FMAC2 soap_instantiate_tt__VideoResolution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoResolution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoResolution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoResolution);
		if (size)
			*size = sizeof(tt__VideoResolution);
		((tt__VideoResolution*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoResolution[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__VideoResolution);
		for (int i = 0; i < n; i++)
			((tt__VideoResolution*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__VideoResolution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoResolution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoResolution %p -> %p\n", q, p));
	*(tt__VideoResolution*)p = *(tt__VideoResolution*)q;
}

void tt__VideoEncoderConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__VideoEncoding(soap, &this->tt__VideoEncoderConfiguration::Encoding);
	this->tt__VideoEncoderConfiguration::Resolution = NULL;
	soap_default_float(soap, &this->tt__VideoEncoderConfiguration::Quality);
	this->tt__VideoEncoderConfiguration::RateControl = NULL;
	this->tt__VideoEncoderConfiguration::MPEG4 = NULL;
	this->tt__VideoEncoderConfiguration::H264 = NULL;
	this->tt__VideoEncoderConfiguration::Multicast = NULL;
	soap_default_xsd__duration(soap, &this->tt__VideoEncoderConfiguration::SessionTimeout);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoEncoderConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__VideoEncoderConfiguration::__anyAttribute);
	soap_default_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_default_int(soap, &this->tt__ConfigurationEntity::UseCount);
	soap_default_tt__ReferenceToken(soap, &this->tt__ConfigurationEntity::token);
	/* transient soap skipped */
}

void tt__VideoEncoderConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__VideoResolution(soap, &this->tt__VideoEncoderConfiguration::Resolution);
	soap_embedded(soap, &this->tt__VideoEncoderConfiguration::Quality, SOAP_TYPE_float);
	soap_serialize_PointerTott__VideoRateControl(soap, &this->tt__VideoEncoderConfiguration::RateControl);
	soap_serialize_PointerTott__Mpeg4Configuration(soap, &this->tt__VideoEncoderConfiguration::MPEG4);
	soap_serialize_PointerTott__H264Configuration(soap, &this->tt__VideoEncoderConfiguration::H264);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &this->tt__VideoEncoderConfiguration::Multicast);
	soap_embedded(soap, &this->tt__VideoEncoderConfiguration::SessionTimeout, SOAP_TYPE_xsd__duration);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoEncoderConfiguration::__any);
	soap_embedded(soap, &this->tt__ConfigurationEntity::Name, SOAP_TYPE_tt__Name);
	soap_serialize_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_embedded(soap, &this->tt__ConfigurationEntity::UseCount, SOAP_TYPE_int);
	/* transient soap skipped */
}

int tt__VideoEncoderConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoEncoderConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const tt__VideoEncoderConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__VideoEncoderConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	if (!((tt__ConfigurationEntity*)a)->token.empty())
		soap_set_attr(soap, "token", ((tt__ConfigurationEntity*)a)->token.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderConfiguration), "tt:VideoEncoderConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &(a->tt__ConfigurationEntity::Name), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &(a->tt__ConfigurationEntity::UseCount), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_tt__VideoEncoding(soap, "tt:Encoding", -1, &(a->tt__VideoEncoderConfiguration::Encoding), ""))
		return soap->error;
	if (a->tt__VideoEncoderConfiguration::Resolution)
	{	if (soap_out_PointerTott__VideoResolution(soap, "tt:Resolution", -1, &a->tt__VideoEncoderConfiguration::Resolution, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Resolution"))
		return soap->error;
	if (soap_out_float(soap, "tt:Quality", -1, &(a->tt__VideoEncoderConfiguration::Quality), ""))
		return soap->error;
	if (soap_out_PointerTott__VideoRateControl(soap, "tt:RateControl", -1, &(a->tt__VideoEncoderConfiguration::RateControl), ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4Configuration(soap, "tt:MPEG4", -1, &(a->tt__VideoEncoderConfiguration::MPEG4), ""))
		return soap->error;
	if (soap_out_PointerTott__H264Configuration(soap, "tt:H264", -1, &(a->tt__VideoEncoderConfiguration::H264), ""))
		return soap->error;
	if (a->tt__VideoEncoderConfiguration::Multicast)
	{	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->tt__VideoEncoderConfiguration::Multicast, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Multicast"))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:SessionTimeout", -1, &(a->tt__VideoEncoderConfiguration::SessionTimeout), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__VideoEncoderConfiguration::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoEncoderConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoEncoderConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoEncoderConfiguration * SOAP_FMAC4 soap_in_tt__VideoEncoderConfiguration(struct soap *soap, const char *tag, tt__VideoEncoderConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoEncoderConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(tt__VideoEncoderConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoEncoderConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoEncoderConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__VideoEncoderConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	{	const char *t = soap_attr_value(soap, "token", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, 64))
				return NULL;
			((tt__ConfigurationEntity*)a)->token.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_Encoding1 = 1;
	size_t soap_flag_Resolution1 = 1;
	size_t soap_flag_Quality1 = 1;
	size_t soap_flag_RateControl1 = 1;
	size_t soap_flag_MPEG41 = 1;
	size_t soap_flag_H2641 = 1;
	size_t soap_flag_Multicast1 = 1;
	size_t soap_flag_SessionTimeout1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &(a->tt__ConfigurationEntity::Name), "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &(a->tt__ConfigurationEntity::UseCount), "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_Encoding1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__VideoEncoding(soap, "tt:Encoding", &(a->tt__VideoEncoderConfiguration::Encoding), "tt:VideoEncoding"))
				{	soap_flag_Encoding1--;
					continue;
				}
			if (soap_flag_Resolution1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoResolution(soap, "tt:Resolution", &(a->tt__VideoEncoderConfiguration::Resolution), "tt:VideoResolution"))
				{	soap_flag_Resolution1--;
					continue;
				}
			if (soap_flag_Quality1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Quality", &(a->tt__VideoEncoderConfiguration::Quality), "xsd:float"))
				{	soap_flag_Quality1--;
					continue;
				}
			if (soap_flag_RateControl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoRateControl(soap, "tt:RateControl", &(a->tt__VideoEncoderConfiguration::RateControl), "tt:VideoRateControl"))
				{	soap_flag_RateControl1--;
					continue;
				}
			if (soap_flag_MPEG41 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Mpeg4Configuration(soap, "tt:MPEG4", &(a->tt__VideoEncoderConfiguration::MPEG4), "tt:Mpeg4Configuration"))
				{	soap_flag_MPEG41--;
					continue;
				}
			if (soap_flag_H2641 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__H264Configuration(soap, "tt:H264", &(a->tt__VideoEncoderConfiguration::H264), "tt:H264Configuration"))
				{	soap_flag_H2641--;
					continue;
				}
			if (soap_flag_Multicast1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &(a->tt__VideoEncoderConfiguration::Multicast), "tt:MulticastConfiguration"))
				{	soap_flag_Multicast1--;
					continue;
				}
			if (soap_flag_SessionTimeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tt:SessionTimeout", &(a->tt__VideoEncoderConfiguration::SessionTimeout), "xsd:duration"))
				{	soap_flag_SessionTimeout1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__VideoEncoderConfiguration::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderConfiguration, 0, sizeof(tt__VideoEncoderConfiguration), 0, soap_copy_tt__VideoEncoderConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_Encoding1 > 0 || soap_flag_Resolution1 > 0 || soap_flag_Quality1 > 0 || soap_flag_Multicast1 > 0 || soap_flag_SessionTimeout1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__VideoEncoderConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoEncoderConfiguration);
	if (this->soap_out(soap, tag?tag:"tt:VideoEncoderConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoEncoderConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoEncoderConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoEncoderConfiguration * SOAP_FMAC4 soap_get_tt__VideoEncoderConfiguration(struct soap *soap, tt__VideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoEncoderConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoEncoderConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoEncoderConfiguration);
		if (size)
			*size = sizeof(tt__VideoEncoderConfiguration);
		((tt__VideoEncoderConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoEncoderConfiguration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__VideoEncoderConfiguration);
		for (int i = 0; i < n; i++)
			((tt__VideoEncoderConfiguration*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__VideoEncoderConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoEncoderConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoEncoderConfiguration %p -> %p\n", q, p));
	*(tt__VideoEncoderConfiguration*)p = *(tt__VideoEncoderConfiguration*)q;
}

void tt__VideoSourceConfigurationOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoSourceConfigurationOptionsExtension::__any);
	/* transient soap skipped */
}

void tt__VideoSourceConfigurationOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoSourceConfigurationOptionsExtension::__any);
	/* transient soap skipped */
}

int tt__VideoSourceConfigurationOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfigurationOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfigurationOptionsExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__VideoSourceConfigurationOptionsExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfigurationOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoSourceConfigurationOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, tt__VideoSourceConfigurationOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfigurationOptionsExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, sizeof(tt__VideoSourceConfigurationOptionsExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoSourceConfigurationOptionsExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__VideoSourceConfigurationOptionsExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, 0, sizeof(tt__VideoSourceConfigurationOptionsExtension), 0, soap_copy_tt__VideoSourceConfigurationOptionsExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__VideoSourceConfigurationOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension);
	if (this->soap_out(soap, tag?tag:"tt:VideoSourceConfigurationOptionsExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfigurationOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfigurationOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, tt__VideoSourceConfigurationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceConfigurationOptionsExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoSourceConfigurationOptionsExtension);
		if (size)
			*size = sizeof(tt__VideoSourceConfigurationOptionsExtension);
		((tt__VideoSourceConfigurationOptionsExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoSourceConfigurationOptionsExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__VideoSourceConfigurationOptionsExtension);
		for (int i = 0; i < n; i++)
			((tt__VideoSourceConfigurationOptionsExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__VideoSourceConfigurationOptionsExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoSourceConfigurationOptionsExtension %p -> %p\n", q, p));
	*(tt__VideoSourceConfigurationOptionsExtension*)p = *(tt__VideoSourceConfigurationOptionsExtension*)q;
}

void tt__VideoSourceConfigurationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__VideoSourceConfigurationOptions::BoundsRange = NULL;
	soap_default_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable);
	this->tt__VideoSourceConfigurationOptions::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__VideoSourceConfigurationOptions::__anyAttribute);
	/* transient soap skipped */
}

void tt__VideoSourceConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IntRectangleRange(soap, &this->tt__VideoSourceConfigurationOptions::BoundsRange);
	soap_serialize_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable);
	soap_serialize_PointerTott__VideoSourceConfigurationOptionsExtension(soap, &this->tt__VideoSourceConfigurationOptions::Extension);
	/* transient soap skipped */
}

int tt__VideoSourceConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfigurationOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__VideoSourceConfigurationOptions*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptions), type))
		return soap->error;
	if (a->tt__VideoSourceConfigurationOptions::BoundsRange)
	{	if (soap_out_PointerTott__IntRectangleRange(soap, "tt:BoundsRange", -1, &a->tt__VideoSourceConfigurationOptions::BoundsRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:BoundsRange"))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ReferenceToken(soap, "tt:VideoSourceTokensAvailable", -1, &(a->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable), ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfigurationOptionsExtension(soap, "tt:Extension", -1, &(a->tt__VideoSourceConfigurationOptions::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoSourceConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, tt__VideoSourceConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfigurationOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptions, sizeof(tt__VideoSourceConfigurationOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoSourceConfigurationOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoSourceConfigurationOptions *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__VideoSourceConfigurationOptions*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_BoundsRange1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BoundsRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRectangleRange(soap, "tt:BoundsRange", &(a->tt__VideoSourceConfigurationOptions::BoundsRange), "tt:IntRectangleRange"))
				{	soap_flag_BoundsRange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftt__ReferenceToken(soap, "tt:VideoSourceTokensAvailable", &(a->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable), "tt:ReferenceToken"))
					continue;
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceConfigurationOptionsExtension(soap, "tt:Extension", &(a->tt__VideoSourceConfigurationOptions::Extension), "tt:VideoSourceConfigurationOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationOptions, 0, sizeof(tt__VideoSourceConfigurationOptions), 0, soap_copy_tt__VideoSourceConfigurationOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_BoundsRange1 > 0 || a->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__VideoSourceConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoSourceConfigurationOptions);
	if (this->soap_out(soap, tag?tag:"tt:VideoSourceConfigurationOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationOptions(struct soap *soap, tt__VideoSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceConfigurationOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoSourceConfigurationOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoSourceConfigurationOptions);
		if (size)
			*size = sizeof(tt__VideoSourceConfigurationOptions);
		((tt__VideoSourceConfigurationOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoSourceConfigurationOptions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__VideoSourceConfigurationOptions);
		for (int i = 0; i < n; i++)
			((tt__VideoSourceConfigurationOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__VideoSourceConfigurationOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoSourceConfigurationOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoSourceConfigurationOptions %p -> %p\n", q, p));
	*(tt__VideoSourceConfigurationOptions*)p = *(tt__VideoSourceConfigurationOptions*)q;
}

void tt__VideoSourceConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->tt__VideoSourceConfiguration::SourceToken);
	this->tt__VideoSourceConfiguration::Bounds = NULL;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoSourceConfiguration::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__VideoSourceConfiguration::__anyAttribute);
	soap_default_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_default_int(soap, &this->tt__ConfigurationEntity::UseCount);
	soap_default_tt__ReferenceToken(soap, &this->tt__ConfigurationEntity::token);
	/* transient soap skipped */
}

void tt__VideoSourceConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__VideoSourceConfiguration::SourceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__VideoSourceConfiguration::SourceToken);
	soap_serialize_PointerTott__IntRectangle(soap, &this->tt__VideoSourceConfiguration::Bounds);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoSourceConfiguration::__any);
	soap_embedded(soap, &this->tt__ConfigurationEntity::Name, SOAP_TYPE_tt__Name);
	soap_serialize_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_embedded(soap, &this->tt__ConfigurationEntity::UseCount, SOAP_TYPE_int);
	/* transient soap skipped */
}

int tt__VideoSourceConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfiguration(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__VideoSourceConfiguration*)a)->__anyAttribute, ""))
		return soap->error;
	if (!((tt__ConfigurationEntity*)a)->token.empty())
		soap_set_attr(soap, "token", ((tt__ConfigurationEntity*)a)->token.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfiguration), "tt:VideoSourceConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &(a->tt__ConfigurationEntity::Name), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &(a->tt__ConfigurationEntity::UseCount), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_tt__ReferenceToken(soap, "tt:SourceToken", -1, &(a->tt__VideoSourceConfiguration::SourceToken), ""))
		return soap->error;
	if (a->tt__VideoSourceConfiguration::Bounds)
	{	if (soap_out_PointerTott__IntRectangle(soap, "tt:Bounds", -1, &a->tt__VideoSourceConfiguration::Bounds, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Bounds"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__VideoSourceConfiguration::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoSourceConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfiguration * SOAP_FMAC4 soap_in_tt__VideoSourceConfiguration(struct soap *soap, const char *tag, tt__VideoSourceConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(tt__VideoSourceConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoSourceConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoSourceConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__VideoSourceConfiguration*)a)->__anyAttribute, "xsd:anyAttribute");
	{	const char *t = soap_attr_value(soap, "token", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, 64))
				return NULL;
			((tt__ConfigurationEntity*)a)->token.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_SourceToken1 = 1;
	size_t soap_flag_Bounds1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &(a->tt__ConfigurationEntity::Name), "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &(a->tt__ConfigurationEntity::UseCount), "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_SourceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:SourceToken", &(a->tt__VideoSourceConfiguration::SourceToken), "tt:ReferenceToken"))
				{	soap_flag_SourceToken1--;
					continue;
				}
			if (soap_flag_Bounds1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRectangle(soap, "tt:Bounds", &(a->tt__VideoSourceConfiguration::Bounds), "tt:IntRectangle"))
				{	soap_flag_Bounds1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__VideoSourceConfiguration::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfiguration, 0, sizeof(tt__VideoSourceConfiguration), 0, soap_copy_tt__VideoSourceConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_SourceToken1 > 0 || soap_flag_Bounds1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__VideoSourceConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoSourceConfiguration);
	if (this->soap_out(soap, tag?tag:"tt:VideoSourceConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfiguration * SOAP_FMAC4 soap_get_tt__VideoSourceConfiguration(struct soap *soap, tt__VideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoSourceConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoSourceConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoSourceConfiguration);
		if (size)
			*size = sizeof(tt__VideoSourceConfiguration);
		((tt__VideoSourceConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoSourceConfiguration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__VideoSourceConfiguration);
		for (int i = 0; i < n; i++)
			((tt__VideoSourceConfiguration*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__VideoSourceConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoSourceConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoSourceConfiguration %p -> %p\n", q, p));
	*(tt__VideoSourceConfiguration*)p = *(tt__VideoSourceConfiguration*)q;
}

void tt__ConfigurationEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_default_int(soap, &this->tt__ConfigurationEntity::UseCount);
	soap_default_tt__ReferenceToken(soap, &this->tt__ConfigurationEntity::token);
	/* transient soap skipped */
}

void tt__ConfigurationEntity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__ConfigurationEntity::Name, SOAP_TYPE_tt__Name);
	soap_serialize_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_embedded(soap, &this->tt__ConfigurationEntity::UseCount, SOAP_TYPE_int);
	/* transient soap skipped */
}

int tt__ConfigurationEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ConfigurationEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ConfigurationEntity(struct soap *soap, const char *tag, int id, const tt__ConfigurationEntity *a, const char *type)
{
	if (!((tt__ConfigurationEntity*)a)->token.empty())
		soap_set_attr(soap, "token", ((tt__ConfigurationEntity*)a)->token.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ConfigurationEntity), type))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &(a->tt__ConfigurationEntity::Name), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &(a->tt__ConfigurationEntity::UseCount), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ConfigurationEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ConfigurationEntity(soap, tag, this, type);
}

SOAP_FMAC3 tt__ConfigurationEntity * SOAP_FMAC4 soap_in_tt__ConfigurationEntity(struct soap *soap, const char *tag, tt__ConfigurationEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ConfigurationEntity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ConfigurationEntity, sizeof(tt__ConfigurationEntity), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ConfigurationEntity)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ConfigurationEntity *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "token", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, 64))
				return NULL;
			((tt__ConfigurationEntity*)a)->token.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_UseCount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &(a->tt__ConfigurationEntity::Name), "tt:Name"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_UseCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &(a->tt__ConfigurationEntity::UseCount), "xsd:int"))
				{	soap_flag_UseCount1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ConfigurationEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ConfigurationEntity, 0, sizeof(tt__ConfigurationEntity), 0, soap_copy_tt__ConfigurationEntity);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || soap_flag_UseCount1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__ConfigurationEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ConfigurationEntity);
	if (this->soap_out(soap, tag?tag:"tt:ConfigurationEntity", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ConfigurationEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ConfigurationEntity(soap, this, tag, type);
}

SOAP_FMAC3 tt__ConfigurationEntity * SOAP_FMAC4 soap_get_tt__ConfigurationEntity(struct soap *soap, tt__ConfigurationEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ConfigurationEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ConfigurationEntity * SOAP_FMAC2 soap_instantiate_tt__ConfigurationEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ConfigurationEntity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ConfigurationEntity, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "tt:VideoSourceConfiguration"))
	{	cp->type = SOAP_TYPE_tt__VideoSourceConfiguration;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__VideoSourceConfiguration);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(tt__VideoSourceConfiguration);
			((tt__VideoSourceConfiguration*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(tt__VideoSourceConfiguration[n]);
			if (size)
				*size = n * sizeof(tt__VideoSourceConfiguration);
			for (int i = 0; i < n; i++)
				((tt__VideoSourceConfiguration*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (tt__VideoSourceConfiguration*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:VideoEncoderConfiguration"))
	{	cp->type = SOAP_TYPE_tt__VideoEncoderConfiguration;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__VideoEncoderConfiguration);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(tt__VideoEncoderConfiguration);
			((tt__VideoEncoderConfiguration*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(tt__VideoEncoderConfiguration[n]);
			if (size)
				*size = n * sizeof(tt__VideoEncoderConfiguration);
			for (int i = 0; i < n; i++)
				((tt__VideoEncoderConfiguration*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (tt__VideoEncoderConfiguration*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:AudioSourceConfiguration"))
	{	cp->type = SOAP_TYPE_tt__AudioSourceConfiguration;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__AudioSourceConfiguration);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(tt__AudioSourceConfiguration);
			((tt__AudioSourceConfiguration*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(tt__AudioSourceConfiguration[n]);
			if (size)
				*size = n * sizeof(tt__AudioSourceConfiguration);
			for (int i = 0; i < n; i++)
				((tt__AudioSourceConfiguration*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (tt__AudioSourceConfiguration*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:AudioEncoderConfiguration"))
	{	cp->type = SOAP_TYPE_tt__AudioEncoderConfiguration;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__AudioEncoderConfiguration);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(tt__AudioEncoderConfiguration);
			((tt__AudioEncoderConfiguration*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(tt__AudioEncoderConfiguration[n]);
			if (size)
				*size = n * sizeof(tt__AudioEncoderConfiguration);
			for (int i = 0; i < n; i++)
				((tt__AudioEncoderConfiguration*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (tt__AudioEncoderConfiguration*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:VideoAnalyticsConfiguration"))
	{	cp->type = SOAP_TYPE_tt__VideoAnalyticsConfiguration;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__VideoAnalyticsConfiguration);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(tt__VideoAnalyticsConfiguration);
			((tt__VideoAnalyticsConfiguration*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(tt__VideoAnalyticsConfiguration[n]);
			if (size)
				*size = n * sizeof(tt__VideoAnalyticsConfiguration);
			for (int i = 0; i < n; i++)
				((tt__VideoAnalyticsConfiguration*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (tt__VideoAnalyticsConfiguration*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:MetadataConfiguration"))
	{	cp->type = SOAP_TYPE_tt__MetadataConfiguration;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__MetadataConfiguration);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(tt__MetadataConfiguration);
			((tt__MetadataConfiguration*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(tt__MetadataConfiguration[n]);
			if (size)
				*size = n * sizeof(tt__MetadataConfiguration);
			for (int i = 0; i < n; i++)
				((tt__MetadataConfiguration*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (tt__MetadataConfiguration*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:PTZConfiguration"))
	{	cp->type = SOAP_TYPE_tt__PTZConfiguration;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__PTZConfiguration);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(tt__PTZConfiguration);
			((tt__PTZConfiguration*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(tt__PTZConfiguration[n]);
			if (size)
				*size = n * sizeof(tt__PTZConfiguration);
			for (int i = 0; i < n; i++)
				((tt__PTZConfiguration*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (tt__PTZConfiguration*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ConfigurationEntity);
		if (size)
			*size = sizeof(tt__ConfigurationEntity);
		((tt__ConfigurationEntity*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ConfigurationEntity[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ConfigurationEntity);
		for (int i = 0; i < n; i++)
			((tt__ConfigurationEntity*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ConfigurationEntity*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ConfigurationEntity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ConfigurationEntity %p -> %p\n", q, p));
	*(tt__ConfigurationEntity*)p = *(tt__ConfigurationEntity*)q;
}

void tt__ProfileExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ProfileExtension::__any);
	/* transient soap skipped */
}

void tt__ProfileExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__ProfileExtension::__any);
	/* transient soap skipped */
}

int tt__ProfileExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ProfileExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileExtension(struct soap *soap, const char *tag, int id, const tt__ProfileExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__ProfileExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__ProfileExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ProfileExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ProfileExtension * SOAP_FMAC4 soap_in_tt__ProfileExtension(struct soap *soap, const char *tag, tt__ProfileExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ProfileExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileExtension, sizeof(tt__ProfileExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ProfileExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ProfileExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__ProfileExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ProfileExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileExtension, 0, sizeof(tt__ProfileExtension), 0, soap_copy_tt__ProfileExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ProfileExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ProfileExtension);
	if (this->soap_out(soap, tag?tag:"tt:ProfileExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ProfileExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ProfileExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ProfileExtension * SOAP_FMAC4 soap_get_tt__ProfileExtension(struct soap *soap, tt__ProfileExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ProfileExtension * SOAP_FMAC2 soap_instantiate_tt__ProfileExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ProfileExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ProfileExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ProfileExtension);
		if (size)
			*size = sizeof(tt__ProfileExtension);
		((tt__ProfileExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__ProfileExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__ProfileExtension);
		for (int i = 0; i < n; i++)
			((tt__ProfileExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__ProfileExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ProfileExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ProfileExtension %p -> %p\n", q, p));
	*(tt__ProfileExtension*)p = *(tt__ProfileExtension*)q;
}

void tt__Profile::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__Name(soap, &this->tt__Profile::Name);
	this->tt__Profile::VideoSourceConfiguration = NULL;
	this->tt__Profile::AudioSourceConfiguration = NULL;
	this->tt__Profile::VideoEncoderConfiguration = NULL;
	this->tt__Profile::AudioEncoderConfiguration = NULL;
	this->tt__Profile::VideoAnalyticsConfiguration = NULL;
	this->tt__Profile::PTZConfiguration = NULL;
	this->tt__Profile::MetadataConfiguration = NULL;
	this->tt__Profile::Extension = NULL;
	soap_default_tt__ReferenceToken(soap, &this->tt__Profile::token);
	this->tt__Profile::fixed = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__Profile::__anyAttribute);
	/* transient soap skipped */
}

void tt__Profile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__Profile::Name, SOAP_TYPE_tt__Name);
	soap_serialize_tt__Name(soap, &this->tt__Profile::Name);
	soap_serialize_PointerTott__VideoSourceConfiguration(soap, &this->tt__Profile::VideoSourceConfiguration);
	soap_serialize_PointerTott__AudioSourceConfiguration(soap, &this->tt__Profile::AudioSourceConfiguration);
	soap_serialize_PointerTott__VideoEncoderConfiguration(soap, &this->tt__Profile::VideoEncoderConfiguration);
	soap_serialize_PointerTott__AudioEncoderConfiguration(soap, &this->tt__Profile::AudioEncoderConfiguration);
	soap_serialize_PointerTott__VideoAnalyticsConfiguration(soap, &this->tt__Profile::VideoAnalyticsConfiguration);
	soap_serialize_PointerTott__PTZConfiguration(soap, &this->tt__Profile::PTZConfiguration);
	soap_serialize_PointerTott__MetadataConfiguration(soap, &this->tt__Profile::MetadataConfiguration);
	soap_serialize_PointerTott__ProfileExtension(soap, &this->tt__Profile::Extension);
	/* transient soap skipped */
}

int tt__Profile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Profile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Profile(struct soap *soap, const char *tag, int id, const tt__Profile *a, const char *type)
{
	if (!((tt__Profile*)a)->token.empty())
		soap_set_attr(soap, "token", ((tt__Profile*)a)->token.c_str(), 1);
	if (((tt__Profile*)a)->fixed)
		soap_set_attr(soap, "fixed", soap_bool2s(soap, *((tt__Profile*)a)->fixed), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__Profile*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Profile), type))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &(a->tt__Profile::Name), ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfiguration(soap, "tt:VideoSourceConfiguration", -1, &(a->tt__Profile::VideoSourceConfiguration), ""))
		return soap->error;
	if (soap_out_PointerTott__AudioSourceConfiguration(soap, "tt:AudioSourceConfiguration", -1, &(a->tt__Profile::AudioSourceConfiguration), ""))
		return soap->error;
	if (soap_out_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoEncoderConfiguration", -1, &(a->tt__Profile::VideoEncoderConfiguration), ""))
		return soap->error;
	if (soap_out_PointerTott__AudioEncoderConfiguration(soap, "tt:AudioEncoderConfiguration", -1, &(a->tt__Profile::AudioEncoderConfiguration), ""))
		return soap->error;
	if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, "tt:VideoAnalyticsConfiguration", -1, &(a->tt__Profile::VideoAnalyticsConfiguration), ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfiguration(soap, "tt:PTZConfiguration", -1, &(a->tt__Profile::PTZConfiguration), ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataConfiguration(soap, "tt:MetadataConfiguration", -1, &(a->tt__Profile::MetadataConfiguration), ""))
		return soap->error;
	if (soap_out_PointerTott__ProfileExtension(soap, "tt:Extension", -1, &(a->tt__Profile::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__Profile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Profile(soap, tag, this, type);
}

SOAP_FMAC3 tt__Profile * SOAP_FMAC4 soap_in_tt__Profile(struct soap *soap, const char *tag, tt__Profile *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Profile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Profile, sizeof(tt__Profile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Profile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Profile *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "token", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, 64))
				return NULL;
			((tt__Profile*)a)->token.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "fixed", 0);
		if (t)
		{
			if (!(((tt__Profile*)a)->fixed = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tt__Profile*)a)->fixed))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__Profile*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_VideoSourceConfiguration1 = 1;
	size_t soap_flag_AudioSourceConfiguration1 = 1;
	size_t soap_flag_VideoEncoderConfiguration1 = 1;
	size_t soap_flag_AudioEncoderConfiguration1 = 1;
	size_t soap_flag_VideoAnalyticsConfiguration1 = 1;
	size_t soap_flag_PTZConfiguration1 = 1;
	size_t soap_flag_MetadataConfiguration1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &(a->tt__Profile::Name), "tt:Name"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_VideoSourceConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceConfiguration(soap, "tt:VideoSourceConfiguration", &(a->tt__Profile::VideoSourceConfiguration), "tt:VideoSourceConfiguration"))
				{	soap_flag_VideoSourceConfiguration1--;
					continue;
				}
			if (soap_flag_AudioSourceConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioSourceConfiguration(soap, "tt:AudioSourceConfiguration", &(a->tt__Profile::AudioSourceConfiguration), "tt:AudioSourceConfiguration"))
				{	soap_flag_AudioSourceConfiguration1--;
					continue;
				}
			if (soap_flag_VideoEncoderConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoEncoderConfiguration", &(a->tt__Profile::VideoEncoderConfiguration), "tt:VideoEncoderConfiguration"))
				{	soap_flag_VideoEncoderConfiguration1--;
					continue;
				}
			if (soap_flag_AudioEncoderConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioEncoderConfiguration(soap, "tt:AudioEncoderConfiguration", &(a->tt__Profile::AudioEncoderConfiguration), "tt:AudioEncoderConfiguration"))
				{	soap_flag_AudioEncoderConfiguration1--;
					continue;
				}
			if (soap_flag_VideoAnalyticsConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoAnalyticsConfiguration(soap, "tt:VideoAnalyticsConfiguration", &(a->tt__Profile::VideoAnalyticsConfiguration), "tt:VideoAnalyticsConfiguration"))
				{	soap_flag_VideoAnalyticsConfiguration1--;
					continue;
				}
			if (soap_flag_PTZConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZConfiguration(soap, "tt:PTZConfiguration", &(a->tt__Profile::PTZConfiguration), "tt:PTZConfiguration"))
				{	soap_flag_PTZConfiguration1--;
					continue;
				}
			if (soap_flag_MetadataConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MetadataConfiguration(soap, "tt:MetadataConfiguration", &(a->tt__Profile::MetadataConfiguration), "tt:MetadataConfiguration"))
				{	soap_flag_MetadataConfiguration1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ProfileExtension(soap, "tt:Extension", &(a->tt__Profile::Extension), "tt:ProfileExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Profile, 0, sizeof(tt__Profile), 0, soap_copy_tt__Profile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Profile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Profile);
	if (this->soap_out(soap, tag?tag:"tt:Profile", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Profile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Profile(soap, this, tag, type);
}

SOAP_FMAC3 tt__Profile * SOAP_FMAC4 soap_get_tt__Profile(struct soap *soap, tt__Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Profile * SOAP_FMAC2 soap_instantiate_tt__Profile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Profile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Profile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Profile);
		if (size)
			*size = sizeof(tt__Profile);
		((tt__Profile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__Profile[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__Profile);
		for (int i = 0; i < n; i++)
			((tt__Profile*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__Profile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Profile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Profile %p -> %p\n", q, p));
	*(tt__Profile*)p = *(tt__Profile*)q;
}

void tt__AudioSource::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tt__AudioSource::Channels);
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioSource::__any);
	soap_default_xsd__anyAttribute(soap, &this->tt__AudioSource::__anyAttribute);
	soap_default_tt__ReferenceToken(soap, &this->tt__DeviceEntity::token);
	/* transient soap skipped */
}

void tt__AudioSource::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__AudioSource::Channels, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__AudioSource::__any);
	/* transient soap skipped */
}

int tt__AudioSource::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioSource(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSource(struct soap *soap, const char *tag, int id, const tt__AudioSource *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__AudioSource*)a)->__anyAttribute, ""))
		return soap->error;
	if (!((tt__DeviceEntity*)a)->token.empty())
		soap_set_attr(soap, "token", ((tt__DeviceEntity*)a)->token.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSource), "tt:AudioSource"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_int(soap, "tt:Channels", -1, &(a->tt__AudioSource::Channels), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__AudioSource::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioSource::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__AudioSource(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioSource * SOAP_FMAC4 soap_in_tt__AudioSource(struct soap *soap, const char *tag, tt__AudioSource *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioSource *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSource, sizeof(tt__AudioSource), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__AudioSource)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__AudioSource *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__AudioSource*)a)->__anyAttribute, "xsd:anyAttribute");
	{	const char *t = soap_attr_value(soap, "token", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, 64))
				return NULL;
			((tt__DeviceEntity*)a)->token.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Channels1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Channels1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Channels", &(a->tt__AudioSource::Channels), "xsd:int"))
				{	soap_flag_Channels1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__AudioSource::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSource, 0, sizeof(tt__AudioSource), 0, soap_copy_tt__AudioSource);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Channels1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__AudioSource::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__AudioSource);
	if (this->soap_out(soap, tag?tag:"tt:AudioSource", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioSource::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioSource(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioSource * SOAP_FMAC4 soap_get_tt__AudioSource(struct soap *soap, tt__AudioSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__AudioSource * SOAP_FMAC2 soap_instantiate_tt__AudioSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioSource(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__AudioSource, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__AudioSource);
		if (size)
			*size = sizeof(tt__AudioSource);
		((tt__AudioSource*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__AudioSource[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__AudioSource);
		for (int i = 0; i < n; i++)
			((tt__AudioSource*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__AudioSource*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__AudioSource(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__AudioSource %p -> %p\n", q, p));
	*(tt__AudioSource*)p = *(tt__AudioSource*)q;
}

void tt__VideoSourceExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoSourceExtension::__any);
	/* transient soap skipped */
}

void tt__VideoSourceExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyType(soap, &this->tt__VideoSourceExtension::__any);
	/* transient soap skipped */
}

int tt__VideoSourceExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceExtension(struct soap *soap, const char *tag, int id, const tt__VideoSourceExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyType(soap, "-any", -1, &(a->tt__VideoSourceExtension::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoSourceExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceExtension * SOAP_FMAC4 soap_in_tt__VideoSourceExtension(struct soap *soap, const char *tag, tt__VideoSourceExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceExtension, sizeof(tt__VideoSourceExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoSourceExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoSourceExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyType(soap, "-any", &(a->tt__VideoSourceExtension::__any), "xsd:anyType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceExtension, 0, sizeof(tt__VideoSourceExtension), 0, soap_copy_tt__VideoSourceExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__VideoSourceExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoSourceExtension);
	if (this->soap_out(soap, tag?tag:"tt:VideoSourceExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceExtension * SOAP_FMAC4 soap_get_tt__VideoSourceExtension(struct soap *soap, tt__VideoSourceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoSourceExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoSourceExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoSourceExtension);
		if (size)
			*size = sizeof(tt__VideoSourceExtension);
		((tt__VideoSourceExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoSourceExtension[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__VideoSourceExtension);
		for (int i = 0; i < n; i++)
			((tt__VideoSourceExtension*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__VideoSourceExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoSourceExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoSourceExtension %p -> %p\n", q, p));
	*(tt__VideoSourceExtension*)p = *(tt__VideoSourceExtension*)q;
}

void tt__VideoSource::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_float(soap, &this->tt__VideoSource::Framerate);
	this->tt__VideoSource::Resolution = NULL;
	this->tt__VideoSource::Imaging = NULL;
	this->tt__VideoSource::Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &this->tt__VideoSource::__anyAttribute);
	soap_default_tt__ReferenceToken(soap, &this->tt__DeviceEntity::token);
	/* transient soap skipped */
}

void tt__VideoSource::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__VideoSource::Framerate, SOAP_TYPE_float);
	soap_serialize_PointerTott__VideoResolution(soap, &this->tt__VideoSource::Resolution);
	soap_serialize_PointerTott__ImagingSettings(soap, &this->tt__VideoSource::Imaging);
	soap_serialize_PointerTott__VideoSourceExtension(soap, &this->tt__VideoSource::Extension);
	/* transient soap skipped */
}

int tt__VideoSource::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSource(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSource(struct soap *soap, const char *tag, int id, const tt__VideoSource *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((tt__VideoSource*)a)->__anyAttribute, ""))
		return soap->error;
	if (!((tt__DeviceEntity*)a)->token.empty())
		soap_set_attr(soap, "token", ((tt__DeviceEntity*)a)->token.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSource), "tt:VideoSource"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_float(soap, "tt:Framerate", -1, &(a->tt__VideoSource::Framerate), ""))
		return soap->error;
	if (a->tt__VideoSource::Resolution)
	{	if (soap_out_PointerTott__VideoResolution(soap, "tt:Resolution", -1, &a->tt__VideoSource::Resolution, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Resolution"))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettings(soap, "tt:Imaging", -1, &(a->tt__VideoSource::Imaging), ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceExtension(soap, "tt:Extension", -1, &(a->tt__VideoSource::Extension), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSource::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoSource(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSource * SOAP_FMAC4 soap_in_tt__VideoSource(struct soap *soap, const char *tag, tt__VideoSource *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSource *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSource, sizeof(tt__VideoSource), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoSource)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoSource *)a->soap_in(soap, tag, type);
		}
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((tt__VideoSource*)a)->__anyAttribute, "xsd:anyAttribute");
	{	const char *t = soap_attr_value(soap, "token", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, 64))
				return NULL;
			((tt__DeviceEntity*)a)->token.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Framerate1 = 1;
	size_t soap_flag_Resolution1 = 1;
	size_t soap_flag_Imaging1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Framerate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Framerate", &(a->tt__VideoSource::Framerate), "xsd:float"))
				{	soap_flag_Framerate1--;
					continue;
				}
			if (soap_flag_Resolution1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoResolution(soap, "tt:Resolution", &(a->tt__VideoSource::Resolution), "tt:VideoResolution"))
				{	soap_flag_Resolution1--;
					continue;
				}
			if (soap_flag_Imaging1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingSettings(soap, "tt:Imaging", &(a->tt__VideoSource::Imaging), "tt:ImagingSettings"))
				{	soap_flag_Imaging1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceExtension(soap, "tt:Extension", &(a->tt__VideoSource::Extension), "tt:VideoSourceExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSource, 0, sizeof(tt__VideoSource), 0, soap_copy_tt__VideoSource);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Framerate1 > 0 || soap_flag_Resolution1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__VideoSource::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoSource);
	if (this->soap_out(soap, tag?tag:"tt:VideoSource", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSource::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSource(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSource * SOAP_FMAC4 soap_get_tt__VideoSource(struct soap *soap, tt__VideoSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoSource * SOAP_FMAC2 soap_instantiate_tt__VideoSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSource(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoSource, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoSource);
		if (size)
			*size = sizeof(tt__VideoSource);
		((tt__VideoSource*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoSource[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__VideoSource);
		for (int i = 0; i < n; i++)
			((tt__VideoSource*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__VideoSource*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoSource(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoSource %p -> %p\n", q, p));
	*(tt__VideoSource*)p = *(tt__VideoSource*)q;
}

void tt__IntList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfint(soap, &this->tt__IntList::Items);
	/* transient soap skipped */
}

void tt__IntList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfint(soap, &this->tt__IntList::Items);
	/* transient soap skipped */
}

int tt__IntList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IntList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntList(struct soap *soap, const char *tag, int id, const tt__IntList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntList), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "tt:Items", -1, &(a->tt__IntList::Items), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__IntList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__IntList(soap, tag, this, type);
}

SOAP_FMAC3 tt__IntList * SOAP_FMAC4 soap_in_tt__IntList(struct soap *soap, const char *tag, tt__IntList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IntList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntList, sizeof(tt__IntList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__IntList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__IntList *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "tt:Items", &(a->tt__IntList::Items), "xsd:int"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IntList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntList, 0, sizeof(tt__IntList), 0, soap_copy_tt__IntList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__IntList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__IntList);
	if (this->soap_out(soap, tag?tag:"tt:IntList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IntList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IntList(soap, this, tag, type);
}

SOAP_FMAC3 tt__IntList * SOAP_FMAC4 soap_get_tt__IntList(struct soap *soap, tt__IntList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__IntList * SOAP_FMAC2 soap_instantiate_tt__IntList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IntList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__IntList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__IntList);
		if (size)
			*size = sizeof(tt__IntList);
		((tt__IntList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__IntList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__IntList);
		for (int i = 0; i < n; i++)
			((tt__IntList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__IntList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__IntList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__IntList %p -> %p\n", q, p));
	*(tt__IntList*)p = *(tt__IntList*)q;
}

void tt__DurationRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__duration(soap, &this->tt__DurationRange::Min);
	soap_default_xsd__duration(soap, &this->tt__DurationRange::Max);
	/* transient soap skipped */
}

void tt__DurationRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__DurationRange::Min, SOAP_TYPE_xsd__duration);
	soap_embedded(soap, &this->tt__DurationRange::Max, SOAP_TYPE_xsd__duration);
	/* transient soap skipped */
}

int tt__DurationRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DurationRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DurationRange(struct soap *soap, const char *tag, int id, const tt__DurationRange *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DurationRange), type))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:Min", -1, &(a->tt__DurationRange::Min), ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:Max", -1, &(a->tt__DurationRange::Max), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__DurationRange::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__DurationRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__DurationRange * SOAP_FMAC4 soap_in_tt__DurationRange(struct soap *soap, const char *tag, tt__DurationRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DurationRange *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DurationRange, sizeof(tt__DurationRange), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__DurationRange)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__DurationRange *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Min1 = 1;
	size_t soap_flag_Max1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tt:Min", &(a->tt__DurationRange::Min), "xsd:duration"))
				{	soap_flag_Min1--;
					continue;
				}
			if (soap_flag_Max1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tt:Max", &(a->tt__DurationRange::Max), "xsd:duration"))
				{	soap_flag_Max1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__DurationRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DurationRange, 0, sizeof(tt__DurationRange), 0, soap_copy_tt__DurationRange);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min1 > 0 || soap_flag_Max1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__DurationRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__DurationRange);
	if (this->soap_out(soap, tag?tag:"tt:DurationRange", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DurationRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DurationRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__DurationRange * SOAP_FMAC4 soap_get_tt__DurationRange(struct soap *soap, tt__DurationRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DurationRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__DurationRange * SOAP_FMAC2 soap_instantiate_tt__DurationRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DurationRange(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__DurationRange, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__DurationRange);
		if (size)
			*size = sizeof(tt__DurationRange);
		((tt__DurationRange*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__DurationRange[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__DurationRange);
		for (int i = 0; i < n; i++)
			((tt__DurationRange*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__DurationRange*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__DurationRange(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__DurationRange %p -> %p\n", q, p));
	*(tt__DurationRange*)p = *(tt__DurationRange*)q;
}

void tt__FloatRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_float(soap, &this->tt__FloatRange::Min);
	soap_default_float(soap, &this->tt__FloatRange::Max);
	/* transient soap skipped */
}

void tt__FloatRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__FloatRange::Min, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__FloatRange::Max, SOAP_TYPE_float);
	/* transient soap skipped */
}

int tt__FloatRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FloatRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatRange(struct soap *soap, const char *tag, int id, const tt__FloatRange *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FloatRange), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Min", -1, &(a->tt__FloatRange::Min), ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Max", -1, &(a->tt__FloatRange::Max), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__FloatRange::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__FloatRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__FloatRange * SOAP_FMAC4 soap_in_tt__FloatRange(struct soap *soap, const char *tag, tt__FloatRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FloatRange *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FloatRange, sizeof(tt__FloatRange), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__FloatRange)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__FloatRange *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Min1 = 1;
	size_t soap_flag_Max1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Min", &(a->tt__FloatRange::Min), "xsd:float"))
				{	soap_flag_Min1--;
					continue;
				}
			if (soap_flag_Max1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Max", &(a->tt__FloatRange::Max), "xsd:float"))
				{	soap_flag_Max1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FloatRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FloatRange, 0, sizeof(tt__FloatRange), 0, soap_copy_tt__FloatRange);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min1 > 0 || soap_flag_Max1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__FloatRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__FloatRange);
	if (this->soap_out(soap, tag?tag:"tt:FloatRange", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FloatRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FloatRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__FloatRange * SOAP_FMAC4 soap_get_tt__FloatRange(struct soap *soap, tt__FloatRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FloatRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__FloatRange * SOAP_FMAC2 soap_instantiate_tt__FloatRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FloatRange(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__FloatRange, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__FloatRange);
		if (size)
			*size = sizeof(tt__FloatRange);
		((tt__FloatRange*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__FloatRange[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__FloatRange);
		for (int i = 0; i < n; i++)
			((tt__FloatRange*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__FloatRange*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__FloatRange(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__FloatRange %p -> %p\n", q, p));
	*(tt__FloatRange*)p = *(tt__FloatRange*)q;
}

void tt__IntRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tt__IntRange::Min);
	soap_default_int(soap, &this->tt__IntRange::Max);
	/* transient soap skipped */
}

void tt__IntRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__IntRange::Min, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__IntRange::Max, SOAP_TYPE_int);
	/* transient soap skipped */
}

int tt__IntRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IntRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRange(struct soap *soap, const char *tag, int id, const tt__IntRange *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRange), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Min", -1, &(a->tt__IntRange::Min), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Max", -1, &(a->tt__IntRange::Max), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__IntRange::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__IntRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__IntRange * SOAP_FMAC4 soap_in_tt__IntRange(struct soap *soap, const char *tag, tt__IntRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IntRange *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRange, sizeof(tt__IntRange), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__IntRange)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__IntRange *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Min1 = 1;
	size_t soap_flag_Max1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Min", &(a->tt__IntRange::Min), "xsd:int"))
				{	soap_flag_Min1--;
					continue;
				}
			if (soap_flag_Max1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Max", &(a->tt__IntRange::Max), "xsd:int"))
				{	soap_flag_Max1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IntRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRange, 0, sizeof(tt__IntRange), 0, soap_copy_tt__IntRange);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min1 > 0 || soap_flag_Max1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__IntRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__IntRange);
	if (this->soap_out(soap, tag?tag:"tt:IntRange", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IntRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IntRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__IntRange * SOAP_FMAC4 soap_get_tt__IntRange(struct soap *soap, tt__IntRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__IntRange * SOAP_FMAC2 soap_instantiate_tt__IntRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IntRange(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__IntRange, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__IntRange);
		if (size)
			*size = sizeof(tt__IntRange);
		((tt__IntRange*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__IntRange[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__IntRange);
		for (int i = 0; i < n; i++)
			((tt__IntRange*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__IntRange*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__IntRange(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__IntRange %p -> %p\n", q, p));
	*(tt__IntRange*)p = *(tt__IntRange*)q;
}

void tt__IntRectangleRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__IntRectangleRange::XRange = NULL;
	this->tt__IntRectangleRange::YRange = NULL;
	this->tt__IntRectangleRange::WidthRange = NULL;
	this->tt__IntRectangleRange::HeightRange = NULL;
	/* transient soap skipped */
}

void tt__IntRectangleRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IntRange(soap, &this->tt__IntRectangleRange::XRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__IntRectangleRange::YRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__IntRectangleRange::WidthRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__IntRectangleRange::HeightRange);
	/* transient soap skipped */
}

int tt__IntRectangleRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IntRectangleRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRectangleRange(struct soap *soap, const char *tag, int id, const tt__IntRectangleRange *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRectangleRange), type))
		return soap->error;
	if (a->tt__IntRectangleRange::XRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:XRange", -1, &a->tt__IntRectangleRange::XRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XRange"))
		return soap->error;
	if (a->tt__IntRectangleRange::YRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:YRange", -1, &a->tt__IntRectangleRange::YRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:YRange"))
		return soap->error;
	if (a->tt__IntRectangleRange::WidthRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:WidthRange", -1, &a->tt__IntRectangleRange::WidthRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:WidthRange"))
		return soap->error;
	if (a->tt__IntRectangleRange::HeightRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:HeightRange", -1, &a->tt__IntRectangleRange::HeightRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:HeightRange"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__IntRectangleRange::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__IntRectangleRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__IntRectangleRange * SOAP_FMAC4 soap_in_tt__IntRectangleRange(struct soap *soap, const char *tag, tt__IntRectangleRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IntRectangleRange *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRectangleRange, sizeof(tt__IntRectangleRange), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__IntRectangleRange)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__IntRectangleRange *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_XRange1 = 1;
	size_t soap_flag_YRange1 = 1;
	size_t soap_flag_WidthRange1 = 1;
	size_t soap_flag_HeightRange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:XRange", &(a->tt__IntRectangleRange::XRange), "tt:IntRange"))
				{	soap_flag_XRange1--;
					continue;
				}
			if (soap_flag_YRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:YRange", &(a->tt__IntRectangleRange::YRange), "tt:IntRange"))
				{	soap_flag_YRange1--;
					continue;
				}
			if (soap_flag_WidthRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:WidthRange", &(a->tt__IntRectangleRange::WidthRange), "tt:IntRange"))
				{	soap_flag_WidthRange1--;
					continue;
				}
			if (soap_flag_HeightRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:HeightRange", &(a->tt__IntRectangleRange::HeightRange), "tt:IntRange"))
				{	soap_flag_HeightRange1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IntRectangleRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRectangleRange, 0, sizeof(tt__IntRectangleRange), 0, soap_copy_tt__IntRectangleRange);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XRange1 > 0 || soap_flag_YRange1 > 0 || soap_flag_WidthRange1 > 0 || soap_flag_HeightRange1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__IntRectangleRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__IntRectangleRange);
	if (this->soap_out(soap, tag?tag:"tt:IntRectangleRange", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IntRectangleRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IntRectangleRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__IntRectangleRange * SOAP_FMAC4 soap_get_tt__IntRectangleRange(struct soap *soap, tt__IntRectangleRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRectangleRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__IntRectangleRange * SOAP_FMAC2 soap_instantiate_tt__IntRectangleRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IntRectangleRange(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__IntRectangleRange, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__IntRectangleRange);
		if (size)
			*size = sizeof(tt__IntRectangleRange);
		((tt__IntRectangleRange*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__IntRectangleRange[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__IntRectangleRange);
		for (int i = 0; i < n; i++)
			((tt__IntRectangleRange*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__IntRectangleRange*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__IntRectangleRange(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__IntRectangleRange %p -> %p\n", q, p));
	*(tt__IntRectangleRange*)p = *(tt__IntRectangleRange*)q;
}

void tt__IntRectangle::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tt__IntRectangle::x);
	soap_default_int(soap, &this->tt__IntRectangle::y);
	soap_default_int(soap, &this->tt__IntRectangle::width);
	soap_default_int(soap, &this->tt__IntRectangle::height);
	/* transient soap skipped */
}

void tt__IntRectangle::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tt__IntRectangle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IntRectangle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRectangle(struct soap *soap, const char *tag, int id, const tt__IntRectangle *a, const char *type)
{
	soap_set_attr(soap, "x", soap_int2s(soap, ((tt__IntRectangle*)a)->x), 1);
	soap_set_attr(soap, "y", soap_int2s(soap, ((tt__IntRectangle*)a)->y), 1);
	soap_set_attr(soap, "width", soap_int2s(soap, ((tt__IntRectangle*)a)->width), 1);
	soap_set_attr(soap, "height", soap_int2s(soap, ((tt__IntRectangle*)a)->height), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRectangle), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__IntRectangle::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__IntRectangle(soap, tag, this, type);
}

SOAP_FMAC3 tt__IntRectangle * SOAP_FMAC4 soap_in_tt__IntRectangle(struct soap *soap, const char *tag, tt__IntRectangle *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IntRectangle *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRectangle, sizeof(tt__IntRectangle), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__IntRectangle)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__IntRectangle *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2int(soap, soap_attr_value(soap, "x", 1), &((tt__IntRectangle*)a)->x))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "y", 1), &((tt__IntRectangle*)a)->y))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "width", 1), &((tt__IntRectangle*)a)->width))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "height", 1), &((tt__IntRectangle*)a)->height))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IntRectangle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRectangle, 0, sizeof(tt__IntRectangle), 0, soap_copy_tt__IntRectangle);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__IntRectangle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__IntRectangle);
	if (this->soap_out(soap, tag?tag:"tt:IntRectangle", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IntRectangle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IntRectangle(soap, this, tag, type);
}

SOAP_FMAC3 tt__IntRectangle * SOAP_FMAC4 soap_get_tt__IntRectangle(struct soap *soap, tt__IntRectangle *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__IntRectangle * SOAP_FMAC2 soap_instantiate_tt__IntRectangle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IntRectangle(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__IntRectangle, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__IntRectangle);
		if (size)
			*size = sizeof(tt__IntRectangle);
		((tt__IntRectangle*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__IntRectangle[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__IntRectangle);
		for (int i = 0; i < n; i++)
			((tt__IntRectangle*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__IntRectangle*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__IntRectangle(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__IntRectangle %p -> %p\n", q, p));
	*(tt__IntRectangle*)p = *(tt__IntRectangle*)q;
}

void tt__DeviceEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->tt__DeviceEntity::token);
	/* transient soap skipped */
}

void tt__DeviceEntity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tt__DeviceEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DeviceEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceEntity(struct soap *soap, const char *tag, int id, const tt__DeviceEntity *a, const char *type)
{
	if (!((tt__DeviceEntity*)a)->token.empty())
		soap_set_attr(soap, "token", ((tt__DeviceEntity*)a)->token.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceEntity), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tt__DeviceEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__DeviceEntity(soap, tag, this, type);
}

SOAP_FMAC3 tt__DeviceEntity * SOAP_FMAC4 soap_in_tt__DeviceEntity(struct soap *soap, const char *tag, tt__DeviceEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DeviceEntity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceEntity, sizeof(tt__DeviceEntity), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__DeviceEntity)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__DeviceEntity *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "token", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, 64))
				return NULL;
			((tt__DeviceEntity*)a)->token.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__DeviceEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceEntity, 0, sizeof(tt__DeviceEntity), 0, soap_copy_tt__DeviceEntity);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__DeviceEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__DeviceEntity);
	if (this->soap_out(soap, tag?tag:"tt:DeviceEntity", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DeviceEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DeviceEntity(soap, this, tag, type);
}

SOAP_FMAC3 tt__DeviceEntity * SOAP_FMAC4 soap_get_tt__DeviceEntity(struct soap *soap, tt__DeviceEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__DeviceEntity * SOAP_FMAC2 soap_instantiate_tt__DeviceEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DeviceEntity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__DeviceEntity, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "tt:VideoSource"))
	{	cp->type = SOAP_TYPE_tt__VideoSource;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__VideoSource);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(tt__VideoSource);
			((tt__VideoSource*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(tt__VideoSource[n]);
			if (size)
				*size = n * sizeof(tt__VideoSource);
			for (int i = 0; i < n; i++)
				((tt__VideoSource*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (tt__VideoSource*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:AudioSource"))
	{	cp->type = SOAP_TYPE_tt__AudioSource;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__AudioSource);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(tt__AudioSource);
			((tt__AudioSource*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(tt__AudioSource[n]);
			if (size)
				*size = n * sizeof(tt__AudioSource);
			for (int i = 0; i < n; i++)
				((tt__AudioSource*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (tt__AudioSource*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:NetworkInterface"))
	{	cp->type = SOAP_TYPE_tt__NetworkInterface;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__NetworkInterface);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(tt__NetworkInterface);
			((tt__NetworkInterface*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(tt__NetworkInterface[n]);
			if (size)
				*size = n * sizeof(tt__NetworkInterface);
			for (int i = 0; i < n; i++)
				((tt__NetworkInterface*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (tt__NetworkInterface*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:RelayOutput"))
	{	cp->type = SOAP_TYPE_tt__RelayOutput;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__RelayOutput);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(tt__RelayOutput);
			((tt__RelayOutput*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(tt__RelayOutput[n]);
			if (size)
				*size = n * sizeof(tt__RelayOutput);
			for (int i = 0; i < n; i++)
				((tt__RelayOutput*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (tt__RelayOutput*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:PTZNode"))
	{	cp->type = SOAP_TYPE_tt__PTZNode;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__PTZNode);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(tt__PTZNode);
			((tt__PTZNode*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(tt__PTZNode[n]);
			if (size)
				*size = n * sizeof(tt__PTZNode);
			for (int i = 0; i < n; i++)
				((tt__PTZNode*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (tt__PTZNode*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__DeviceEntity);
		if (size)
			*size = sizeof(tt__DeviceEntity);
		((tt__DeviceEntity*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tt__DeviceEntity[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tt__DeviceEntity);
		for (int i = 0; i < n; i++)
			((tt__DeviceEntity*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tt__DeviceEntity*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__DeviceEntity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__DeviceEntity %p -> %p\n", q, p));
	*(tt__DeviceEntity*)p = *(tt__DeviceEntity*)q;
}

void _tan__GetAnalyticsModulesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Config(soap, &this->_tan__GetAnalyticsModulesResponse::AnalyticsModule);
	/* transient soap skipped */
}

void _tan__GetAnalyticsModulesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTott__Config(soap, &this->_tan__GetAnalyticsModulesResponse::AnalyticsModule);
	/* transient soap skipped */
}

int _tan__GetAnalyticsModulesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tan__GetAnalyticsModulesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, const _tan__GetAnalyticsModulesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetAnalyticsModulesResponse), type))
		return soap->error;
	soap_element_result(soap, "tan:AnalyticsModule");
	if (soap_out_std__vectorTemplateOfPointerTott__Config(soap, "tan:AnalyticsModule", -1, &(a->_tan__GetAnalyticsModulesResponse::AnalyticsModule), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tan__GetAnalyticsModulesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tan__GetAnalyticsModulesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tan__GetAnalyticsModulesResponse * SOAP_FMAC4 soap_in__tan__GetAnalyticsModulesResponse(struct soap *soap, const char *tag, _tan__GetAnalyticsModulesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tan__GetAnalyticsModulesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetAnalyticsModulesResponse, sizeof(_tan__GetAnalyticsModulesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tan__GetAnalyticsModulesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tan__GetAnalyticsModulesResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Config(soap, "tan:AnalyticsModule", &(a->_tan__GetAnalyticsModulesResponse::AnalyticsModule), "tt:Config"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "tan:AnalyticsModule");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tan__GetAnalyticsModulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetAnalyticsModulesResponse, 0, sizeof(_tan__GetAnalyticsModulesResponse), 0, soap_copy__tan__GetAnalyticsModulesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tan__GetAnalyticsModulesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tan__GetAnalyticsModulesResponse);
	if (this->soap_out(soap, tag?tag:"tan:GetAnalyticsModulesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tan__GetAnalyticsModulesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tan__GetAnalyticsModulesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tan__GetAnalyticsModulesResponse * SOAP_FMAC4 soap_get__tan__GetAnalyticsModulesResponse(struct soap *soap, _tan__GetAnalyticsModulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tan__GetAnalyticsModulesResponse * SOAP_FMAC2 soap_instantiate__tan__GetAnalyticsModulesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tan__GetAnalyticsModulesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tan__GetAnalyticsModulesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tan__GetAnalyticsModulesResponse);
		if (size)
			*size = sizeof(_tan__GetAnalyticsModulesResponse);
		((_tan__GetAnalyticsModulesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tan__GetAnalyticsModulesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tan__GetAnalyticsModulesResponse);
		for (int i = 0; i < n; i++)
			((_tan__GetAnalyticsModulesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tan__GetAnalyticsModulesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tan__GetAnalyticsModulesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tan__GetAnalyticsModulesResponse %p -> %p\n", q, p));
	*(_tan__GetAnalyticsModulesResponse*)p = *(_tan__GetAnalyticsModulesResponse*)q;
}

void _tan__GetAnalyticsModules::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tan__GetAnalyticsModules::ConfigurationToken);
	/* transient soap skipped */
}

void _tan__GetAnalyticsModules::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_tan__GetAnalyticsModules::ConfigurationToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tan__GetAnalyticsModules::ConfigurationToken);
	/* transient soap skipped */
}

int _tan__GetAnalyticsModules::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tan__GetAnalyticsModules(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetAnalyticsModules(struct soap *soap, const char *tag, int id, const _tan__GetAnalyticsModules *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetAnalyticsModules), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, &(a->_tan__GetAnalyticsModules::ConfigurationToken), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tan__GetAnalyticsModules::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tan__GetAnalyticsModules(soap, tag, this, type);
}

SOAP_FMAC3 _tan__GetAnalyticsModules * SOAP_FMAC4 soap_in__tan__GetAnalyticsModules(struct soap *soap, const char *tag, _tan__GetAnalyticsModules *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tan__GetAnalyticsModules *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetAnalyticsModules, sizeof(_tan__GetAnalyticsModules), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tan__GetAnalyticsModules)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tan__GetAnalyticsModules *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ConfigurationToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", &(a->_tan__GetAnalyticsModules::ConfigurationToken), "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tan__GetAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetAnalyticsModules, 0, sizeof(_tan__GetAnalyticsModules), 0, soap_copy__tan__GetAnalyticsModules);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tan__GetAnalyticsModules::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tan__GetAnalyticsModules);
	if (this->soap_out(soap, tag?tag:"tan:GetAnalyticsModules", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tan__GetAnalyticsModules::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tan__GetAnalyticsModules(soap, this, tag, type);
}

SOAP_FMAC3 _tan__GetAnalyticsModules * SOAP_FMAC4 soap_get__tan__GetAnalyticsModules(struct soap *soap, _tan__GetAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tan__GetAnalyticsModules * SOAP_FMAC2 soap_instantiate__tan__GetAnalyticsModules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tan__GetAnalyticsModules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tan__GetAnalyticsModules, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tan__GetAnalyticsModules);
		if (size)
			*size = sizeof(_tan__GetAnalyticsModules);
		((_tan__GetAnalyticsModules*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tan__GetAnalyticsModules[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tan__GetAnalyticsModules);
		for (int i = 0; i < n; i++)
			((_tan__GetAnalyticsModules*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tan__GetAnalyticsModules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tan__GetAnalyticsModules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tan__GetAnalyticsModules %p -> %p\n", q, p));
	*(_tan__GetAnalyticsModules*)p = *(_tan__GetAnalyticsModules*)q;
}

void _tan__ModifyAnalyticsModulesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tan__ModifyAnalyticsModulesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _tan__ModifyAnalyticsModulesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tan__ModifyAnalyticsModulesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__ModifyAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, const _tan__ModifyAnalyticsModulesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tan__ModifyAnalyticsModulesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tan__ModifyAnalyticsModulesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tan__ModifyAnalyticsModulesResponse * SOAP_FMAC4 soap_in__tan__ModifyAnalyticsModulesResponse(struct soap *soap, const char *tag, _tan__ModifyAnalyticsModulesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tan__ModifyAnalyticsModulesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse, sizeof(_tan__ModifyAnalyticsModulesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tan__ModifyAnalyticsModulesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tan__ModifyAnalyticsModulesResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tan__ModifyAnalyticsModulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse, 0, sizeof(_tan__ModifyAnalyticsModulesResponse), 0, soap_copy__tan__ModifyAnalyticsModulesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tan__ModifyAnalyticsModulesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse);
	if (this->soap_out(soap, tag?tag:"tan:ModifyAnalyticsModulesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tan__ModifyAnalyticsModulesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tan__ModifyAnalyticsModulesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tan__ModifyAnalyticsModulesResponse * SOAP_FMAC4 soap_get__tan__ModifyAnalyticsModulesResponse(struct soap *soap, _tan__ModifyAnalyticsModulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__ModifyAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tan__ModifyAnalyticsModulesResponse * SOAP_FMAC2 soap_instantiate__tan__ModifyAnalyticsModulesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tan__ModifyAnalyticsModulesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tan__ModifyAnalyticsModulesResponse);
		if (size)
			*size = sizeof(_tan__ModifyAnalyticsModulesResponse);
		((_tan__ModifyAnalyticsModulesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tan__ModifyAnalyticsModulesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tan__ModifyAnalyticsModulesResponse);
		for (int i = 0; i < n; i++)
			((_tan__ModifyAnalyticsModulesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tan__ModifyAnalyticsModulesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tan__ModifyAnalyticsModulesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tan__ModifyAnalyticsModulesResponse %p -> %p\n", q, p));
	*(_tan__ModifyAnalyticsModulesResponse*)p = *(_tan__ModifyAnalyticsModulesResponse*)q;
}

void _tan__ModifyAnalyticsModules::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tan__ModifyAnalyticsModules::ConfigurationToken);
	soap_default_std__vectorTemplateOfPointerTott__Config(soap, &this->_tan__ModifyAnalyticsModules::AnalyticsModule);
	/* transient soap skipped */
}

void _tan__ModifyAnalyticsModules::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_tan__ModifyAnalyticsModules::ConfigurationToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tan__ModifyAnalyticsModules::ConfigurationToken);
	soap_serialize_std__vectorTemplateOfPointerTott__Config(soap, &this->_tan__ModifyAnalyticsModules::AnalyticsModule);
	/* transient soap skipped */
}

int _tan__ModifyAnalyticsModules::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tan__ModifyAnalyticsModules(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__ModifyAnalyticsModules(struct soap *soap, const char *tag, int id, const _tan__ModifyAnalyticsModules *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__ModifyAnalyticsModules), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, &(a->_tan__ModifyAnalyticsModules::ConfigurationToken), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Config(soap, "tan:AnalyticsModule", -1, &(a->_tan__ModifyAnalyticsModules::AnalyticsModule), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tan__ModifyAnalyticsModules::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tan__ModifyAnalyticsModules(soap, tag, this, type);
}

SOAP_FMAC3 _tan__ModifyAnalyticsModules * SOAP_FMAC4 soap_in__tan__ModifyAnalyticsModules(struct soap *soap, const char *tag, _tan__ModifyAnalyticsModules *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tan__ModifyAnalyticsModules *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tan__ModifyAnalyticsModules, sizeof(_tan__ModifyAnalyticsModules), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tan__ModifyAnalyticsModules)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tan__ModifyAnalyticsModules *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ConfigurationToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", &(a->_tan__ModifyAnalyticsModules::ConfigurationToken), "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Config(soap, "tan:AnalyticsModule", &(a->_tan__ModifyAnalyticsModules::AnalyticsModule), "tt:Config"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tan__ModifyAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__ModifyAnalyticsModules, 0, sizeof(_tan__ModifyAnalyticsModules), 0, soap_copy__tan__ModifyAnalyticsModules);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken1 > 0 || a->_tan__ModifyAnalyticsModules::AnalyticsModule.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tan__ModifyAnalyticsModules::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tan__ModifyAnalyticsModules);
	if (this->soap_out(soap, tag?tag:"tan:ModifyAnalyticsModules", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tan__ModifyAnalyticsModules::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tan__ModifyAnalyticsModules(soap, this, tag, type);
}

SOAP_FMAC3 _tan__ModifyAnalyticsModules * SOAP_FMAC4 soap_get__tan__ModifyAnalyticsModules(struct soap *soap, _tan__ModifyAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__ModifyAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tan__ModifyAnalyticsModules * SOAP_FMAC2 soap_instantiate__tan__ModifyAnalyticsModules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tan__ModifyAnalyticsModules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tan__ModifyAnalyticsModules, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tan__ModifyAnalyticsModules);
		if (size)
			*size = sizeof(_tan__ModifyAnalyticsModules);
		((_tan__ModifyAnalyticsModules*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tan__ModifyAnalyticsModules[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tan__ModifyAnalyticsModules);
		for (int i = 0; i < n; i++)
			((_tan__ModifyAnalyticsModules*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tan__ModifyAnalyticsModules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tan__ModifyAnalyticsModules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tan__ModifyAnalyticsModules %p -> %p\n", q, p));
	*(_tan__ModifyAnalyticsModules*)p = *(_tan__ModifyAnalyticsModules*)q;
}

void _tan__DeleteAnalyticsModulesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tan__DeleteAnalyticsModulesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _tan__DeleteAnalyticsModulesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tan__DeleteAnalyticsModulesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__DeleteAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, const _tan__DeleteAnalyticsModulesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tan__DeleteAnalyticsModulesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tan__DeleteAnalyticsModulesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tan__DeleteAnalyticsModulesResponse * SOAP_FMAC4 soap_in__tan__DeleteAnalyticsModulesResponse(struct soap *soap, const char *tag, _tan__DeleteAnalyticsModulesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tan__DeleteAnalyticsModulesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse, sizeof(_tan__DeleteAnalyticsModulesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tan__DeleteAnalyticsModulesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tan__DeleteAnalyticsModulesResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tan__DeleteAnalyticsModulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse, 0, sizeof(_tan__DeleteAnalyticsModulesResponse), 0, soap_copy__tan__DeleteAnalyticsModulesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tan__DeleteAnalyticsModulesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse);
	if (this->soap_out(soap, tag?tag:"tan:DeleteAnalyticsModulesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tan__DeleteAnalyticsModulesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tan__DeleteAnalyticsModulesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tan__DeleteAnalyticsModulesResponse * SOAP_FMAC4 soap_get__tan__DeleteAnalyticsModulesResponse(struct soap *soap, _tan__DeleteAnalyticsModulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__DeleteAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tan__DeleteAnalyticsModulesResponse * SOAP_FMAC2 soap_instantiate__tan__DeleteAnalyticsModulesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tan__DeleteAnalyticsModulesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tan__DeleteAnalyticsModulesResponse);
		if (size)
			*size = sizeof(_tan__DeleteAnalyticsModulesResponse);
		((_tan__DeleteAnalyticsModulesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tan__DeleteAnalyticsModulesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tan__DeleteAnalyticsModulesResponse);
		for (int i = 0; i < n; i++)
			((_tan__DeleteAnalyticsModulesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tan__DeleteAnalyticsModulesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tan__DeleteAnalyticsModulesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tan__DeleteAnalyticsModulesResponse %p -> %p\n", q, p));
	*(_tan__DeleteAnalyticsModulesResponse*)p = *(_tan__DeleteAnalyticsModulesResponse*)q;
}

void _tan__DeleteAnalyticsModules::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tan__DeleteAnalyticsModules::ConfigurationToken);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->_tan__DeleteAnalyticsModules::AnalyticsModuleName);
	/* transient soap skipped */
}

void _tan__DeleteAnalyticsModules::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_tan__DeleteAnalyticsModules::ConfigurationToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tan__DeleteAnalyticsModules::ConfigurationToken);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->_tan__DeleteAnalyticsModules::AnalyticsModuleName);
	/* transient soap skipped */
}

int _tan__DeleteAnalyticsModules::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tan__DeleteAnalyticsModules(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__DeleteAnalyticsModules(struct soap *soap, const char *tag, int id, const _tan__DeleteAnalyticsModules *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__DeleteAnalyticsModules), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, &(a->_tan__DeleteAnalyticsModules::ConfigurationToken), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tan:AnalyticsModuleName", -1, &(a->_tan__DeleteAnalyticsModules::AnalyticsModuleName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tan__DeleteAnalyticsModules::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tan__DeleteAnalyticsModules(soap, tag, this, type);
}

SOAP_FMAC3 _tan__DeleteAnalyticsModules * SOAP_FMAC4 soap_in__tan__DeleteAnalyticsModules(struct soap *soap, const char *tag, _tan__DeleteAnalyticsModules *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tan__DeleteAnalyticsModules *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tan__DeleteAnalyticsModules, sizeof(_tan__DeleteAnalyticsModules), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tan__DeleteAnalyticsModules)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tan__DeleteAnalyticsModules *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ConfigurationToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", &(a->_tan__DeleteAnalyticsModules::ConfigurationToken), "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "tan:AnalyticsModuleName", &(a->_tan__DeleteAnalyticsModules::AnalyticsModuleName), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tan__DeleteAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__DeleteAnalyticsModules, 0, sizeof(_tan__DeleteAnalyticsModules), 0, soap_copy__tan__DeleteAnalyticsModules);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken1 > 0 || a->_tan__DeleteAnalyticsModules::AnalyticsModuleName.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tan__DeleteAnalyticsModules::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tan__DeleteAnalyticsModules);
	if (this->soap_out(soap, tag?tag:"tan:DeleteAnalyticsModules", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tan__DeleteAnalyticsModules::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tan__DeleteAnalyticsModules(soap, this, tag, type);
}

SOAP_FMAC3 _tan__DeleteAnalyticsModules * SOAP_FMAC4 soap_get__tan__DeleteAnalyticsModules(struct soap *soap, _tan__DeleteAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__DeleteAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tan__DeleteAnalyticsModules * SOAP_FMAC2 soap_instantiate__tan__DeleteAnalyticsModules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tan__DeleteAnalyticsModules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tan__DeleteAnalyticsModules, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tan__DeleteAnalyticsModules);
		if (size)
			*size = sizeof(_tan__DeleteAnalyticsModules);
		((_tan__DeleteAnalyticsModules*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tan__DeleteAnalyticsModules[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tan__DeleteAnalyticsModules);
		for (int i = 0; i < n; i++)
			((_tan__DeleteAnalyticsModules*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tan__DeleteAnalyticsModules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tan__DeleteAnalyticsModules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tan__DeleteAnalyticsModules %p -> %p\n", q, p));
	*(_tan__DeleteAnalyticsModules*)p = *(_tan__DeleteAnalyticsModules*)q;
}

void _tan__CreateAnalyticsModulesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tan__CreateAnalyticsModulesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _tan__CreateAnalyticsModulesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tan__CreateAnalyticsModulesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__CreateAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, const _tan__CreateAnalyticsModulesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__CreateAnalyticsModulesResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tan__CreateAnalyticsModulesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tan__CreateAnalyticsModulesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tan__CreateAnalyticsModulesResponse * SOAP_FMAC4 soap_in__tan__CreateAnalyticsModulesResponse(struct soap *soap, const char *tag, _tan__CreateAnalyticsModulesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tan__CreateAnalyticsModulesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tan__CreateAnalyticsModulesResponse, sizeof(_tan__CreateAnalyticsModulesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tan__CreateAnalyticsModulesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tan__CreateAnalyticsModulesResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tan__CreateAnalyticsModulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__CreateAnalyticsModulesResponse, 0, sizeof(_tan__CreateAnalyticsModulesResponse), 0, soap_copy__tan__CreateAnalyticsModulesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tan__CreateAnalyticsModulesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tan__CreateAnalyticsModulesResponse);
	if (this->soap_out(soap, tag?tag:"tan:CreateAnalyticsModulesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tan__CreateAnalyticsModulesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tan__CreateAnalyticsModulesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tan__CreateAnalyticsModulesResponse * SOAP_FMAC4 soap_get__tan__CreateAnalyticsModulesResponse(struct soap *soap, _tan__CreateAnalyticsModulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__CreateAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tan__CreateAnalyticsModulesResponse * SOAP_FMAC2 soap_instantiate__tan__CreateAnalyticsModulesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tan__CreateAnalyticsModulesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tan__CreateAnalyticsModulesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tan__CreateAnalyticsModulesResponse);
		if (size)
			*size = sizeof(_tan__CreateAnalyticsModulesResponse);
		((_tan__CreateAnalyticsModulesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tan__CreateAnalyticsModulesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tan__CreateAnalyticsModulesResponse);
		for (int i = 0; i < n; i++)
			((_tan__CreateAnalyticsModulesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tan__CreateAnalyticsModulesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tan__CreateAnalyticsModulesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tan__CreateAnalyticsModulesResponse %p -> %p\n", q, p));
	*(_tan__CreateAnalyticsModulesResponse*)p = *(_tan__CreateAnalyticsModulesResponse*)q;
}

void _tan__CreateAnalyticsModules::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tan__CreateAnalyticsModules::ConfigurationToken);
	soap_default_std__vectorTemplateOfPointerTott__Config(soap, &this->_tan__CreateAnalyticsModules::AnalyticsModule);
	/* transient soap skipped */
}

void _tan__CreateAnalyticsModules::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_tan__CreateAnalyticsModules::ConfigurationToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tan__CreateAnalyticsModules::ConfigurationToken);
	soap_serialize_std__vectorTemplateOfPointerTott__Config(soap, &this->_tan__CreateAnalyticsModules::AnalyticsModule);
	/* transient soap skipped */
}

int _tan__CreateAnalyticsModules::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tan__CreateAnalyticsModules(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__CreateAnalyticsModules(struct soap *soap, const char *tag, int id, const _tan__CreateAnalyticsModules *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__CreateAnalyticsModules), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, &(a->_tan__CreateAnalyticsModules::ConfigurationToken), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Config(soap, "tan:AnalyticsModule", -1, &(a->_tan__CreateAnalyticsModules::AnalyticsModule), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tan__CreateAnalyticsModules::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tan__CreateAnalyticsModules(soap, tag, this, type);
}

SOAP_FMAC3 _tan__CreateAnalyticsModules * SOAP_FMAC4 soap_in__tan__CreateAnalyticsModules(struct soap *soap, const char *tag, _tan__CreateAnalyticsModules *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tan__CreateAnalyticsModules *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tan__CreateAnalyticsModules, sizeof(_tan__CreateAnalyticsModules), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tan__CreateAnalyticsModules)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tan__CreateAnalyticsModules *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ConfigurationToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", &(a->_tan__CreateAnalyticsModules::ConfigurationToken), "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Config(soap, "tan:AnalyticsModule", &(a->_tan__CreateAnalyticsModules::AnalyticsModule), "tt:Config"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tan__CreateAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__CreateAnalyticsModules, 0, sizeof(_tan__CreateAnalyticsModules), 0, soap_copy__tan__CreateAnalyticsModules);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken1 > 0 || a->_tan__CreateAnalyticsModules::AnalyticsModule.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tan__CreateAnalyticsModules::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tan__CreateAnalyticsModules);
	if (this->soap_out(soap, tag?tag:"tan:CreateAnalyticsModules", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tan__CreateAnalyticsModules::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tan__CreateAnalyticsModules(soap, this, tag, type);
}

SOAP_FMAC3 _tan__CreateAnalyticsModules * SOAP_FMAC4 soap_get__tan__CreateAnalyticsModules(struct soap *soap, _tan__CreateAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__CreateAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tan__CreateAnalyticsModules * SOAP_FMAC2 soap_instantiate__tan__CreateAnalyticsModules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tan__CreateAnalyticsModules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tan__CreateAnalyticsModules, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tan__CreateAnalyticsModules);
		if (size)
			*size = sizeof(_tan__CreateAnalyticsModules);
		((_tan__CreateAnalyticsModules*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tan__CreateAnalyticsModules[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tan__CreateAnalyticsModules);
		for (int i = 0; i < n; i++)
			((_tan__CreateAnalyticsModules*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tan__CreateAnalyticsModules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tan__CreateAnalyticsModules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tan__CreateAnalyticsModules %p -> %p\n", q, p));
	*(_tan__CreateAnalyticsModules*)p = *(_tan__CreateAnalyticsModules*)q;
}

void _tan__GetSupportedAnalyticsModulesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tan__GetSupportedAnalyticsModulesResponse::SupportedAnalyticsModules = NULL;
	/* transient soap skipped */
}

void _tan__GetSupportedAnalyticsModulesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__SupportedAnalyticsModules(soap, &this->_tan__GetSupportedAnalyticsModulesResponse::SupportedAnalyticsModules);
	/* transient soap skipped */
}

int _tan__GetSupportedAnalyticsModulesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tan__GetSupportedAnalyticsModulesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, const _tan__GetSupportedAnalyticsModulesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse), type))
		return soap->error;
	if (a->SupportedAnalyticsModules)
		soap_element_result(soap, "tan:SupportedAnalyticsModules");
	if (a->_tan__GetSupportedAnalyticsModulesResponse::SupportedAnalyticsModules)
	{	if (soap_out_PointerTott__SupportedAnalyticsModules(soap, "tan:SupportedAnalyticsModules", -1, &a->_tan__GetSupportedAnalyticsModulesResponse::SupportedAnalyticsModules, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tan:SupportedAnalyticsModules"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tan__GetSupportedAnalyticsModulesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tan__GetSupportedAnalyticsModulesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tan__GetSupportedAnalyticsModulesResponse * SOAP_FMAC4 soap_in__tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, const char *tag, _tan__GetSupportedAnalyticsModulesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tan__GetSupportedAnalyticsModulesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse, sizeof(_tan__GetSupportedAnalyticsModulesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tan__GetSupportedAnalyticsModulesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SupportedAnalyticsModules1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SupportedAnalyticsModules1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SupportedAnalyticsModules(soap, "tan:SupportedAnalyticsModules", &(a->_tan__GetSupportedAnalyticsModulesResponse::SupportedAnalyticsModules), "tt:SupportedAnalyticsModules"))
				{	soap_flag_SupportedAnalyticsModules1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tan:SupportedAnalyticsModules");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tan__GetSupportedAnalyticsModulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse, 0, sizeof(_tan__GetSupportedAnalyticsModulesResponse), 0, soap_copy__tan__GetSupportedAnalyticsModulesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SupportedAnalyticsModules1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tan__GetSupportedAnalyticsModulesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse);
	if (this->soap_out(soap, tag?tag:"tan:GetSupportedAnalyticsModulesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tan__GetSupportedAnalyticsModulesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tan__GetSupportedAnalyticsModulesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tan__GetSupportedAnalyticsModulesResponse * SOAP_FMAC4 soap_get__tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, _tan__GetSupportedAnalyticsModulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetSupportedAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tan__GetSupportedAnalyticsModulesResponse * SOAP_FMAC2 soap_instantiate__tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tan__GetSupportedAnalyticsModulesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tan__GetSupportedAnalyticsModulesResponse);
		if (size)
			*size = sizeof(_tan__GetSupportedAnalyticsModulesResponse);
		((_tan__GetSupportedAnalyticsModulesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tan__GetSupportedAnalyticsModulesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tan__GetSupportedAnalyticsModulesResponse);
		for (int i = 0; i < n; i++)
			((_tan__GetSupportedAnalyticsModulesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tan__GetSupportedAnalyticsModulesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tan__GetSupportedAnalyticsModulesResponse %p -> %p\n", q, p));
	*(_tan__GetSupportedAnalyticsModulesResponse*)p = *(_tan__GetSupportedAnalyticsModulesResponse*)q;
}

void _tan__GetSupportedAnalyticsModules::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tan__GetSupportedAnalyticsModules::ConfigurationToken);
	/* transient soap skipped */
}

void _tan__GetSupportedAnalyticsModules::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_tan__GetSupportedAnalyticsModules::ConfigurationToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tan__GetSupportedAnalyticsModules::ConfigurationToken);
	/* transient soap skipped */
}

int _tan__GetSupportedAnalyticsModules::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tan__GetSupportedAnalyticsModules(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetSupportedAnalyticsModules(struct soap *soap, const char *tag, int id, const _tan__GetSupportedAnalyticsModules *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetSupportedAnalyticsModules), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, &(a->_tan__GetSupportedAnalyticsModules::ConfigurationToken), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tan__GetSupportedAnalyticsModules::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tan__GetSupportedAnalyticsModules(soap, tag, this, type);
}

SOAP_FMAC3 _tan__GetSupportedAnalyticsModules * SOAP_FMAC4 soap_in__tan__GetSupportedAnalyticsModules(struct soap *soap, const char *tag, _tan__GetSupportedAnalyticsModules *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tan__GetSupportedAnalyticsModules *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetSupportedAnalyticsModules, sizeof(_tan__GetSupportedAnalyticsModules), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tan__GetSupportedAnalyticsModules)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tan__GetSupportedAnalyticsModules *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ConfigurationToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", &(a->_tan__GetSupportedAnalyticsModules::ConfigurationToken), "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tan__GetSupportedAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetSupportedAnalyticsModules, 0, sizeof(_tan__GetSupportedAnalyticsModules), 0, soap_copy__tan__GetSupportedAnalyticsModules);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tan__GetSupportedAnalyticsModules::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tan__GetSupportedAnalyticsModules);
	if (this->soap_out(soap, tag?tag:"tan:GetSupportedAnalyticsModules", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tan__GetSupportedAnalyticsModules::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tan__GetSupportedAnalyticsModules(soap, this, tag, type);
}

SOAP_FMAC3 _tan__GetSupportedAnalyticsModules * SOAP_FMAC4 soap_get__tan__GetSupportedAnalyticsModules(struct soap *soap, _tan__GetSupportedAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetSupportedAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tan__GetSupportedAnalyticsModules * SOAP_FMAC2 soap_instantiate__tan__GetSupportedAnalyticsModules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tan__GetSupportedAnalyticsModules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tan__GetSupportedAnalyticsModules, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tan__GetSupportedAnalyticsModules);
		if (size)
			*size = sizeof(_tan__GetSupportedAnalyticsModules);
		((_tan__GetSupportedAnalyticsModules*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tan__GetSupportedAnalyticsModules[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tan__GetSupportedAnalyticsModules);
		for (int i = 0; i < n; i++)
			((_tan__GetSupportedAnalyticsModules*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tan__GetSupportedAnalyticsModules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tan__GetSupportedAnalyticsModules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tan__GetSupportedAnalyticsModules %p -> %p\n", q, p));
	*(_tan__GetSupportedAnalyticsModules*)p = *(_tan__GetSupportedAnalyticsModules*)q;
}

void _tan__GetRulesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Config(soap, &this->_tan__GetRulesResponse::Rule);
	/* transient soap skipped */
}

void _tan__GetRulesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTott__Config(soap, &this->_tan__GetRulesResponse::Rule);
	/* transient soap skipped */
}

int _tan__GetRulesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tan__GetRulesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetRulesResponse(struct soap *soap, const char *tag, int id, const _tan__GetRulesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetRulesResponse), type))
		return soap->error;
	soap_element_result(soap, "tan:Rule");
	if (soap_out_std__vectorTemplateOfPointerTott__Config(soap, "tan:Rule", -1, &(a->_tan__GetRulesResponse::Rule), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tan__GetRulesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tan__GetRulesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tan__GetRulesResponse * SOAP_FMAC4 soap_in__tan__GetRulesResponse(struct soap *soap, const char *tag, _tan__GetRulesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tan__GetRulesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetRulesResponse, sizeof(_tan__GetRulesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tan__GetRulesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tan__GetRulesResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Config(soap, "tan:Rule", &(a->_tan__GetRulesResponse::Rule), "tt:Config"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "tan:Rule");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tan__GetRulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetRulesResponse, 0, sizeof(_tan__GetRulesResponse), 0, soap_copy__tan__GetRulesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tan__GetRulesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tan__GetRulesResponse);
	if (this->soap_out(soap, tag?tag:"tan:GetRulesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tan__GetRulesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tan__GetRulesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tan__GetRulesResponse * SOAP_FMAC4 soap_get__tan__GetRulesResponse(struct soap *soap, _tan__GetRulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tan__GetRulesResponse * SOAP_FMAC2 soap_instantiate__tan__GetRulesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tan__GetRulesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tan__GetRulesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tan__GetRulesResponse);
		if (size)
			*size = sizeof(_tan__GetRulesResponse);
		((_tan__GetRulesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tan__GetRulesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tan__GetRulesResponse);
		for (int i = 0; i < n; i++)
			((_tan__GetRulesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tan__GetRulesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tan__GetRulesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tan__GetRulesResponse %p -> %p\n", q, p));
	*(_tan__GetRulesResponse*)p = *(_tan__GetRulesResponse*)q;
}

void _tan__GetRules::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tan__GetRules::ConfigurationToken);
	/* transient soap skipped */
}

void _tan__GetRules::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_tan__GetRules::ConfigurationToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tan__GetRules::ConfigurationToken);
	/* transient soap skipped */
}

int _tan__GetRules::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tan__GetRules(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetRules(struct soap *soap, const char *tag, int id, const _tan__GetRules *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetRules), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, &(a->_tan__GetRules::ConfigurationToken), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tan__GetRules::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tan__GetRules(soap, tag, this, type);
}

SOAP_FMAC3 _tan__GetRules * SOAP_FMAC4 soap_in__tan__GetRules(struct soap *soap, const char *tag, _tan__GetRules *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tan__GetRules *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetRules, sizeof(_tan__GetRules), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tan__GetRules)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tan__GetRules *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ConfigurationToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", &(a->_tan__GetRules::ConfigurationToken), "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tan__GetRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetRules, 0, sizeof(_tan__GetRules), 0, soap_copy__tan__GetRules);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tan__GetRules::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tan__GetRules);
	if (this->soap_out(soap, tag?tag:"tan:GetRules", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tan__GetRules::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tan__GetRules(soap, this, tag, type);
}

SOAP_FMAC3 _tan__GetRules * SOAP_FMAC4 soap_get__tan__GetRules(struct soap *soap, _tan__GetRules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tan__GetRules * SOAP_FMAC2 soap_instantiate__tan__GetRules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tan__GetRules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tan__GetRules, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tan__GetRules);
		if (size)
			*size = sizeof(_tan__GetRules);
		((_tan__GetRules*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tan__GetRules[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tan__GetRules);
		for (int i = 0; i < n; i++)
			((_tan__GetRules*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tan__GetRules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tan__GetRules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tan__GetRules %p -> %p\n", q, p));
	*(_tan__GetRules*)p = *(_tan__GetRules*)q;
}

void _tan__ModifyRulesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tan__ModifyRulesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _tan__ModifyRulesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tan__ModifyRulesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__ModifyRulesResponse(struct soap *soap, const char *tag, int id, const _tan__ModifyRulesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__ModifyRulesResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tan__ModifyRulesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tan__ModifyRulesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tan__ModifyRulesResponse * SOAP_FMAC4 soap_in__tan__ModifyRulesResponse(struct soap *soap, const char *tag, _tan__ModifyRulesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tan__ModifyRulesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tan__ModifyRulesResponse, sizeof(_tan__ModifyRulesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tan__ModifyRulesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tan__ModifyRulesResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tan__ModifyRulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__ModifyRulesResponse, 0, sizeof(_tan__ModifyRulesResponse), 0, soap_copy__tan__ModifyRulesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tan__ModifyRulesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tan__ModifyRulesResponse);
	if (this->soap_out(soap, tag?tag:"tan:ModifyRulesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tan__ModifyRulesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tan__ModifyRulesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tan__ModifyRulesResponse * SOAP_FMAC4 soap_get__tan__ModifyRulesResponse(struct soap *soap, _tan__ModifyRulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__ModifyRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tan__ModifyRulesResponse * SOAP_FMAC2 soap_instantiate__tan__ModifyRulesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tan__ModifyRulesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tan__ModifyRulesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tan__ModifyRulesResponse);
		if (size)
			*size = sizeof(_tan__ModifyRulesResponse);
		((_tan__ModifyRulesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tan__ModifyRulesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tan__ModifyRulesResponse);
		for (int i = 0; i < n; i++)
			((_tan__ModifyRulesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tan__ModifyRulesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tan__ModifyRulesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tan__ModifyRulesResponse %p -> %p\n", q, p));
	*(_tan__ModifyRulesResponse*)p = *(_tan__ModifyRulesResponse*)q;
}

void _tan__ModifyRules::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tan__ModifyRules::ConfigurationToken);
	soap_default_std__vectorTemplateOfPointerTott__Config(soap, &this->_tan__ModifyRules::Rule);
	/* transient soap skipped */
}

void _tan__ModifyRules::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_tan__ModifyRules::ConfigurationToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tan__ModifyRules::ConfigurationToken);
	soap_serialize_std__vectorTemplateOfPointerTott__Config(soap, &this->_tan__ModifyRules::Rule);
	/* transient soap skipped */
}

int _tan__ModifyRules::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tan__ModifyRules(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__ModifyRules(struct soap *soap, const char *tag, int id, const _tan__ModifyRules *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__ModifyRules), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, &(a->_tan__ModifyRules::ConfigurationToken), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Config(soap, "tan:Rule", -1, &(a->_tan__ModifyRules::Rule), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tan__ModifyRules::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tan__ModifyRules(soap, tag, this, type);
}

SOAP_FMAC3 _tan__ModifyRules * SOAP_FMAC4 soap_in__tan__ModifyRules(struct soap *soap, const char *tag, _tan__ModifyRules *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tan__ModifyRules *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tan__ModifyRules, sizeof(_tan__ModifyRules), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tan__ModifyRules)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tan__ModifyRules *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ConfigurationToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", &(a->_tan__ModifyRules::ConfigurationToken), "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Config(soap, "tan:Rule", &(a->_tan__ModifyRules::Rule), "tt:Config"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tan__ModifyRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__ModifyRules, 0, sizeof(_tan__ModifyRules), 0, soap_copy__tan__ModifyRules);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken1 > 0 || a->_tan__ModifyRules::Rule.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tan__ModifyRules::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tan__ModifyRules);
	if (this->soap_out(soap, tag?tag:"tan:ModifyRules", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tan__ModifyRules::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tan__ModifyRules(soap, this, tag, type);
}

SOAP_FMAC3 _tan__ModifyRules * SOAP_FMAC4 soap_get__tan__ModifyRules(struct soap *soap, _tan__ModifyRules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__ModifyRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tan__ModifyRules * SOAP_FMAC2 soap_instantiate__tan__ModifyRules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tan__ModifyRules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tan__ModifyRules, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tan__ModifyRules);
		if (size)
			*size = sizeof(_tan__ModifyRules);
		((_tan__ModifyRules*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tan__ModifyRules[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tan__ModifyRules);
		for (int i = 0; i < n; i++)
			((_tan__ModifyRules*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tan__ModifyRules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tan__ModifyRules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tan__ModifyRules %p -> %p\n", q, p));
	*(_tan__ModifyRules*)p = *(_tan__ModifyRules*)q;
}

void _tan__DeleteRulesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tan__DeleteRulesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _tan__DeleteRulesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tan__DeleteRulesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__DeleteRulesResponse(struct soap *soap, const char *tag, int id, const _tan__DeleteRulesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__DeleteRulesResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tan__DeleteRulesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tan__DeleteRulesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tan__DeleteRulesResponse * SOAP_FMAC4 soap_in__tan__DeleteRulesResponse(struct soap *soap, const char *tag, _tan__DeleteRulesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tan__DeleteRulesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tan__DeleteRulesResponse, sizeof(_tan__DeleteRulesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tan__DeleteRulesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tan__DeleteRulesResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tan__DeleteRulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__DeleteRulesResponse, 0, sizeof(_tan__DeleteRulesResponse), 0, soap_copy__tan__DeleteRulesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tan__DeleteRulesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tan__DeleteRulesResponse);
	if (this->soap_out(soap, tag?tag:"tan:DeleteRulesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tan__DeleteRulesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tan__DeleteRulesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tan__DeleteRulesResponse * SOAP_FMAC4 soap_get__tan__DeleteRulesResponse(struct soap *soap, _tan__DeleteRulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__DeleteRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tan__DeleteRulesResponse * SOAP_FMAC2 soap_instantiate__tan__DeleteRulesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tan__DeleteRulesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tan__DeleteRulesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tan__DeleteRulesResponse);
		if (size)
			*size = sizeof(_tan__DeleteRulesResponse);
		((_tan__DeleteRulesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tan__DeleteRulesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tan__DeleteRulesResponse);
		for (int i = 0; i < n; i++)
			((_tan__DeleteRulesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tan__DeleteRulesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tan__DeleteRulesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tan__DeleteRulesResponse %p -> %p\n", q, p));
	*(_tan__DeleteRulesResponse*)p = *(_tan__DeleteRulesResponse*)q;
}

void _tan__DeleteRules::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tan__DeleteRules::ConfigurationToken);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->_tan__DeleteRules::RuleName);
	/* transient soap skipped */
}

void _tan__DeleteRules::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_tan__DeleteRules::ConfigurationToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tan__DeleteRules::ConfigurationToken);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->_tan__DeleteRules::RuleName);
	/* transient soap skipped */
}

int _tan__DeleteRules::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tan__DeleteRules(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__DeleteRules(struct soap *soap, const char *tag, int id, const _tan__DeleteRules *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__DeleteRules), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, &(a->_tan__DeleteRules::ConfigurationToken), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tan:RuleName", -1, &(a->_tan__DeleteRules::RuleName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tan__DeleteRules::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tan__DeleteRules(soap, tag, this, type);
}

SOAP_FMAC3 _tan__DeleteRules * SOAP_FMAC4 soap_in__tan__DeleteRules(struct soap *soap, const char *tag, _tan__DeleteRules *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tan__DeleteRules *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tan__DeleteRules, sizeof(_tan__DeleteRules), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tan__DeleteRules)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tan__DeleteRules *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ConfigurationToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", &(a->_tan__DeleteRules::ConfigurationToken), "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "tan:RuleName", &(a->_tan__DeleteRules::RuleName), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tan__DeleteRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__DeleteRules, 0, sizeof(_tan__DeleteRules), 0, soap_copy__tan__DeleteRules);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken1 > 0 || a->_tan__DeleteRules::RuleName.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tan__DeleteRules::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tan__DeleteRules);
	if (this->soap_out(soap, tag?tag:"tan:DeleteRules", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tan__DeleteRules::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tan__DeleteRules(soap, this, tag, type);
}

SOAP_FMAC3 _tan__DeleteRules * SOAP_FMAC4 soap_get__tan__DeleteRules(struct soap *soap, _tan__DeleteRules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__DeleteRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tan__DeleteRules * SOAP_FMAC2 soap_instantiate__tan__DeleteRules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tan__DeleteRules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tan__DeleteRules, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tan__DeleteRules);
		if (size)
			*size = sizeof(_tan__DeleteRules);
		((_tan__DeleteRules*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tan__DeleteRules[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tan__DeleteRules);
		for (int i = 0; i < n; i++)
			((_tan__DeleteRules*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tan__DeleteRules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tan__DeleteRules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tan__DeleteRules %p -> %p\n", q, p));
	*(_tan__DeleteRules*)p = *(_tan__DeleteRules*)q;
}

void _tan__CreateRulesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tan__CreateRulesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _tan__CreateRulesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tan__CreateRulesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__CreateRulesResponse(struct soap *soap, const char *tag, int id, const _tan__CreateRulesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__CreateRulesResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tan__CreateRulesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tan__CreateRulesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tan__CreateRulesResponse * SOAP_FMAC4 soap_in__tan__CreateRulesResponse(struct soap *soap, const char *tag, _tan__CreateRulesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tan__CreateRulesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tan__CreateRulesResponse, sizeof(_tan__CreateRulesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tan__CreateRulesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tan__CreateRulesResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tan__CreateRulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__CreateRulesResponse, 0, sizeof(_tan__CreateRulesResponse), 0, soap_copy__tan__CreateRulesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tan__CreateRulesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tan__CreateRulesResponse);
	if (this->soap_out(soap, tag?tag:"tan:CreateRulesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tan__CreateRulesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tan__CreateRulesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tan__CreateRulesResponse * SOAP_FMAC4 soap_get__tan__CreateRulesResponse(struct soap *soap, _tan__CreateRulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__CreateRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tan__CreateRulesResponse * SOAP_FMAC2 soap_instantiate__tan__CreateRulesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tan__CreateRulesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tan__CreateRulesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tan__CreateRulesResponse);
		if (size)
			*size = sizeof(_tan__CreateRulesResponse);
		((_tan__CreateRulesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tan__CreateRulesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tan__CreateRulesResponse);
		for (int i = 0; i < n; i++)
			((_tan__CreateRulesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tan__CreateRulesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tan__CreateRulesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tan__CreateRulesResponse %p -> %p\n", q, p));
	*(_tan__CreateRulesResponse*)p = *(_tan__CreateRulesResponse*)q;
}

void _tan__CreateRules::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tan__CreateRules::ConfigurationToken);
	soap_default_std__vectorTemplateOfPointerTott__Config(soap, &this->_tan__CreateRules::Rule);
	/* transient soap skipped */
}

void _tan__CreateRules::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_tan__CreateRules::ConfigurationToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tan__CreateRules::ConfigurationToken);
	soap_serialize_std__vectorTemplateOfPointerTott__Config(soap, &this->_tan__CreateRules::Rule);
	/* transient soap skipped */
}

int _tan__CreateRules::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tan__CreateRules(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__CreateRules(struct soap *soap, const char *tag, int id, const _tan__CreateRules *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__CreateRules), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, &(a->_tan__CreateRules::ConfigurationToken), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Config(soap, "tan:Rule", -1, &(a->_tan__CreateRules::Rule), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tan__CreateRules::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tan__CreateRules(soap, tag, this, type);
}

SOAP_FMAC3 _tan__CreateRules * SOAP_FMAC4 soap_in__tan__CreateRules(struct soap *soap, const char *tag, _tan__CreateRules *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tan__CreateRules *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tan__CreateRules, sizeof(_tan__CreateRules), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tan__CreateRules)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tan__CreateRules *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ConfigurationToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", &(a->_tan__CreateRules::ConfigurationToken), "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTott__Config(soap, "tan:Rule", &(a->_tan__CreateRules::Rule), "tt:Config"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tan__CreateRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__CreateRules, 0, sizeof(_tan__CreateRules), 0, soap_copy__tan__CreateRules);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken1 > 0 || a->_tan__CreateRules::Rule.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tan__CreateRules::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tan__CreateRules);
	if (this->soap_out(soap, tag?tag:"tan:CreateRules", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tan__CreateRules::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tan__CreateRules(soap, this, tag, type);
}

SOAP_FMAC3 _tan__CreateRules * SOAP_FMAC4 soap_get__tan__CreateRules(struct soap *soap, _tan__CreateRules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__CreateRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tan__CreateRules * SOAP_FMAC2 soap_instantiate__tan__CreateRules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tan__CreateRules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tan__CreateRules, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tan__CreateRules);
		if (size)
			*size = sizeof(_tan__CreateRules);
		((_tan__CreateRules*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tan__CreateRules[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tan__CreateRules);
		for (int i = 0; i < n; i++)
			((_tan__CreateRules*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tan__CreateRules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tan__CreateRules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tan__CreateRules %p -> %p\n", q, p));
	*(_tan__CreateRules*)p = *(_tan__CreateRules*)q;
}

void _tan__GetSupportedRulesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tan__GetSupportedRulesResponse::SupportedRules = NULL;
	/* transient soap skipped */
}

void _tan__GetSupportedRulesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__SupportedRules(soap, &this->_tan__GetSupportedRulesResponse::SupportedRules);
	/* transient soap skipped */
}

int _tan__GetSupportedRulesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tan__GetSupportedRulesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetSupportedRulesResponse(struct soap *soap, const char *tag, int id, const _tan__GetSupportedRulesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetSupportedRulesResponse), type))
		return soap->error;
	if (a->SupportedRules)
		soap_element_result(soap, "tan:SupportedRules");
	if (a->_tan__GetSupportedRulesResponse::SupportedRules)
	{	if (soap_out_PointerTott__SupportedRules(soap, "tan:SupportedRules", -1, &a->_tan__GetSupportedRulesResponse::SupportedRules, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tan:SupportedRules"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tan__GetSupportedRulesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tan__GetSupportedRulesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tan__GetSupportedRulesResponse * SOAP_FMAC4 soap_in__tan__GetSupportedRulesResponse(struct soap *soap, const char *tag, _tan__GetSupportedRulesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tan__GetSupportedRulesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetSupportedRulesResponse, sizeof(_tan__GetSupportedRulesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tan__GetSupportedRulesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tan__GetSupportedRulesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SupportedRules1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SupportedRules1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SupportedRules(soap, "tan:SupportedRules", &(a->_tan__GetSupportedRulesResponse::SupportedRules), "tt:SupportedRules"))
				{	soap_flag_SupportedRules1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tan:SupportedRules");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tan__GetSupportedRulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetSupportedRulesResponse, 0, sizeof(_tan__GetSupportedRulesResponse), 0, soap_copy__tan__GetSupportedRulesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SupportedRules1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tan__GetSupportedRulesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tan__GetSupportedRulesResponse);
	if (this->soap_out(soap, tag?tag:"tan:GetSupportedRulesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tan__GetSupportedRulesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tan__GetSupportedRulesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tan__GetSupportedRulesResponse * SOAP_FMAC4 soap_get__tan__GetSupportedRulesResponse(struct soap *soap, _tan__GetSupportedRulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetSupportedRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tan__GetSupportedRulesResponse * SOAP_FMAC2 soap_instantiate__tan__GetSupportedRulesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tan__GetSupportedRulesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tan__GetSupportedRulesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tan__GetSupportedRulesResponse);
		if (size)
			*size = sizeof(_tan__GetSupportedRulesResponse);
		((_tan__GetSupportedRulesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tan__GetSupportedRulesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tan__GetSupportedRulesResponse);
		for (int i = 0; i < n; i++)
			((_tan__GetSupportedRulesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tan__GetSupportedRulesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tan__GetSupportedRulesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tan__GetSupportedRulesResponse %p -> %p\n", q, p));
	*(_tan__GetSupportedRulesResponse*)p = *(_tan__GetSupportedRulesResponse*)q;
}

void _tan__GetSupportedRules::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tan__GetSupportedRules::ConfigurationToken);
	/* transient soap skipped */
}

void _tan__GetSupportedRules::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_tan__GetSupportedRules::ConfigurationToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tan__GetSupportedRules::ConfigurationToken);
	/* transient soap skipped */
}

int _tan__GetSupportedRules::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tan__GetSupportedRules(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetSupportedRules(struct soap *soap, const char *tag, int id, const _tan__GetSupportedRules *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetSupportedRules), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, &(a->_tan__GetSupportedRules::ConfigurationToken), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tan__GetSupportedRules::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tan__GetSupportedRules(soap, tag, this, type);
}

SOAP_FMAC3 _tan__GetSupportedRules * SOAP_FMAC4 soap_in__tan__GetSupportedRules(struct soap *soap, const char *tag, _tan__GetSupportedRules *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tan__GetSupportedRules *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetSupportedRules, sizeof(_tan__GetSupportedRules), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tan__GetSupportedRules)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tan__GetSupportedRules *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ConfigurationToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", &(a->_tan__GetSupportedRules::ConfigurationToken), "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tan__GetSupportedRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetSupportedRules, 0, sizeof(_tan__GetSupportedRules), 0, soap_copy__tan__GetSupportedRules);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tan__GetSupportedRules::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tan__GetSupportedRules);
	if (this->soap_out(soap, tag?tag:"tan:GetSupportedRules", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tan__GetSupportedRules::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tan__GetSupportedRules(soap, this, tag, type);
}

SOAP_FMAC3 _tan__GetSupportedRules * SOAP_FMAC4 soap_get__tan__GetSupportedRules(struct soap *soap, _tan__GetSupportedRules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetSupportedRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tan__GetSupportedRules * SOAP_FMAC2 soap_instantiate__tan__GetSupportedRules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tan__GetSupportedRules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tan__GetSupportedRules, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tan__GetSupportedRules);
		if (size)
			*size = sizeof(_tan__GetSupportedRules);
		((_tan__GetSupportedRules*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_tan__GetSupportedRules[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_tan__GetSupportedRules);
		for (int i = 0; i < n; i++)
			((_tan__GetSupportedRules*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_tan__GetSupportedRules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tan__GetSupportedRules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tan__GetSupportedRules %p -> %p\n", q, p));
	*(_tan__GetSupportedRules*)p = *(_tan__GetSupportedRules*)q;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__token), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__token(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__token, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__token, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__token, 0, sizeof(std::string), 0, soap_copy_xsd__token);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__token);
	if (soap_out_xsd__token(soap, tag?tag:"xsd:token", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__nonNegativeInteger), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__nonNegativeInteger, 0, sizeof(std::string), 0, soap_copy_xsd__nonNegativeInteger);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__nonNegativeInteger);
	if (soap_out_xsd__nonNegativeInteger(soap, tag?tag:"xsd:nonNegativeInteger", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__integer), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__integer, 0, sizeof(std::string), 0, soap_copy_xsd__integer);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__integer);
	if (soap_out_xsd__integer(soap, tag?tag:"xsd:integer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if (this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (this->soap_out(soap, tag?tag:"xsd:base64Binary", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__base64Binary);
		if (size)
			*size = sizeof(xsd__base64Binary);
		((xsd__base64Binary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(xsd__base64Binary[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__base64Binary);
		for (int i = 0; i < n; i++)
			((xsd__base64Binary*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__base64Binary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__anyURI, 0, sizeof(std::string), 0, soap_copy_xsd__anyURI);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag?tag:"xsd:anyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anySimpleType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anySimpleType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anySimpleType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anySimpleType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anySimpleType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__anySimpleType, 0, sizeof(std::string), 0, soap_copy_xsd__anySimpleType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anySimpleType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anySimpleType);
	if (soap_out_xsd__anySimpleType(soap, tag?tag:"xsd:anySimpleType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anySimpleType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anySimpleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, const xsd__QName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__QName), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__QName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 2, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__QName, 0, sizeof(std::string), 0, soap_copy_xsd__QName);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap *soap, const xsd__QName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__QName);
	if (soap_out_xsd__QName(soap, tag?tag:"xsd:QName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__QName * SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, xsd__QName *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__QName * SOAP_FMAC2 soap_instantiate_xsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__QName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__QName);
		if (size)
			*size = sizeof(xsd__QName);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(xsd__QName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__QName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__QName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__QName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__QName %p -> %p\n", q, p));
	*(xsd__QName*)p = *(xsd__QName*)q;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__NCName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__NCName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NCName, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NCName, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__NCName, 0, sizeof(std::string), 0, soap_copy_xsd__NCName);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__NCName);
	if (soap_out_xsd__NCName(soap, tag?tag:"xsd:NCName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__ModifyAnalyticsModules(struct soap *soap, struct __ns2__ModifyAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__ModifyAnalyticsModules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__ModifyAnalyticsModules(struct soap *soap, const struct __ns2__ModifyAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tan__ModifyAnalyticsModules(soap, &a->tan__ModifyAnalyticsModules);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__ModifyAnalyticsModules(struct soap *soap, const char *tag, int id, const struct __ns2__ModifyAnalyticsModules *a, const char *type)
{
	if (soap_out_PointerTo_tan__ModifyAnalyticsModules(soap, "tan:ModifyAnalyticsModules", -1, &a->tan__ModifyAnalyticsModules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__ModifyAnalyticsModules * SOAP_FMAC4 soap_in___ns2__ModifyAnalyticsModules(struct soap *soap, const char *tag, struct __ns2__ModifyAnalyticsModules *a, const char *type)
{
	size_t soap_flag_tan__ModifyAnalyticsModules = 1;
	short soap_flag;
	a = (struct __ns2__ModifyAnalyticsModules *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__ModifyAnalyticsModules, sizeof(struct __ns2__ModifyAnalyticsModules), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__ModifyAnalyticsModules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__ModifyAnalyticsModules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tan__ModifyAnalyticsModules(soap, "tan:ModifyAnalyticsModules", &a->tan__ModifyAnalyticsModules, ""))
				{	soap_flag_tan__ModifyAnalyticsModules--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__ModifyAnalyticsModules(struct soap *soap, const struct __ns2__ModifyAnalyticsModules *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__ModifyAnalyticsModules(soap, tag?tag:"-ns2:ModifyAnalyticsModules", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__ModifyAnalyticsModules * SOAP_FMAC4 soap_get___ns2__ModifyAnalyticsModules(struct soap *soap, struct __ns2__ModifyAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__ModifyAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__ModifyAnalyticsModules * SOAP_FMAC2 soap_instantiate___ns2__ModifyAnalyticsModules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__ModifyAnalyticsModules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__ModifyAnalyticsModules, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__ModifyAnalyticsModules);
		if (size)
			*size = sizeof(struct __ns2__ModifyAnalyticsModules);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__ModifyAnalyticsModules[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__ModifyAnalyticsModules);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__ModifyAnalyticsModules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__ModifyAnalyticsModules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__ModifyAnalyticsModules %p -> %p\n", q, p));
	*(struct __ns2__ModifyAnalyticsModules*)p = *(struct __ns2__ModifyAnalyticsModules*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetAnalyticsModules(struct soap *soap, struct __ns2__GetAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__GetAnalyticsModules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetAnalyticsModules(struct soap *soap, const struct __ns2__GetAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tan__GetAnalyticsModules(soap, &a->tan__GetAnalyticsModules);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__GetAnalyticsModules(struct soap *soap, const char *tag, int id, const struct __ns2__GetAnalyticsModules *a, const char *type)
{
	if (soap_out_PointerTo_tan__GetAnalyticsModules(soap, "tan:GetAnalyticsModules", -1, &a->tan__GetAnalyticsModules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetAnalyticsModules * SOAP_FMAC4 soap_in___ns2__GetAnalyticsModules(struct soap *soap, const char *tag, struct __ns2__GetAnalyticsModules *a, const char *type)
{
	size_t soap_flag_tan__GetAnalyticsModules = 1;
	short soap_flag;
	a = (struct __ns2__GetAnalyticsModules *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetAnalyticsModules, sizeof(struct __ns2__GetAnalyticsModules), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__GetAnalyticsModules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__GetAnalyticsModules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tan__GetAnalyticsModules(soap, "tan:GetAnalyticsModules", &a->tan__GetAnalyticsModules, ""))
				{	soap_flag_tan__GetAnalyticsModules--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetAnalyticsModules(struct soap *soap, const struct __ns2__GetAnalyticsModules *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__GetAnalyticsModules(soap, tag?tag:"-ns2:GetAnalyticsModules", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetAnalyticsModules * SOAP_FMAC4 soap_get___ns2__GetAnalyticsModules(struct soap *soap, struct __ns2__GetAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__GetAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetAnalyticsModules * SOAP_FMAC2 soap_instantiate___ns2__GetAnalyticsModules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetAnalyticsModules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetAnalyticsModules, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__GetAnalyticsModules);
		if (size)
			*size = sizeof(struct __ns2__GetAnalyticsModules);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__GetAnalyticsModules[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__GetAnalyticsModules);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GetAnalyticsModules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetAnalyticsModules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetAnalyticsModules %p -> %p\n", q, p));
	*(struct __ns2__GetAnalyticsModules*)p = *(struct __ns2__GetAnalyticsModules*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__DeleteAnalyticsModules(struct soap *soap, struct __ns2__DeleteAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__DeleteAnalyticsModules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__DeleteAnalyticsModules(struct soap *soap, const struct __ns2__DeleteAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tan__DeleteAnalyticsModules(soap, &a->tan__DeleteAnalyticsModules);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__DeleteAnalyticsModules(struct soap *soap, const char *tag, int id, const struct __ns2__DeleteAnalyticsModules *a, const char *type)
{
	if (soap_out_PointerTo_tan__DeleteAnalyticsModules(soap, "tan:DeleteAnalyticsModules", -1, &a->tan__DeleteAnalyticsModules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__DeleteAnalyticsModules * SOAP_FMAC4 soap_in___ns2__DeleteAnalyticsModules(struct soap *soap, const char *tag, struct __ns2__DeleteAnalyticsModules *a, const char *type)
{
	size_t soap_flag_tan__DeleteAnalyticsModules = 1;
	short soap_flag;
	a = (struct __ns2__DeleteAnalyticsModules *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__DeleteAnalyticsModules, sizeof(struct __ns2__DeleteAnalyticsModules), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__DeleteAnalyticsModules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__DeleteAnalyticsModules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tan__DeleteAnalyticsModules(soap, "tan:DeleteAnalyticsModules", &a->tan__DeleteAnalyticsModules, ""))
				{	soap_flag_tan__DeleteAnalyticsModules--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__DeleteAnalyticsModules(struct soap *soap, const struct __ns2__DeleteAnalyticsModules *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__DeleteAnalyticsModules(soap, tag?tag:"-ns2:DeleteAnalyticsModules", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__DeleteAnalyticsModules * SOAP_FMAC4 soap_get___ns2__DeleteAnalyticsModules(struct soap *soap, struct __ns2__DeleteAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__DeleteAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__DeleteAnalyticsModules * SOAP_FMAC2 soap_instantiate___ns2__DeleteAnalyticsModules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__DeleteAnalyticsModules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__DeleteAnalyticsModules, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__DeleteAnalyticsModules);
		if (size)
			*size = sizeof(struct __ns2__DeleteAnalyticsModules);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__DeleteAnalyticsModules[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__DeleteAnalyticsModules);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__DeleteAnalyticsModules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__DeleteAnalyticsModules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__DeleteAnalyticsModules %p -> %p\n", q, p));
	*(struct __ns2__DeleteAnalyticsModules*)p = *(struct __ns2__DeleteAnalyticsModules*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__CreateAnalyticsModules(struct soap *soap, struct __ns2__CreateAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__CreateAnalyticsModules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__CreateAnalyticsModules(struct soap *soap, const struct __ns2__CreateAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tan__CreateAnalyticsModules(soap, &a->tan__CreateAnalyticsModules);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__CreateAnalyticsModules(struct soap *soap, const char *tag, int id, const struct __ns2__CreateAnalyticsModules *a, const char *type)
{
	if (soap_out_PointerTo_tan__CreateAnalyticsModules(soap, "tan:CreateAnalyticsModules", -1, &a->tan__CreateAnalyticsModules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__CreateAnalyticsModules * SOAP_FMAC4 soap_in___ns2__CreateAnalyticsModules(struct soap *soap, const char *tag, struct __ns2__CreateAnalyticsModules *a, const char *type)
{
	size_t soap_flag_tan__CreateAnalyticsModules = 1;
	short soap_flag;
	a = (struct __ns2__CreateAnalyticsModules *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__CreateAnalyticsModules, sizeof(struct __ns2__CreateAnalyticsModules), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__CreateAnalyticsModules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__CreateAnalyticsModules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tan__CreateAnalyticsModules(soap, "tan:CreateAnalyticsModules", &a->tan__CreateAnalyticsModules, ""))
				{	soap_flag_tan__CreateAnalyticsModules--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__CreateAnalyticsModules(struct soap *soap, const struct __ns2__CreateAnalyticsModules *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__CreateAnalyticsModules(soap, tag?tag:"-ns2:CreateAnalyticsModules", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__CreateAnalyticsModules * SOAP_FMAC4 soap_get___ns2__CreateAnalyticsModules(struct soap *soap, struct __ns2__CreateAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__CreateAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__CreateAnalyticsModules * SOAP_FMAC2 soap_instantiate___ns2__CreateAnalyticsModules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__CreateAnalyticsModules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__CreateAnalyticsModules, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__CreateAnalyticsModules);
		if (size)
			*size = sizeof(struct __ns2__CreateAnalyticsModules);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__CreateAnalyticsModules[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__CreateAnalyticsModules);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__CreateAnalyticsModules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__CreateAnalyticsModules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__CreateAnalyticsModules %p -> %p\n", q, p));
	*(struct __ns2__CreateAnalyticsModules*)p = *(struct __ns2__CreateAnalyticsModules*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetSupportedAnalyticsModules(struct soap *soap, struct __ns2__GetSupportedAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__GetSupportedAnalyticsModules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetSupportedAnalyticsModules(struct soap *soap, const struct __ns2__GetSupportedAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tan__GetSupportedAnalyticsModules(soap, &a->tan__GetSupportedAnalyticsModules);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__GetSupportedAnalyticsModules(struct soap *soap, const char *tag, int id, const struct __ns2__GetSupportedAnalyticsModules *a, const char *type)
{
	if (soap_out_PointerTo_tan__GetSupportedAnalyticsModules(soap, "tan:GetSupportedAnalyticsModules", -1, &a->tan__GetSupportedAnalyticsModules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetSupportedAnalyticsModules * SOAP_FMAC4 soap_in___ns2__GetSupportedAnalyticsModules(struct soap *soap, const char *tag, struct __ns2__GetSupportedAnalyticsModules *a, const char *type)
{
	size_t soap_flag_tan__GetSupportedAnalyticsModules = 1;
	short soap_flag;
	a = (struct __ns2__GetSupportedAnalyticsModules *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetSupportedAnalyticsModules, sizeof(struct __ns2__GetSupportedAnalyticsModules), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__GetSupportedAnalyticsModules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__GetSupportedAnalyticsModules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tan__GetSupportedAnalyticsModules(soap, "tan:GetSupportedAnalyticsModules", &a->tan__GetSupportedAnalyticsModules, ""))
				{	soap_flag_tan__GetSupportedAnalyticsModules--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetSupportedAnalyticsModules(struct soap *soap, const struct __ns2__GetSupportedAnalyticsModules *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__GetSupportedAnalyticsModules(soap, tag?tag:"-ns2:GetSupportedAnalyticsModules", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetSupportedAnalyticsModules * SOAP_FMAC4 soap_get___ns2__GetSupportedAnalyticsModules(struct soap *soap, struct __ns2__GetSupportedAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__GetSupportedAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetSupportedAnalyticsModules * SOAP_FMAC2 soap_instantiate___ns2__GetSupportedAnalyticsModules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetSupportedAnalyticsModules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetSupportedAnalyticsModules, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__GetSupportedAnalyticsModules);
		if (size)
			*size = sizeof(struct __ns2__GetSupportedAnalyticsModules);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__GetSupportedAnalyticsModules[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__GetSupportedAnalyticsModules);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__GetSupportedAnalyticsModules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetSupportedAnalyticsModules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetSupportedAnalyticsModules %p -> %p\n", q, p));
	*(struct __ns2__GetSupportedAnalyticsModules*)p = *(struct __ns2__GetSupportedAnalyticsModules*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ModifyRules(struct soap *soap, struct __ns1__ModifyRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__ModifyRules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ModifyRules(struct soap *soap, const struct __ns1__ModifyRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tan__ModifyRules(soap, &a->tan__ModifyRules);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ModifyRules(struct soap *soap, const char *tag, int id, const struct __ns1__ModifyRules *a, const char *type)
{
	if (soap_out_PointerTo_tan__ModifyRules(soap, "tan:ModifyRules", -1, &a->tan__ModifyRules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ModifyRules * SOAP_FMAC4 soap_in___ns1__ModifyRules(struct soap *soap, const char *tag, struct __ns1__ModifyRules *a, const char *type)
{
	size_t soap_flag_tan__ModifyRules = 1;
	short soap_flag;
	a = (struct __ns1__ModifyRules *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ModifyRules, sizeof(struct __ns1__ModifyRules), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ModifyRules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__ModifyRules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tan__ModifyRules(soap, "tan:ModifyRules", &a->tan__ModifyRules, ""))
				{	soap_flag_tan__ModifyRules--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ModifyRules(struct soap *soap, const struct __ns1__ModifyRules *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__ModifyRules(soap, tag?tag:"-ns1:ModifyRules", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ModifyRules * SOAP_FMAC4 soap_get___ns1__ModifyRules(struct soap *soap, struct __ns1__ModifyRules *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ModifyRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__ModifyRules * SOAP_FMAC2 soap_instantiate___ns1__ModifyRules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ModifyRules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__ModifyRules, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__ModifyRules);
		if (size)
			*size = sizeof(struct __ns1__ModifyRules);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__ModifyRules[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__ModifyRules);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__ModifyRules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__ModifyRules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__ModifyRules %p -> %p\n", q, p));
	*(struct __ns1__ModifyRules*)p = *(struct __ns1__ModifyRules*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRules(struct soap *soap, struct __ns1__GetRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__GetRules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRules(struct soap *soap, const struct __ns1__GetRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tan__GetRules(soap, &a->tan__GetRules);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetRules(struct soap *soap, const char *tag, int id, const struct __ns1__GetRules *a, const char *type)
{
	if (soap_out_PointerTo_tan__GetRules(soap, "tan:GetRules", -1, &a->tan__GetRules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRules * SOAP_FMAC4 soap_in___ns1__GetRules(struct soap *soap, const char *tag, struct __ns1__GetRules *a, const char *type)
{
	size_t soap_flag_tan__GetRules = 1;
	short soap_flag;
	a = (struct __ns1__GetRules *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetRules, sizeof(struct __ns1__GetRules), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetRules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__GetRules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tan__GetRules(soap, "tan:GetRules", &a->tan__GetRules, ""))
				{	soap_flag_tan__GetRules--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRules(struct soap *soap, const struct __ns1__GetRules *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetRules(soap, tag?tag:"-ns1:GetRules", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRules * SOAP_FMAC4 soap_get___ns1__GetRules(struct soap *soap, struct __ns1__GetRules *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetRules * SOAP_FMAC2 soap_instantiate___ns1__GetRules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetRules, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetRules);
		if (size)
			*size = sizeof(struct __ns1__GetRules);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetRules[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetRules);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetRules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetRules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetRules %p -> %p\n", q, p));
	*(struct __ns1__GetRules*)p = *(struct __ns1__GetRules*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DeleteRules(struct soap *soap, struct __ns1__DeleteRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__DeleteRules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DeleteRules(struct soap *soap, const struct __ns1__DeleteRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tan__DeleteRules(soap, &a->tan__DeleteRules);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DeleteRules(struct soap *soap, const char *tag, int id, const struct __ns1__DeleteRules *a, const char *type)
{
	if (soap_out_PointerTo_tan__DeleteRules(soap, "tan:DeleteRules", -1, &a->tan__DeleteRules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DeleteRules * SOAP_FMAC4 soap_in___ns1__DeleteRules(struct soap *soap, const char *tag, struct __ns1__DeleteRules *a, const char *type)
{
	size_t soap_flag_tan__DeleteRules = 1;
	short soap_flag;
	a = (struct __ns1__DeleteRules *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DeleteRules, sizeof(struct __ns1__DeleteRules), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DeleteRules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__DeleteRules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tan__DeleteRules(soap, "tan:DeleteRules", &a->tan__DeleteRules, ""))
				{	soap_flag_tan__DeleteRules--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DeleteRules(struct soap *soap, const struct __ns1__DeleteRules *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__DeleteRules(soap, tag?tag:"-ns1:DeleteRules", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DeleteRules * SOAP_FMAC4 soap_get___ns1__DeleteRules(struct soap *soap, struct __ns1__DeleteRules *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DeleteRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__DeleteRules * SOAP_FMAC2 soap_instantiate___ns1__DeleteRules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DeleteRules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__DeleteRules, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__DeleteRules);
		if (size)
			*size = sizeof(struct __ns1__DeleteRules);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__DeleteRules[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__DeleteRules);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__DeleteRules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__DeleteRules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__DeleteRules %p -> %p\n", q, p));
	*(struct __ns1__DeleteRules*)p = *(struct __ns1__DeleteRules*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CreateRules(struct soap *soap, struct __ns1__CreateRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__CreateRules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CreateRules(struct soap *soap, const struct __ns1__CreateRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tan__CreateRules(soap, &a->tan__CreateRules);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CreateRules(struct soap *soap, const char *tag, int id, const struct __ns1__CreateRules *a, const char *type)
{
	if (soap_out_PointerTo_tan__CreateRules(soap, "tan:CreateRules", -1, &a->tan__CreateRules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CreateRules * SOAP_FMAC4 soap_in___ns1__CreateRules(struct soap *soap, const char *tag, struct __ns1__CreateRules *a, const char *type)
{
	size_t soap_flag_tan__CreateRules = 1;
	short soap_flag;
	a = (struct __ns1__CreateRules *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CreateRules, sizeof(struct __ns1__CreateRules), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CreateRules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__CreateRules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tan__CreateRules(soap, "tan:CreateRules", &a->tan__CreateRules, ""))
				{	soap_flag_tan__CreateRules--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CreateRules(struct soap *soap, const struct __ns1__CreateRules *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__CreateRules(soap, tag?tag:"-ns1:CreateRules", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CreateRules * SOAP_FMAC4 soap_get___ns1__CreateRules(struct soap *soap, struct __ns1__CreateRules *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CreateRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__CreateRules * SOAP_FMAC2 soap_instantiate___ns1__CreateRules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CreateRules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__CreateRules, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__CreateRules);
		if (size)
			*size = sizeof(struct __ns1__CreateRules);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__CreateRules[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__CreateRules);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__CreateRules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__CreateRules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__CreateRules %p -> %p\n", q, p));
	*(struct __ns1__CreateRules*)p = *(struct __ns1__CreateRules*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetSupportedRules(struct soap *soap, struct __ns1__GetSupportedRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__GetSupportedRules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetSupportedRules(struct soap *soap, const struct __ns1__GetSupportedRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tan__GetSupportedRules(soap, &a->tan__GetSupportedRules);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetSupportedRules(struct soap *soap, const char *tag, int id, const struct __ns1__GetSupportedRules *a, const char *type)
{
	if (soap_out_PointerTo_tan__GetSupportedRules(soap, "tan:GetSupportedRules", -1, &a->tan__GetSupportedRules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSupportedRules * SOAP_FMAC4 soap_in___ns1__GetSupportedRules(struct soap *soap, const char *tag, struct __ns1__GetSupportedRules *a, const char *type)
{
	size_t soap_flag_tan__GetSupportedRules = 1;
	short soap_flag;
	a = (struct __ns1__GetSupportedRules *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetSupportedRules, sizeof(struct __ns1__GetSupportedRules), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetSupportedRules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__GetSupportedRules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tan__GetSupportedRules(soap, "tan:GetSupportedRules", &a->tan__GetSupportedRules, ""))
				{	soap_flag_tan__GetSupportedRules--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetSupportedRules(struct soap *soap, const struct __ns1__GetSupportedRules *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetSupportedRules(soap, tag?tag:"-ns1:GetSupportedRules", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSupportedRules * SOAP_FMAC4 soap_get___ns1__GetSupportedRules(struct soap *soap, struct __ns1__GetSupportedRules *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetSupportedRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetSupportedRules * SOAP_FMAC2 soap_instantiate___ns1__GetSupportedRules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetSupportedRules(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetSupportedRules, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetSupportedRules);
		if (size)
			*size = sizeof(struct __ns1__GetSupportedRules);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetSupportedRules[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetSupportedRules);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetSupportedRules*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetSupportedRules(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetSupportedRules %p -> %p\n", q, p));
	*(struct __ns1__GetSupportedRules*)p = *(struct __ns1__GetSupportedRules*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsse__Security = NULL;
	soap_default__wsa5__MessageID(soap, &a->wsa5__MessageID);
	a->wsa5__RelatesTo = NULL;
	a->wsa5__From = NULL;
	a->wsa5__ReplyTo = NULL;
	a->wsa5__FaultTo = NULL;
	soap_default__wsa5__To(soap, &a->wsa5__To);
	soap_default__wsa5__Action(soap, &a->wsa5__Action);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsse__Security(soap, &a->wsse__Security);
	soap_serialize__wsa5__MessageID(soap, &a->wsa5__MessageID);
	soap_serialize_PointerTo_wsa5__RelatesTo(soap, &a->wsa5__RelatesTo);
	soap_serialize_PointerTo_wsa5__From(soap, &a->wsa5__From);
	soap_serialize_PointerTo_wsa5__ReplyTo(soap, &a->wsa5__ReplyTo);
	soap_serialize_PointerTo_wsa5__FaultTo(soap, &a->wsa5__FaultTo);
	soap_serialize__wsa5__To(soap, &a->wsa5__To);
	soap_serialize__wsa5__Action(soap, &a->wsa5__Action);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsse__Security(soap, "wsse:Security", -1, &a->wsse__Security, ""))
		return soap->error;
	if (soap_out__wsa5__MessageID(soap, "wsa5:MessageID", -1, &a->wsa5__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", -1, &a->wsa5__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__From(soap, "wsa5:From", -1, &a->wsa5__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", -1, &a->wsa5__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", -1, &a->wsa5__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__To(soap, "wsa5:To", -1, &a->wsa5__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__Action(soap, "wsa5:Action", -1, &a->wsa5__Action, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsse__Security = 1;
	size_t soap_flag_wsa5__MessageID = 1;
	size_t soap_flag_wsa5__RelatesTo = 1;
	size_t soap_flag_wsa5__From = 1;
	size_t soap_flag_wsa5__ReplyTo = 1;
	size_t soap_flag_wsa5__FaultTo = 1;
	size_t soap_flag_wsa5__To = 1;
	size_t soap_flag_wsa5__Action = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsse__Security && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Security(soap, "wsse:Security", &a->wsse__Security, ""))
				{	soap_flag_wsse__Security--;
					continue;
				}
			if (soap_flag_wsa5__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__MessageID(soap, "wsa5:MessageID", &a->wsa5__MessageID, ""))
				{	soap_flag_wsa5__MessageID--;
					continue;
				}
			if (soap_flag_wsa5__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", &a->wsa5__RelatesTo, ""))
				{	soap_flag_wsa5__RelatesTo--;
					continue;
				}
			if (soap_flag_wsa5__From && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__From(soap, "wsa5:From", &a->wsa5__From, ""))
				{	soap_flag_wsa5__From--;
					continue;
				}
			if (soap_flag_wsa5__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", &a->wsa5__ReplyTo, ""))
				{	soap_flag_wsa5__ReplyTo--;
					continue;
				}
			if (soap_flag_wsa5__FaultTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", &a->wsa5__FaultTo, ""))
				{	soap_flag_wsa5__FaultTo--;
					continue;
				}
			if (soap_flag_wsa5__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__To(soap, "wsa5:To", &a->wsa5__To, ""))
				{	soap_flag_wsa5__To--;
					continue;
				}
			if (soap_flag_wsa5__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__Action(soap, "wsa5:Action", &a->wsa5__Action, ""))
				{	soap_flag_wsa5__Action--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Security(struct soap *soap, struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsu__Timestamp = NULL;
	a->UsernameToken = NULL;
	a->BinarySecurityToken = NULL;
	a->ds__Signature = NULL;
	soap_default_string(soap, &a->SOAP_ENV__actor);
	soap_default_string(soap, &a->SOAP_ENV__role);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Security(struct soap *soap, const struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsu__Timestamp(soap, &a->wsu__Timestamp);
	soap_serialize_PointerTo_wsse__UsernameToken(soap, &a->UsernameToken);
	soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, &a->BinarySecurityToken);
	soap_serialize_PointerTods__SignatureType(soap, &a->ds__Signature);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Security(struct soap *soap, const char *tag, int id, const struct _wsse__Security *a, const char *type)
{
	if (a->SOAP_ENV__actor)
		soap_set_attr(soap, "SOAP-ENV:actor", a->SOAP_ENV__actor, 1);
	if (a->SOAP_ENV__role)
		soap_set_attr(soap, "SOAP-ENV:role", a->SOAP_ENV__role, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Security), type))
		return soap->error;
	if (soap_out_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", -1, &a->wsu__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", -1, &a->UsernameToken, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", -1, &a->BinarySecurityToken, ""))
		return soap->error;
	if (soap_out_PointerTods__SignatureType(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_in__wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security *a, const char *type)
{
	size_t soap_flag_wsu__Timestamp = 1;
	size_t soap_flag_UsernameToken = 1;
	size_t soap_flag_BinarySecurityToken = 1;
	size_t soap_flag_ds__Signature = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Security *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Security(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:actor", 0), &a->SOAP_ENV__actor, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:role", 0), &a->SOAP_ENV__role, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsu__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", &a->wsu__Timestamp, ""))
				{	soap_flag_wsu__Timestamp--;
					continue;
				}
			if (soap_flag_UsernameToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", &a->UsernameToken, ""))
				{	soap_flag_UsernameToken--;
					continue;
				}
			if (soap_flag_BinarySecurityToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", &a->BinarySecurityToken, ""))
				{	soap_flag_BinarySecurityToken--;
					continue;
				}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureType(soap, "ds:Signature", &a->ds__Signature, "ds:SignatureType"))
				{	soap_flag_ds__Signature--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Security, 0, sizeof(struct _wsse__Security), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Security(struct soap *soap, const struct _wsse__Security *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Security);
	if (soap_out__wsse__Security(soap, tag?tag:"wsse:Security", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_get__wsse__Security(struct soap *soap, struct _wsse__Security *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__Security * SOAP_FMAC2 soap_instantiate__wsse__Security(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Security(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__Security, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__Security);
		if (size)
			*size = sizeof(struct _wsse__Security);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__Security[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__Security);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__Security*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__Security(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__Security %p -> %p\n", q, p));
	*(struct _wsse__Security*)p = *(struct _wsse__Security*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Modulus);
	soap_default_string(soap, &a->Exponent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Modulus);
	soap_serialize_string(soap, &a->Exponent);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__RSAKeyValueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RSAKeyValueType), type))
		return soap->error;
	if (a->Modulus)
	{	if (soap_out_string(soap, "ds:Modulus", -1, &a->Modulus, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Modulus"))
		return soap->error;
	if (a->Exponent)
	{	if (soap_out_string(soap, "ds:Exponent", -1, &a->Exponent, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Exponent"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_in_ds__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType *a, const char *type)
{
	size_t soap_flag_Modulus = 1;
	size_t soap_flag_Exponent = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Modulus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Modulus", &a->Modulus, "xsd:string"))
				{	soap_flag_Modulus--;
					continue;
				}
			if (soap_flag_Exponent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Exponent", &a->Exponent, "xsd:string"))
				{	soap_flag_Exponent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RSAKeyValueType, 0, sizeof(struct ds__RSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Modulus > 0 || soap_flag_Exponent > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RSAKeyValueType);
	if (soap_out_ds__RSAKeyValueType(soap, tag?tag:"ds:RSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_get_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__RSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__RSAKeyValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__RSAKeyValueType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__RSAKeyValueType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__RSAKeyValueType);
		if (size)
			*size = sizeof(struct ds__RSAKeyValueType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__RSAKeyValueType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__RSAKeyValueType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__RSAKeyValueType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__RSAKeyValueType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__RSAKeyValueType %p -> %p\n", q, p));
	*(struct ds__RSAKeyValueType*)p = *(struct ds__RSAKeyValueType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->G);
	soap_default_string(soap, &a->Y);
	soap_default_string(soap, &a->J);
	soap_default_string(soap, &a->P);
	soap_default_string(soap, &a->Q);
	soap_default_string(soap, &a->Seed);
	soap_default_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->G);
	soap_serialize_string(soap, &a->Y);
	soap_serialize_string(soap, &a->J);
	soap_serialize_string(soap, &a->P);
	soap_serialize_string(soap, &a->Q);
	soap_serialize_string(soap, &a->Seed);
	soap_serialize_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__DSAKeyValueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DSAKeyValueType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:G", -1, &a->G, ""))
		return soap->error;
	if (a->Y)
	{	if (soap_out_string(soap, "ds:Y", -1, &a->Y, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Y"))
		return soap->error;
	if (soap_out_string(soap, "ds:J", -1, &a->J, ""))
		return soap->error;
	if (a->P)
	{	if (soap_out_string(soap, "ds:P", -1, &a->P, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:P"))
		return soap->error;
	if (a->Q)
	{	if (soap_out_string(soap, "ds:Q", -1, &a->Q, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Q"))
		return soap->error;
	if (a->Seed)
	{	if (soap_out_string(soap, "ds:Seed", -1, &a->Seed, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Seed"))
		return soap->error;
	if (a->PgenCounter)
	{	if (soap_out_string(soap, "ds:PgenCounter", -1, &a->PgenCounter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:PgenCounter"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_in_ds__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType *a, const char *type)
{
	size_t soap_flag_G = 1;
	size_t soap_flag_Y = 1;
	size_t soap_flag_J = 1;
	size_t soap_flag_P = 1;
	size_t soap_flag_Q = 1;
	size_t soap_flag_Seed = 1;
	size_t soap_flag_PgenCounter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_G && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:G", &a->G, "xsd:string"))
				{	soap_flag_G--;
					continue;
				}
			if (soap_flag_Y && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Y", &a->Y, "xsd:string"))
				{	soap_flag_Y--;
					continue;
				}
			if (soap_flag_J && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:J", &a->J, "xsd:string"))
				{	soap_flag_J--;
					continue;
				}
			if (soap_flag_P && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:P", &a->P, "xsd:string"))
				{	soap_flag_P--;
					continue;
				}
			if (soap_flag_Q && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Q", &a->Q, "xsd:string"))
				{	soap_flag_Q--;
					continue;
				}
			if (soap_flag_Seed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Seed", &a->Seed, "xsd:string"))
				{	soap_flag_Seed--;
					continue;
				}
			if (soap_flag_PgenCounter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:PgenCounter", &a->PgenCounter, "xsd:string"))
				{	soap_flag_PgenCounter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DSAKeyValueType, 0, sizeof(struct ds__DSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Y > 0 || soap_flag_P > 0 || soap_flag_Q > 0 || soap_flag_Seed > 0 || soap_flag_PgenCounter > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DSAKeyValueType);
	if (soap_out_ds__DSAKeyValueType(soap, tag?tag:"ds:DSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_get_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__DSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__DSAKeyValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__DSAKeyValueType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__DSAKeyValueType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__DSAKeyValueType);
		if (size)
			*size = sizeof(struct ds__DSAKeyValueType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__DSAKeyValueType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__DSAKeyValueType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__DSAKeyValueType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__DSAKeyValueType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__DSAKeyValueType %p -> %p\n", q, p));
	*(struct ds__DSAKeyValueType*)p = *(struct ds__DSAKeyValueType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->X509IssuerName);
	soap_default_int(soap, &a->X509SerialNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->X509IssuerName);
	soap_embedded(soap, &a->X509SerialNumber, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509IssuerSerialType(struct soap *soap, const char *tag, int id, const struct ds__X509IssuerSerialType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509IssuerSerialType), type))
		return soap->error;
	if (a->X509IssuerName)
	{	if (soap_out_string(soap, "ds:X509IssuerName", -1, &a->X509IssuerName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509IssuerName"))
		return soap->error;
	if (soap_out_int(soap, "ds:X509SerialNumber", -1, &a->X509SerialNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_in_ds__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType *a, const char *type)
{
	size_t soap_flag_X509IssuerName = 1;
	size_t soap_flag_X509SerialNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509IssuerSerialType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509IssuerSerialType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509IssuerName", &a->X509IssuerName, "xsd:string"))
				{	soap_flag_X509IssuerName--;
					continue;
				}
			if (soap_flag_X509SerialNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ds:X509SerialNumber", &a->X509SerialNumber, "xsd:int"))
				{	soap_flag_X509SerialNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509IssuerSerialType, 0, sizeof(struct ds__X509IssuerSerialType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X509IssuerName > 0 || soap_flag_X509SerialNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509IssuerSerialType);
	if (soap_out_ds__X509IssuerSerialType(soap, tag?tag:"ds:X509IssuerSerialType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_get_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__X509IssuerSerialType * SOAP_FMAC2 soap_instantiate_ds__X509IssuerSerialType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__X509IssuerSerialType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__X509IssuerSerialType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__X509IssuerSerialType);
		if (size)
			*size = sizeof(struct ds__X509IssuerSerialType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__X509IssuerSerialType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__X509IssuerSerialType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__X509IssuerSerialType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__X509IssuerSerialType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__X509IssuerSerialType %p -> %p\n", q, p));
	*(struct ds__X509IssuerSerialType*)p = *(struct ds__X509IssuerSerialType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509DataType(struct soap *soap, struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->X509IssuerSerial = NULL;
	soap_default_string(soap, &a->X509SKI);
	soap_default_string(soap, &a->X509SubjectName);
	soap_default_string(soap, &a->X509Certificate);
	soap_default_string(soap, &a->X509CRL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__X509IssuerSerialType(soap, &a->X509IssuerSerial);
	soap_serialize_string(soap, &a->X509SKI);
	soap_serialize_string(soap, &a->X509SubjectName);
	soap_serialize_string(soap, &a->X509Certificate);
	soap_serialize_string(soap, &a->X509CRL);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509DataType(struct soap *soap, const char *tag, int id, const struct ds__X509DataType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509DataType), type))
		return soap->error;
	if (a->X509IssuerSerial)
	{	if (soap_out_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", -1, &a->X509IssuerSerial, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509IssuerSerial"))
		return soap->error;
	if (a->X509SKI)
	{	if (soap_out_string(soap, "ds:X509SKI", -1, &a->X509SKI, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509SKI"))
		return soap->error;
	if (a->X509SubjectName)
	{	if (soap_out_string(soap, "ds:X509SubjectName", -1, &a->X509SubjectName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509SubjectName"))
		return soap->error;
	if (a->X509Certificate)
	{	if (soap_out_string(soap, "ds:X509Certificate", -1, &a->X509Certificate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509Certificate"))
		return soap->error;
	if (a->X509CRL)
	{	if (soap_out_string(soap, "ds:X509CRL", -1, &a->X509CRL, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509CRL"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_in_ds__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType *a, const char *type)
{
	size_t soap_flag_X509IssuerSerial = 1;
	size_t soap_flag_X509SKI = 1;
	size_t soap_flag_X509SubjectName = 1;
	size_t soap_flag_X509Certificate = 1;
	size_t soap_flag_X509CRL = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509DataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509DataType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerSerial && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", &a->X509IssuerSerial, "ds:X509IssuerSerialType"))
				{	soap_flag_X509IssuerSerial--;
					continue;
				}
			if (soap_flag_X509SKI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SKI", &a->X509SKI, "xsd:string"))
				{	soap_flag_X509SKI--;
					continue;
				}
			if (soap_flag_X509SubjectName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SubjectName", &a->X509SubjectName, "xsd:string"))
				{	soap_flag_X509SubjectName--;
					continue;
				}
			if (soap_flag_X509Certificate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509Certificate", &a->X509Certificate, "xsd:string"))
				{	soap_flag_X509Certificate--;
					continue;
				}
			if (soap_flag_X509CRL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509CRL", &a->X509CRL, "xsd:string"))
				{	soap_flag_X509CRL--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509DataType, 0, sizeof(struct ds__X509DataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X509IssuerSerial > 0 || soap_flag_X509SKI > 0 || soap_flag_X509SubjectName > 0 || soap_flag_X509Certificate > 0 || soap_flag_X509CRL > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509DataType);
	if (soap_out_ds__X509DataType(soap, tag?tag:"ds:X509DataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_get_ds__X509DataType(struct soap *soap, struct ds__X509DataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__X509DataType * SOAP_FMAC2 soap_instantiate_ds__X509DataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__X509DataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__X509DataType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__X509DataType);
		if (size)
			*size = sizeof(struct ds__X509DataType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__X509DataType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__X509DataType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__X509DataType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__X509DataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__X509DataType %p -> %p\n", q, p));
	*(struct ds__X509DataType*)p = *(struct ds__X509DataType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RetrievalMethodType(struct soap *soap, const char *tag, int id, const struct ds__RetrievalMethodType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RetrievalMethodType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_in_ds__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RetrievalMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RetrievalMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RetrievalMethodType, 0, sizeof(struct ds__RetrievalMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RetrievalMethodType);
	if (soap_out_ds__RetrievalMethodType(soap, tag?tag:"ds:RetrievalMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_get_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__RetrievalMethodType * SOAP_FMAC2 soap_instantiate_ds__RetrievalMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__RetrievalMethodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__RetrievalMethodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__RetrievalMethodType);
		if (size)
			*size = sizeof(struct ds__RetrievalMethodType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__RetrievalMethodType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__RetrievalMethodType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__RetrievalMethodType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__RetrievalMethodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__RetrievalMethodType %p -> %p\n", q, p));
	*(struct ds__RetrievalMethodType*)p = *(struct ds__RetrievalMethodType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DSAKeyValue = NULL;
	a->RSAKeyValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__DSAKeyValueType(soap, &a->DSAKeyValue);
	soap_serialize_PointerTods__RSAKeyValueType(soap, &a->RSAKeyValue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyValueType(struct soap *soap, const char *tag, int id, const struct ds__KeyValueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyValueType), type))
		return soap->error;
	if (a->DSAKeyValue)
	{	if (soap_out_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", -1, &a->DSAKeyValue, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:DSAKeyValue"))
		return soap->error;
	if (a->RSAKeyValue)
	{	if (soap_out_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", -1, &a->RSAKeyValue, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:RSAKeyValue"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_in_ds__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType *a, const char *type)
{
	size_t soap_flag_DSAKeyValue = 1;
	size_t soap_flag_RSAKeyValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", &a->DSAKeyValue, "ds:DSAKeyValueType"))
				{	soap_flag_DSAKeyValue--;
					continue;
				}
			if (soap_flag_RSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", &a->RSAKeyValue, "ds:RSAKeyValueType"))
				{	soap_flag_RSAKeyValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyValueType, 0, sizeof(struct ds__KeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DSAKeyValue > 0 || soap_flag_RSAKeyValue > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyValueType);
	if (soap_out_ds__KeyValueType(soap, tag?tag:"ds:KeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_get_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__KeyValueType * SOAP_FMAC2 soap_instantiate_ds__KeyValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__KeyValueType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__KeyValueType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__KeyValueType);
		if (size)
			*size = sizeof(struct ds__KeyValueType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__KeyValueType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__KeyValueType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__KeyValueType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__KeyValueType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__KeyValueType %p -> %p\n", q, p));
	*(struct ds__KeyValueType*)p = *(struct ds__KeyValueType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DigestMethodType(struct soap *soap, const char *tag, int id, const struct ds__DigestMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DigestMethodType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_in_ds__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DigestMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DigestMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DigestMethodType, 0, sizeof(struct ds__DigestMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DigestMethodType);
	if (soap_out_ds__DigestMethodType(soap, tag?tag:"ds:DigestMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_get_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__DigestMethodType * SOAP_FMAC2 soap_instantiate_ds__DigestMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__DigestMethodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__DigestMethodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__DigestMethodType);
		if (size)
			*size = sizeof(struct ds__DigestMethodType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__DigestMethodType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__DigestMethodType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__DigestMethodType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__DigestMethodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__DigestMethodType %p -> %p\n", q, p));
	*(struct ds__DigestMethodType*)p = *(struct ds__DigestMethodType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformType(struct soap *soap, struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->c14n__InclusiveNamespaces = NULL;
	a->__any = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformType(struct soap *soap, const struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformType(struct soap *soap, const char *tag, int id, const struct ds__TransformType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_in_ds__TransformType(struct soap *soap, const char *tag, struct ds__TransformType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 0), &a->Algorithm, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformType, 0, sizeof(struct ds__TransformType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformType(struct soap *soap, const struct ds__TransformType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformType);
	if (soap_out_ds__TransformType(soap, tag?tag:"ds:TransformType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_get_ds__TransformType(struct soap *soap, struct ds__TransformType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__TransformType * SOAP_FMAC2 soap_instantiate_ds__TransformType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__TransformType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__TransformType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__TransformType);
		if (size)
			*size = sizeof(struct ds__TransformType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__TransformType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__TransformType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__TransformType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__TransformType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__TransformType %p -> %p\n", q, p));
	*(struct ds__TransformType*)p = *(struct ds__TransformType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->PrefixList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, const struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (a->PrefixList)
		soap_set_attr(soap, "PrefixList", a->PrefixList, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__c14n__InclusiveNamespaces), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_in__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _c14n__InclusiveNamespaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__c14n__InclusiveNamespaces(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PrefixList", 0), &a->PrefixList, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__c14n__InclusiveNamespaces, 0, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__c14n__InclusiveNamespaces);
	if (soap_out__c14n__InclusiveNamespaces(soap, tag?tag:"c14n:InclusiveNamespaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_get__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _c14n__InclusiveNamespaces * SOAP_FMAC2 soap_instantiate__c14n__InclusiveNamespaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__c14n__InclusiveNamespaces(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__c14n__InclusiveNamespaces, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _c14n__InclusiveNamespaces);
		if (size)
			*size = sizeof(struct _c14n__InclusiveNamespaces);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct _c14n__InclusiveNamespaces[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _c14n__InclusiveNamespaces);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _c14n__InclusiveNamespaces*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__c14n__InclusiveNamespaces(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _c14n__InclusiveNamespaces %p -> %p\n", q, p));
	*(struct _c14n__InclusiveNamespaces*)p = *(struct _c14n__InclusiveNamespaces*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformsType(struct soap *soap, struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTransform = 0;
	a->Transform = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Transform)
	{	int i;
		for (i = 0; i < a->__sizeTransform; i++)
		{
			soap_embedded(soap, a->Transform + i, SOAP_TYPE_ds__TransformType);
			soap_serialize_ds__TransformType(soap, a->Transform + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformsType(struct soap *soap, const char *tag, int id, const struct ds__TransformsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformsType), type))
		return soap->error;
	if (a->Transform)
	{	int i;
		for (i = 0; i < a->__sizeTransform; i++)
			if (soap_out_ds__TransformType(soap, "ds:Transform", -1, a->Transform + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_in_ds__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType *a, const char *type)
{
	struct soap_blist *soap_blist_Transform = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Transform", 1, NULL))
			{	if (a->Transform == NULL)
				{	if (soap_blist_Transform == NULL)
						soap_blist_Transform = soap_new_block(soap);
					a->Transform = (struct ds__TransformType *)soap_push_block(soap, soap_blist_Transform, sizeof(struct ds__TransformType));
					if (a->Transform == NULL)
						return NULL;
					soap_default_ds__TransformType(soap, a->Transform);
				}
				soap_revert(soap);
				if (soap_in_ds__TransformType(soap, "ds:Transform", a->Transform, "ds:TransformType"))
				{	a->__sizeTransform++;
					a->Transform = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Transform)
			soap_pop_block(soap, soap_blist_Transform);
		if (a->__sizeTransform)
			a->Transform = (struct ds__TransformType *)soap_save_block(soap, soap_blist_Transform, NULL, 1);
		else
		{	a->Transform = NULL;
			if (soap_blist_Transform)
				soap_end_block(soap, soap_blist_Transform);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformsType, 0, sizeof(struct ds__TransformsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformsType);
	if (soap_out_ds__TransformsType(soap, tag?tag:"ds:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_get_ds__TransformsType(struct soap *soap, struct ds__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__TransformsType * SOAP_FMAC2 soap_instantiate_ds__TransformsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__TransformsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__TransformsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__TransformsType);
		if (size)
			*size = sizeof(struct ds__TransformsType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__TransformsType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__TransformsType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__TransformsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__TransformsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__TransformsType %p -> %p\n", q, p));
	*(struct ds__TransformsType*)p = *(struct ds__TransformsType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	a->DigestMethod = NULL;
	soap_default_string(soap, &a->DigestValue);
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->DigestMethod);
	soap_serialize_string(soap, &a->DigestValue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__ReferenceType(struct soap *soap, const char *tag, int id, const struct ds__ReferenceType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__ReferenceType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	if (a->DigestMethod)
	{	if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->DigestMethod, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:DigestMethod"))
		return soap->error;
	if (a->DigestValue)
	{	if (soap_out_string(soap, "ds:DigestValue", -1, &a->DigestValue, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:DigestValue"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_in_ds__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	size_t soap_flag_DigestMethod = 1;
	size_t soap_flag_DigestValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap_flag_DigestMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->DigestMethod, "ds:DigestMethodType"))
				{	soap_flag_DigestMethod--;
					continue;
				}
			if (soap_flag_DigestValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:DigestValue", &a->DigestValue, "xsd:string"))
				{	soap_flag_DigestValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__ReferenceType, 0, sizeof(struct ds__ReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DigestMethod > 0 || soap_flag_DigestValue > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__ReferenceType);
	if (soap_out_ds__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_get_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__ReferenceType * SOAP_FMAC2 soap_instantiate_ds__ReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__ReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__ReferenceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__ReferenceType);
		if (size)
			*size = sizeof(struct ds__ReferenceType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__ReferenceType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__ReferenceType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__ReferenceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__ReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__ReferenceType %p -> %p\n", q, p));
	*(struct ds__ReferenceType*)p = *(struct ds__ReferenceType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HMACOutputLength = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->HMACOutputLength);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureMethodType(struct soap *soap, const char *tag, int id, const struct ds__SignatureMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ds:HMACOutputLength", -1, &a->HMACOutputLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_in_ds__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType *a, const char *type)
{
	size_t soap_flag_HMACOutputLength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HMACOutputLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ds:HMACOutputLength", &a->HMACOutputLength, "xsd:int"))
				{	soap_flag_HMACOutputLength--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureMethodType, 0, sizeof(struct ds__SignatureMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureMethodType);
	if (soap_out_ds__SignatureMethodType(soap, tag?tag:"ds:SignatureMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_get_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__SignatureMethodType * SOAP_FMAC2 soap_instantiate_ds__SignatureMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__SignatureMethodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__SignatureMethodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__SignatureMethodType);
		if (size)
			*size = sizeof(struct ds__SignatureMethodType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__SignatureMethodType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__SignatureMethodType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__SignatureMethodType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__SignatureMethodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__SignatureMethodType %p -> %p\n", q, p));
	*(struct ds__SignatureMethodType*)p = *(struct ds__SignatureMethodType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
	a->c14n__InclusiveNamespaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, const struct ds__CanonicalizationMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__CanonicalizationMethodType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_in_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__CanonicalizationMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__CanonicalizationMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__CanonicalizationMethodType, 0, sizeof(struct ds__CanonicalizationMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__CanonicalizationMethodType);
	if (soap_out_ds__CanonicalizationMethodType(soap, tag?tag:"ds:CanonicalizationMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_get_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__CanonicalizationMethodType * SOAP_FMAC2 soap_instantiate_ds__CanonicalizationMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__CanonicalizationMethodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__CanonicalizationMethodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__CanonicalizationMethodType);
		if (size)
			*size = sizeof(struct ds__CanonicalizationMethodType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__CanonicalizationMethodType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__CanonicalizationMethodType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__CanonicalizationMethodType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__CanonicalizationMethodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__CanonicalizationMethodType %p -> %p\n", q, p));
	*(struct ds__CanonicalizationMethodType*)p = *(struct ds__CanonicalizationMethodType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->KeyName);
	a->KeyValue = NULL;
	a->RetrievalMethod = NULL;
	a->X509Data = NULL;
	a->wsse__SecurityTokenReference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->KeyName);
	soap_serialize_PointerTods__KeyValueType(soap, &a->KeyValue);
	soap_serialize_PointerTods__RetrievalMethodType(soap, &a->RetrievalMethod);
	soap_serialize_PointerTods__X509DataType(soap, &a->X509Data);
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyInfoType(struct soap *soap, const char *tag, int id, const struct ds__KeyInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyInfoType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:KeyName", -1, &a->KeyName, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyValueType(soap, "ds:KeyValue", -1, &a->KeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", -1, &a->RetrievalMethod, ""))
		return soap->error;
	if (soap_out_PointerTods__X509DataType(soap, "ds:X509Data", -1, &a->X509Data, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_in_ds__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType *a, const char *type)
{
	size_t soap_flag_KeyName = 1;
	size_t soap_flag_KeyValue = 1;
	size_t soap_flag_RetrievalMethod = 1;
	size_t soap_flag_X509Data = 1;
	size_t soap_flag_wsse__SecurityTokenReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:KeyName", &a->KeyName, "xsd:string"))
				{	soap_flag_KeyName--;
					continue;
				}
			if (soap_flag_KeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyValueType(soap, "ds:KeyValue", &a->KeyValue, "ds:KeyValueType"))
				{	soap_flag_KeyValue--;
					continue;
				}
			if (soap_flag_RetrievalMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", &a->RetrievalMethod, "ds:RetrievalMethodType"))
				{	soap_flag_RetrievalMethod--;
					continue;
				}
			if (soap_flag_X509Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509DataType(soap, "ds:X509Data", &a->X509Data, "ds:X509DataType"))
				{	soap_flag_X509Data--;
					continue;
				}
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
				{	soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyInfoType, 0, sizeof(struct ds__KeyInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyInfoType);
	if (soap_out_ds__KeyInfoType(soap, tag?tag:"ds:KeyInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_get_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__KeyInfoType * SOAP_FMAC2 soap_instantiate_ds__KeyInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__KeyInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__KeyInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__KeyInfoType);
		if (size)
			*size = sizeof(struct ds__KeyInfoType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__KeyInfoType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__KeyInfoType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__KeyInfoType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__KeyInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__KeyInfoType %p -> %p\n", q, p));
	*(struct ds__KeyInfoType*)p = *(struct ds__KeyInfoType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CanonicalizationMethod = NULL;
	a->SignatureMethod = NULL;
	a->__sizeReference = 0;
	a->Reference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__CanonicalizationMethodType(soap, &a->CanonicalizationMethod);
	soap_serialize_PointerTods__SignatureMethodType(soap, &a->SignatureMethod);
	if (a->Reference)
	{	int i;
		for (i = 0; i < a->__sizeReference; i++)
		{
			soap_serialize_PointerTods__ReferenceType(soap, a->Reference + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignedInfoType(struct soap *soap, const char *tag, int id, const struct ds__SignedInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignedInfoType), type))
		return soap->error;
	if (a->CanonicalizationMethod)
	{	if (soap_out_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", -1, &a->CanonicalizationMethod, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:CanonicalizationMethod"))
		return soap->error;
	if (a->SignatureMethod)
	{	if (soap_out_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", -1, &a->SignatureMethod, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:SignatureMethod"))
		return soap->error;
	if (a->Reference)
	{	int i;
		for (i = 0; i < a->__sizeReference; i++)
			if (soap_out_PointerTods__ReferenceType(soap, "ds:Reference", -1, a->Reference + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_in_ds__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType *a, const char *type)
{
	size_t soap_flag_CanonicalizationMethod = 1;
	size_t soap_flag_SignatureMethod = 1;
	struct soap_blist *soap_blist_Reference = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignedInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignedInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CanonicalizationMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", &a->CanonicalizationMethod, "ds:CanonicalizationMethodType"))
				{	soap_flag_CanonicalizationMethod--;
					continue;
				}
			if (soap_flag_SignatureMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", &a->SignatureMethod, "ds:SignatureMethodType"))
				{	soap_flag_SignatureMethod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Reference", 1, NULL))
			{	if (a->Reference == NULL)
				{	if (soap_blist_Reference == NULL)
						soap_blist_Reference = soap_new_block(soap);
					a->Reference = (struct ds__ReferenceType **)soap_push_block(soap, soap_blist_Reference, sizeof(struct ds__ReferenceType *));
					if (a->Reference == NULL)
						return NULL;
					*a->Reference = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTods__ReferenceType(soap, "ds:Reference", a->Reference, "ds:ReferenceType"))
				{	a->__sizeReference++;
					a->Reference = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Reference)
			soap_pop_block(soap, soap_blist_Reference);
		if (a->__sizeReference)
			a->Reference = (struct ds__ReferenceType **)soap_save_block(soap, soap_blist_Reference, NULL, 1);
		else
		{	a->Reference = NULL;
			if (soap_blist_Reference)
				soap_end_block(soap, soap_blist_Reference);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignedInfoType, 0, sizeof(struct ds__SignedInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CanonicalizationMethod > 0 || soap_flag_SignatureMethod > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignedInfoType);
	if (soap_out_ds__SignedInfoType(soap, tag?tag:"ds:SignedInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_get_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__SignedInfoType * SOAP_FMAC2 soap_instantiate_ds__SignedInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__SignedInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__SignedInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__SignedInfoType);
		if (size)
			*size = sizeof(struct ds__SignedInfoType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__SignedInfoType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__SignedInfoType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__SignedInfoType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__SignedInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__SignedInfoType %p -> %p\n", q, p));
	*(struct ds__SignedInfoType*)p = *(struct ds__SignedInfoType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureType(struct soap *soap, struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SignedInfo = NULL;
	soap_default_string(soap, &a->SignatureValue);
	a->KeyInfo = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__SignedInfoType(soap, &a->SignedInfo);
	soap_serialize_string(soap, &a->SignatureValue);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->KeyInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureType(struct soap *soap, const char *tag, int id, const struct ds__SignatureType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureType), type))
		return soap->error;
	if (soap_out_PointerTods__SignedInfoType(soap, "ds:SignedInfo", -1, &a->SignedInfo, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:SignatureValue", -1, &a->SignatureValue, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "ds:KeyInfo", -1, &a->KeyInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_in_ds__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType *a, const char *type)
{
	size_t soap_flag_SignedInfo = 1;
	size_t soap_flag_SignatureValue = 1;
	size_t soap_flag_KeyInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SignedInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignedInfoType(soap, "ds:SignedInfo", &a->SignedInfo, "ds:SignedInfoType"))
				{	soap_flag_SignedInfo--;
					continue;
				}
			if (soap_flag_SignatureValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:SignatureValue", &a->SignatureValue, "xsd:string"))
				{	soap_flag_SignatureValue--;
					continue;
				}
			if (soap_flag_KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "ds:KeyInfo", &a->KeyInfo, "ds:KeyInfoType"))
				{	soap_flag_KeyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureType, 0, sizeof(struct ds__SignatureType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureType);
	if (soap_out_ds__SignatureType(soap, tag?tag:"ds:SignatureType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_get_ds__SignatureType(struct soap *soap, struct ds__SignatureType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__SignatureType * SOAP_FMAC2 soap_instantiate_ds__SignatureType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__SignatureType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__SignatureType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__SignatureType);
		if (size)
			*size = sizeof(struct ds__SignatureType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__SignatureType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__SignatureType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__SignatureType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__SignatureType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__SignatureType %p -> %p\n", q, p));
	*(struct ds__SignatureType*)p = *(struct ds__SignatureType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Reference = NULL;
	a->KeyIdentifier = NULL;
	a->Embedded = NULL;
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Usage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsse__Reference(soap, &a->Reference);
	soap_serialize_PointerTo_wsse__KeyIdentifier(soap, &a->KeyIdentifier);
	soap_serialize_PointerTo_wsse__Embedded(soap, &a->Embedded);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, const struct _wsse__SecurityTokenReference *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->Usage)
		soap_set_attr(soap, "Usage", a->Usage, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__SecurityTokenReference), type))
		return soap->error;
	if (soap_out_PointerTo_wsse__Reference(soap, "wsse:Reference", -1, &a->Reference, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", -1, &a->KeyIdentifier, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Embedded(soap, "wsse:Embedded", -1, &a->Embedded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_in__wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference *a, const char *type)
{
	size_t soap_flag_Reference = 1;
	size_t soap_flag_KeyIdentifier = 1;
	size_t soap_flag_Embedded = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__SecurityTokenReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__SecurityTokenReference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Usage", 0), &a->Usage, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Reference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Reference(soap, "wsse:Reference", &a->Reference, ""))
				{	soap_flag_Reference--;
					continue;
				}
			if (soap_flag_KeyIdentifier && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", &a->KeyIdentifier, ""))
				{	soap_flag_KeyIdentifier--;
					continue;
				}
			if (soap_flag_Embedded && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Embedded(soap, "wsse:Embedded", &a->Embedded, ""))
				{	soap_flag_Embedded--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__SecurityTokenReference, 0, sizeof(struct _wsse__SecurityTokenReference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__SecurityTokenReference);
	if (soap_out__wsse__SecurityTokenReference(soap, tag?tag:"wsse:SecurityTokenReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_get__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__SecurityTokenReference * SOAP_FMAC2 soap_instantiate__wsse__SecurityTokenReference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__SecurityTokenReference(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__SecurityTokenReference, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__SecurityTokenReference);
		if (size)
			*size = sizeof(struct _wsse__SecurityTokenReference);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__SecurityTokenReference[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__SecurityTokenReference);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__SecurityTokenReference*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__SecurityTokenReference(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__SecurityTokenReference %p -> %p\n", q, p));
	*(struct _wsse__SecurityTokenReference*)p = *(struct _wsse__SecurityTokenReference*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, const struct _wsse__KeyIdentifier *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", a->EncodingType, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_in__wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__KeyIdentifier *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__KeyIdentifier(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__KeyIdentifier);
	if (soap_out__wsse__KeyIdentifier(soap, tag?tag:"wsse:KeyIdentifier", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_get__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__KeyIdentifier * SOAP_FMAC2 soap_instantiate__wsse__KeyIdentifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__KeyIdentifier(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__KeyIdentifier, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__KeyIdentifier);
		if (size)
			*size = sizeof(struct _wsse__KeyIdentifier);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__KeyIdentifier[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__KeyIdentifier);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__KeyIdentifier*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__KeyIdentifier(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__KeyIdentifier %p -> %p\n", q, p));
	*(struct _wsse__KeyIdentifier*)p = *(struct _wsse__KeyIdentifier*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Embedded(struct soap *soap, const char *tag, int id, const struct _wsse__Embedded *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Embedded), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_in__wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Embedded *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Embedded(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Embedded, 0, sizeof(struct _wsse__Embedded), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Embedded);
	if (soap_out__wsse__Embedded(soap, tag?tag:"wsse:Embedded", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_get__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__Embedded * SOAP_FMAC2 soap_instantiate__wsse__Embedded(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Embedded(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__Embedded, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__Embedded);
		if (size)
			*size = sizeof(struct _wsse__Embedded);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__Embedded[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__Embedded);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__Embedded*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__Embedded(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__Embedded %p -> %p\n", q, p));
	*(struct _wsse__Embedded*)p = *(struct _wsse__Embedded*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Reference(struct soap *soap, struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Reference(struct soap *soap, const char *tag, int id, const struct _wsse__Reference *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Reference), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_in__wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Reference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Reference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Reference, 0, sizeof(struct _wsse__Reference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Reference);
	if (soap_out__wsse__Reference(soap, tag?tag:"wsse:Reference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_get__wsse__Reference(struct soap *soap, struct _wsse__Reference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__Reference * SOAP_FMAC2 soap_instantiate__wsse__Reference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Reference(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__Reference, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__Reference);
		if (size)
			*size = sizeof(struct _wsse__Reference);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__Reference[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__Reference);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__Reference*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__Reference(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__Reference %p -> %p\n", q, p));
	*(struct _wsse__Reference*)p = *(struct _wsse__Reference*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, const struct _wsse__BinarySecurityToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", a->EncodingType, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_in__wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__BinarySecurityToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__BinarySecurityToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__BinarySecurityToken);
	if (soap_out__wsse__BinarySecurityToken(soap, tag?tag:"wsse:BinarySecurityToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_get__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__BinarySecurityToken * SOAP_FMAC2 soap_instantiate__wsse__BinarySecurityToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__BinarySecurityToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__BinarySecurityToken, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__BinarySecurityToken);
		if (size)
			*size = sizeof(struct _wsse__BinarySecurityToken);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__BinarySecurityToken[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__BinarySecurityToken);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__BinarySecurityToken*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__BinarySecurityToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__BinarySecurityToken %p -> %p\n", q, p));
	*(struct _wsse__BinarySecurityToken*)p = *(struct _wsse__BinarySecurityToken*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Password(struct soap *soap, struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Password(struct soap *soap, const struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Password(struct soap *soap, const char *tag, int id, const struct _wsse__Password *a, const char *type)
{
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_in__wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__Password *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__Password(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Password(struct soap *soap, const struct _wsse__Password *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Password);
	if (soap_out__wsse__Password(soap, tag?tag:"wsse:Password", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_get__wsse__Password(struct soap *soap, struct _wsse__Password *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__Password * SOAP_FMAC2 soap_instantiate__wsse__Password(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Password(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__Password, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__Password);
		if (size)
			*size = sizeof(struct _wsse__Password);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__Password[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__Password);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__Password*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__Password(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__Password %p -> %p\n", q, p));
	*(struct _wsse__Password*)p = *(struct _wsse__Password*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	a->Password = NULL;
	soap_default_string(soap, &a->Nonce);
	soap_default_string(soap, &a->wsu__Created);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Username);
	soap_serialize_PointerTo_wsse__Password(soap, &a->Password);
	soap_serialize_string(soap, &a->Nonce);
	soap_serialize_string(soap, &a->wsu__Created);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__UsernameToken(struct soap *soap, const char *tag, int id, const struct _wsse__UsernameToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__UsernameToken), type))
		return soap->error;
	if (soap_out_string(soap, "wsse:Username", -1, &a->Username, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Password(soap, "wsse:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_string(soap, "wsse:Nonce", -1, &a->Nonce, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, &a->wsu__Created, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_in__wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Nonce = 1;
	size_t soap_flag_wsu__Created = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__UsernameToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__UsernameToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsse:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Password(soap, "wsse:Password", &a->Password, ""))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsse:Nonce", &a->Nonce, "xsd:string"))
				{	soap_flag_Nonce--;
					continue;
				}
			if (soap_flag_wsu__Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Created", &a->wsu__Created, "xsd:string"))
				{	soap_flag_wsu__Created--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__UsernameToken, 0, sizeof(struct _wsse__UsernameToken), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__UsernameToken);
	if (soap_out__wsse__UsernameToken(soap, tag?tag:"wsse:UsernameToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_get__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__UsernameToken * SOAP_FMAC2 soap_instantiate__wsse__UsernameToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__UsernameToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__UsernameToken, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__UsernameToken);
		if (size)
			*size = sizeof(struct _wsse__UsernameToken);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__UsernameToken[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__UsernameToken);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__UsernameToken*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__UsernameToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__UsernameToken %p -> %p\n", q, p));
	*(struct _wsse__UsernameToken*)p = *(struct _wsse__UsernameToken*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Created);
	soap_default_string(soap, &a->Expires);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Created);
	soap_serialize_string(soap, &a->Expires);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsu__Timestamp(struct soap *soap, const char *tag, int id, const struct _wsu__Timestamp *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsu__Timestamp), type))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, &a->Created, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Expires", -1, &a->Expires, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_in__wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp *a, const char *type)
{
	size_t soap_flag_Created = 1;
	size_t soap_flag_Expires = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsu__Timestamp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsu__Timestamp(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Created", &a->Created, "xsd:string"))
				{	soap_flag_Created--;
					continue;
				}
			if (soap_flag_Expires && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Expires", &a->Expires, "xsd:string"))
				{	soap_flag_Expires--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsu__Timestamp, 0, sizeof(struct _wsu__Timestamp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsu__Timestamp);
	if (soap_out__wsu__Timestamp(soap, tag?tag:"wsu:Timestamp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_get__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsu__Timestamp * SOAP_FMAC2 soap_instantiate__wsu__Timestamp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsu__Timestamp(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsu__Timestamp, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsu__Timestamp);
		if (size)
			*size = sizeof(struct _wsu__Timestamp);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct _wsu__Timestamp[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsu__Timestamp);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsu__Timestamp*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsu__Timestamp(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsu__Timestamp %p -> %p\n", q, p));
	*(struct _wsu__Timestamp*)p = *(struct _wsu__Timestamp*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Action);
	soap_default_string(soap, &a->SoapAction);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Action);
	soap_serialize_string(soap, &a->SoapAction);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ProblemActionType(struct soap *soap, const char *tag, int id, const struct wsa5__ProblemActionType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ProblemActionType), type))
		return soap->error;
	if (soap_out_string(soap, "wsa5:Action", -1, &a->Action, ""))
		return soap->error;
	if (soap_out_string(soap, "wsa5:SoapAction", -1, &a->SoapAction, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_in_wsa5__ProblemActionType(struct soap *soap, const char *tag, struct wsa5__ProblemActionType *a, const char *type)
{
	size_t soap_flag_Action = 1;
	size_t soap_flag_SoapAction = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__ProblemActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ProblemActionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa5:Action", &a->Action, "xsd:string"))
				{	soap_flag_Action--;
					continue;
				}
			if (soap_flag_SoapAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa5:SoapAction", &a->SoapAction, "xsd:string"))
				{	soap_flag_SoapAction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ProblemActionType, 0, sizeof(struct wsa5__ProblemActionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__ProblemActionType);
	if (soap_out_wsa5__ProblemActionType(soap, tag?tag:"wsa5:ProblemActionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_get_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ProblemActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa5__ProblemActionType * SOAP_FMAC2 soap_instantiate_wsa5__ProblemActionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__ProblemActionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa5__ProblemActionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__ProblemActionType);
		if (size)
			*size = sizeof(struct wsa5__ProblemActionType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__ProblemActionType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct wsa5__ProblemActionType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct wsa5__ProblemActionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa5__ProblemActionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa5__ProblemActionType %p -> %p\n", q, p));
	*(struct wsa5__ProblemActionType*)p = *(struct wsa5__ProblemActionType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_wsa5__RelationshipTypeOpenEnum(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelatesToType(struct soap *soap, const char *tag, int id, const struct wsa5__RelatesToType *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", a->RelationshipType, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_in_wsa5__RelatesToType(struct soap *soap, const char *tag, struct wsa5__RelatesToType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa5__RelatesToType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelatesToType, sizeof(struct wsa5__RelatesToType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa5__RelatesToType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "RelationshipType", 0), &a->RelationshipType, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "wsa5:RelatesToType"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__RelatesToType);
	if (soap_out_wsa5__RelatesToType(soap, tag?tag:"wsa5:RelatesToType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_get_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelatesToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa5__RelatesToType * SOAP_FMAC2 soap_instantiate_wsa5__RelatesToType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__RelatesToType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa5__RelatesToType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__RelatesToType);
		if (size)
			*size = sizeof(struct wsa5__RelatesToType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__RelatesToType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct wsa5__RelatesToType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct wsa5__RelatesToType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa5__RelatesToType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa5__RelatesToType %p -> %p\n", q, p));
	*(struct wsa5__RelatesToType*)p = *(struct wsa5__RelatesToType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__MetadataType(struct soap *soap, const char *tag, int id, const struct wsa5__MetadataType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__MetadataType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_in_wsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__MetadataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__MetadataType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__MetadataType, 0, sizeof(struct wsa5__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__MetadataType);
	if (soap_out_wsa5__MetadataType(soap, tag?tag:"wsa5:MetadataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_get_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa5__MetadataType * SOAP_FMAC2 soap_instantiate_wsa5__MetadataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__MetadataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa5__MetadataType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__MetadataType);
		if (size)
			*size = sizeof(struct wsa5__MetadataType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__MetadataType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct wsa5__MetadataType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct wsa5__MetadataType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa5__MetadataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa5__MetadataType %p -> %p\n", q, p));
	*(struct wsa5__MetadataType*)p = *(struct wsa5__MetadataType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa5__ReferenceParametersType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ReferenceParametersType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ReferenceParametersType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ReferenceParametersType, 0, sizeof(struct wsa5__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__ReferenceParametersType);
	if (soap_out_wsa5__ReferenceParametersType(soap, tag?tag:"wsa5:ReferenceParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa5__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa5__ReferenceParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__ReferenceParametersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa5__ReferenceParametersType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__ReferenceParametersType);
		if (size)
			*size = sizeof(struct wsa5__ReferenceParametersType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__ReferenceParametersType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct wsa5__ReferenceParametersType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct wsa5__ReferenceParametersType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa5__ReferenceParametersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa5__ReferenceParametersType %p -> %p\n", q, p));
	*(struct wsa5__ReferenceParametersType*)p = *(struct wsa5__ReferenceParametersType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceParameters = NULL;
	a->Metadata = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Address);
	soap_serialize_PointerTowsa5__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTowsa5__MetadataType(soap, &a->Metadata);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa5__EndpointReferenceType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__EndpointReferenceType), type))
		return soap->error;
	if (a->Address)
	{	if (soap_out_string(soap, "wsa5:Address", -1, &a->Address, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wsa5:Address"))
		return soap->error;
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", -1, &a->Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_Metadata = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__EndpointReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa5:Address", &a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", &a->ReferenceParameters, "wsa5:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			if (soap_flag_Metadata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", &a->Metadata, "wsa5:MetadataType"))
				{	soap_flag_Metadata--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__EndpointReferenceType, 0, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__EndpointReferenceType);
	if (soap_out_wsa5__EndpointReferenceType(soap, tag?tag:"wsa5:EndpointReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa5__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa5__EndpointReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__EndpointReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa5__EndpointReferenceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__EndpointReferenceType);
		if (size)
			*size = sizeof(struct wsa5__EndpointReferenceType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__EndpointReferenceType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct wsa5__EndpointReferenceType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct wsa5__EndpointReferenceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa5__EndpointReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa5__EndpointReferenceType %p -> %p\n", q, p));
	*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xop__Include(struct soap *soap, struct _xop__Include *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xop__Include(struct soap *soap, struct _xop__Include const*a)
{
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE__xop__Include))
		if (a->id || a->type)
			soap->mode |= SOAP_ENC_DIME;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xop__Include(struct soap *soap, const char *tag, int id, const struct _xop__Include *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE__xop__Include);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE__xop__Include);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_in__xop__Include(struct soap *soap, const char *tag, struct _xop__Include *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct _xop__Include *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xop__Include, sizeof(struct _xop__Include), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__xop__Include(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (struct _xop__Include *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xop__Include, 0, sizeof(struct _xop__Include), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xop__Include(struct soap *soap, const struct _xop__Include *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE__xop__Include);
	if (soap_out__xop__Include(soap, tag?tag:"xop:Include", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_get__xop__Include(struct soap *soap, struct _xop__Include *p, const char *tag, const char *type)
{
	if ((p = soap_in__xop__Include(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _xop__Include * SOAP_FMAC2 soap_instantiate__xop__Include(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__xop__Include(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__xop__Include, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _xop__Include);
		if (size)
			*size = sizeof(struct _xop__Include);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct _xop__Include[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _xop__Include);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _xop__Include*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__xop__Include(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _xop__Include %p -> %p\n", q, p));
	*(struct _xop__Include*)p = *(struct _xop__Include*)q;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyAttribute(struct soap *soap, const struct soap_dom_attribute *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyAttribute);
	if (soap_out_xsd__anyAttribute(soap, tag?tag:"xsd:anyAttribute", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct soap_dom_attribute * SOAP_FMAC4 soap_get_xsd__anyAttribute(struct soap *soap, struct soap_dom_attribute *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct soap_dom_attribute * SOAP_FMAC2 soap_instantiate_xsd__anyAttribute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyAttribute(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyAttribute, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct soap_dom_attribute);
		if (size)
			*size = sizeof(struct soap_dom_attribute);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct soap_dom_attribute[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct soap_dom_attribute);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct soap_dom_attribute*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyAttribute(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct soap_dom_attribute %p -> %p\n", q, p));
	*(struct soap_dom_attribute*)p = *(struct soap_dom_attribute*)q;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyType(struct soap *soap, const struct soap_dom_element *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyType);
	if (soap_out_xsd__anyType(soap, tag?tag:"xsd:anyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct soap_dom_element * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, struct soap_dom_element *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct soap_dom_element * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct soap_dom_element);
		if (size)
			*size = sizeof(struct soap_dom_element);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct soap_dom_element[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct soap_dom_element);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct soap_dom_element*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct soap_dom_element %p -> %p\n", q, p));
	*(struct soap_dom_element*)p = *(struct soap_dom_element*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_EventStream(struct soap *soap, int choice, const union _tt__union_EventStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_EventStream_wsnb__NotificationMessage:
		soap_serialize_PointerTowsnb__NotificationMessageHolderType(soap, &a->wsnb__NotificationMessage);
		break;
	case SOAP_UNION__tt__union_EventStream_Extension:
		soap_serialize_PointerTott__EventStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_EventStream(struct soap *soap, int choice, const union _tt__union_EventStream *a)
{
	switch (choice)
	{
	case SOAP_UNION__tt__union_EventStream_wsnb__NotificationMessage:
		return soap_out_PointerTowsnb__NotificationMessageHolderType(soap, "wsnb:NotificationMessage", -1, &a->wsnb__NotificationMessage, "");
	case SOAP_UNION__tt__union_EventStream_Extension:
		return soap_out_PointerTott__EventStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_EventStream * SOAP_FMAC4 soap_in__tt__union_EventStream(struct soap *soap, int *choice, union _tt__union_EventStream *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->wsnb__NotificationMessage = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTowsnb__NotificationMessageHolderType(soap, "wsnb:NotificationMessage", &a->wsnb__NotificationMessage, "wsnb:NotificationMessageHolderType"))
	{	*choice = SOAP_UNION__tt__union_EventStream_wsnb__NotificationMessage;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__EventStreamExtension(soap, "tt:Extension", &a->Extension, "tt:EventStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_EventStream_Extension;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_PTZStream(struct soap *soap, int choice, const union _tt__union_PTZStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_PTZStream_PTZStatus:
		soap_serialize_PointerTott__PTZStatus(soap, &a->PTZStatus);
		break;
	case SOAP_UNION__tt__union_PTZStream_Extension:
		soap_serialize_PointerTott__PTZStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_PTZStream(struct soap *soap, int choice, const union _tt__union_PTZStream *a)
{
	switch (choice)
	{
	case SOAP_UNION__tt__union_PTZStream_PTZStatus:
		return soap_out_PointerTott__PTZStatus(soap, "tt:PTZStatus", -1, &a->PTZStatus, "");
	case SOAP_UNION__tt__union_PTZStream_Extension:
		return soap_out_PointerTott__PTZStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_PTZStream * SOAP_FMAC4 soap_in__tt__union_PTZStream(struct soap *soap, int *choice, union _tt__union_PTZStream *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->PTZStatus = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZStatus(soap, "tt:PTZStatus", &a->PTZStatus, "tt:PTZStatus"))
	{	*choice = SOAP_UNION__tt__union_PTZStream_PTZStatus;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZStreamExtension(soap, "tt:Extension", &a->Extension, "tt:PTZStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_PTZStream_Extension;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_VideoAnalyticsStream(struct soap *soap, int choice, const union _tt__union_VideoAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Frame:
		soap_serialize_PointerTott__Frame(soap, &a->Frame);
		break;
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Extension:
		soap_serialize_PointerTott__VideoAnalyticsStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_VideoAnalyticsStream(struct soap *soap, int choice, const union _tt__union_VideoAnalyticsStream *a)
{
	switch (choice)
	{
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Frame:
		return soap_out_PointerTott__Frame(soap, "tt:Frame", -1, &a->Frame, "");
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Extension:
		return soap_out_PointerTott__VideoAnalyticsStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_VideoAnalyticsStream * SOAP_FMAC4 soap_in__tt__union_VideoAnalyticsStream(struct soap *soap, int *choice, union _tt__union_VideoAnalyticsStream *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->Frame = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__Frame(soap, "tt:Frame", &a->Frame, "tt:Frame"))
	{	*choice = SOAP_UNION__tt__union_VideoAnalyticsStream_Frame;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__VideoAnalyticsStreamExtension(soap, "tt:Extension", &a->Extension, "tt:VideoAnalyticsStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_VideoAnalyticsStream_Extension;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_MetadataStream(struct soap *soap, int choice, const union _tt__union_MetadataStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_MetadataStream_VideoAnalytics:
		soap_serialize_PointerTott__VideoAnalyticsStream(soap, &a->VideoAnalytics);
		break;
	case SOAP_UNION__tt__union_MetadataStream_PTZ:
		soap_serialize_PointerTott__PTZStream(soap, &a->PTZ);
		break;
	case SOAP_UNION__tt__union_MetadataStream_Event:
		soap_serialize_PointerTott__EventStream(soap, &a->Event);
		break;
	case SOAP_UNION__tt__union_MetadataStream_Extension:
		soap_serialize_PointerTott__MetadataStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_MetadataStream(struct soap *soap, int choice, const union _tt__union_MetadataStream *a)
{
	switch (choice)
	{
	case SOAP_UNION__tt__union_MetadataStream_VideoAnalytics:
		return soap_out_PointerTott__VideoAnalyticsStream(soap, "tt:VideoAnalytics", -1, &a->VideoAnalytics, "");
	case SOAP_UNION__tt__union_MetadataStream_PTZ:
		return soap_out_PointerTott__PTZStream(soap, "tt:PTZ", -1, &a->PTZ, "");
	case SOAP_UNION__tt__union_MetadataStream_Event:
		return soap_out_PointerTott__EventStream(soap, "tt:Event", -1, &a->Event, "");
	case SOAP_UNION__tt__union_MetadataStream_Extension:
		return soap_out_PointerTott__MetadataStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_MetadataStream * SOAP_FMAC4 soap_in__tt__union_MetadataStream(struct soap *soap, int *choice, union _tt__union_MetadataStream *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->VideoAnalytics = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__VideoAnalyticsStream(soap, "tt:VideoAnalytics", &a->VideoAnalytics, "tt:VideoAnalyticsStream"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_VideoAnalytics;
		return a;
	}
	a->PTZ = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZStream(soap, "tt:PTZ", &a->PTZ, "tt:PTZStream"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_PTZ;
		return a;
	}
	a->Event = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__EventStream(soap, "tt:Event", &a->Event, "tt:EventStream"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_Event;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__MetadataStreamExtension(soap, "tt:Extension", &a->Extension, "tt:MetadataStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_Extension;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__ModifyAnalyticsModulesResponse(struct soap *soap, _tan__ModifyAnalyticsModulesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__ModifyAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, _tan__ModifyAnalyticsModulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tan__ModifyAnalyticsModulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__ModifyAnalyticsModulesResponse(struct soap *soap, const char *tag, _tan__ModifyAnalyticsModulesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tan__ModifyAnalyticsModulesResponse **)soap_malloc(soap, sizeof(_tan__ModifyAnalyticsModulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tan__ModifyAnalyticsModulesResponse *)soap_instantiate__tan__ModifyAnalyticsModulesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tan__ModifyAnalyticsModulesResponse ** p = (_tan__ModifyAnalyticsModulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse, sizeof(_tan__ModifyAnalyticsModulesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__ModifyAnalyticsModulesResponse(struct soap *soap, _tan__ModifyAnalyticsModulesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__ModifyAnalyticsModulesResponse);
	if (soap_out_PointerTo_tan__ModifyAnalyticsModulesResponse(soap, tag?tag:"tan:ModifyAnalyticsModulesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tan__ModifyAnalyticsModulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__ModifyAnalyticsModulesResponse(struct soap *soap, _tan__ModifyAnalyticsModulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__ModifyAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__ModifyAnalyticsModules(struct soap *soap, _tan__ModifyAnalyticsModules *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__ModifyAnalyticsModules))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__ModifyAnalyticsModules(struct soap *soap, const char *tag, int id, _tan__ModifyAnalyticsModules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__ModifyAnalyticsModules);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tan__ModifyAnalyticsModules ** SOAP_FMAC4 soap_in_PointerTo_tan__ModifyAnalyticsModules(struct soap *soap, const char *tag, _tan__ModifyAnalyticsModules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tan__ModifyAnalyticsModules **)soap_malloc(soap, sizeof(_tan__ModifyAnalyticsModules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tan__ModifyAnalyticsModules *)soap_instantiate__tan__ModifyAnalyticsModules(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tan__ModifyAnalyticsModules ** p = (_tan__ModifyAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__ModifyAnalyticsModules, sizeof(_tan__ModifyAnalyticsModules), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__ModifyAnalyticsModules(struct soap *soap, _tan__ModifyAnalyticsModules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__ModifyAnalyticsModules);
	if (soap_out_PointerTo_tan__ModifyAnalyticsModules(soap, tag?tag:"tan:ModifyAnalyticsModules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tan__ModifyAnalyticsModules ** SOAP_FMAC4 soap_get_PointerTo_tan__ModifyAnalyticsModules(struct soap *soap, _tan__ModifyAnalyticsModules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__ModifyAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetAnalyticsModulesResponse(struct soap *soap, _tan__GetAnalyticsModulesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetAnalyticsModulesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, _tan__GetAnalyticsModulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetAnalyticsModulesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tan__GetAnalyticsModulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__GetAnalyticsModulesResponse(struct soap *soap, const char *tag, _tan__GetAnalyticsModulesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tan__GetAnalyticsModulesResponse **)soap_malloc(soap, sizeof(_tan__GetAnalyticsModulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tan__GetAnalyticsModulesResponse *)soap_instantiate__tan__GetAnalyticsModulesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tan__GetAnalyticsModulesResponse ** p = (_tan__GetAnalyticsModulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetAnalyticsModulesResponse, sizeof(_tan__GetAnalyticsModulesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetAnalyticsModulesResponse(struct soap *soap, _tan__GetAnalyticsModulesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__GetAnalyticsModulesResponse);
	if (soap_out_PointerTo_tan__GetAnalyticsModulesResponse(soap, tag?tag:"tan:GetAnalyticsModulesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tan__GetAnalyticsModulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__GetAnalyticsModulesResponse(struct soap *soap, _tan__GetAnalyticsModulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetAnalyticsModules(struct soap *soap, _tan__GetAnalyticsModules *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetAnalyticsModules))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetAnalyticsModules(struct soap *soap, const char *tag, int id, _tan__GetAnalyticsModules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetAnalyticsModules);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tan__GetAnalyticsModules ** SOAP_FMAC4 soap_in_PointerTo_tan__GetAnalyticsModules(struct soap *soap, const char *tag, _tan__GetAnalyticsModules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tan__GetAnalyticsModules **)soap_malloc(soap, sizeof(_tan__GetAnalyticsModules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tan__GetAnalyticsModules *)soap_instantiate__tan__GetAnalyticsModules(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tan__GetAnalyticsModules ** p = (_tan__GetAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetAnalyticsModules, sizeof(_tan__GetAnalyticsModules), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetAnalyticsModules(struct soap *soap, _tan__GetAnalyticsModules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__GetAnalyticsModules);
	if (soap_out_PointerTo_tan__GetAnalyticsModules(soap, tag?tag:"tan:GetAnalyticsModules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tan__GetAnalyticsModules ** SOAP_FMAC4 soap_get_PointerTo_tan__GetAnalyticsModules(struct soap *soap, _tan__GetAnalyticsModules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__DeleteAnalyticsModulesResponse(struct soap *soap, _tan__DeleteAnalyticsModulesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__DeleteAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, _tan__DeleteAnalyticsModulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tan__DeleteAnalyticsModulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__DeleteAnalyticsModulesResponse(struct soap *soap, const char *tag, _tan__DeleteAnalyticsModulesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tan__DeleteAnalyticsModulesResponse **)soap_malloc(soap, sizeof(_tan__DeleteAnalyticsModulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tan__DeleteAnalyticsModulesResponse *)soap_instantiate__tan__DeleteAnalyticsModulesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tan__DeleteAnalyticsModulesResponse ** p = (_tan__DeleteAnalyticsModulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse, sizeof(_tan__DeleteAnalyticsModulesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__DeleteAnalyticsModulesResponse(struct soap *soap, _tan__DeleteAnalyticsModulesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__DeleteAnalyticsModulesResponse);
	if (soap_out_PointerTo_tan__DeleteAnalyticsModulesResponse(soap, tag?tag:"tan:DeleteAnalyticsModulesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tan__DeleteAnalyticsModulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__DeleteAnalyticsModulesResponse(struct soap *soap, _tan__DeleteAnalyticsModulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__DeleteAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__DeleteAnalyticsModules(struct soap *soap, _tan__DeleteAnalyticsModules *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__DeleteAnalyticsModules))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__DeleteAnalyticsModules(struct soap *soap, const char *tag, int id, _tan__DeleteAnalyticsModules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__DeleteAnalyticsModules);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tan__DeleteAnalyticsModules ** SOAP_FMAC4 soap_in_PointerTo_tan__DeleteAnalyticsModules(struct soap *soap, const char *tag, _tan__DeleteAnalyticsModules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tan__DeleteAnalyticsModules **)soap_malloc(soap, sizeof(_tan__DeleteAnalyticsModules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tan__DeleteAnalyticsModules *)soap_instantiate__tan__DeleteAnalyticsModules(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tan__DeleteAnalyticsModules ** p = (_tan__DeleteAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__DeleteAnalyticsModules, sizeof(_tan__DeleteAnalyticsModules), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__DeleteAnalyticsModules(struct soap *soap, _tan__DeleteAnalyticsModules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__DeleteAnalyticsModules);
	if (soap_out_PointerTo_tan__DeleteAnalyticsModules(soap, tag?tag:"tan:DeleteAnalyticsModules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tan__DeleteAnalyticsModules ** SOAP_FMAC4 soap_get_PointerTo_tan__DeleteAnalyticsModules(struct soap *soap, _tan__DeleteAnalyticsModules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__DeleteAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__CreateAnalyticsModulesResponse(struct soap *soap, _tan__CreateAnalyticsModulesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__CreateAnalyticsModulesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__CreateAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, _tan__CreateAnalyticsModulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__CreateAnalyticsModulesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tan__CreateAnalyticsModulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__CreateAnalyticsModulesResponse(struct soap *soap, const char *tag, _tan__CreateAnalyticsModulesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tan__CreateAnalyticsModulesResponse **)soap_malloc(soap, sizeof(_tan__CreateAnalyticsModulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tan__CreateAnalyticsModulesResponse *)soap_instantiate__tan__CreateAnalyticsModulesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tan__CreateAnalyticsModulesResponse ** p = (_tan__CreateAnalyticsModulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__CreateAnalyticsModulesResponse, sizeof(_tan__CreateAnalyticsModulesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__CreateAnalyticsModulesResponse(struct soap *soap, _tan__CreateAnalyticsModulesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__CreateAnalyticsModulesResponse);
	if (soap_out_PointerTo_tan__CreateAnalyticsModulesResponse(soap, tag?tag:"tan:CreateAnalyticsModulesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tan__CreateAnalyticsModulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__CreateAnalyticsModulesResponse(struct soap *soap, _tan__CreateAnalyticsModulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__CreateAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__CreateAnalyticsModules(struct soap *soap, _tan__CreateAnalyticsModules *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__CreateAnalyticsModules))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__CreateAnalyticsModules(struct soap *soap, const char *tag, int id, _tan__CreateAnalyticsModules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__CreateAnalyticsModules);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tan__CreateAnalyticsModules ** SOAP_FMAC4 soap_in_PointerTo_tan__CreateAnalyticsModules(struct soap *soap, const char *tag, _tan__CreateAnalyticsModules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tan__CreateAnalyticsModules **)soap_malloc(soap, sizeof(_tan__CreateAnalyticsModules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tan__CreateAnalyticsModules *)soap_instantiate__tan__CreateAnalyticsModules(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tan__CreateAnalyticsModules ** p = (_tan__CreateAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__CreateAnalyticsModules, sizeof(_tan__CreateAnalyticsModules), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__CreateAnalyticsModules(struct soap *soap, _tan__CreateAnalyticsModules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__CreateAnalyticsModules);
	if (soap_out_PointerTo_tan__CreateAnalyticsModules(soap, tag?tag:"tan:CreateAnalyticsModules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tan__CreateAnalyticsModules ** SOAP_FMAC4 soap_get_PointerTo_tan__CreateAnalyticsModules(struct soap *soap, _tan__CreateAnalyticsModules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__CreateAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, _tan__GetSupportedAnalyticsModulesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, _tan__GetSupportedAnalyticsModulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tan__GetSupportedAnalyticsModulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, const char *tag, _tan__GetSupportedAnalyticsModulesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tan__GetSupportedAnalyticsModulesResponse **)soap_malloc(soap, sizeof(_tan__GetSupportedAnalyticsModulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tan__GetSupportedAnalyticsModulesResponse *)soap_instantiate__tan__GetSupportedAnalyticsModulesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tan__GetSupportedAnalyticsModulesResponse ** p = (_tan__GetSupportedAnalyticsModulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse, sizeof(_tan__GetSupportedAnalyticsModulesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, _tan__GetSupportedAnalyticsModulesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__GetSupportedAnalyticsModulesResponse);
	if (soap_out_PointerTo_tan__GetSupportedAnalyticsModulesResponse(soap, tag?tag:"tan:GetSupportedAnalyticsModulesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tan__GetSupportedAnalyticsModulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, _tan__GetSupportedAnalyticsModulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetSupportedAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetSupportedAnalyticsModules(struct soap *soap, _tan__GetSupportedAnalyticsModules *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetSupportedAnalyticsModules))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetSupportedAnalyticsModules(struct soap *soap, const char *tag, int id, _tan__GetSupportedAnalyticsModules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetSupportedAnalyticsModules);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tan__GetSupportedAnalyticsModules ** SOAP_FMAC4 soap_in_PointerTo_tan__GetSupportedAnalyticsModules(struct soap *soap, const char *tag, _tan__GetSupportedAnalyticsModules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tan__GetSupportedAnalyticsModules **)soap_malloc(soap, sizeof(_tan__GetSupportedAnalyticsModules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tan__GetSupportedAnalyticsModules *)soap_instantiate__tan__GetSupportedAnalyticsModules(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tan__GetSupportedAnalyticsModules ** p = (_tan__GetSupportedAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetSupportedAnalyticsModules, sizeof(_tan__GetSupportedAnalyticsModules), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetSupportedAnalyticsModules(struct soap *soap, _tan__GetSupportedAnalyticsModules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__GetSupportedAnalyticsModules);
	if (soap_out_PointerTo_tan__GetSupportedAnalyticsModules(soap, tag?tag:"tan:GetSupportedAnalyticsModules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tan__GetSupportedAnalyticsModules ** SOAP_FMAC4 soap_get_PointerTo_tan__GetSupportedAnalyticsModules(struct soap *soap, _tan__GetSupportedAnalyticsModules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetSupportedAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__ModifyRulesResponse(struct soap *soap, _tan__ModifyRulesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__ModifyRulesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__ModifyRulesResponse(struct soap *soap, const char *tag, int id, _tan__ModifyRulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__ModifyRulesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tan__ModifyRulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__ModifyRulesResponse(struct soap *soap, const char *tag, _tan__ModifyRulesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tan__ModifyRulesResponse **)soap_malloc(soap, sizeof(_tan__ModifyRulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tan__ModifyRulesResponse *)soap_instantiate__tan__ModifyRulesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tan__ModifyRulesResponse ** p = (_tan__ModifyRulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__ModifyRulesResponse, sizeof(_tan__ModifyRulesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__ModifyRulesResponse(struct soap *soap, _tan__ModifyRulesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__ModifyRulesResponse);
	if (soap_out_PointerTo_tan__ModifyRulesResponse(soap, tag?tag:"tan:ModifyRulesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tan__ModifyRulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__ModifyRulesResponse(struct soap *soap, _tan__ModifyRulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__ModifyRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__ModifyRules(struct soap *soap, _tan__ModifyRules *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__ModifyRules))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__ModifyRules(struct soap *soap, const char *tag, int id, _tan__ModifyRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__ModifyRules);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tan__ModifyRules ** SOAP_FMAC4 soap_in_PointerTo_tan__ModifyRules(struct soap *soap, const char *tag, _tan__ModifyRules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tan__ModifyRules **)soap_malloc(soap, sizeof(_tan__ModifyRules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tan__ModifyRules *)soap_instantiate__tan__ModifyRules(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tan__ModifyRules ** p = (_tan__ModifyRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__ModifyRules, sizeof(_tan__ModifyRules), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__ModifyRules(struct soap *soap, _tan__ModifyRules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__ModifyRules);
	if (soap_out_PointerTo_tan__ModifyRules(soap, tag?tag:"tan:ModifyRules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tan__ModifyRules ** SOAP_FMAC4 soap_get_PointerTo_tan__ModifyRules(struct soap *soap, _tan__ModifyRules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__ModifyRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetRulesResponse(struct soap *soap, _tan__GetRulesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetRulesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetRulesResponse(struct soap *soap, const char *tag, int id, _tan__GetRulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetRulesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tan__GetRulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__GetRulesResponse(struct soap *soap, const char *tag, _tan__GetRulesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tan__GetRulesResponse **)soap_malloc(soap, sizeof(_tan__GetRulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tan__GetRulesResponse *)soap_instantiate__tan__GetRulesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tan__GetRulesResponse ** p = (_tan__GetRulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetRulesResponse, sizeof(_tan__GetRulesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetRulesResponse(struct soap *soap, _tan__GetRulesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__GetRulesResponse);
	if (soap_out_PointerTo_tan__GetRulesResponse(soap, tag?tag:"tan:GetRulesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tan__GetRulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__GetRulesResponse(struct soap *soap, _tan__GetRulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetRules(struct soap *soap, _tan__GetRules *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetRules))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetRules(struct soap *soap, const char *tag, int id, _tan__GetRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetRules);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tan__GetRules ** SOAP_FMAC4 soap_in_PointerTo_tan__GetRules(struct soap *soap, const char *tag, _tan__GetRules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tan__GetRules **)soap_malloc(soap, sizeof(_tan__GetRules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tan__GetRules *)soap_instantiate__tan__GetRules(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tan__GetRules ** p = (_tan__GetRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetRules, sizeof(_tan__GetRules), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetRules(struct soap *soap, _tan__GetRules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__GetRules);
	if (soap_out_PointerTo_tan__GetRules(soap, tag?tag:"tan:GetRules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tan__GetRules ** SOAP_FMAC4 soap_get_PointerTo_tan__GetRules(struct soap *soap, _tan__GetRules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__DeleteRulesResponse(struct soap *soap, _tan__DeleteRulesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__DeleteRulesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__DeleteRulesResponse(struct soap *soap, const char *tag, int id, _tan__DeleteRulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__DeleteRulesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tan__DeleteRulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__DeleteRulesResponse(struct soap *soap, const char *tag, _tan__DeleteRulesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tan__DeleteRulesResponse **)soap_malloc(soap, sizeof(_tan__DeleteRulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tan__DeleteRulesResponse *)soap_instantiate__tan__DeleteRulesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tan__DeleteRulesResponse ** p = (_tan__DeleteRulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__DeleteRulesResponse, sizeof(_tan__DeleteRulesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__DeleteRulesResponse(struct soap *soap, _tan__DeleteRulesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__DeleteRulesResponse);
	if (soap_out_PointerTo_tan__DeleteRulesResponse(soap, tag?tag:"tan:DeleteRulesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tan__DeleteRulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__DeleteRulesResponse(struct soap *soap, _tan__DeleteRulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__DeleteRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__DeleteRules(struct soap *soap, _tan__DeleteRules *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__DeleteRules))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__DeleteRules(struct soap *soap, const char *tag, int id, _tan__DeleteRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__DeleteRules);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tan__DeleteRules ** SOAP_FMAC4 soap_in_PointerTo_tan__DeleteRules(struct soap *soap, const char *tag, _tan__DeleteRules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tan__DeleteRules **)soap_malloc(soap, sizeof(_tan__DeleteRules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tan__DeleteRules *)soap_instantiate__tan__DeleteRules(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tan__DeleteRules ** p = (_tan__DeleteRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__DeleteRules, sizeof(_tan__DeleteRules), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__DeleteRules(struct soap *soap, _tan__DeleteRules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__DeleteRules);
	if (soap_out_PointerTo_tan__DeleteRules(soap, tag?tag:"tan:DeleteRules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tan__DeleteRules ** SOAP_FMAC4 soap_get_PointerTo_tan__DeleteRules(struct soap *soap, _tan__DeleteRules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__DeleteRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__CreateRulesResponse(struct soap *soap, _tan__CreateRulesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__CreateRulesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__CreateRulesResponse(struct soap *soap, const char *tag, int id, _tan__CreateRulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__CreateRulesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tan__CreateRulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__CreateRulesResponse(struct soap *soap, const char *tag, _tan__CreateRulesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tan__CreateRulesResponse **)soap_malloc(soap, sizeof(_tan__CreateRulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tan__CreateRulesResponse *)soap_instantiate__tan__CreateRulesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tan__CreateRulesResponse ** p = (_tan__CreateRulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__CreateRulesResponse, sizeof(_tan__CreateRulesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__CreateRulesResponse(struct soap *soap, _tan__CreateRulesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__CreateRulesResponse);
	if (soap_out_PointerTo_tan__CreateRulesResponse(soap, tag?tag:"tan:CreateRulesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tan__CreateRulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__CreateRulesResponse(struct soap *soap, _tan__CreateRulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__CreateRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__CreateRules(struct soap *soap, _tan__CreateRules *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__CreateRules))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__CreateRules(struct soap *soap, const char *tag, int id, _tan__CreateRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__CreateRules);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tan__CreateRules ** SOAP_FMAC4 soap_in_PointerTo_tan__CreateRules(struct soap *soap, const char *tag, _tan__CreateRules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tan__CreateRules **)soap_malloc(soap, sizeof(_tan__CreateRules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tan__CreateRules *)soap_instantiate__tan__CreateRules(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tan__CreateRules ** p = (_tan__CreateRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__CreateRules, sizeof(_tan__CreateRules), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__CreateRules(struct soap *soap, _tan__CreateRules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__CreateRules);
	if (soap_out_PointerTo_tan__CreateRules(soap, tag?tag:"tan:CreateRules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tan__CreateRules ** SOAP_FMAC4 soap_get_PointerTo_tan__CreateRules(struct soap *soap, _tan__CreateRules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__CreateRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetSupportedRulesResponse(struct soap *soap, _tan__GetSupportedRulesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetSupportedRulesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetSupportedRulesResponse(struct soap *soap, const char *tag, int id, _tan__GetSupportedRulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetSupportedRulesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tan__GetSupportedRulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__GetSupportedRulesResponse(struct soap *soap, const char *tag, _tan__GetSupportedRulesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tan__GetSupportedRulesResponse **)soap_malloc(soap, sizeof(_tan__GetSupportedRulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tan__GetSupportedRulesResponse *)soap_instantiate__tan__GetSupportedRulesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tan__GetSupportedRulesResponse ** p = (_tan__GetSupportedRulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetSupportedRulesResponse, sizeof(_tan__GetSupportedRulesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetSupportedRulesResponse(struct soap *soap, _tan__GetSupportedRulesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__GetSupportedRulesResponse);
	if (soap_out_PointerTo_tan__GetSupportedRulesResponse(soap, tag?tag:"tan:GetSupportedRulesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tan__GetSupportedRulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__GetSupportedRulesResponse(struct soap *soap, _tan__GetSupportedRulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetSupportedRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetSupportedRules(struct soap *soap, _tan__GetSupportedRules *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetSupportedRules))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetSupportedRules(struct soap *soap, const char *tag, int id, _tan__GetSupportedRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetSupportedRules);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tan__GetSupportedRules ** SOAP_FMAC4 soap_in_PointerTo_tan__GetSupportedRules(struct soap *soap, const char *tag, _tan__GetSupportedRules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tan__GetSupportedRules **)soap_malloc(soap, sizeof(_tan__GetSupportedRules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tan__GetSupportedRules *)soap_instantiate__tan__GetSupportedRules(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tan__GetSupportedRules ** p = (_tan__GetSupportedRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetSupportedRules, sizeof(_tan__GetSupportedRules), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetSupportedRules(struct soap *soap, _tan__GetSupportedRules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__GetSupportedRules);
	if (soap_out_PointerTo_tan__GetSupportedRules(soap, tag?tag:"tan:GetSupportedRules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tan__GetSupportedRules ** SOAP_FMAC4 soap_get_PointerTo_tan__GetSupportedRules(struct soap *soap, _tan__GetSupportedRules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetSupportedRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__NCName(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__NCName))
		soap_serialize_xsd__NCName(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__NCName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__NCName);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__NCName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__NCName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__NCName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__NCName, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__NCName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__NCName);
	if (soap_out_PointerToxsd__NCName(soap, tag?tag:"xsd:NCName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__NCName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, _wstop__TopicNamespaceType_Topic *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wstop__TopicNamespaceType_Topic))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, int id, _wstop__TopicNamespaceType_Topic *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wstop__TopicNamespaceType_Topic);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _wstop__TopicNamespaceType_Topic ** SOAP_FMAC4 soap_in_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, _wstop__TopicNamespaceType_Topic **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wstop__TopicNamespaceType_Topic **)soap_malloc(soap, sizeof(_wstop__TopicNamespaceType_Topic *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wstop__TopicNamespaceType_Topic *)soap_instantiate__wstop__TopicNamespaceType_Topic(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_wstop__TopicNamespaceType_Topic ** p = (_wstop__TopicNamespaceType_Topic **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wstop__TopicNamespaceType_Topic, sizeof(_wstop__TopicNamespaceType_Topic), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, _wstop__TopicNamespaceType_Topic *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wstop__TopicNamespaceType_Topic);
	if (soap_out_PointerTo_wstop__TopicNamespaceType_Topic(soap, tag?tag:"wstop:TopicNamespaceType-Topic", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wstop__TopicNamespaceType_Topic ** SOAP_FMAC4 soap_get_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, _wstop__TopicNamespaceType_Topic **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wstop__TopicNamespaceType_Topic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__ConcreteTopicExpression(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__ConcreteTopicExpression))
		soap_serialize_wstop__ConcreteTopicExpression(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__ConcreteTopicExpression(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__ConcreteTopicExpression);
	if (id < 0)
		return soap->error;
	return soap_out_wstop__ConcreteTopicExpression(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTowstop__ConcreteTopicExpression(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__ConcreteTopicExpression(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__ConcreteTopicExpression, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__ConcreteTopicExpression(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowstop__ConcreteTopicExpression);
	if (soap_out_PointerTowstop__ConcreteTopicExpression(soap, tag?tag:"wstop:ConcreteTopicExpression", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTowstop__ConcreteTopicExpression(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__ConcreteTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicType(struct soap *soap, wstop__TopicType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__TopicType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicType(struct soap *soap, const char *tag, int id, wstop__TopicType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__TopicType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 wstop__TopicType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicType(struct soap *soap, const char *tag, wstop__TopicType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__TopicType **)soap_malloc(soap, sizeof(wstop__TopicType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__TopicType *)soap_instantiate_wstop__TopicType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	wstop__TopicType ** p = (wstop__TopicType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicType, sizeof(wstop__TopicType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicType(struct soap *soap, wstop__TopicType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowstop__TopicType);
	if (soap_out_PointerTowstop__TopicType(soap, tag?tag:"wstop:TopicType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__TopicType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicType(struct soap *soap, wstop__TopicType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__TopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__QueryExpressionType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__QueryExpressionType(struct soap *soap, const char *tag, int id, wstop__QueryExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__QueryExpressionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 wstop__QueryExpressionType ** SOAP_FMAC4 soap_in_PointerTowstop__QueryExpressionType(struct soap *soap, const char *tag, wstop__QueryExpressionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__QueryExpressionType **)soap_malloc(soap, sizeof(wstop__QueryExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__QueryExpressionType *)soap_instantiate_wstop__QueryExpressionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	wstop__QueryExpressionType ** p = (wstop__QueryExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__QueryExpressionType, sizeof(wstop__QueryExpressionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowstop__QueryExpressionType);
	if (soap_out_PointerTowstop__QueryExpressionType(soap, tag?tag:"wstop:QueryExpressionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__QueryExpressionType ** SOAP_FMAC4 soap_get_PointerTowstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ObjectExtension(struct soap *soap, tt__ObjectExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ObjectExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ObjectExtension(struct soap *soap, const char *tag, int id, tt__ObjectExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ObjectExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ObjectExtension ** SOAP_FMAC4 soap_in_PointerTott__ObjectExtension(struct soap *soap, const char *tag, tt__ObjectExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ObjectExtension **)soap_malloc(soap, sizeof(tt__ObjectExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ObjectExtension *)soap_instantiate_tt__ObjectExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ObjectExtension ** p = (tt__ObjectExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ObjectExtension, sizeof(tt__ObjectExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ObjectExtension(struct soap *soap, tt__ObjectExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ObjectExtension);
	if (soap_out_PointerTott__ObjectExtension(soap, tag?tag:"tt:ObjectExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ObjectExtension ** SOAP_FMAC4 soap_get_PointerTott__ObjectExtension(struct soap *soap, tt__ObjectExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ObjectExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Behaviour(struct soap *soap, tt__Behaviour *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Behaviour))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Behaviour(struct soap *soap, const char *tag, int id, tt__Behaviour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Behaviour);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Behaviour ** SOAP_FMAC4 soap_in_PointerTott__Behaviour(struct soap *soap, const char *tag, tt__Behaviour **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Behaviour **)soap_malloc(soap, sizeof(tt__Behaviour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Behaviour *)soap_instantiate_tt__Behaviour(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Behaviour ** p = (tt__Behaviour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Behaviour, sizeof(tt__Behaviour), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Behaviour(struct soap *soap, tt__Behaviour *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Behaviour);
	if (soap_out_PointerTott__Behaviour(soap, tag?tag:"tt:Behaviour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Behaviour ** SOAP_FMAC4 soap_get_PointerTott__Behaviour(struct soap *soap, tt__Behaviour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Behaviour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Appearance(struct soap *soap, tt__Appearance *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Appearance))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Appearance(struct soap *soap, const char *tag, int id, tt__Appearance *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Appearance);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Appearance ** SOAP_FMAC4 soap_in_PointerTott__Appearance(struct soap *soap, const char *tag, tt__Appearance **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Appearance **)soap_malloc(soap, sizeof(tt__Appearance *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Appearance *)soap_instantiate_tt__Appearance(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Appearance ** p = (tt__Appearance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Appearance, sizeof(tt__Appearance), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Appearance(struct soap *soap, tt__Appearance *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Appearance);
	if (soap_out_PointerTott__Appearance(soap, tag?tag:"tt:Appearance", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Appearance ** SOAP_FMAC4 soap_get_PointerTott__Appearance(struct soap *soap, tt__Appearance **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Appearance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationExtension(struct soap *soap, const char *tag, int id, tt__PTZConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationExtension(struct soap *soap, const char *tag, tt__PTZConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZConfigurationExtension **)soap_malloc(soap, sizeof(tt__PTZConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZConfigurationExtension *)soap_instantiate_tt__PTZConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PTZConfigurationExtension ** p = (tt__PTZConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(tt__PTZConfigurationExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZConfigurationExtension);
	if (soap_out_PointerTott__PTZConfigurationExtension(soap, tag?tag:"tt:PTZConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ZoomLimits(struct soap *soap, tt__ZoomLimits *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ZoomLimits))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ZoomLimits(struct soap *soap, const char *tag, int id, tt__ZoomLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ZoomLimits);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ZoomLimits ** SOAP_FMAC4 soap_in_PointerTott__ZoomLimits(struct soap *soap, const char *tag, tt__ZoomLimits **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ZoomLimits **)soap_malloc(soap, sizeof(tt__ZoomLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ZoomLimits *)soap_instantiate_tt__ZoomLimits(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ZoomLimits ** p = (tt__ZoomLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ZoomLimits, sizeof(tt__ZoomLimits), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ZoomLimits(struct soap *soap, tt__ZoomLimits *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ZoomLimits);
	if (soap_out_PointerTott__ZoomLimits(soap, tag?tag:"tt:ZoomLimits", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ZoomLimits ** SOAP_FMAC4 soap_get_PointerTott__ZoomLimits(struct soap *soap, tt__ZoomLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ZoomLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PanTiltLimits(struct soap *soap, tt__PanTiltLimits *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PanTiltLimits))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PanTiltLimits(struct soap *soap, const char *tag, int id, tt__PanTiltLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PanTiltLimits);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PanTiltLimits ** SOAP_FMAC4 soap_in_PointerTott__PanTiltLimits(struct soap *soap, const char *tag, tt__PanTiltLimits **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PanTiltLimits **)soap_malloc(soap, sizeof(tt__PanTiltLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PanTiltLimits *)soap_instantiate_tt__PanTiltLimits(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PanTiltLimits ** p = (tt__PanTiltLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PanTiltLimits, sizeof(tt__PanTiltLimits), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PanTiltLimits(struct soap *soap, tt__PanTiltLimits *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PanTiltLimits);
	if (soap_out_PointerTott__PanTiltLimits(soap, tag?tag:"tt:PanTiltLimits", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PanTiltLimits ** SOAP_FMAC4 soap_get_PointerTott__PanTiltLimits(struct soap *soap, tt__PanTiltLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PanTiltLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZSpeed(struct soap *soap, tt__PTZSpeed *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZSpeed))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZSpeed(struct soap *soap, const char *tag, int id, tt__PTZSpeed *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZSpeed);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PTZSpeed ** SOAP_FMAC4 soap_in_PointerTott__PTZSpeed(struct soap *soap, const char *tag, tt__PTZSpeed **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZSpeed **)soap_malloc(soap, sizeof(tt__PTZSpeed *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZSpeed *)soap_instantiate_tt__PTZSpeed(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PTZSpeed ** p = (tt__PTZSpeed **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZSpeed, sizeof(tt__PTZSpeed), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZSpeed(struct soap *soap, tt__PTZSpeed *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZSpeed);
	if (soap_out_PointerTott__PTZSpeed(soap, tag?tag:"tt:PTZSpeed", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZSpeed ** SOAP_FMAC4 soap_get_PointerTott__PTZSpeed(struct soap *soap, tt__PTZSpeed **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZNodeExtension(struct soap *soap, tt__PTZNodeExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZNodeExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZNodeExtension(struct soap *soap, const char *tag, int id, tt__PTZNodeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZNodeExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PTZNodeExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZNodeExtension(struct soap *soap, const char *tag, tt__PTZNodeExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZNodeExtension **)soap_malloc(soap, sizeof(tt__PTZNodeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZNodeExtension *)soap_instantiate_tt__PTZNodeExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PTZNodeExtension ** p = (tt__PTZNodeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZNodeExtension, sizeof(tt__PTZNodeExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZNodeExtension(struct soap *soap, tt__PTZNodeExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZNodeExtension);
	if (soap_out_PointerTott__PTZNodeExtension(soap, tag?tag:"tt:PTZNodeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZNodeExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZNodeExtension(struct soap *soap, tt__PTZNodeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZNodeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelayOutputSettings(struct soap *soap, tt__RelayOutputSettings *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelayOutputSettings))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelayOutputSettings(struct soap *soap, const char *tag, int id, tt__RelayOutputSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelayOutputSettings);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__RelayOutputSettings ** SOAP_FMAC4 soap_in_PointerTott__RelayOutputSettings(struct soap *soap, const char *tag, tt__RelayOutputSettings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RelayOutputSettings **)soap_malloc(soap, sizeof(tt__RelayOutputSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RelayOutputSettings *)soap_instantiate_tt__RelayOutputSettings(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__RelayOutputSettings ** p = (tt__RelayOutputSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelayOutputSettings, sizeof(tt__RelayOutputSettings), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelayOutputSettings(struct soap *soap, tt__RelayOutputSettings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RelayOutputSettings);
	if (soap_out_PointerTott__RelayOutputSettings(soap, tag?tag:"tt:RelayOutputSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RelayOutputSettings ** SOAP_FMAC4 soap_get_PointerTott__RelayOutputSettings(struct soap *soap, tt__RelayOutputSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceExtension(struct soap *soap, tt__NetworkInterfaceExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceExtension(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceExtension(struct soap *soap, const char *tag, tt__NetworkInterfaceExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceExtension **)soap_malloc(soap, sizeof(tt__NetworkInterfaceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceExtension *)soap_instantiate_tt__NetworkInterfaceExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__NetworkInterfaceExtension ** p = (tt__NetworkInterfaceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(tt__NetworkInterfaceExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceExtension(struct soap *soap, tt__NetworkInterfaceExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceExtension);
	if (soap_out_PointerTott__NetworkInterfaceExtension(soap, tag?tag:"tt:NetworkInterfaceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceExtension(struct soap *soap, tt__NetworkInterfaceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6NetworkInterface(struct soap *soap, tt__IPv6NetworkInterface *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6NetworkInterface))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6NetworkInterface(struct soap *soap, const char *tag, int id, tt__IPv6NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6NetworkInterface);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__IPv6NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__IPv6NetworkInterface(struct soap *soap, const char *tag, tt__IPv6NetworkInterface **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv6NetworkInterface **)soap_malloc(soap, sizeof(tt__IPv6NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv6NetworkInterface *)soap_instantiate_tt__IPv6NetworkInterface(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__IPv6NetworkInterface ** p = (tt__IPv6NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(tt__IPv6NetworkInterface), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6NetworkInterface(struct soap *soap, tt__IPv6NetworkInterface *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv6NetworkInterface);
	if (soap_out_PointerTott__IPv6NetworkInterface(soap, tag?tag:"tt:IPv6NetworkInterface", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv6NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__IPv6NetworkInterface(struct soap *soap, tt__IPv6NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4NetworkInterface(struct soap *soap, tt__IPv4NetworkInterface *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4NetworkInterface))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4NetworkInterface(struct soap *soap, const char *tag, int id, tt__IPv4NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4NetworkInterface);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__IPv4NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__IPv4NetworkInterface(struct soap *soap, const char *tag, tt__IPv4NetworkInterface **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv4NetworkInterface **)soap_malloc(soap, sizeof(tt__IPv4NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv4NetworkInterface *)soap_instantiate_tt__IPv4NetworkInterface(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__IPv4NetworkInterface ** p = (tt__IPv4NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(tt__IPv4NetworkInterface), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4NetworkInterface(struct soap *soap, tt__IPv4NetworkInterface *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv4NetworkInterface);
	if (soap_out_PointerTott__IPv4NetworkInterface(soap, tag?tag:"tt:IPv4NetworkInterface", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv4NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__IPv4NetworkInterface(struct soap *soap, tt__IPv4NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceLink(struct soap *soap, tt__NetworkInterfaceLink *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceLink))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceLink(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceLink *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceLink);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__NetworkInterfaceLink ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceLink(struct soap *soap, const char *tag, tt__NetworkInterfaceLink **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceLink **)soap_malloc(soap, sizeof(tt__NetworkInterfaceLink *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceLink *)soap_instantiate_tt__NetworkInterfaceLink(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__NetworkInterfaceLink ** p = (tt__NetworkInterfaceLink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(tt__NetworkInterfaceLink), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceLink(struct soap *soap, tt__NetworkInterfaceLink *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceLink);
	if (soap_out_PointerTott__NetworkInterfaceLink(soap, tag?tag:"tt:NetworkInterfaceLink", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceLink ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceLink(struct soap *soap, tt__NetworkInterfaceLink **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceInfo(struct soap *soap, tt__NetworkInterfaceInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceInfo(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__NetworkInterfaceInfo ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceInfo(struct soap *soap, const char *tag, tt__NetworkInterfaceInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceInfo **)soap_malloc(soap, sizeof(tt__NetworkInterfaceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceInfo *)soap_instantiate_tt__NetworkInterfaceInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__NetworkInterfaceInfo ** p = (tt__NetworkInterfaceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(tt__NetworkInterfaceInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceInfo(struct soap *soap, tt__NetworkInterfaceInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceInfo);
	if (soap_out_PointerTott__NetworkInterfaceInfo(soap, tag?tag:"tt:NetworkInterfaceInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceInfo ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceInfo(struct soap *soap, tt__NetworkInterfaceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventSubscription(struct soap *soap, tt__EventSubscription *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventSubscription))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventSubscription(struct soap *soap, const char *tag, int id, tt__EventSubscription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventSubscription);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__EventSubscription ** SOAP_FMAC4 soap_in_PointerTott__EventSubscription(struct soap *soap, const char *tag, tt__EventSubscription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EventSubscription **)soap_malloc(soap, sizeof(tt__EventSubscription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__EventSubscription *)soap_instantiate_tt__EventSubscription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__EventSubscription ** p = (tt__EventSubscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventSubscription, sizeof(tt__EventSubscription), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventSubscription(struct soap *soap, tt__EventSubscription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__EventSubscription);
	if (soap_out_PointerTott__EventSubscription(soap, tag?tag:"tt:EventSubscription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EventSubscription ** SOAP_FMAC4 soap_get_PointerTott__EventSubscription(struct soap *soap, tt__EventSubscription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZFilter(struct soap *soap, tt__PTZFilter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZFilter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZFilter(struct soap *soap, const char *tag, int id, tt__PTZFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZFilter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PTZFilter ** SOAP_FMAC4 soap_in_PointerTott__PTZFilter(struct soap *soap, const char *tag, tt__PTZFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZFilter **)soap_malloc(soap, sizeof(tt__PTZFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZFilter *)soap_instantiate_tt__PTZFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PTZFilter ** p = (tt__PTZFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZFilter, sizeof(tt__PTZFilter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZFilter(struct soap *soap, tt__PTZFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZFilter);
	if (soap_out_PointerTott__PTZFilter(soap, tag?tag:"tt:PTZFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZFilter ** SOAP_FMAC4 soap_get_PointerTott__PTZFilter(struct soap *soap, tt__PTZFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RuleEngineConfiguration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RuleEngineConfiguration(struct soap *soap, const char *tag, int id, tt__RuleEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RuleEngineConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__RuleEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__RuleEngineConfiguration(struct soap *soap, const char *tag, tt__RuleEngineConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RuleEngineConfiguration **)soap_malloc(soap, sizeof(tt__RuleEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RuleEngineConfiguration *)soap_instantiate_tt__RuleEngineConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__RuleEngineConfiguration ** p = (tt__RuleEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(tt__RuleEngineConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RuleEngineConfiguration);
	if (soap_out_PointerTott__RuleEngineConfiguration(soap, tag?tag:"tt:RuleEngineConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RuleEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RuleEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineConfiguration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, int id, tt__AnalyticsEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__AnalyticsEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, tt__AnalyticsEngineConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsEngineConfiguration **)soap_malloc(soap, sizeof(tt__AnalyticsEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsEngineConfiguration *)soap_instantiate_tt__AnalyticsEngineConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__AnalyticsEngineConfiguration ** p = (tt__AnalyticsEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(tt__AnalyticsEngineConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsEngineConfiguration);
	if (soap_out_PointerTott__AnalyticsEngineConfiguration(soap, tag?tag:"tt:AnalyticsEngineConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MulticastConfiguration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MulticastConfiguration(struct soap *soap, const char *tag, int id, tt__MulticastConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MulticastConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__MulticastConfiguration ** SOAP_FMAC4 soap_in_PointerTott__MulticastConfiguration(struct soap *soap, const char *tag, tt__MulticastConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MulticastConfiguration **)soap_malloc(soap, sizeof(tt__MulticastConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MulticastConfiguration *)soap_instantiate_tt__MulticastConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__MulticastConfiguration ** p = (tt__MulticastConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MulticastConfiguration, sizeof(tt__MulticastConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MulticastConfiguration);
	if (soap_out_PointerTott__MulticastConfiguration(soap, tag?tag:"tt:MulticastConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MulticastConfiguration ** SOAP_FMAC4 soap_get_PointerTott__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MulticastConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Configuration(struct soap *soap, tt__H264Configuration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Configuration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Configuration(struct soap *soap, const char *tag, int id, tt__H264Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Configuration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__H264Configuration ** SOAP_FMAC4 soap_in_PointerTott__H264Configuration(struct soap *soap, const char *tag, tt__H264Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__H264Configuration **)soap_malloc(soap, sizeof(tt__H264Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__H264Configuration *)soap_instantiate_tt__H264Configuration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__H264Configuration ** p = (tt__H264Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Configuration, sizeof(tt__H264Configuration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Configuration(struct soap *soap, tt__H264Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__H264Configuration);
	if (soap_out_PointerTott__H264Configuration(soap, tag?tag:"tt:H264Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__H264Configuration ** SOAP_FMAC4 soap_get_PointerTott__H264Configuration(struct soap *soap, tt__H264Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Configuration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Configuration(struct soap *soap, const char *tag, int id, tt__Mpeg4Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Configuration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Mpeg4Configuration ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Configuration(struct soap *soap, const char *tag, tt__Mpeg4Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Mpeg4Configuration **)soap_malloc(soap, sizeof(tt__Mpeg4Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Mpeg4Configuration *)soap_instantiate_tt__Mpeg4Configuration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Mpeg4Configuration ** p = (tt__Mpeg4Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(tt__Mpeg4Configuration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Mpeg4Configuration);
	if (soap_out_PointerTott__Mpeg4Configuration(soap, tag?tag:"tt:Mpeg4Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Mpeg4Configuration ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoRateControl(struct soap *soap, tt__VideoRateControl *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoRateControl))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoRateControl(struct soap *soap, const char *tag, int id, tt__VideoRateControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoRateControl);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__VideoRateControl ** SOAP_FMAC4 soap_in_PointerTott__VideoRateControl(struct soap *soap, const char *tag, tt__VideoRateControl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoRateControl **)soap_malloc(soap, sizeof(tt__VideoRateControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoRateControl *)soap_instantiate_tt__VideoRateControl(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__VideoRateControl ** p = (tt__VideoRateControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoRateControl, sizeof(tt__VideoRateControl), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoRateControl(struct soap *soap, tt__VideoRateControl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoRateControl);
	if (soap_out_PointerTott__VideoRateControl(soap, tag?tag:"tt:VideoRateControl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoRateControl ** SOAP_FMAC4 soap_get_PointerTott__VideoRateControl(struct soap *soap, tt__VideoRateControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoRateControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRectangle(struct soap *soap, tt__IntRectangle *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRectangle))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRectangle(struct soap *soap, const char *tag, int id, tt__IntRectangle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRectangle);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__IntRectangle ** SOAP_FMAC4 soap_in_PointerTott__IntRectangle(struct soap *soap, const char *tag, tt__IntRectangle **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IntRectangle **)soap_malloc(soap, sizeof(tt__IntRectangle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IntRectangle *)soap_instantiate_tt__IntRectangle(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__IntRectangle ** p = (tt__IntRectangle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRectangle, sizeof(tt__IntRectangle), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRectangle(struct soap *soap, tt__IntRectangle *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IntRectangle);
	if (soap_out_PointerTott__IntRectangle(soap, tag?tag:"tt:IntRectangle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IntRectangle ** SOAP_FMAC4 soap_get_PointerTott__IntRectangle(struct soap *soap, tt__IntRectangle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceExtension(struct soap *soap, tt__VideoSourceExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceExtension(struct soap *soap, const char *tag, int id, tt__VideoSourceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__VideoSourceExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceExtension(struct soap *soap, const char *tag, tt__VideoSourceExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoSourceExtension **)soap_malloc(soap, sizeof(tt__VideoSourceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoSourceExtension *)soap_instantiate_tt__VideoSourceExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__VideoSourceExtension ** p = (tt__VideoSourceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceExtension, sizeof(tt__VideoSourceExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceExtension(struct soap *soap, tt__VideoSourceExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoSourceExtension);
	if (soap_out_PointerTott__VideoSourceExtension(soap, tag?tag:"tt:VideoSourceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoSourceExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceExtension(struct soap *soap, tt__VideoSourceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettings(struct soap *soap, tt__ImagingSettings *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettings))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettings(struct soap *soap, const char *tag, int id, tt__ImagingSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettings);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ImagingSettings ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettings(struct soap *soap, const char *tag, tt__ImagingSettings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingSettings **)soap_malloc(soap, sizeof(tt__ImagingSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingSettings *)soap_instantiate_tt__ImagingSettings(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ImagingSettings ** p = (tt__ImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettings, sizeof(tt__ImagingSettings), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettings(struct soap *soap, tt__ImagingSettings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingSettings);
	if (soap_out_PointerTott__ImagingSettings(soap, tag?tag:"tt:ImagingSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingSettings ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettings(struct soap *soap, tt__ImagingSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__Documentation(struct soap *soap, wstop__Documentation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__Documentation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__Documentation(struct soap *soap, const char *tag, int id, wstop__Documentation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__Documentation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 wstop__Documentation ** SOAP_FMAC4 soap_in_PointerTowstop__Documentation(struct soap *soap, const char *tag, wstop__Documentation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__Documentation **)soap_malloc(soap, sizeof(wstop__Documentation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__Documentation *)soap_instantiate_wstop__Documentation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	wstop__Documentation ** p = (wstop__Documentation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__Documentation, sizeof(wstop__Documentation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__Documentation(struct soap *soap, wstop__Documentation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowstop__Documentation);
	if (soap_out_PointerTowstop__Documentation(soap, tag?tag:"wstop:Documentation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__Documentation ** SOAP_FMAC4 soap_get_PointerTowstop__Documentation(struct soap *soap, wstop__Documentation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__Documentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, int id, _wsrfbf__BaseFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsrfbf__BaseFaultType_FaultCause **)soap_malloc(soap, sizeof(_wsrfbf__BaseFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsrfbf__BaseFaultType_FaultCause *)soap_instantiate__wsrfbf__BaseFaultType_FaultCause(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_wsrfbf__BaseFaultType_FaultCause ** p = (_wsrfbf__BaseFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(_wsrfbf__BaseFaultType_FaultCause), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause);
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag?tag:"wsrfbf:BaseFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, _wsrfbf__BaseFaultType_Description *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_Description))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, int id, _wsrfbf__BaseFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsrfbf__BaseFaultType_Description **)soap_malloc(soap, sizeof(_wsrfbf__BaseFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsrfbf__BaseFaultType_Description *)soap_instantiate__wsrfbf__BaseFaultType_Description(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_wsrfbf__BaseFaultType_Description ** p = (_wsrfbf__BaseFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_Description, sizeof(_wsrfbf__BaseFaultType_Description), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, _wsrfbf__BaseFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_Description);
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_Description(soap, tag?tag:"wsrfbf:BaseFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, _wsrfbf__BaseFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xml__lang(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__xml__lang))
		soap_serialize__xml__lang(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xml__lang(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__xml__lang);
	if (id < 0)
		return soap->error;
	return soap_out__xml__lang(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTo_xml__lang(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__xml__lang(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xml__lang, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xml__lang(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_xml__lang);
	if (soap_out_PointerTo_xml__lang(soap, tag?tag:"xml:lang", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTo_xml__lang(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_xml__lang(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, int id, _wsrfbf__BaseFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsrfbf__BaseFaultType_ErrorCode **)soap_malloc(soap, sizeof(_wsrfbf__BaseFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsrfbf__BaseFaultType_ErrorCode *)soap_instantiate__wsrfbf__BaseFaultType_ErrorCode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_wsrfbf__BaseFaultType_ErrorCode ** p = (_wsrfbf__BaseFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(_wsrfbf__BaseFaultType_ErrorCode), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode);
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag?tag:"wsrfbf:BaseFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__nonNegativeInteger))
		soap_serialize_xsd__nonNegativeInteger(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__nonNegativeInteger);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__nonNegativeInteger(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__nonNegativeInteger);
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, tag?tag:"xsd:nonNegativeInteger", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnb__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnb__Subscribe_SubscriptionPolicy *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnb__Subscribe_SubscriptionPolicy))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnb__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, _wsnb__Subscribe_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnb__Subscribe_SubscriptionPolicy);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _wsnb__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_wsnb__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, _wsnb__Subscribe_SubscriptionPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsnb__Subscribe_SubscriptionPolicy **)soap_malloc(soap, sizeof(_wsnb__Subscribe_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsnb__Subscribe_SubscriptionPolicy *)soap_instantiate__wsnb__Subscribe_SubscriptionPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_wsnb__Subscribe_SubscriptionPolicy ** p = (_wsnb__Subscribe_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnb__Subscribe_SubscriptionPolicy, sizeof(_wsnb__Subscribe_SubscriptionPolicy), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnb__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnb__Subscribe_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnb__Subscribe_SubscriptionPolicy);
	if (soap_out_PointerTo_wsnb__Subscribe_SubscriptionPolicy(soap, tag?tag:"wsnb:Subscribe-SubscriptionPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsnb__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_wsnb__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnb__Subscribe_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnb__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnb__AbsoluteOrRelativeTimeType(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnb__AbsoluteOrRelativeTimeType))
		soap_serialize_wsnb__AbsoluteOrRelativeTimeType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnb__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnb__AbsoluteOrRelativeTimeType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnb__AbsoluteOrRelativeTimeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTowsnb__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnb__AbsoluteOrRelativeTimeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnb__AbsoluteOrRelativeTimeType, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnb__AbsoluteOrRelativeTimeType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnb__AbsoluteOrRelativeTimeType);
	if (soap_out_PointerTowsnb__AbsoluteOrRelativeTimeType(soap, tag?tag:"wsnb:AbsoluteOrRelativeTimeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTowsnb__AbsoluteOrRelativeTimeType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnb__AbsoluteOrRelativeTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnb__SubscriptionPolicyType(struct soap *soap, wsnb__SubscriptionPolicyType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnb__SubscriptionPolicyType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnb__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, wsnb__SubscriptionPolicyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnb__SubscriptionPolicyType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 wsnb__SubscriptionPolicyType ** SOAP_FMAC4 soap_in_PointerTowsnb__SubscriptionPolicyType(struct soap *soap, const char *tag, wsnb__SubscriptionPolicyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnb__SubscriptionPolicyType **)soap_malloc(soap, sizeof(wsnb__SubscriptionPolicyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnb__SubscriptionPolicyType *)soap_instantiate_wsnb__SubscriptionPolicyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	wsnb__SubscriptionPolicyType ** p = (wsnb__SubscriptionPolicyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnb__SubscriptionPolicyType, sizeof(wsnb__SubscriptionPolicyType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnb__SubscriptionPolicyType(struct soap *soap, wsnb__SubscriptionPolicyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnb__SubscriptionPolicyType);
	if (soap_out_PointerTowsnb__SubscriptionPolicyType(soap, tag?tag:"wsnb:SubscriptionPolicyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnb__SubscriptionPolicyType ** SOAP_FMAC4 soap_get_PointerTowsnb__SubscriptionPolicyType(struct soap *soap, wsnb__SubscriptionPolicyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnb__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicSetType(struct soap *soap, wstop__TopicSetType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__TopicSetType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicSetType(struct soap *soap, const char *tag, int id, wstop__TopicSetType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__TopicSetType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 wstop__TopicSetType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicSetType(struct soap *soap, const char *tag, wstop__TopicSetType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__TopicSetType **)soap_malloc(soap, sizeof(wstop__TopicSetType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__TopicSetType *)soap_instantiate_wstop__TopicSetType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	wstop__TopicSetType ** p = (wstop__TopicSetType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicSetType, sizeof(wstop__TopicSetType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicSetType(struct soap *soap, wstop__TopicSetType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowstop__TopicSetType);
	if (soap_out_PointerTowstop__TopicSetType(soap, tag?tag:"wstop:TopicSetType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__TopicSetType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicSetType(struct soap *soap, wstop__TopicSetType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__TopicSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnb__TopicExpressionType(struct soap *soap, wsnb__TopicExpressionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnb__TopicExpressionType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnb__TopicExpressionType(struct soap *soap, const char *tag, int id, wsnb__TopicExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnb__TopicExpressionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 wsnb__TopicExpressionType ** SOAP_FMAC4 soap_in_PointerTowsnb__TopicExpressionType(struct soap *soap, const char *tag, wsnb__TopicExpressionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnb__TopicExpressionType **)soap_malloc(soap, sizeof(wsnb__TopicExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnb__TopicExpressionType *)soap_instantiate_wsnb__TopicExpressionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	wsnb__TopicExpressionType ** p = (wsnb__TopicExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnb__TopicExpressionType, sizeof(wsnb__TopicExpressionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnb__TopicExpressionType(struct soap *soap, wsnb__TopicExpressionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnb__TopicExpressionType);
	if (soap_out_PointerTowsnb__TopicExpressionType(soap, tag?tag:"wsnb:TopicExpressionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnb__TopicExpressionType ** SOAP_FMAC4 soap_get_PointerTowsnb__TopicExpressionType(struct soap *soap, wsnb__TopicExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnb__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__EndpointReferenceType))
		soap_serialize_wsa5__EndpointReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__EndpointReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__EndpointReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__EndpointReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa5__EndpointReferenceType);
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, tag?tag:"wsa5:EndpointReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PropertyOperation(struct soap *soap, enum tt__PropertyOperation *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_tt__PropertyOperation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PropertyOperation(struct soap *soap, const char *tag, int id, enum tt__PropertyOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PropertyOperation);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PropertyOperation(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__PropertyOperation ** SOAP_FMAC4 soap_in_PointerTott__PropertyOperation(struct soap *soap, const char *tag, enum tt__PropertyOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__PropertyOperation **)soap_malloc(soap, sizeof(enum tt__PropertyOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PropertyOperation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__PropertyOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PropertyOperation, sizeof(enum tt__PropertyOperation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PropertyOperation(struct soap *soap, enum tt__PropertyOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PropertyOperation);
	if (soap_out_PointerTott__PropertyOperation(soap, tag?tag:"tt:PropertyOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__PropertyOperation ** SOAP_FMAC4 soap_get_PointerTott__PropertyOperation(struct soap *soap, enum tt__PropertyOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PropertyOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MessageExtension(struct soap *soap, tt__MessageExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MessageExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MessageExtension(struct soap *soap, const char *tag, int id, tt__MessageExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MessageExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__MessageExtension ** SOAP_FMAC4 soap_in_PointerTott__MessageExtension(struct soap *soap, const char *tag, tt__MessageExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MessageExtension **)soap_malloc(soap, sizeof(tt__MessageExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MessageExtension *)soap_instantiate_tt__MessageExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__MessageExtension ** p = (tt__MessageExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MessageExtension, sizeof(tt__MessageExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MessageExtension(struct soap *soap, tt__MessageExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MessageExtension);
	if (soap_out_PointerTott__MessageExtension(soap, tag?tag:"tt:MessageExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MessageExtension ** SOAP_FMAC4 soap_get_PointerTott__MessageExtension(struct soap *soap, tt__MessageExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MessageExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__tt__union_EventStream(struct soap *soap, __tt__union_EventStream *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE___tt__union_EventStream))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__tt__union_EventStream(struct soap *soap, const char *tag, int id, __tt__union_EventStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___tt__union_EventStream);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __tt__union_EventStream ** SOAP_FMAC4 soap_in_PointerTo__tt__union_EventStream(struct soap *soap, const char *tag, __tt__union_EventStream **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__tt__union_EventStream **)soap_malloc(soap, sizeof(__tt__union_EventStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__tt__union_EventStream *)soap_instantiate___tt__union_EventStream(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__tt__union_EventStream ** p = (__tt__union_EventStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___tt__union_EventStream, sizeof(__tt__union_EventStream), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__tt__union_EventStream(struct soap *soap, __tt__union_EventStream *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__tt__union_EventStream);
	if (soap_out_PointerTo__tt__union_EventStream(soap, tag?tag:"-tt:union-EventStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __tt__union_EventStream ** SOAP_FMAC4 soap_get_PointerTo__tt__union_EventStream(struct soap *soap, __tt__union_EventStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__tt__union_EventStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventStreamExtension(struct soap *soap, tt__EventStreamExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventStreamExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventStreamExtension(struct soap *soap, const char *tag, int id, tt__EventStreamExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventStreamExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__EventStreamExtension ** SOAP_FMAC4 soap_in_PointerTott__EventStreamExtension(struct soap *soap, const char *tag, tt__EventStreamExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EventStreamExtension **)soap_malloc(soap, sizeof(tt__EventStreamExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__EventStreamExtension *)soap_instantiate_tt__EventStreamExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__EventStreamExtension ** p = (tt__EventStreamExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventStreamExtension, sizeof(tt__EventStreamExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventStreamExtension(struct soap *soap, tt__EventStreamExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__EventStreamExtension);
	if (soap_out_PointerTott__EventStreamExtension(soap, tag?tag:"tt:EventStreamExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EventStreamExtension ** SOAP_FMAC4 soap_get_PointerTott__EventStreamExtension(struct soap *soap, tt__EventStreamExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnb__NotificationMessageHolderType(struct soap *soap, wsnb__NotificationMessageHolderType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnb__NotificationMessageHolderType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnb__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, wsnb__NotificationMessageHolderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnb__NotificationMessageHolderType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 wsnb__NotificationMessageHolderType ** SOAP_FMAC4 soap_in_PointerTowsnb__NotificationMessageHolderType(struct soap *soap, const char *tag, wsnb__NotificationMessageHolderType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnb__NotificationMessageHolderType **)soap_malloc(soap, sizeof(wsnb__NotificationMessageHolderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnb__NotificationMessageHolderType *)soap_instantiate_wsnb__NotificationMessageHolderType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	wsnb__NotificationMessageHolderType ** p = (wsnb__NotificationMessageHolderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnb__NotificationMessageHolderType, sizeof(wsnb__NotificationMessageHolderType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnb__NotificationMessageHolderType(struct soap *soap, wsnb__NotificationMessageHolderType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnb__NotificationMessageHolderType);
	if (soap_out_PointerTowsnb__NotificationMessageHolderType(soap, tag?tag:"wsnb:NotificationMessageHolderType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnb__NotificationMessageHolderType ** SOAP_FMAC4 soap_get_PointerTowsnb__NotificationMessageHolderType(struct soap *soap, wsnb__NotificationMessageHolderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnb__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__tt__union_PTZStream(struct soap *soap, __tt__union_PTZStream *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE___tt__union_PTZStream))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__tt__union_PTZStream(struct soap *soap, const char *tag, int id, __tt__union_PTZStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___tt__union_PTZStream);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __tt__union_PTZStream ** SOAP_FMAC4 soap_in_PointerTo__tt__union_PTZStream(struct soap *soap, const char *tag, __tt__union_PTZStream **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__tt__union_PTZStream **)soap_malloc(soap, sizeof(__tt__union_PTZStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__tt__union_PTZStream *)soap_instantiate___tt__union_PTZStream(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__tt__union_PTZStream ** p = (__tt__union_PTZStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___tt__union_PTZStream, sizeof(__tt__union_PTZStream), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__tt__union_PTZStream(struct soap *soap, __tt__union_PTZStream *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__tt__union_PTZStream);
	if (soap_out_PointerTo__tt__union_PTZStream(soap, tag?tag:"-tt:union-PTZStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __tt__union_PTZStream ** SOAP_FMAC4 soap_get_PointerTo__tt__union_PTZStream(struct soap *soap, __tt__union_PTZStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__tt__union_PTZStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZStreamExtension(struct soap *soap, tt__PTZStreamExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZStreamExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZStreamExtension(struct soap *soap, const char *tag, int id, tt__PTZStreamExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZStreamExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PTZStreamExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZStreamExtension(struct soap *soap, const char *tag, tt__PTZStreamExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZStreamExtension **)soap_malloc(soap, sizeof(tt__PTZStreamExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZStreamExtension *)soap_instantiate_tt__PTZStreamExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PTZStreamExtension ** p = (tt__PTZStreamExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZStreamExtension, sizeof(tt__PTZStreamExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZStreamExtension(struct soap *soap, tt__PTZStreamExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZStreamExtension);
	if (soap_out_PointerTott__PTZStreamExtension(soap, tag?tag:"tt:PTZStreamExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZStreamExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZStreamExtension(struct soap *soap, tt__PTZStreamExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__tt__union_VideoAnalyticsStream(struct soap *soap, __tt__union_VideoAnalyticsStream *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE___tt__union_VideoAnalyticsStream))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__tt__union_VideoAnalyticsStream(struct soap *soap, const char *tag, int id, __tt__union_VideoAnalyticsStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___tt__union_VideoAnalyticsStream);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __tt__union_VideoAnalyticsStream ** SOAP_FMAC4 soap_in_PointerTo__tt__union_VideoAnalyticsStream(struct soap *soap, const char *tag, __tt__union_VideoAnalyticsStream **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__tt__union_VideoAnalyticsStream **)soap_malloc(soap, sizeof(__tt__union_VideoAnalyticsStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__tt__union_VideoAnalyticsStream *)soap_instantiate___tt__union_VideoAnalyticsStream(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__tt__union_VideoAnalyticsStream ** p = (__tt__union_VideoAnalyticsStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___tt__union_VideoAnalyticsStream, sizeof(__tt__union_VideoAnalyticsStream), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__tt__union_VideoAnalyticsStream(struct soap *soap, __tt__union_VideoAnalyticsStream *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__tt__union_VideoAnalyticsStream);
	if (soap_out_PointerTo__tt__union_VideoAnalyticsStream(soap, tag?tag:"-tt:union-VideoAnalyticsStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __tt__union_VideoAnalyticsStream ** SOAP_FMAC4 soap_get_PointerTo__tt__union_VideoAnalyticsStream(struct soap *soap, __tt__union_VideoAnalyticsStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__tt__union_VideoAnalyticsStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoAnalyticsStreamExtension(struct soap *soap, tt__VideoAnalyticsStreamExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoAnalyticsStreamExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoAnalyticsStreamExtension(struct soap *soap, const char *tag, int id, tt__VideoAnalyticsStreamExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoAnalyticsStreamExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__VideoAnalyticsStreamExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoAnalyticsStreamExtension(struct soap *soap, const char *tag, tt__VideoAnalyticsStreamExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoAnalyticsStreamExtension **)soap_malloc(soap, sizeof(tt__VideoAnalyticsStreamExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoAnalyticsStreamExtension *)soap_instantiate_tt__VideoAnalyticsStreamExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__VideoAnalyticsStreamExtension ** p = (tt__VideoAnalyticsStreamExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoAnalyticsStreamExtension, sizeof(tt__VideoAnalyticsStreamExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoAnalyticsStreamExtension(struct soap *soap, tt__VideoAnalyticsStreamExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoAnalyticsStreamExtension);
	if (soap_out_PointerTott__VideoAnalyticsStreamExtension(soap, tag?tag:"tt:VideoAnalyticsStreamExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoAnalyticsStreamExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoAnalyticsStreamExtension(struct soap *soap, tt__VideoAnalyticsStreamExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoAnalyticsStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Frame(struct soap *soap, tt__Frame *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Frame))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Frame(struct soap *soap, const char *tag, int id, tt__Frame *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Frame);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Frame ** SOAP_FMAC4 soap_in_PointerTott__Frame(struct soap *soap, const char *tag, tt__Frame **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Frame **)soap_malloc(soap, sizeof(tt__Frame *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Frame *)soap_instantiate_tt__Frame(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Frame ** p = (tt__Frame **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Frame, sizeof(tt__Frame), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Frame(struct soap *soap, tt__Frame *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Frame);
	if (soap_out_PointerTott__Frame(soap, tag?tag:"tt:Frame", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Frame ** SOAP_FMAC4 soap_get_PointerTott__Frame(struct soap *soap, tt__Frame **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Frame(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__tt__union_MetadataStream(struct soap *soap, __tt__union_MetadataStream *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE___tt__union_MetadataStream))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__tt__union_MetadataStream(struct soap *soap, const char *tag, int id, __tt__union_MetadataStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___tt__union_MetadataStream);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __tt__union_MetadataStream ** SOAP_FMAC4 soap_in_PointerTo__tt__union_MetadataStream(struct soap *soap, const char *tag, __tt__union_MetadataStream **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__tt__union_MetadataStream **)soap_malloc(soap, sizeof(__tt__union_MetadataStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__tt__union_MetadataStream *)soap_instantiate___tt__union_MetadataStream(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__tt__union_MetadataStream ** p = (__tt__union_MetadataStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___tt__union_MetadataStream, sizeof(__tt__union_MetadataStream), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__tt__union_MetadataStream(struct soap *soap, __tt__union_MetadataStream *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__tt__union_MetadataStream);
	if (soap_out_PointerTo__tt__union_MetadataStream(soap, tag?tag:"-tt:union-MetadataStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __tt__union_MetadataStream ** SOAP_FMAC4 soap_get_PointerTo__tt__union_MetadataStream(struct soap *soap, __tt__union_MetadataStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__tt__union_MetadataStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataStreamExtension(struct soap *soap, tt__MetadataStreamExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataStreamExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataStreamExtension(struct soap *soap, const char *tag, int id, tt__MetadataStreamExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataStreamExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__MetadataStreamExtension ** SOAP_FMAC4 soap_in_PointerTott__MetadataStreamExtension(struct soap *soap, const char *tag, tt__MetadataStreamExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MetadataStreamExtension **)soap_malloc(soap, sizeof(tt__MetadataStreamExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MetadataStreamExtension *)soap_instantiate_tt__MetadataStreamExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__MetadataStreamExtension ** p = (tt__MetadataStreamExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataStreamExtension, sizeof(tt__MetadataStreamExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataStreamExtension(struct soap *soap, tt__MetadataStreamExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MetadataStreamExtension);
	if (soap_out_PointerTott__MetadataStreamExtension(soap, tag?tag:"tt:MetadataStreamExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MetadataStreamExtension ** SOAP_FMAC4 soap_get_PointerTott__MetadataStreamExtension(struct soap *soap, tt__MetadataStreamExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventStream(struct soap *soap, tt__EventStream *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventStream))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventStream(struct soap *soap, const char *tag, int id, tt__EventStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventStream);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__EventStream ** SOAP_FMAC4 soap_in_PointerTott__EventStream(struct soap *soap, const char *tag, tt__EventStream **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EventStream **)soap_malloc(soap, sizeof(tt__EventStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__EventStream *)soap_instantiate_tt__EventStream(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__EventStream ** p = (tt__EventStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventStream, sizeof(tt__EventStream), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventStream(struct soap *soap, tt__EventStream *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__EventStream);
	if (soap_out_PointerTott__EventStream(soap, tag?tag:"tt:EventStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EventStream ** SOAP_FMAC4 soap_get_PointerTott__EventStream(struct soap *soap, tt__EventStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZStream(struct soap *soap, tt__PTZStream *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZStream))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZStream(struct soap *soap, const char *tag, int id, tt__PTZStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZStream);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PTZStream ** SOAP_FMAC4 soap_in_PointerTott__PTZStream(struct soap *soap, const char *tag, tt__PTZStream **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZStream **)soap_malloc(soap, sizeof(tt__PTZStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZStream *)soap_instantiate_tt__PTZStream(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PTZStream ** p = (tt__PTZStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZStream, sizeof(tt__PTZStream), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZStream(struct soap *soap, tt__PTZStream *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZStream);
	if (soap_out_PointerTott__PTZStream(soap, tag?tag:"tt:PTZStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZStream ** SOAP_FMAC4 soap_get_PointerTott__PTZStream(struct soap *soap, tt__PTZStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoAnalyticsStream(struct soap *soap, tt__VideoAnalyticsStream *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoAnalyticsStream))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoAnalyticsStream(struct soap *soap, const char *tag, int id, tt__VideoAnalyticsStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoAnalyticsStream);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__VideoAnalyticsStream ** SOAP_FMAC4 soap_in_PointerTott__VideoAnalyticsStream(struct soap *soap, const char *tag, tt__VideoAnalyticsStream **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoAnalyticsStream **)soap_malloc(soap, sizeof(tt__VideoAnalyticsStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoAnalyticsStream *)soap_instantiate_tt__VideoAnalyticsStream(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__VideoAnalyticsStream ** p = (tt__VideoAnalyticsStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoAnalyticsStream, sizeof(tt__VideoAnalyticsStream), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoAnalyticsStream(struct soap *soap, tt__VideoAnalyticsStream *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoAnalyticsStream);
	if (soap_out_PointerTott__VideoAnalyticsStream(soap, tag?tag:"tt:VideoAnalyticsStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoAnalyticsStream ** SOAP_FMAC4 soap_get_PointerTott__VideoAnalyticsStream(struct soap *soap, tt__VideoAnalyticsStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoAnalyticsStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, tt__SupportedAnalyticsModulesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, int id, tt__SupportedAnalyticsModulesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__SupportedAnalyticsModulesExtension ** SOAP_FMAC4 soap_in_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, tt__SupportedAnalyticsModulesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SupportedAnalyticsModulesExtension **)soap_malloc(soap, sizeof(tt__SupportedAnalyticsModulesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SupportedAnalyticsModulesExtension *)soap_instantiate_tt__SupportedAnalyticsModulesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__SupportedAnalyticsModulesExtension ** p = (tt__SupportedAnalyticsModulesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, sizeof(tt__SupportedAnalyticsModulesExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, tt__SupportedAnalyticsModulesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SupportedAnalyticsModulesExtension);
	if (soap_out_PointerTott__SupportedAnalyticsModulesExtension(soap, tag?tag:"tt:SupportedAnalyticsModulesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SupportedAnalyticsModulesExtension ** SOAP_FMAC4 soap_get_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, tt__SupportedAnalyticsModulesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SupportedAnalyticsModulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SupportedRulesExtension(struct soap *soap, tt__SupportedRulesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SupportedRulesExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SupportedRulesExtension(struct soap *soap, const char *tag, int id, tt__SupportedRulesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SupportedRulesExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__SupportedRulesExtension ** SOAP_FMAC4 soap_in_PointerTott__SupportedRulesExtension(struct soap *soap, const char *tag, tt__SupportedRulesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SupportedRulesExtension **)soap_malloc(soap, sizeof(tt__SupportedRulesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SupportedRulesExtension *)soap_instantiate_tt__SupportedRulesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__SupportedRulesExtension ** p = (tt__SupportedRulesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportedRulesExtension, sizeof(tt__SupportedRulesExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SupportedRulesExtension(struct soap *soap, tt__SupportedRulesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SupportedRulesExtension);
	if (soap_out_PointerTott__SupportedRulesExtension(soap, tag?tag:"tt:SupportedRulesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SupportedRulesExtension ** SOAP_FMAC4 soap_get_PointerTott__SupportedRulesExtension(struct soap *soap, tt__SupportedRulesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SupportedRulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ConfigDescription(struct soap *soap, tt__ConfigDescription *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ConfigDescription))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ConfigDescription(struct soap *soap, const char *tag, int id, tt__ConfigDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ConfigDescription);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ConfigDescription ** SOAP_FMAC4 soap_in_PointerTott__ConfigDescription(struct soap *soap, const char *tag, tt__ConfigDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ConfigDescription **)soap_malloc(soap, sizeof(tt__ConfigDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ConfigDescription *)soap_instantiate_tt__ConfigDescription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ConfigDescription ** p = (tt__ConfigDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ConfigDescription, sizeof(tt__ConfigDescription), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ConfigDescription(struct soap *soap, tt__ConfigDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ConfigDescription);
	if (soap_out_PointerTott__ConfigDescription(soap, tag?tag:"tt:ConfigDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ConfigDescription ** SOAP_FMAC4 soap_get_PointerTott__ConfigDescription(struct soap *soap, tt__ConfigDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ConfigDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ConfigDescriptionExtension(struct soap *soap, tt__ConfigDescriptionExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ConfigDescriptionExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ConfigDescriptionExtension(struct soap *soap, const char *tag, int id, tt__ConfigDescriptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ConfigDescriptionExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ConfigDescriptionExtension ** SOAP_FMAC4 soap_in_PointerTott__ConfigDescriptionExtension(struct soap *soap, const char *tag, tt__ConfigDescriptionExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ConfigDescriptionExtension **)soap_malloc(soap, sizeof(tt__ConfigDescriptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ConfigDescriptionExtension *)soap_instantiate_tt__ConfigDescriptionExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ConfigDescriptionExtension ** p = (tt__ConfigDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ConfigDescriptionExtension, sizeof(tt__ConfigDescriptionExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ConfigDescriptionExtension(struct soap *soap, tt__ConfigDescriptionExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ConfigDescriptionExtension);
	if (soap_out_PointerTott__ConfigDescriptionExtension(soap, tag?tag:"tt:ConfigDescriptionExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ConfigDescriptionExtension ** SOAP_FMAC4 soap_get_PointerTott__ConfigDescriptionExtension(struct soap *soap, tt__ConfigDescriptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ConfigDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ConfigDescription_Messages(struct soap *soap, _tt__ConfigDescription_Messages *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ConfigDescription_Messages))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ConfigDescription_Messages(struct soap *soap, const char *tag, int id, _tt__ConfigDescription_Messages *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ConfigDescription_Messages);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tt__ConfigDescription_Messages ** SOAP_FMAC4 soap_in_PointerTo_tt__ConfigDescription_Messages(struct soap *soap, const char *tag, _tt__ConfigDescription_Messages **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tt__ConfigDescription_Messages **)soap_malloc(soap, sizeof(_tt__ConfigDescription_Messages *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tt__ConfigDescription_Messages *)soap_instantiate__tt__ConfigDescription_Messages(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tt__ConfigDescription_Messages ** p = (_tt__ConfigDescription_Messages **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ConfigDescription_Messages, sizeof(_tt__ConfigDescription_Messages), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ConfigDescription_Messages(struct soap *soap, _tt__ConfigDescription_Messages *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tt__ConfigDescription_Messages);
	if (soap_out_PointerTo_tt__ConfigDescription_Messages(soap, tag?tag:"tt:ConfigDescription-Messages", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tt__ConfigDescription_Messages ** SOAP_FMAC4 soap_get_PointerTo_tt__ConfigDescription_Messages(struct soap *soap, _tt__ConfigDescription_Messages **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ConfigDescription_Messages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemList(struct soap *soap, tt__ItemList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemList(struct soap *soap, const char *tag, int id, tt__ItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ItemList ** SOAP_FMAC4 soap_in_PointerTott__ItemList(struct soap *soap, const char *tag, tt__ItemList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ItemList **)soap_malloc(soap, sizeof(tt__ItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ItemList *)soap_instantiate_tt__ItemList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ItemList ** p = (tt__ItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemList, sizeof(tt__ItemList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemList(struct soap *soap, tt__ItemList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ItemList);
	if (soap_out_PointerTott__ItemList(soap, tag?tag:"tt:ItemList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ItemList ** SOAP_FMAC4 soap_get_PointerTott__ItemList(struct soap *soap, tt__ItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, tt__RuleEngineConfigurationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RuleEngineConfigurationExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, int id, tt__RuleEngineConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RuleEngineConfigurationExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__RuleEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, tt__RuleEngineConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RuleEngineConfigurationExtension **)soap_malloc(soap, sizeof(tt__RuleEngineConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RuleEngineConfigurationExtension *)soap_instantiate_tt__RuleEngineConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__RuleEngineConfigurationExtension ** p = (tt__RuleEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RuleEngineConfigurationExtension, sizeof(tt__RuleEngineConfigurationExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, tt__RuleEngineConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RuleEngineConfigurationExtension);
	if (soap_out_PointerTott__RuleEngineConfigurationExtension(soap, tag?tag:"tt:RuleEngineConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RuleEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, tt__RuleEngineConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RuleEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, tt__AnalyticsEngineConfigurationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, int id, tt__AnalyticsEngineConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__AnalyticsEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, tt__AnalyticsEngineConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsEngineConfigurationExtension **)soap_malloc(soap, sizeof(tt__AnalyticsEngineConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsEngineConfigurationExtension *)soap_instantiate_tt__AnalyticsEngineConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__AnalyticsEngineConfigurationExtension ** p = (tt__AnalyticsEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, sizeof(tt__AnalyticsEngineConfigurationExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, tt__AnalyticsEngineConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsEngineConfigurationExtension);
	if (soap_out_PointerTott__AnalyticsEngineConfigurationExtension(soap, tag?tag:"tt:AnalyticsEngineConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, tt__AnalyticsEngineConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ObjectTreeExtension(struct soap *soap, tt__ObjectTreeExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ObjectTreeExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ObjectTreeExtension(struct soap *soap, const char *tag, int id, tt__ObjectTreeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ObjectTreeExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ObjectTreeExtension ** SOAP_FMAC4 soap_in_PointerTott__ObjectTreeExtension(struct soap *soap, const char *tag, tt__ObjectTreeExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ObjectTreeExtension **)soap_malloc(soap, sizeof(tt__ObjectTreeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ObjectTreeExtension *)soap_instantiate_tt__ObjectTreeExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ObjectTreeExtension ** p = (tt__ObjectTreeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ObjectTreeExtension, sizeof(tt__ObjectTreeExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ObjectTreeExtension(struct soap *soap, tt__ObjectTreeExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ObjectTreeExtension);
	if (soap_out_PointerTott__ObjectTreeExtension(soap, tag?tag:"tt:ObjectTreeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ObjectTreeExtension ** SOAP_FMAC4 soap_get_PointerTott__ObjectTreeExtension(struct soap *soap, tt__ObjectTreeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ObjectTreeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Merge(struct soap *soap, tt__Merge *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Merge))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Merge(struct soap *soap, const char *tag, int id, tt__Merge *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Merge);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Merge ** SOAP_FMAC4 soap_in_PointerTott__Merge(struct soap *soap, const char *tag, tt__Merge **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Merge **)soap_malloc(soap, sizeof(tt__Merge *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Merge *)soap_instantiate_tt__Merge(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Merge ** p = (tt__Merge **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Merge, sizeof(tt__Merge), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Merge(struct soap *soap, tt__Merge *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Merge);
	if (soap_out_PointerTott__Merge(soap, tag?tag:"tt:Merge", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Merge ** SOAP_FMAC4 soap_get_PointerTott__Merge(struct soap *soap, tt__Merge **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Merge(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Split(struct soap *soap, tt__Split *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Split))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Split(struct soap *soap, const char *tag, int id, tt__Split *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Split);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Split ** SOAP_FMAC4 soap_in_PointerTott__Split(struct soap *soap, const char *tag, tt__Split **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Split **)soap_malloc(soap, sizeof(tt__Split *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Split *)soap_instantiate_tt__Split(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Split ** p = (tt__Split **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Split, sizeof(tt__Split), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Split(struct soap *soap, tt__Split *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Split);
	if (soap_out_PointerTott__Split(soap, tag?tag:"tt:Split", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Split ** SOAP_FMAC4 soap_get_PointerTott__Split(struct soap *soap, tt__Split **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Split(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Rename(struct soap *soap, tt__Rename *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Rename))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Rename(struct soap *soap, const char *tag, int id, tt__Rename *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Rename);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Rename ** SOAP_FMAC4 soap_in_PointerTott__Rename(struct soap *soap, const char *tag, tt__Rename **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Rename **)soap_malloc(soap, sizeof(tt__Rename *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Rename *)soap_instantiate_tt__Rename(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Rename ** p = (tt__Rename **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Rename, sizeof(tt__Rename), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Rename(struct soap *soap, tt__Rename *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Rename);
	if (soap_out_PointerTott__Rename(soap, tag?tag:"tt:Rename", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Rename ** SOAP_FMAC4 soap_get_PointerTott__Rename(struct soap *soap, tt__Rename **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Rename(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BehaviourExtension(struct soap *soap, tt__BehaviourExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BehaviourExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BehaviourExtension(struct soap *soap, const char *tag, int id, tt__BehaviourExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BehaviourExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__BehaviourExtension ** SOAP_FMAC4 soap_in_PointerTott__BehaviourExtension(struct soap *soap, const char *tag, tt__BehaviourExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__BehaviourExtension **)soap_malloc(soap, sizeof(tt__BehaviourExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__BehaviourExtension *)soap_instantiate_tt__BehaviourExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__BehaviourExtension ** p = (tt__BehaviourExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BehaviourExtension, sizeof(tt__BehaviourExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BehaviourExtension(struct soap *soap, tt__BehaviourExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__BehaviourExtension);
	if (soap_out_PointerTott__BehaviourExtension(soap, tag?tag:"tt:BehaviourExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__BehaviourExtension ** SOAP_FMAC4 soap_get_PointerTott__BehaviourExtension(struct soap *soap, tt__BehaviourExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BehaviourExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__Behaviour_Idle(struct soap *soap, _tt__Behaviour_Idle *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__Behaviour_Idle))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__Behaviour_Idle(struct soap *soap, const char *tag, int id, _tt__Behaviour_Idle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__Behaviour_Idle);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tt__Behaviour_Idle ** SOAP_FMAC4 soap_in_PointerTo_tt__Behaviour_Idle(struct soap *soap, const char *tag, _tt__Behaviour_Idle **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tt__Behaviour_Idle **)soap_malloc(soap, sizeof(_tt__Behaviour_Idle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tt__Behaviour_Idle *)soap_instantiate__tt__Behaviour_Idle(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tt__Behaviour_Idle ** p = (_tt__Behaviour_Idle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__Behaviour_Idle, sizeof(_tt__Behaviour_Idle), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__Behaviour_Idle(struct soap *soap, _tt__Behaviour_Idle *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tt__Behaviour_Idle);
	if (soap_out_PointerTo_tt__Behaviour_Idle(soap, tag?tag:"tt:Behaviour-Idle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tt__Behaviour_Idle ** SOAP_FMAC4 soap_get_PointerTo_tt__Behaviour_Idle(struct soap *soap, _tt__Behaviour_Idle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__Behaviour_Idle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__Behaviour_Removed(struct soap *soap, _tt__Behaviour_Removed *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__Behaviour_Removed))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__Behaviour_Removed(struct soap *soap, const char *tag, int id, _tt__Behaviour_Removed *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__Behaviour_Removed);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tt__Behaviour_Removed ** SOAP_FMAC4 soap_in_PointerTo_tt__Behaviour_Removed(struct soap *soap, const char *tag, _tt__Behaviour_Removed **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tt__Behaviour_Removed **)soap_malloc(soap, sizeof(_tt__Behaviour_Removed *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tt__Behaviour_Removed *)soap_instantiate__tt__Behaviour_Removed(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tt__Behaviour_Removed ** p = (_tt__Behaviour_Removed **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__Behaviour_Removed, sizeof(_tt__Behaviour_Removed), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__Behaviour_Removed(struct soap *soap, _tt__Behaviour_Removed *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tt__Behaviour_Removed);
	if (soap_out_PointerTo_tt__Behaviour_Removed(soap, tag?tag:"tt:Behaviour-Removed", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tt__Behaviour_Removed ** SOAP_FMAC4 soap_get_PointerTo_tt__Behaviour_Removed(struct soap *soap, _tt__Behaviour_Removed **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__Behaviour_Removed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__integer(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__integer))
		soap_serialize_xsd__integer(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__integer(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__integer);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__integer(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__integer(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__integer(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__integer, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__integer(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__integer);
	if (soap_out_PointerToxsd__integer(soap, tag?tag:"xsd:integer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__integer(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ObjectId(struct soap *soap, tt__ObjectId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ObjectId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ObjectId(struct soap *soap, const char *tag, int id, tt__ObjectId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ObjectId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ObjectId ** SOAP_FMAC4 soap_in_PointerTott__ObjectId(struct soap *soap, const char *tag, tt__ObjectId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ObjectId **)soap_malloc(soap, sizeof(tt__ObjectId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ObjectId *)soap_instantiate_tt__ObjectId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ObjectId ** p = (tt__ObjectId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ObjectId, sizeof(tt__ObjectId), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (tt__ObjectId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Object, sizeof(tt__Object), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ObjectId(struct soap *soap, tt__ObjectId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ObjectId);
	if (soap_out_PointerTott__ObjectId(soap, tag?tag:"tt:ObjectId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ObjectId ** SOAP_FMAC4 soap_get_PointerTott__ObjectId(struct soap *soap, tt__ObjectId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ObjectId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FrameExtension(struct soap *soap, tt__FrameExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FrameExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FrameExtension(struct soap *soap, const char *tag, int id, tt__FrameExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FrameExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__FrameExtension ** SOAP_FMAC4 soap_in_PointerTott__FrameExtension(struct soap *soap, const char *tag, tt__FrameExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FrameExtension **)soap_malloc(soap, sizeof(tt__FrameExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FrameExtension *)soap_instantiate_tt__FrameExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__FrameExtension ** p = (tt__FrameExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FrameExtension, sizeof(tt__FrameExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FrameExtension(struct soap *soap, tt__FrameExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FrameExtension);
	if (soap_out_PointerTott__FrameExtension(soap, tag?tag:"tt:FrameExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FrameExtension ** SOAP_FMAC4 soap_get_PointerTott__FrameExtension(struct soap *soap, tt__FrameExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FrameExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ObjectTree(struct soap *soap, tt__ObjectTree *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ObjectTree))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ObjectTree(struct soap *soap, const char *tag, int id, tt__ObjectTree *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ObjectTree);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ObjectTree ** SOAP_FMAC4 soap_in_PointerTott__ObjectTree(struct soap *soap, const char *tag, tt__ObjectTree **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ObjectTree **)soap_malloc(soap, sizeof(tt__ObjectTree *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ObjectTree *)soap_instantiate_tt__ObjectTree(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ObjectTree ** p = (tt__ObjectTree **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ObjectTree, sizeof(tt__ObjectTree), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ObjectTree(struct soap *soap, tt__ObjectTree *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ObjectTree);
	if (soap_out_PointerTott__ObjectTree(soap, tag?tag:"tt:ObjectTree", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ObjectTree ** SOAP_FMAC4 soap_get_PointerTott__ObjectTree(struct soap *soap, tt__ObjectTree **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ObjectTree(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Object(struct soap *soap, tt__Object *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Object))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Object(struct soap *soap, const char *tag, int id, tt__Object *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Object);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Object ** SOAP_FMAC4 soap_in_PointerTott__Object(struct soap *soap, const char *tag, tt__Object **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Object **)soap_malloc(soap, sizeof(tt__Object *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Object *)soap_instantiate_tt__Object(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Object ** p = (tt__Object **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Object, sizeof(tt__Object), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Object(struct soap *soap, tt__Object *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Object);
	if (soap_out_PointerTott__Object(soap, tag?tag:"tt:Object", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Object ** SOAP_FMAC4 soap_get_PointerTott__Object(struct soap *soap, tt__Object **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Object(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZStatus(struct soap *soap, tt__PTZStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZStatus(struct soap *soap, const char *tag, int id, tt__PTZStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PTZStatus ** SOAP_FMAC4 soap_in_PointerTott__PTZStatus(struct soap *soap, const char *tag, tt__PTZStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZStatus **)soap_malloc(soap, sizeof(tt__PTZStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZStatus *)soap_instantiate_tt__PTZStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PTZStatus ** p = (tt__PTZStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZStatus, sizeof(tt__PTZStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZStatus(struct soap *soap, tt__PTZStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZStatus);
	if (soap_out_PointerTott__PTZStatus(soap, tag?tag:"tt:PTZStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZStatus ** SOAP_FMAC4 soap_get_PointerTott__PTZStatus(struct soap *soap, tt__PTZStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TransformationExtension(struct soap *soap, tt__TransformationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TransformationExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TransformationExtension(struct soap *soap, const char *tag, int id, tt__TransformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TransformationExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__TransformationExtension ** SOAP_FMAC4 soap_in_PointerTott__TransformationExtension(struct soap *soap, const char *tag, tt__TransformationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__TransformationExtension **)soap_malloc(soap, sizeof(tt__TransformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__TransformationExtension *)soap_instantiate_tt__TransformationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__TransformationExtension ** p = (tt__TransformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TransformationExtension, sizeof(tt__TransformationExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TransformationExtension(struct soap *soap, tt__TransformationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__TransformationExtension);
	if (soap_out_PointerTott__TransformationExtension(soap, tag?tag:"tt:TransformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__TransformationExtension ** SOAP_FMAC4 soap_get_PointerTott__TransformationExtension(struct soap *soap, tt__TransformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TransformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ClassDescriptorExtension(struct soap *soap, tt__ClassDescriptorExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ClassDescriptorExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ClassDescriptorExtension(struct soap *soap, const char *tag, int id, tt__ClassDescriptorExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ClassDescriptorExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ClassDescriptorExtension ** SOAP_FMAC4 soap_in_PointerTott__ClassDescriptorExtension(struct soap *soap, const char *tag, tt__ClassDescriptorExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ClassDescriptorExtension **)soap_malloc(soap, sizeof(tt__ClassDescriptorExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ClassDescriptorExtension *)soap_instantiate_tt__ClassDescriptorExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ClassDescriptorExtension ** p = (tt__ClassDescriptorExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ClassDescriptorExtension, sizeof(tt__ClassDescriptorExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ClassDescriptorExtension(struct soap *soap, tt__ClassDescriptorExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ClassDescriptorExtension);
	if (soap_out_PointerTott__ClassDescriptorExtension(soap, tag?tag:"tt:ClassDescriptorExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ClassDescriptorExtension ** SOAP_FMAC4 soap_get_PointerTott__ClassDescriptorExtension(struct soap *soap, tt__ClassDescriptorExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ClassDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ClassDescriptor_ClassCandidate(struct soap *soap, _tt__ClassDescriptor_ClassCandidate *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ClassDescriptor_ClassCandidate(struct soap *soap, const char *tag, int id, _tt__ClassDescriptor_ClassCandidate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tt__ClassDescriptor_ClassCandidate ** SOAP_FMAC4 soap_in_PointerTo_tt__ClassDescriptor_ClassCandidate(struct soap *soap, const char *tag, _tt__ClassDescriptor_ClassCandidate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tt__ClassDescriptor_ClassCandidate **)soap_malloc(soap, sizeof(_tt__ClassDescriptor_ClassCandidate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tt__ClassDescriptor_ClassCandidate *)soap_instantiate__tt__ClassDescriptor_ClassCandidate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tt__ClassDescriptor_ClassCandidate ** p = (_tt__ClassDescriptor_ClassCandidate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate, sizeof(_tt__ClassDescriptor_ClassCandidate), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ClassDescriptor_ClassCandidate(struct soap *soap, _tt__ClassDescriptor_ClassCandidate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tt__ClassDescriptor_ClassCandidate);
	if (soap_out_PointerTo_tt__ClassDescriptor_ClassCandidate(soap, tag?tag:"tt:ClassDescriptor-ClassCandidate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tt__ClassDescriptor_ClassCandidate ** SOAP_FMAC4 soap_get_PointerTo_tt__ClassDescriptor_ClassCandidate(struct soap *soap, _tt__ClassDescriptor_ClassCandidate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ClassDescriptor_ClassCandidate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ColorDescriptorExtension(struct soap *soap, tt__ColorDescriptorExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ColorDescriptorExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ColorDescriptorExtension(struct soap *soap, const char *tag, int id, tt__ColorDescriptorExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ColorDescriptorExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ColorDescriptorExtension ** SOAP_FMAC4 soap_in_PointerTott__ColorDescriptorExtension(struct soap *soap, const char *tag, tt__ColorDescriptorExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ColorDescriptorExtension **)soap_malloc(soap, sizeof(tt__ColorDescriptorExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ColorDescriptorExtension *)soap_instantiate_tt__ColorDescriptorExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ColorDescriptorExtension ** p = (tt__ColorDescriptorExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ColorDescriptorExtension, sizeof(tt__ColorDescriptorExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ColorDescriptorExtension(struct soap *soap, tt__ColorDescriptorExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ColorDescriptorExtension);
	if (soap_out_PointerTott__ColorDescriptorExtension(soap, tag?tag:"tt:ColorDescriptorExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ColorDescriptorExtension ** SOAP_FMAC4 soap_get_PointerTott__ColorDescriptorExtension(struct soap *soap, tt__ColorDescriptorExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ColorDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, _tt__ColorDescriptor_ColorCluster *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ColorDescriptor_ColorCluster))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, int id, _tt__ColorDescriptor_ColorCluster *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ColorDescriptor_ColorCluster);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tt__ColorDescriptor_ColorCluster ** SOAP_FMAC4 soap_in_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, _tt__ColorDescriptor_ColorCluster **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tt__ColorDescriptor_ColorCluster **)soap_malloc(soap, sizeof(_tt__ColorDescriptor_ColorCluster *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tt__ColorDescriptor_ColorCluster *)soap_instantiate__tt__ColorDescriptor_ColorCluster(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tt__ColorDescriptor_ColorCluster ** p = (_tt__ColorDescriptor_ColorCluster **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ColorDescriptor_ColorCluster, sizeof(_tt__ColorDescriptor_ColorCluster), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, _tt__ColorDescriptor_ColorCluster *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tt__ColorDescriptor_ColorCluster);
	if (soap_out_PointerTo_tt__ColorDescriptor_ColorCluster(soap, tag?tag:"tt:ColorDescriptor-ColorCluster", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tt__ColorDescriptor_ColorCluster ** SOAP_FMAC4 soap_get_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, _tt__ColorDescriptor_ColorCluster **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ColorDescriptor_ColorCluster(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ColorCovariance(struct soap *soap, tt__ColorCovariance *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ColorCovariance))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ColorCovariance(struct soap *soap, const char *tag, int id, tt__ColorCovariance *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ColorCovariance);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ColorCovariance ** SOAP_FMAC4 soap_in_PointerTott__ColorCovariance(struct soap *soap, const char *tag, tt__ColorCovariance **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ColorCovariance **)soap_malloc(soap, sizeof(tt__ColorCovariance *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ColorCovariance *)soap_instantiate_tt__ColorCovariance(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ColorCovariance ** p = (tt__ColorCovariance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ColorCovariance, sizeof(tt__ColorCovariance), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ColorCovariance(struct soap *soap, tt__ColorCovariance *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ColorCovariance);
	if (soap_out_PointerTott__ColorCovariance(soap, tag?tag:"tt:ColorCovariance", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ColorCovariance ** SOAP_FMAC4 soap_get_PointerTott__ColorCovariance(struct soap *soap, tt__ColorCovariance **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ColorCovariance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Color(struct soap *soap, tt__Color *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Color))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Color(struct soap *soap, const char *tag, int id, tt__Color *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Color);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Color ** SOAP_FMAC4 soap_in_PointerTott__Color(struct soap *soap, const char *tag, tt__Color **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Color **)soap_malloc(soap, sizeof(tt__Color *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Color *)soap_instantiate_tt__Color(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Color ** p = (tt__Color **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Color, sizeof(tt__Color), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Color(struct soap *soap, tt__Color *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Color);
	if (soap_out_PointerTott__Color(soap, tag?tag:"tt:Color", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Color ** SOAP_FMAC4 soap_get_PointerTott__Color(struct soap *soap, tt__Color **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Color(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ShapeDescriptorExtension(struct soap *soap, tt__ShapeDescriptorExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ShapeDescriptorExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ShapeDescriptorExtension(struct soap *soap, const char *tag, int id, tt__ShapeDescriptorExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ShapeDescriptorExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ShapeDescriptorExtension ** SOAP_FMAC4 soap_in_PointerTott__ShapeDescriptorExtension(struct soap *soap, const char *tag, tt__ShapeDescriptorExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ShapeDescriptorExtension **)soap_malloc(soap, sizeof(tt__ShapeDescriptorExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ShapeDescriptorExtension *)soap_instantiate_tt__ShapeDescriptorExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ShapeDescriptorExtension ** p = (tt__ShapeDescriptorExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ShapeDescriptorExtension, sizeof(tt__ShapeDescriptorExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ShapeDescriptorExtension(struct soap *soap, tt__ShapeDescriptorExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ShapeDescriptorExtension);
	if (soap_out_PointerTott__ShapeDescriptorExtension(soap, tag?tag:"tt:ShapeDescriptorExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ShapeDescriptorExtension ** SOAP_FMAC4 soap_get_PointerTott__ShapeDescriptorExtension(struct soap *soap, tt__ShapeDescriptorExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ShapeDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Polygon(struct soap *soap, tt__Polygon *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Polygon))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Polygon(struct soap *soap, const char *tag, int id, tt__Polygon *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Polygon);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Polygon ** SOAP_FMAC4 soap_in_PointerTott__Polygon(struct soap *soap, const char *tag, tt__Polygon **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Polygon **)soap_malloc(soap, sizeof(tt__Polygon *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Polygon *)soap_instantiate_tt__Polygon(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Polygon ** p = (tt__Polygon **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Polygon, sizeof(tt__Polygon), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Polygon(struct soap *soap, tt__Polygon *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Polygon);
	if (soap_out_PointerTott__Polygon(soap, tag?tag:"tt:Polygon", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Polygon ** SOAP_FMAC4 soap_get_PointerTott__Polygon(struct soap *soap, tt__Polygon **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Polygon(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AppearanceExtension(struct soap *soap, tt__AppearanceExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AppearanceExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AppearanceExtension(struct soap *soap, const char *tag, int id, tt__AppearanceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AppearanceExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__AppearanceExtension ** SOAP_FMAC4 soap_in_PointerTott__AppearanceExtension(struct soap *soap, const char *tag, tt__AppearanceExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AppearanceExtension **)soap_malloc(soap, sizeof(tt__AppearanceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AppearanceExtension *)soap_instantiate_tt__AppearanceExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__AppearanceExtension ** p = (tt__AppearanceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AppearanceExtension, sizeof(tt__AppearanceExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AppearanceExtension(struct soap *soap, tt__AppearanceExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AppearanceExtension);
	if (soap_out_PointerTott__AppearanceExtension(soap, tag?tag:"tt:AppearanceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AppearanceExtension ** SOAP_FMAC4 soap_get_PointerTott__AppearanceExtension(struct soap *soap, tt__AppearanceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AppearanceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ClassDescriptor(struct soap *soap, tt__ClassDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ClassDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ClassDescriptor(struct soap *soap, const char *tag, int id, tt__ClassDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ClassDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ClassDescriptor ** SOAP_FMAC4 soap_in_PointerTott__ClassDescriptor(struct soap *soap, const char *tag, tt__ClassDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ClassDescriptor **)soap_malloc(soap, sizeof(tt__ClassDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ClassDescriptor *)soap_instantiate_tt__ClassDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ClassDescriptor ** p = (tt__ClassDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ClassDescriptor, sizeof(tt__ClassDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ClassDescriptor(struct soap *soap, tt__ClassDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ClassDescriptor);
	if (soap_out_PointerTott__ClassDescriptor(soap, tag?tag:"tt:ClassDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ClassDescriptor ** SOAP_FMAC4 soap_get_PointerTott__ClassDescriptor(struct soap *soap, tt__ClassDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ClassDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ColorDescriptor(struct soap *soap, tt__ColorDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ColorDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ColorDescriptor(struct soap *soap, const char *tag, int id, tt__ColorDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ColorDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ColorDescriptor ** SOAP_FMAC4 soap_in_PointerTott__ColorDescriptor(struct soap *soap, const char *tag, tt__ColorDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ColorDescriptor **)soap_malloc(soap, sizeof(tt__ColorDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ColorDescriptor *)soap_instantiate_tt__ColorDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ColorDescriptor ** p = (tt__ColorDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ColorDescriptor, sizeof(tt__ColorDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ColorDescriptor(struct soap *soap, tt__ColorDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ColorDescriptor);
	if (soap_out_PointerTott__ColorDescriptor(soap, tag?tag:"tt:ColorDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ColorDescriptor ** SOAP_FMAC4 soap_get_PointerTott__ColorDescriptor(struct soap *soap, tt__ColorDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ColorDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ShapeDescriptor(struct soap *soap, tt__ShapeDescriptor *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ShapeDescriptor))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ShapeDescriptor(struct soap *soap, const char *tag, int id, tt__ShapeDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ShapeDescriptor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ShapeDescriptor ** SOAP_FMAC4 soap_in_PointerTott__ShapeDescriptor(struct soap *soap, const char *tag, tt__ShapeDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ShapeDescriptor **)soap_malloc(soap, sizeof(tt__ShapeDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ShapeDescriptor *)soap_instantiate_tt__ShapeDescriptor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ShapeDescriptor ** p = (tt__ShapeDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ShapeDescriptor, sizeof(tt__ShapeDescriptor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ShapeDescriptor(struct soap *soap, tt__ShapeDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ShapeDescriptor);
	if (soap_out_PointerTott__ShapeDescriptor(soap, tag?tag:"tt:ShapeDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ShapeDescriptor ** SOAP_FMAC4 soap_get_PointerTott__ShapeDescriptor(struct soap *soap, tt__ShapeDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ShapeDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Transformation(struct soap *soap, tt__Transformation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Transformation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Transformation(struct soap *soap, const char *tag, int id, tt__Transformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Transformation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Transformation ** SOAP_FMAC4 soap_in_PointerTott__Transformation(struct soap *soap, const char *tag, tt__Transformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Transformation **)soap_malloc(soap, sizeof(tt__Transformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Transformation *)soap_instantiate_tt__Transformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Transformation ** p = (tt__Transformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Transformation, sizeof(tt__Transformation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Transformation(struct soap *soap, tt__Transformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Transformation);
	if (soap_out_PointerTott__Transformation(soap, tag?tag:"tt:Transformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Transformation ** SOAP_FMAC4 soap_get_PointerTott__Transformation(struct soap *soap, tt__Transformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Transformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector(struct soap *soap, tt__Vector *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector(struct soap *soap, const char *tag, int id, tt__Vector *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Vector ** SOAP_FMAC4 soap_in_PointerTott__Vector(struct soap *soap, const char *tag, tt__Vector **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Vector **)soap_malloc(soap, sizeof(tt__Vector *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Vector *)soap_instantiate_tt__Vector(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Vector ** p = (tt__Vector **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector, sizeof(tt__Vector), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector(struct soap *soap, tt__Vector *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Vector);
	if (soap_out_PointerTott__Vector(soap, tag?tag:"tt:Vector", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Vector ** SOAP_FMAC4 soap_get_PointerTott__Vector(struct soap *soap, tt__Vector **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemListDescriptionExtension(struct soap *soap, tt__ItemListDescriptionExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemListDescriptionExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemListDescriptionExtension(struct soap *soap, const char *tag, int id, tt__ItemListDescriptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemListDescriptionExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ItemListDescriptionExtension ** SOAP_FMAC4 soap_in_PointerTott__ItemListDescriptionExtension(struct soap *soap, const char *tag, tt__ItemListDescriptionExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ItemListDescriptionExtension **)soap_malloc(soap, sizeof(tt__ItemListDescriptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ItemListDescriptionExtension *)soap_instantiate_tt__ItemListDescriptionExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ItemListDescriptionExtension ** p = (tt__ItemListDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListDescriptionExtension, sizeof(tt__ItemListDescriptionExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemListDescriptionExtension(struct soap *soap, tt__ItemListDescriptionExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ItemListDescriptionExtension);
	if (soap_out_PointerTott__ItemListDescriptionExtension(soap, tag?tag:"tt:ItemListDescriptionExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ItemListDescriptionExtension ** SOAP_FMAC4 soap_get_PointerTott__ItemListDescriptionExtension(struct soap *soap, tt__ItemListDescriptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemListDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, _tt__ItemListDescription_ElementItemDescription *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, int id, _tt__ItemListDescription_ElementItemDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tt__ItemListDescription_ElementItemDescription ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, _tt__ItemListDescription_ElementItemDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tt__ItemListDescription_ElementItemDescription **)soap_malloc(soap, sizeof(_tt__ItemListDescription_ElementItemDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tt__ItemListDescription_ElementItemDescription *)soap_instantiate__tt__ItemListDescription_ElementItemDescription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tt__ItemListDescription_ElementItemDescription ** p = (_tt__ItemListDescription_ElementItemDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, sizeof(_tt__ItemListDescription_ElementItemDescription), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, _tt__ItemListDescription_ElementItemDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tt__ItemListDescription_ElementItemDescription);
	if (soap_out_PointerTo_tt__ItemListDescription_ElementItemDescription(soap, tag?tag:"tt:ItemListDescription-ElementItemDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tt__ItemListDescription_ElementItemDescription ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, _tt__ItemListDescription_ElementItemDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemListDescription_ElementItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, _tt__ItemListDescription_SimpleItemDescription *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, int id, _tt__ItemListDescription_SimpleItemDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tt__ItemListDescription_SimpleItemDescription ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, _tt__ItemListDescription_SimpleItemDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tt__ItemListDescription_SimpleItemDescription **)soap_malloc(soap, sizeof(_tt__ItemListDescription_SimpleItemDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tt__ItemListDescription_SimpleItemDescription *)soap_instantiate__tt__ItemListDescription_SimpleItemDescription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tt__ItemListDescription_SimpleItemDescription ** p = (_tt__ItemListDescription_SimpleItemDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, sizeof(_tt__ItemListDescription_SimpleItemDescription), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, _tt__ItemListDescription_SimpleItemDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tt__ItemListDescription_SimpleItemDescription);
	if (soap_out_PointerTo_tt__ItemListDescription_SimpleItemDescription(soap, tag?tag:"tt:ItemListDescription-SimpleItemDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tt__ItemListDescription_SimpleItemDescription ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, _tt__ItemListDescription_SimpleItemDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemListDescription_SimpleItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MessageDescriptionExtension(struct soap *soap, tt__MessageDescriptionExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MessageDescriptionExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MessageDescriptionExtension(struct soap *soap, const char *tag, int id, tt__MessageDescriptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MessageDescriptionExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__MessageDescriptionExtension ** SOAP_FMAC4 soap_in_PointerTott__MessageDescriptionExtension(struct soap *soap, const char *tag, tt__MessageDescriptionExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MessageDescriptionExtension **)soap_malloc(soap, sizeof(tt__MessageDescriptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MessageDescriptionExtension *)soap_instantiate_tt__MessageDescriptionExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__MessageDescriptionExtension ** p = (tt__MessageDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MessageDescriptionExtension, sizeof(tt__MessageDescriptionExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MessageDescriptionExtension(struct soap *soap, tt__MessageDescriptionExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MessageDescriptionExtension);
	if (soap_out_PointerTott__MessageDescriptionExtension(soap, tag?tag:"tt:MessageDescriptionExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MessageDescriptionExtension ** SOAP_FMAC4 soap_get_PointerTott__MessageDescriptionExtension(struct soap *soap, tt__MessageDescriptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MessageDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemListDescription(struct soap *soap, tt__ItemListDescription *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemListDescription))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemListDescription(struct soap *soap, const char *tag, int id, tt__ItemListDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemListDescription);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ItemListDescription ** SOAP_FMAC4 soap_in_PointerTott__ItemListDescription(struct soap *soap, const char *tag, tt__ItemListDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ItemListDescription **)soap_malloc(soap, sizeof(tt__ItemListDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ItemListDescription *)soap_instantiate_tt__ItemListDescription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ItemListDescription ** p = (tt__ItemListDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListDescription, sizeof(tt__ItemListDescription), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemListDescription(struct soap *soap, tt__ItemListDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ItemListDescription);
	if (soap_out_PointerTott__ItemListDescription(soap, tag?tag:"tt:ItemListDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ItemListDescription ** SOAP_FMAC4 soap_get_PointerTott__ItemListDescription(struct soap *soap, tt__ItemListDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemListDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemListExtension(struct soap *soap, tt__ItemListExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemListExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemListExtension(struct soap *soap, const char *tag, int id, tt__ItemListExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemListExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ItemListExtension ** SOAP_FMAC4 soap_in_PointerTott__ItemListExtension(struct soap *soap, const char *tag, tt__ItemListExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ItemListExtension **)soap_malloc(soap, sizeof(tt__ItemListExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ItemListExtension *)soap_instantiate_tt__ItemListExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ItemListExtension ** p = (tt__ItemListExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListExtension, sizeof(tt__ItemListExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemListExtension(struct soap *soap, tt__ItemListExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ItemListExtension);
	if (soap_out_PointerTott__ItemListExtension(soap, tag?tag:"tt:ItemListExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ItemListExtension ** SOAP_FMAC4 soap_get_PointerTott__ItemListExtension(struct soap *soap, tt__ItemListExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemListExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemList_ElementItem(struct soap *soap, _tt__ItemList_ElementItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemList_ElementItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemList_ElementItem(struct soap *soap, const char *tag, int id, _tt__ItemList_ElementItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemList_ElementItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tt__ItemList_ElementItem ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemList_ElementItem(struct soap *soap, const char *tag, _tt__ItemList_ElementItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tt__ItemList_ElementItem **)soap_malloc(soap, sizeof(_tt__ItemList_ElementItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tt__ItemList_ElementItem *)soap_instantiate__tt__ItemList_ElementItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tt__ItemList_ElementItem ** p = (_tt__ItemList_ElementItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemList_ElementItem, sizeof(_tt__ItemList_ElementItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemList_ElementItem(struct soap *soap, _tt__ItemList_ElementItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tt__ItemList_ElementItem);
	if (soap_out_PointerTo_tt__ItemList_ElementItem(soap, tag?tag:"tt:ItemList-ElementItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tt__ItemList_ElementItem ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemList_ElementItem(struct soap *soap, _tt__ItemList_ElementItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemList_ElementItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, _tt__ItemList_SimpleItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemList_SimpleItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, const char *tag, int id, _tt__ItemList_SimpleItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemList_SimpleItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tt__ItemList_SimpleItem ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, const char *tag, _tt__ItemList_SimpleItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tt__ItemList_SimpleItem **)soap_malloc(soap, sizeof(_tt__ItemList_SimpleItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tt__ItemList_SimpleItem *)soap_instantiate__tt__ItemList_SimpleItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tt__ItemList_SimpleItem ** p = (_tt__ItemList_SimpleItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemList_SimpleItem, sizeof(_tt__ItemList_SimpleItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, _tt__ItemList_SimpleItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tt__ItemList_SimpleItem);
	if (soap_out_PointerTo_tt__ItemList_SimpleItem(soap, tag?tag:"tt:ItemList-SimpleItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tt__ItemList_SimpleItem ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, _tt__ItemList_SimpleItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemList_SimpleItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusOptions20Extension(struct soap *soap, tt__FocusOptions20Extension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusOptions20Extension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusOptions20Extension(struct soap *soap, const char *tag, int id, tt__FocusOptions20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusOptions20Extension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__FocusOptions20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusOptions20Extension(struct soap *soap, const char *tag, tt__FocusOptions20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusOptions20Extension **)soap_malloc(soap, sizeof(tt__FocusOptions20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusOptions20Extension *)soap_instantiate_tt__FocusOptions20Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__FocusOptions20Extension ** p = (tt__FocusOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusOptions20Extension, sizeof(tt__FocusOptions20Extension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusOptions20Extension(struct soap *soap, tt__FocusOptions20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FocusOptions20Extension);
	if (soap_out_PointerTott__FocusOptions20Extension(soap, tag?tag:"tt:FocusOptions20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusOptions20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusOptions20Extension(struct soap *soap, tt__FocusOptions20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, tt__WhiteBalanceOptions20Extension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, int id, tt__WhiteBalanceOptions20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalanceOptions20Extension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20Extension ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, tt__WhiteBalanceOptions20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WhiteBalanceOptions20Extension **)soap_malloc(soap, sizeof(tt__WhiteBalanceOptions20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WhiteBalanceOptions20Extension *)soap_instantiate_tt__WhiteBalanceOptions20Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__WhiteBalanceOptions20Extension ** p = (tt__WhiteBalanceOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, sizeof(tt__WhiteBalanceOptions20Extension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, tt__WhiteBalanceOptions20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WhiteBalanceOptions20Extension);
	if (soap_out_PointerTott__WhiteBalanceOptions20Extension(soap, tag?tag:"tt:WhiteBalanceOptions20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20Extension ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, tt__WhiteBalanceOptions20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalanceOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusConfiguration20Extension(struct soap *soap, tt__FocusConfiguration20Extension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusConfiguration20Extension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusConfiguration20Extension(struct soap *soap, const char *tag, int id, tt__FocusConfiguration20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusConfiguration20Extension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__FocusConfiguration20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusConfiguration20Extension(struct soap *soap, const char *tag, tt__FocusConfiguration20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusConfiguration20Extension **)soap_malloc(soap, sizeof(tt__FocusConfiguration20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusConfiguration20Extension *)soap_instantiate_tt__FocusConfiguration20Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__FocusConfiguration20Extension ** p = (tt__FocusConfiguration20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(tt__FocusConfiguration20Extension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusConfiguration20Extension(struct soap *soap, tt__FocusConfiguration20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FocusConfiguration20Extension);
	if (soap_out_PointerTott__FocusConfiguration20Extension(soap, tag?tag:"tt:FocusConfiguration20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusConfiguration20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusConfiguration20Extension(struct soap *soap, tt__FocusConfiguration20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusConfiguration20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalance20Extension(struct soap *soap, tt__WhiteBalance20Extension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalance20Extension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalance20Extension(struct soap *soap, const char *tag, int id, tt__WhiteBalance20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalance20Extension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__WhiteBalance20Extension ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalance20Extension(struct soap *soap, const char *tag, tt__WhiteBalance20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WhiteBalance20Extension **)soap_malloc(soap, sizeof(tt__WhiteBalance20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WhiteBalance20Extension *)soap_instantiate_tt__WhiteBalance20Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__WhiteBalance20Extension ** p = (tt__WhiteBalance20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(tt__WhiteBalance20Extension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalance20Extension(struct soap *soap, tt__WhiteBalance20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WhiteBalance20Extension);
	if (soap_out_PointerTott__WhiteBalance20Extension(soap, tag?tag:"tt:WhiteBalance20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WhiteBalance20Extension ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalance20Extension(struct soap *soap, tt__WhiteBalance20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalance20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelativeFocusOptions20(struct soap *soap, tt__RelativeFocusOptions20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelativeFocusOptions20))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelativeFocusOptions20(struct soap *soap, const char *tag, int id, tt__RelativeFocusOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelativeFocusOptions20);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__RelativeFocusOptions20 ** SOAP_FMAC4 soap_in_PointerTott__RelativeFocusOptions20(struct soap *soap, const char *tag, tt__RelativeFocusOptions20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RelativeFocusOptions20 **)soap_malloc(soap, sizeof(tt__RelativeFocusOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RelativeFocusOptions20 *)soap_instantiate_tt__RelativeFocusOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__RelativeFocusOptions20 ** p = (tt__RelativeFocusOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelativeFocusOptions20, sizeof(tt__RelativeFocusOptions20), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelativeFocusOptions20(struct soap *soap, tt__RelativeFocusOptions20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RelativeFocusOptions20);
	if (soap_out_PointerTott__RelativeFocusOptions20(soap, tag?tag:"tt:RelativeFocusOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RelativeFocusOptions20 ** SOAP_FMAC4 soap_get_PointerTott__RelativeFocusOptions20(struct soap *soap, tt__RelativeFocusOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelativeFocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20Extension(struct soap *soap, tt__ImagingOptions20Extension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingOptions20Extension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20Extension(struct soap *soap, const char *tag, int id, tt__ImagingOptions20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingOptions20Extension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20Extension(struct soap *soap, const char *tag, tt__ImagingOptions20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingOptions20Extension **)soap_malloc(soap, sizeof(tt__ImagingOptions20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingOptions20Extension *)soap_instantiate_tt__ImagingOptions20Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ImagingOptions20Extension ** p = (tt__ImagingOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20Extension, sizeof(tt__ImagingOptions20Extension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20Extension(struct soap *soap, tt__ImagingOptions20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingOptions20Extension);
	if (soap_out_PointerTott__ImagingOptions20Extension(soap, tag?tag:"tt:ImagingOptions20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingOptions20Extension ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20Extension(struct soap *soap, tt__ImagingOptions20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalanceOptions20(struct soap *soap, tt__WhiteBalanceOptions20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalanceOptions20))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalanceOptions20(struct soap *soap, const char *tag, int id, tt__WhiteBalanceOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalanceOptions20);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20 ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalanceOptions20(struct soap *soap, const char *tag, tt__WhiteBalanceOptions20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WhiteBalanceOptions20 **)soap_malloc(soap, sizeof(tt__WhiteBalanceOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WhiteBalanceOptions20 *)soap_instantiate_tt__WhiteBalanceOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__WhiteBalanceOptions20 ** p = (tt__WhiteBalanceOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalanceOptions20, sizeof(tt__WhiteBalanceOptions20), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalanceOptions20(struct soap *soap, tt__WhiteBalanceOptions20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WhiteBalanceOptions20);
	if (soap_out_PointerTott__WhiteBalanceOptions20(soap, tag?tag:"tt:WhiteBalanceOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20 ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalanceOptions20(struct soap *soap, tt__WhiteBalanceOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalanceOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WideDynamicRangeOptions20(struct soap *soap, tt__WideDynamicRangeOptions20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WideDynamicRangeOptions20))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WideDynamicRangeOptions20(struct soap *soap, const char *tag, int id, tt__WideDynamicRangeOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WideDynamicRangeOptions20);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__WideDynamicRangeOptions20 ** SOAP_FMAC4 soap_in_PointerTott__WideDynamicRangeOptions20(struct soap *soap, const char *tag, tt__WideDynamicRangeOptions20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WideDynamicRangeOptions20 **)soap_malloc(soap, sizeof(tt__WideDynamicRangeOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WideDynamicRangeOptions20 *)soap_instantiate_tt__WideDynamicRangeOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__WideDynamicRangeOptions20 ** p = (tt__WideDynamicRangeOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicRangeOptions20, sizeof(tt__WideDynamicRangeOptions20), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WideDynamicRangeOptions20(struct soap *soap, tt__WideDynamicRangeOptions20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WideDynamicRangeOptions20);
	if (soap_out_PointerTott__WideDynamicRangeOptions20(soap, tag?tag:"tt:WideDynamicRangeOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WideDynamicRangeOptions20 ** SOAP_FMAC4 soap_get_PointerTott__WideDynamicRangeOptions20(struct soap *soap, tt__WideDynamicRangeOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WideDynamicRangeOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusOptions20(struct soap *soap, tt__FocusOptions20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusOptions20))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusOptions20(struct soap *soap, const char *tag, int id, tt__FocusOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusOptions20);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__FocusOptions20 ** SOAP_FMAC4 soap_in_PointerTott__FocusOptions20(struct soap *soap, const char *tag, tt__FocusOptions20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusOptions20 **)soap_malloc(soap, sizeof(tt__FocusOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusOptions20 *)soap_instantiate_tt__FocusOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__FocusOptions20 ** p = (tt__FocusOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusOptions20, sizeof(tt__FocusOptions20), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusOptions20(struct soap *soap, tt__FocusOptions20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FocusOptions20);
	if (soap_out_PointerTott__FocusOptions20(soap, tag?tag:"tt:FocusOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusOptions20 ** SOAP_FMAC4 soap_get_PointerTott__FocusOptions20(struct soap *soap, tt__FocusOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ExposureOptions20(struct soap *soap, tt__ExposureOptions20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ExposureOptions20))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ExposureOptions20(struct soap *soap, const char *tag, int id, tt__ExposureOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ExposureOptions20);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ExposureOptions20 ** SOAP_FMAC4 soap_in_PointerTott__ExposureOptions20(struct soap *soap, const char *tag, tt__ExposureOptions20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ExposureOptions20 **)soap_malloc(soap, sizeof(tt__ExposureOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ExposureOptions20 *)soap_instantiate_tt__ExposureOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ExposureOptions20 ** p = (tt__ExposureOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ExposureOptions20, sizeof(tt__ExposureOptions20), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ExposureOptions20(struct soap *soap, tt__ExposureOptions20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ExposureOptions20);
	if (soap_out_PointerTott__ExposureOptions20(soap, tag?tag:"tt:ExposureOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ExposureOptions20 ** SOAP_FMAC4 soap_get_PointerTott__ExposureOptions20(struct soap *soap, tt__ExposureOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ExposureOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensationOptions20(struct soap *soap, tt__BacklightCompensationOptions20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BacklightCompensationOptions20))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensationOptions20(struct soap *soap, const char *tag, int id, tt__BacklightCompensationOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BacklightCompensationOptions20);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__BacklightCompensationOptions20 ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensationOptions20(struct soap *soap, const char *tag, tt__BacklightCompensationOptions20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__BacklightCompensationOptions20 **)soap_malloc(soap, sizeof(tt__BacklightCompensationOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__BacklightCompensationOptions20 *)soap_instantiate_tt__BacklightCompensationOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__BacklightCompensationOptions20 ** p = (tt__BacklightCompensationOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensationOptions20, sizeof(tt__BacklightCompensationOptions20), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensationOptions20(struct soap *soap, tt__BacklightCompensationOptions20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__BacklightCompensationOptions20);
	if (soap_out_PointerTott__BacklightCompensationOptions20(soap, tag?tag:"tt:BacklightCompensationOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__BacklightCompensationOptions20 ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensationOptions20(struct soap *soap, tt__BacklightCompensationOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BacklightCompensationOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ExposurePriority(struct soap *soap, enum tt__ExposurePriority *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_tt__ExposurePriority);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ExposurePriority(struct soap *soap, const char *tag, int id, enum tt__ExposurePriority *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ExposurePriority);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ExposurePriority(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__ExposurePriority ** SOAP_FMAC4 soap_in_PointerTott__ExposurePriority(struct soap *soap, const char *tag, enum tt__ExposurePriority **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__ExposurePriority **)soap_malloc(soap, sizeof(enum tt__ExposurePriority *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ExposurePriority(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__ExposurePriority **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ExposurePriority, sizeof(enum tt__ExposurePriority), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ExposurePriority(struct soap *soap, enum tt__ExposurePriority *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ExposurePriority);
	if (soap_out_PointerTott__ExposurePriority(soap, tag?tag:"tt:ExposurePriority", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ExposurePriority ** SOAP_FMAC4 soap_get_PointerTott__ExposurePriority(struct soap *soap, enum tt__ExposurePriority **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ExposurePriority(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension20(struct soap *soap, tt__ImagingSettingsExtension20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettingsExtension20))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension20(struct soap *soap, const char *tag, int id, tt__ImagingSettingsExtension20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettingsExtension20);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension20(struct soap *soap, const char *tag, tt__ImagingSettingsExtension20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingSettingsExtension20 **)soap_malloc(soap, sizeof(tt__ImagingSettingsExtension20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingSettingsExtension20 *)soap_instantiate_tt__ImagingSettingsExtension20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ImagingSettingsExtension20 ** p = (tt__ImagingSettingsExtension20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension20, sizeof(tt__ImagingSettingsExtension20), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension20(struct soap *soap, tt__ImagingSettingsExtension20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingSettingsExtension20);
	if (soap_out_PointerTott__ImagingSettingsExtension20(soap, tag?tag:"tt:ImagingSettingsExtension20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingSettingsExtension20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension20(struct soap *soap, tt__ImagingSettingsExtension20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettingsExtension20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalance20(struct soap *soap, tt__WhiteBalance20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalance20))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalance20(struct soap *soap, const char *tag, int id, tt__WhiteBalance20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalance20);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__WhiteBalance20 ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalance20(struct soap *soap, const char *tag, tt__WhiteBalance20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WhiteBalance20 **)soap_malloc(soap, sizeof(tt__WhiteBalance20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WhiteBalance20 *)soap_instantiate_tt__WhiteBalance20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__WhiteBalance20 ** p = (tt__WhiteBalance20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalance20, sizeof(tt__WhiteBalance20), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalance20(struct soap *soap, tt__WhiteBalance20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WhiteBalance20);
	if (soap_out_PointerTott__WhiteBalance20(soap, tag?tag:"tt:WhiteBalance20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WhiteBalance20 ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalance20(struct soap *soap, tt__WhiteBalance20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalance20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WideDynamicRange20(struct soap *soap, tt__WideDynamicRange20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WideDynamicRange20))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WideDynamicRange20(struct soap *soap, const char *tag, int id, tt__WideDynamicRange20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WideDynamicRange20);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__WideDynamicRange20 ** SOAP_FMAC4 soap_in_PointerTott__WideDynamicRange20(struct soap *soap, const char *tag, tt__WideDynamicRange20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WideDynamicRange20 **)soap_malloc(soap, sizeof(tt__WideDynamicRange20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WideDynamicRange20 *)soap_instantiate_tt__WideDynamicRange20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__WideDynamicRange20 ** p = (tt__WideDynamicRange20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicRange20, sizeof(tt__WideDynamicRange20), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WideDynamicRange20(struct soap *soap, tt__WideDynamicRange20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WideDynamicRange20);
	if (soap_out_PointerTott__WideDynamicRange20(soap, tag?tag:"tt:WideDynamicRange20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WideDynamicRange20 ** SOAP_FMAC4 soap_get_PointerTott__WideDynamicRange20(struct soap *soap, tt__WideDynamicRange20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WideDynamicRange20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusConfiguration20(struct soap *soap, tt__FocusConfiguration20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusConfiguration20))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusConfiguration20(struct soap *soap, const char *tag, int id, tt__FocusConfiguration20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusConfiguration20);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__FocusConfiguration20 ** SOAP_FMAC4 soap_in_PointerTott__FocusConfiguration20(struct soap *soap, const char *tag, tt__FocusConfiguration20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusConfiguration20 **)soap_malloc(soap, sizeof(tt__FocusConfiguration20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusConfiguration20 *)soap_instantiate_tt__FocusConfiguration20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__FocusConfiguration20 ** p = (tt__FocusConfiguration20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusConfiguration20, sizeof(tt__FocusConfiguration20), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusConfiguration20(struct soap *soap, tt__FocusConfiguration20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FocusConfiguration20);
	if (soap_out_PointerTott__FocusConfiguration20(soap, tag?tag:"tt:FocusConfiguration20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusConfiguration20 ** SOAP_FMAC4 soap_get_PointerTott__FocusConfiguration20(struct soap *soap, tt__FocusConfiguration20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusConfiguration20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Exposure20(struct soap *soap, tt__Exposure20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Exposure20))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Exposure20(struct soap *soap, const char *tag, int id, tt__Exposure20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Exposure20);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Exposure20 ** SOAP_FMAC4 soap_in_PointerTott__Exposure20(struct soap *soap, const char *tag, tt__Exposure20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Exposure20 **)soap_malloc(soap, sizeof(tt__Exposure20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Exposure20 *)soap_instantiate_tt__Exposure20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Exposure20 ** p = (tt__Exposure20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Exposure20, sizeof(tt__Exposure20), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Exposure20(struct soap *soap, tt__Exposure20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Exposure20);
	if (soap_out_PointerTott__Exposure20(soap, tag?tag:"tt:Exposure20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Exposure20 ** SOAP_FMAC4 soap_get_PointerTott__Exposure20(struct soap *soap, tt__Exposure20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Exposure20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensation20(struct soap *soap, tt__BacklightCompensation20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BacklightCompensation20))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensation20(struct soap *soap, const char *tag, int id, tt__BacklightCompensation20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BacklightCompensation20);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__BacklightCompensation20 ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensation20(struct soap *soap, const char *tag, tt__BacklightCompensation20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__BacklightCompensation20 **)soap_malloc(soap, sizeof(tt__BacklightCompensation20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__BacklightCompensation20 *)soap_instantiate_tt__BacklightCompensation20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__BacklightCompensation20 ** p = (tt__BacklightCompensation20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensation20, sizeof(tt__BacklightCompensation20), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensation20(struct soap *soap, tt__BacklightCompensation20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__BacklightCompensation20);
	if (soap_out_PointerTott__BacklightCompensation20(soap, tag?tag:"tt:BacklightCompensation20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__BacklightCompensation20 ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensation20(struct soap *soap, tt__BacklightCompensation20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BacklightCompensation20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusStatus20Extension(struct soap *soap, tt__FocusStatus20Extension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusStatus20Extension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusStatus20Extension(struct soap *soap, const char *tag, int id, tt__FocusStatus20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusStatus20Extension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__FocusStatus20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusStatus20Extension(struct soap *soap, const char *tag, tt__FocusStatus20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusStatus20Extension **)soap_malloc(soap, sizeof(tt__FocusStatus20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusStatus20Extension *)soap_instantiate_tt__FocusStatus20Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__FocusStatus20Extension ** p = (tt__FocusStatus20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusStatus20Extension, sizeof(tt__FocusStatus20Extension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusStatus20Extension(struct soap *soap, tt__FocusStatus20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FocusStatus20Extension);
	if (soap_out_PointerTott__FocusStatus20Extension(soap, tag?tag:"tt:FocusStatus20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusStatus20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusStatus20Extension(struct soap *soap, tt__FocusStatus20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingStatus20Extension(struct soap *soap, tt__ImagingStatus20Extension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingStatus20Extension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingStatus20Extension(struct soap *soap, const char *tag, int id, tt__ImagingStatus20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingStatus20Extension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ImagingStatus20Extension ** SOAP_FMAC4 soap_in_PointerTott__ImagingStatus20Extension(struct soap *soap, const char *tag, tt__ImagingStatus20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingStatus20Extension **)soap_malloc(soap, sizeof(tt__ImagingStatus20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingStatus20Extension *)soap_instantiate_tt__ImagingStatus20Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ImagingStatus20Extension ** p = (tt__ImagingStatus20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingStatus20Extension, sizeof(tt__ImagingStatus20Extension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingStatus20Extension(struct soap *soap, tt__ImagingStatus20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingStatus20Extension);
	if (soap_out_PointerTott__ImagingStatus20Extension(soap, tag?tag:"tt:ImagingStatus20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingStatus20Extension ** SOAP_FMAC4 soap_get_PointerTott__ImagingStatus20Extension(struct soap *soap, tt__ImagingStatus20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusStatus20(struct soap *soap, tt__FocusStatus20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusStatus20))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusStatus20(struct soap *soap, const char *tag, int id, tt__FocusStatus20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusStatus20);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__FocusStatus20 ** SOAP_FMAC4 soap_in_PointerTott__FocusStatus20(struct soap *soap, const char *tag, tt__FocusStatus20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusStatus20 **)soap_malloc(soap, sizeof(tt__FocusStatus20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusStatus20 *)soap_instantiate_tt__FocusStatus20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__FocusStatus20 ** p = (tt__FocusStatus20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusStatus20, sizeof(tt__FocusStatus20), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusStatus20(struct soap *soap, tt__FocusStatus20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FocusStatus20);
	if (soap_out_PointerTott__FocusStatus20(soap, tag?tag:"tt:FocusStatus20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusStatus20 ** SOAP_FMAC4 soap_get_PointerTott__FocusStatus20(struct soap *soap, tt__FocusStatus20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ContinuousFocusOptions(struct soap *soap, tt__ContinuousFocusOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ContinuousFocusOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ContinuousFocusOptions(struct soap *soap, const char *tag, int id, tt__ContinuousFocusOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ContinuousFocusOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ContinuousFocusOptions ** SOAP_FMAC4 soap_in_PointerTott__ContinuousFocusOptions(struct soap *soap, const char *tag, tt__ContinuousFocusOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ContinuousFocusOptions **)soap_malloc(soap, sizeof(tt__ContinuousFocusOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ContinuousFocusOptions *)soap_instantiate_tt__ContinuousFocusOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ContinuousFocusOptions ** p = (tt__ContinuousFocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ContinuousFocusOptions, sizeof(tt__ContinuousFocusOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ContinuousFocusOptions(struct soap *soap, tt__ContinuousFocusOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ContinuousFocusOptions);
	if (soap_out_PointerTott__ContinuousFocusOptions(soap, tag?tag:"tt:ContinuousFocusOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ContinuousFocusOptions ** SOAP_FMAC4 soap_get_PointerTott__ContinuousFocusOptions(struct soap *soap, tt__ContinuousFocusOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ContinuousFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelativeFocusOptions(struct soap *soap, tt__RelativeFocusOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelativeFocusOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelativeFocusOptions(struct soap *soap, const char *tag, int id, tt__RelativeFocusOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelativeFocusOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__RelativeFocusOptions ** SOAP_FMAC4 soap_in_PointerTott__RelativeFocusOptions(struct soap *soap, const char *tag, tt__RelativeFocusOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RelativeFocusOptions **)soap_malloc(soap, sizeof(tt__RelativeFocusOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RelativeFocusOptions *)soap_instantiate_tt__RelativeFocusOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__RelativeFocusOptions ** p = (tt__RelativeFocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelativeFocusOptions, sizeof(tt__RelativeFocusOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelativeFocusOptions(struct soap *soap, tt__RelativeFocusOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RelativeFocusOptions);
	if (soap_out_PointerTott__RelativeFocusOptions(soap, tag?tag:"tt:RelativeFocusOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RelativeFocusOptions ** SOAP_FMAC4 soap_get_PointerTott__RelativeFocusOptions(struct soap *soap, tt__RelativeFocusOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelativeFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AbsoluteFocusOptions(struct soap *soap, tt__AbsoluteFocusOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AbsoluteFocusOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AbsoluteFocusOptions(struct soap *soap, const char *tag, int id, tt__AbsoluteFocusOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AbsoluteFocusOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__AbsoluteFocusOptions ** SOAP_FMAC4 soap_in_PointerTott__AbsoluteFocusOptions(struct soap *soap, const char *tag, tt__AbsoluteFocusOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AbsoluteFocusOptions **)soap_malloc(soap, sizeof(tt__AbsoluteFocusOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AbsoluteFocusOptions *)soap_instantiate_tt__AbsoluteFocusOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__AbsoluteFocusOptions ** p = (tt__AbsoluteFocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AbsoluteFocusOptions, sizeof(tt__AbsoluteFocusOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AbsoluteFocusOptions(struct soap *soap, tt__AbsoluteFocusOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AbsoluteFocusOptions);
	if (soap_out_PointerTott__AbsoluteFocusOptions(soap, tag?tag:"tt:AbsoluteFocusOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AbsoluteFocusOptions ** SOAP_FMAC4 soap_get_PointerTott__AbsoluteFocusOptions(struct soap *soap, tt__AbsoluteFocusOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AbsoluteFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ContinuousFocus(struct soap *soap, tt__ContinuousFocus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ContinuousFocus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ContinuousFocus(struct soap *soap, const char *tag, int id, tt__ContinuousFocus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ContinuousFocus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ContinuousFocus ** SOAP_FMAC4 soap_in_PointerTott__ContinuousFocus(struct soap *soap, const char *tag, tt__ContinuousFocus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ContinuousFocus **)soap_malloc(soap, sizeof(tt__ContinuousFocus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ContinuousFocus *)soap_instantiate_tt__ContinuousFocus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ContinuousFocus ** p = (tt__ContinuousFocus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ContinuousFocus, sizeof(tt__ContinuousFocus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ContinuousFocus(struct soap *soap, tt__ContinuousFocus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ContinuousFocus);
	if (soap_out_PointerTott__ContinuousFocus(soap, tag?tag:"tt:ContinuousFocus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ContinuousFocus ** SOAP_FMAC4 soap_get_PointerTott__ContinuousFocus(struct soap *soap, tt__ContinuousFocus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ContinuousFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelativeFocus(struct soap *soap, tt__RelativeFocus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelativeFocus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelativeFocus(struct soap *soap, const char *tag, int id, tt__RelativeFocus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelativeFocus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__RelativeFocus ** SOAP_FMAC4 soap_in_PointerTott__RelativeFocus(struct soap *soap, const char *tag, tt__RelativeFocus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RelativeFocus **)soap_malloc(soap, sizeof(tt__RelativeFocus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RelativeFocus *)soap_instantiate_tt__RelativeFocus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__RelativeFocus ** p = (tt__RelativeFocus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelativeFocus, sizeof(tt__RelativeFocus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelativeFocus(struct soap *soap, tt__RelativeFocus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RelativeFocus);
	if (soap_out_PointerTott__RelativeFocus(soap, tag?tag:"tt:RelativeFocus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RelativeFocus ** SOAP_FMAC4 soap_get_PointerTott__RelativeFocus(struct soap *soap, tt__RelativeFocus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelativeFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AbsoluteFocus(struct soap *soap, tt__AbsoluteFocus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AbsoluteFocus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AbsoluteFocus(struct soap *soap, const char *tag, int id, tt__AbsoluteFocus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AbsoluteFocus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__AbsoluteFocus ** SOAP_FMAC4 soap_in_PointerTott__AbsoluteFocus(struct soap *soap, const char *tag, tt__AbsoluteFocus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AbsoluteFocus **)soap_malloc(soap, sizeof(tt__AbsoluteFocus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AbsoluteFocus *)soap_instantiate_tt__AbsoluteFocus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__AbsoluteFocus ** p = (tt__AbsoluteFocus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AbsoluteFocus, sizeof(tt__AbsoluteFocus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AbsoluteFocus(struct soap *soap, tt__AbsoluteFocus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AbsoluteFocus);
	if (soap_out_PointerTott__AbsoluteFocus(soap, tag?tag:"tt:AbsoluteFocus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AbsoluteFocus ** SOAP_FMAC4 soap_get_PointerTott__AbsoluteFocus(struct soap *soap, tt__AbsoluteFocus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AbsoluteFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalanceOptions(struct soap *soap, tt__WhiteBalanceOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalanceOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalanceOptions(struct soap *soap, const char *tag, int id, tt__WhiteBalanceOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalanceOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalanceOptions(struct soap *soap, const char *tag, tt__WhiteBalanceOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WhiteBalanceOptions **)soap_malloc(soap, sizeof(tt__WhiteBalanceOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WhiteBalanceOptions *)soap_instantiate_tt__WhiteBalanceOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__WhiteBalanceOptions ** p = (tt__WhiteBalanceOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalanceOptions, sizeof(tt__WhiteBalanceOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalanceOptions(struct soap *soap, tt__WhiteBalanceOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WhiteBalanceOptions);
	if (soap_out_PointerTott__WhiteBalanceOptions(soap, tag?tag:"tt:WhiteBalanceOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WhiteBalanceOptions ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalanceOptions(struct soap *soap, tt__WhiteBalanceOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalanceOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WideDynamicRangeOptions(struct soap *soap, tt__WideDynamicRangeOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WideDynamicRangeOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WideDynamicRangeOptions(struct soap *soap, const char *tag, int id, tt__WideDynamicRangeOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WideDynamicRangeOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__WideDynamicRangeOptions ** SOAP_FMAC4 soap_in_PointerTott__WideDynamicRangeOptions(struct soap *soap, const char *tag, tt__WideDynamicRangeOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WideDynamicRangeOptions **)soap_malloc(soap, sizeof(tt__WideDynamicRangeOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WideDynamicRangeOptions *)soap_instantiate_tt__WideDynamicRangeOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__WideDynamicRangeOptions ** p = (tt__WideDynamicRangeOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicRangeOptions, sizeof(tt__WideDynamicRangeOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WideDynamicRangeOptions(struct soap *soap, tt__WideDynamicRangeOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WideDynamicRangeOptions);
	if (soap_out_PointerTott__WideDynamicRangeOptions(soap, tag?tag:"tt:WideDynamicRangeOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WideDynamicRangeOptions ** SOAP_FMAC4 soap_get_PointerTott__WideDynamicRangeOptions(struct soap *soap, tt__WideDynamicRangeOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WideDynamicRangeOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusOptions(struct soap *soap, tt__FocusOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusOptions(struct soap *soap, const char *tag, int id, tt__FocusOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__FocusOptions ** SOAP_FMAC4 soap_in_PointerTott__FocusOptions(struct soap *soap, const char *tag, tt__FocusOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusOptions **)soap_malloc(soap, sizeof(tt__FocusOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusOptions *)soap_instantiate_tt__FocusOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__FocusOptions ** p = (tt__FocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusOptions, sizeof(tt__FocusOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusOptions(struct soap *soap, tt__FocusOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FocusOptions);
	if (soap_out_PointerTott__FocusOptions(soap, tag?tag:"tt:FocusOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusOptions ** SOAP_FMAC4 soap_get_PointerTott__FocusOptions(struct soap *soap, tt__FocusOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ExposureOptions(struct soap *soap, tt__ExposureOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ExposureOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ExposureOptions(struct soap *soap, const char *tag, int id, tt__ExposureOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ExposureOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ExposureOptions ** SOAP_FMAC4 soap_in_PointerTott__ExposureOptions(struct soap *soap, const char *tag, tt__ExposureOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ExposureOptions **)soap_malloc(soap, sizeof(tt__ExposureOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ExposureOptions *)soap_instantiate_tt__ExposureOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ExposureOptions ** p = (tt__ExposureOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ExposureOptions, sizeof(tt__ExposureOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ExposureOptions(struct soap *soap, tt__ExposureOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ExposureOptions);
	if (soap_out_PointerTott__ExposureOptions(soap, tag?tag:"tt:ExposureOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ExposureOptions ** SOAP_FMAC4 soap_get_PointerTott__ExposureOptions(struct soap *soap, tt__ExposureOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ExposureOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensationOptions(struct soap *soap, tt__BacklightCompensationOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BacklightCompensationOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensationOptions(struct soap *soap, const char *tag, int id, tt__BacklightCompensationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BacklightCompensationOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__BacklightCompensationOptions ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensationOptions(struct soap *soap, const char *tag, tt__BacklightCompensationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__BacklightCompensationOptions **)soap_malloc(soap, sizeof(tt__BacklightCompensationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__BacklightCompensationOptions *)soap_instantiate_tt__BacklightCompensationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__BacklightCompensationOptions ** p = (tt__BacklightCompensationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensationOptions, sizeof(tt__BacklightCompensationOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensationOptions(struct soap *soap, tt__BacklightCompensationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__BacklightCompensationOptions);
	if (soap_out_PointerTott__BacklightCompensationOptions(soap, tag?tag:"tt:BacklightCompensationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__BacklightCompensationOptions ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensationOptions(struct soap *soap, tt__BacklightCompensationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BacklightCompensationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Rectangle(struct soap *soap, tt__Rectangle *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Rectangle))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Rectangle(struct soap *soap, const char *tag, int id, tt__Rectangle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Rectangle);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Rectangle ** SOAP_FMAC4 soap_in_PointerTott__Rectangle(struct soap *soap, const char *tag, tt__Rectangle **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Rectangle **)soap_malloc(soap, sizeof(tt__Rectangle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Rectangle *)soap_instantiate_tt__Rectangle(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Rectangle ** p = (tt__Rectangle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Rectangle, sizeof(tt__Rectangle), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Rectangle(struct soap *soap, tt__Rectangle *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Rectangle);
	if (soap_out_PointerTott__Rectangle(soap, tag?tag:"tt:Rectangle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Rectangle ** SOAP_FMAC4 soap_get_PointerTott__Rectangle(struct soap *soap, tt__Rectangle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Rectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension(struct soap *soap, tt__ImagingSettingsExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettingsExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension(struct soap *soap, const char *tag, int id, tt__ImagingSettingsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettingsExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension(struct soap *soap, const char *tag, tt__ImagingSettingsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingSettingsExtension **)soap_malloc(soap, sizeof(tt__ImagingSettingsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingSettingsExtension *)soap_instantiate_tt__ImagingSettingsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ImagingSettingsExtension ** p = (tt__ImagingSettingsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension, sizeof(tt__ImagingSettingsExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension(struct soap *soap, tt__ImagingSettingsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingSettingsExtension);
	if (soap_out_PointerTott__ImagingSettingsExtension(soap, tag?tag:"tt:ImagingSettingsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingSettingsExtension ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension(struct soap *soap, tt__ImagingSettingsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettingsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalance(struct soap *soap, tt__WhiteBalance *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalance))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalance(struct soap *soap, const char *tag, int id, tt__WhiteBalance *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalance);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__WhiteBalance ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalance(struct soap *soap, const char *tag, tt__WhiteBalance **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WhiteBalance **)soap_malloc(soap, sizeof(tt__WhiteBalance *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WhiteBalance *)soap_instantiate_tt__WhiteBalance(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__WhiteBalance ** p = (tt__WhiteBalance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalance, sizeof(tt__WhiteBalance), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalance(struct soap *soap, tt__WhiteBalance *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WhiteBalance);
	if (soap_out_PointerTott__WhiteBalance(soap, tag?tag:"tt:WhiteBalance", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WhiteBalance ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalance(struct soap *soap, tt__WhiteBalance **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WideDynamicRange(struct soap *soap, tt__WideDynamicRange *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WideDynamicRange))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WideDynamicRange(struct soap *soap, const char *tag, int id, tt__WideDynamicRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WideDynamicRange);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__WideDynamicRange ** SOAP_FMAC4 soap_in_PointerTott__WideDynamicRange(struct soap *soap, const char *tag, tt__WideDynamicRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WideDynamicRange **)soap_malloc(soap, sizeof(tt__WideDynamicRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WideDynamicRange *)soap_instantiate_tt__WideDynamicRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__WideDynamicRange ** p = (tt__WideDynamicRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicRange, sizeof(tt__WideDynamicRange), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WideDynamicRange(struct soap *soap, tt__WideDynamicRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WideDynamicRange);
	if (soap_out_PointerTott__WideDynamicRange(soap, tag?tag:"tt:WideDynamicRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WideDynamicRange ** SOAP_FMAC4 soap_get_PointerTott__WideDynamicRange(struct soap *soap, tt__WideDynamicRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WideDynamicRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_tt__IrCutFilterMode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterMode(struct soap *soap, const char *tag, int id, enum tt__IrCutFilterMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IrCutFilterMode);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IrCutFilterMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__IrCutFilterMode ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterMode(struct soap *soap, const char *tag, enum tt__IrCutFilterMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__IrCutFilterMode **)soap_malloc(soap, sizeof(enum tt__IrCutFilterMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IrCutFilterMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__IrCutFilterMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterMode, sizeof(enum tt__IrCutFilterMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IrCutFilterMode);
	if (soap_out_PointerTott__IrCutFilterMode(soap, tag?tag:"tt:IrCutFilterMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IrCutFilterMode ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IrCutFilterMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusConfiguration(struct soap *soap, tt__FocusConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusConfiguration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusConfiguration(struct soap *soap, const char *tag, int id, tt__FocusConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__FocusConfiguration ** SOAP_FMAC4 soap_in_PointerTott__FocusConfiguration(struct soap *soap, const char *tag, tt__FocusConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusConfiguration **)soap_malloc(soap, sizeof(tt__FocusConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusConfiguration *)soap_instantiate_tt__FocusConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__FocusConfiguration ** p = (tt__FocusConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusConfiguration, sizeof(tt__FocusConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusConfiguration(struct soap *soap, tt__FocusConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FocusConfiguration);
	if (soap_out_PointerTott__FocusConfiguration(soap, tag?tag:"tt:FocusConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusConfiguration ** SOAP_FMAC4 soap_get_PointerTott__FocusConfiguration(struct soap *soap, tt__FocusConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Exposure(struct soap *soap, tt__Exposure *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Exposure))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Exposure(struct soap *soap, const char *tag, int id, tt__Exposure *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Exposure);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Exposure ** SOAP_FMAC4 soap_in_PointerTott__Exposure(struct soap *soap, const char *tag, tt__Exposure **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Exposure **)soap_malloc(soap, sizeof(tt__Exposure *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Exposure *)soap_instantiate_tt__Exposure(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Exposure ** p = (tt__Exposure **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Exposure, sizeof(tt__Exposure), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Exposure(struct soap *soap, tt__Exposure *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Exposure);
	if (soap_out_PointerTott__Exposure(soap, tag?tag:"tt:Exposure", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Exposure ** SOAP_FMAC4 soap_get_PointerTott__Exposure(struct soap *soap, tt__Exposure **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Exposure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofloat(struct soap *soap, float *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofloat(struct soap *soap, const char *tag, int id, float *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_float);
	if (id < 0)
		return soap->error;
	return soap_out_float(soap, tag, id, *a, type);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_in_PointerTofloat(struct soap *soap, const char *tag, float **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (float **)soap_malloc(soap, sizeof(float *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_float(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (float **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_float, sizeof(float), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofloat(struct soap *soap, float *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofloat);
	if (soap_out_PointerTofloat(soap, tag?tag:"float", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_get_PointerTofloat(struct soap *soap, float **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofloat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensation(struct soap *soap, tt__BacklightCompensation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BacklightCompensation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensation(struct soap *soap, const char *tag, int id, tt__BacklightCompensation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BacklightCompensation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__BacklightCompensation ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensation(struct soap *soap, const char *tag, tt__BacklightCompensation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__BacklightCompensation **)soap_malloc(soap, sizeof(tt__BacklightCompensation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__BacklightCompensation *)soap_instantiate_tt__BacklightCompensation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__BacklightCompensation ** p = (tt__BacklightCompensation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensation, sizeof(tt__BacklightCompensation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensation(struct soap *soap, tt__BacklightCompensation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__BacklightCompensation);
	if (soap_out_PointerTott__BacklightCompensation(soap, tag?tag:"tt:BacklightCompensation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__BacklightCompensation ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensation(struct soap *soap, tt__BacklightCompensation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BacklightCompensation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusStatus(struct soap *soap, tt__FocusStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusStatus(struct soap *soap, const char *tag, int id, tt__FocusStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__FocusStatus ** SOAP_FMAC4 soap_in_PointerTott__FocusStatus(struct soap *soap, const char *tag, tt__FocusStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusStatus **)soap_malloc(soap, sizeof(tt__FocusStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusStatus *)soap_instantiate_tt__FocusStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__FocusStatus ** p = (tt__FocusStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusStatus, sizeof(tt__FocusStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusStatus(struct soap *soap, tt__FocusStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FocusStatus);
	if (soap_out_PointerTott__FocusStatus(soap, tag?tag:"tt:FocusStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusStatus ** SOAP_FMAC4 soap_get_PointerTott__FocusStatus(struct soap *soap, tt__FocusStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MoveStatus(struct soap *soap, enum tt__MoveStatus *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_tt__MoveStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MoveStatus(struct soap *soap, const char *tag, int id, enum tt__MoveStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MoveStatus);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MoveStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__MoveStatus ** SOAP_FMAC4 soap_in_PointerTott__MoveStatus(struct soap *soap, const char *tag, enum tt__MoveStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__MoveStatus **)soap_malloc(soap, sizeof(enum tt__MoveStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MoveStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__MoveStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MoveStatus, sizeof(enum tt__MoveStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MoveStatus(struct soap *soap, enum tt__MoveStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MoveStatus);
	if (soap_out_PointerTott__MoveStatus(soap, tag?tag:"tt:MoveStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__MoveStatus ** SOAP_FMAC4 soap_get_PointerTott__MoveStatus(struct soap *soap, enum tt__MoveStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReferenceToken(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReferenceToken))
		soap_serialize_tt__ReferenceToken(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReferenceToken(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReferenceToken);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReferenceToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__ReferenceToken(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReferenceToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReferenceToken, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReferenceToken(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ReferenceToken);
	if (soap_out_PointerTott__ReferenceToken(soap, tag?tag:"tt:ReferenceToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__ReferenceToken(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReferenceToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Name(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Name))
		soap_serialize_tt__Name(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Name(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Name);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Name(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__Name(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Name(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Name, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Name(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Name);
	if (soap_out_PointerTott__Name(soap, tag?tag:"tt:Name", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__Name(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Name(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZMoveStatus(struct soap *soap, tt__PTZMoveStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZMoveStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZMoveStatus(struct soap *soap, const char *tag, int id, tt__PTZMoveStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZMoveStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PTZMoveStatus ** SOAP_FMAC4 soap_in_PointerTott__PTZMoveStatus(struct soap *soap, const char *tag, tt__PTZMoveStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZMoveStatus **)soap_malloc(soap, sizeof(tt__PTZMoveStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZMoveStatus *)soap_instantiate_tt__PTZMoveStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PTZMoveStatus ** p = (tt__PTZMoveStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZMoveStatus, sizeof(tt__PTZMoveStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZMoveStatus(struct soap *soap, tt__PTZMoveStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZMoveStatus);
	if (soap_out_PointerTott__PTZMoveStatus(soap, tag?tag:"tt:PTZMoveStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZMoveStatus ** SOAP_FMAC4 soap_get_PointerTott__PTZMoveStatus(struct soap *soap, tt__PTZMoveStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZMoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZVector(struct soap *soap, tt__PTZVector *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZVector))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZVector(struct soap *soap, const char *tag, int id, tt__PTZVector *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZVector);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PTZVector ** SOAP_FMAC4 soap_in_PointerTott__PTZVector(struct soap *soap, const char *tag, tt__PTZVector **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZVector **)soap_malloc(soap, sizeof(tt__PTZVector *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZVector *)soap_instantiate_tt__PTZVector(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PTZVector ** p = (tt__PTZVector **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZVector, sizeof(tt__PTZVector), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZVector(struct soap *soap, tt__PTZVector *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZVector);
	if (soap_out_PointerTott__PTZVector(soap, tag?tag:"tt:PTZVector", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZVector ** SOAP_FMAC4 soap_get_PointerTott__PTZVector(struct soap *soap, tt__PTZVector **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZVector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector1D(struct soap *soap, tt__Vector1D *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector1D))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector1D(struct soap *soap, const char *tag, int id, tt__Vector1D *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector1D);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Vector1D ** SOAP_FMAC4 soap_in_PointerTott__Vector1D(struct soap *soap, const char *tag, tt__Vector1D **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Vector1D **)soap_malloc(soap, sizeof(tt__Vector1D *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Vector1D *)soap_instantiate_tt__Vector1D(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Vector1D ** p = (tt__Vector1D **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector1D, sizeof(tt__Vector1D), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector1D(struct soap *soap, tt__Vector1D *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Vector1D);
	if (soap_out_PointerTott__Vector1D(soap, tag?tag:"tt:Vector1D", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Vector1D ** SOAP_FMAC4 soap_get_PointerTott__Vector1D(struct soap *soap, tt__Vector1D **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector1D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector2D(struct soap *soap, tt__Vector2D *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector2D))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector2D(struct soap *soap, const char *tag, int id, tt__Vector2D *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector2D);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Vector2D ** SOAP_FMAC4 soap_in_PointerTott__Vector2D(struct soap *soap, const char *tag, tt__Vector2D **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Vector2D **)soap_malloc(soap, sizeof(tt__Vector2D *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Vector2D *)soap_instantiate_tt__Vector2D(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Vector2D ** p = (tt__Vector2D **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector2D, sizeof(tt__Vector2D), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector2D(struct soap *soap, tt__Vector2D *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Vector2D);
	if (soap_out_PointerTott__Vector2D(soap, tag?tag:"tt:Vector2D", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Vector2D ** SOAP_FMAC4 soap_get_PointerTott__Vector2D(struct soap *soap, tt__Vector2D **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector2D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyURI);
	if (soap_out_PointerToxsd__anyURI(soap, tag?tag:"xsd:anyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FloatRange(struct soap *soap, tt__FloatRange *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FloatRange))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FloatRange(struct soap *soap, const char *tag, int id, tt__FloatRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FloatRange);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__FloatRange ** SOAP_FMAC4 soap_in_PointerTott__FloatRange(struct soap *soap, const char *tag, tt__FloatRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FloatRange **)soap_malloc(soap, sizeof(tt__FloatRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FloatRange *)soap_instantiate_tt__FloatRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__FloatRange ** p = (tt__FloatRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FloatRange, sizeof(tt__FloatRange), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FloatRange(struct soap *soap, tt__FloatRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FloatRange);
	if (soap_out_PointerTott__FloatRange(soap, tag?tag:"tt:FloatRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FloatRange ** SOAP_FMAC4 soap_get_PointerTott__FloatRange(struct soap *soap, tt__FloatRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FloatRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZSpacesExtension(struct soap *soap, tt__PTZSpacesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZSpacesExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZSpacesExtension(struct soap *soap, const char *tag, int id, tt__PTZSpacesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZSpacesExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PTZSpacesExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZSpacesExtension(struct soap *soap, const char *tag, tt__PTZSpacesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZSpacesExtension **)soap_malloc(soap, sizeof(tt__PTZSpacesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZSpacesExtension *)soap_instantiate_tt__PTZSpacesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PTZSpacesExtension ** p = (tt__PTZSpacesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZSpacesExtension, sizeof(tt__PTZSpacesExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZSpacesExtension(struct soap *soap, tt__PTZSpacesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZSpacesExtension);
	if (soap_out_PointerTott__PTZSpacesExtension(soap, tag?tag:"tt:PTZSpacesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZSpacesExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZSpacesExtension(struct soap *soap, tt__PTZSpacesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZSpacesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Space1DDescription(struct soap *soap, tt__Space1DDescription *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Space1DDescription))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Space1DDescription(struct soap *soap, const char *tag, int id, tt__Space1DDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Space1DDescription);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Space1DDescription ** SOAP_FMAC4 soap_in_PointerTott__Space1DDescription(struct soap *soap, const char *tag, tt__Space1DDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Space1DDescription **)soap_malloc(soap, sizeof(tt__Space1DDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Space1DDescription *)soap_instantiate_tt__Space1DDescription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Space1DDescription ** p = (tt__Space1DDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Space1DDescription, sizeof(tt__Space1DDescription), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Space1DDescription(struct soap *soap, tt__Space1DDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Space1DDescription);
	if (soap_out_PointerTott__Space1DDescription(soap, tag?tag:"tt:Space1DDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Space1DDescription ** SOAP_FMAC4 soap_get_PointerTott__Space1DDescription(struct soap *soap, tt__Space1DDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Space1DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Space2DDescription(struct soap *soap, tt__Space2DDescription *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Space2DDescription))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Space2DDescription(struct soap *soap, const char *tag, int id, tt__Space2DDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Space2DDescription);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Space2DDescription ** SOAP_FMAC4 soap_in_PointerTott__Space2DDescription(struct soap *soap, const char *tag, tt__Space2DDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Space2DDescription **)soap_malloc(soap, sizeof(tt__Space2DDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Space2DDescription *)soap_instantiate_tt__Space2DDescription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Space2DDescription ** p = (tt__Space2DDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Space2DDescription, sizeof(tt__Space2DDescription), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Space2DDescription(struct soap *soap, tt__Space2DDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Space2DDescription);
	if (soap_out_PointerTott__Space2DDescription(soap, tag?tag:"tt:Space2DDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Space2DDescription ** SOAP_FMAC4 soap_get_PointerTott__Space2DDescription(struct soap *soap, tt__Space2DDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Space2DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DurationRange(struct soap *soap, tt__DurationRange *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DurationRange))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DurationRange(struct soap *soap, const char *tag, int id, tt__DurationRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DurationRange);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__DurationRange ** SOAP_FMAC4 soap_in_PointerTott__DurationRange(struct soap *soap, const char *tag, tt__DurationRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DurationRange **)soap_malloc(soap, sizeof(tt__DurationRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DurationRange *)soap_instantiate_tt__DurationRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__DurationRange ** p = (tt__DurationRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DurationRange, sizeof(tt__DurationRange), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DurationRange(struct soap *soap, tt__DurationRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DurationRange);
	if (soap_out_PointerTott__DurationRange(soap, tag?tag:"tt:DurationRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DurationRange ** SOAP_FMAC4 soap_get_PointerTott__DurationRange(struct soap *soap, tt__DurationRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DurationRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZSpaces(struct soap *soap, tt__PTZSpaces *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZSpaces))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZSpaces(struct soap *soap, const char *tag, int id, tt__PTZSpaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZSpaces);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PTZSpaces ** SOAP_FMAC4 soap_in_PointerTott__PTZSpaces(struct soap *soap, const char *tag, tt__PTZSpaces **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZSpaces **)soap_malloc(soap, sizeof(tt__PTZSpaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZSpaces *)soap_instantiate_tt__PTZSpaces(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PTZSpaces ** p = (tt__PTZSpaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZSpaces, sizeof(tt__PTZSpaces), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZSpaces(struct soap *soap, tt__PTZSpaces *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZSpaces);
	if (soap_out_PointerTott__PTZSpaces(soap, tag?tag:"tt:PTZSpaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZSpaces ** SOAP_FMAC4 soap_get_PointerTott__PTZSpaces(struct soap *soap, tt__PTZSpaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZSpaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BinaryData(struct soap *soap, tt__BinaryData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BinaryData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BinaryData(struct soap *soap, const char *tag, int id, tt__BinaryData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BinaryData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__BinaryData ** SOAP_FMAC4 soap_in_PointerTott__BinaryData(struct soap *soap, const char *tag, tt__BinaryData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__BinaryData **)soap_malloc(soap, sizeof(tt__BinaryData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__BinaryData *)soap_instantiate_tt__BinaryData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__BinaryData ** p = (tt__BinaryData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BinaryData, sizeof(tt__BinaryData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BinaryData(struct soap *soap, tt__BinaryData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__BinaryData);
	if (soap_out_PointerTott__BinaryData(soap, tag?tag:"tt:BinaryData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__BinaryData ** SOAP_FMAC4 soap_get_PointerTott__BinaryData(struct soap *soap, tt__BinaryData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BinaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateGenerationParametersExtension(struct soap *soap, tt__CertificateGenerationParametersExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateGenerationParametersExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateGenerationParametersExtension(struct soap *soap, const char *tag, int id, tt__CertificateGenerationParametersExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateGenerationParametersExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__CertificateGenerationParametersExtension ** SOAP_FMAC4 soap_in_PointerTott__CertificateGenerationParametersExtension(struct soap *soap, const char *tag, tt__CertificateGenerationParametersExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__CertificateGenerationParametersExtension **)soap_malloc(soap, sizeof(tt__CertificateGenerationParametersExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__CertificateGenerationParametersExtension *)soap_instantiate_tt__CertificateGenerationParametersExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__CertificateGenerationParametersExtension ** p = (tt__CertificateGenerationParametersExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateGenerationParametersExtension, sizeof(tt__CertificateGenerationParametersExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateGenerationParametersExtension(struct soap *soap, tt__CertificateGenerationParametersExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__CertificateGenerationParametersExtension);
	if (soap_out_PointerTott__CertificateGenerationParametersExtension(soap, tag?tag:"tt:CertificateGenerationParametersExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__CertificateGenerationParametersExtension ** SOAP_FMAC4 soap_get_PointerTott__CertificateGenerationParametersExtension(struct soap *soap, tt__CertificateGenerationParametersExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateGenerationParametersExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__UserExtension(struct soap *soap, tt__UserExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__UserExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__UserExtension(struct soap *soap, const char *tag, int id, tt__UserExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__UserExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__UserExtension ** SOAP_FMAC4 soap_in_PointerTott__UserExtension(struct soap *soap, const char *tag, tt__UserExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__UserExtension **)soap_malloc(soap, sizeof(tt__UserExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__UserExtension *)soap_instantiate_tt__UserExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__UserExtension ** p = (tt__UserExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__UserExtension, sizeof(tt__UserExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__UserExtension(struct soap *soap, tt__UserExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__UserExtension);
	if (soap_out_PointerTott__UserExtension(soap, tag?tag:"tt:UserExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__UserExtension ** SOAP_FMAC4 soap_get_PointerTott__UserExtension(struct soap *soap, tt__UserExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__UserExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Date(struct soap *soap, tt__Date *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Date))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Date(struct soap *soap, const char *tag, int id, tt__Date *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Date);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Date ** SOAP_FMAC4 soap_in_PointerTott__Date(struct soap *soap, const char *tag, tt__Date **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Date **)soap_malloc(soap, sizeof(tt__Date *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Date *)soap_instantiate_tt__Date(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Date ** p = (tt__Date **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Date, sizeof(tt__Date), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Date(struct soap *soap, tt__Date *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Date);
	if (soap_out_PointerTott__Date(soap, tag?tag:"tt:Date", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Date ** SOAP_FMAC4 soap_get_PointerTott__Date(struct soap *soap, tt__Date **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Time(struct soap *soap, tt__Time *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Time))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Time(struct soap *soap, const char *tag, int id, tt__Time *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Time);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Time ** SOAP_FMAC4 soap_in_PointerTott__Time(struct soap *soap, const char *tag, tt__Time **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Time **)soap_malloc(soap, sizeof(tt__Time *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Time *)soap_instantiate_tt__Time(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Time ** p = (tt__Time **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Time, sizeof(tt__Time), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Time(struct soap *soap, tt__Time *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Time);
	if (soap_out_PointerTott__Time(soap, tag?tag:"tt:Time", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Time ** SOAP_FMAC4 soap_get_PointerTott__Time(struct soap *soap, tt__Time **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemDateTimeExtension(struct soap *soap, tt__SystemDateTimeExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemDateTimeExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemDateTimeExtension(struct soap *soap, const char *tag, int id, tt__SystemDateTimeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemDateTimeExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__SystemDateTimeExtension ** SOAP_FMAC4 soap_in_PointerTott__SystemDateTimeExtension(struct soap *soap, const char *tag, tt__SystemDateTimeExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SystemDateTimeExtension **)soap_malloc(soap, sizeof(tt__SystemDateTimeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SystemDateTimeExtension *)soap_instantiate_tt__SystemDateTimeExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__SystemDateTimeExtension ** p = (tt__SystemDateTimeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemDateTimeExtension, sizeof(tt__SystemDateTimeExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemDateTimeExtension(struct soap *soap, tt__SystemDateTimeExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SystemDateTimeExtension);
	if (soap_out_PointerTott__SystemDateTimeExtension(soap, tag?tag:"tt:SystemDateTimeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SystemDateTimeExtension ** SOAP_FMAC4 soap_get_PointerTott__SystemDateTimeExtension(struct soap *soap, tt__SystemDateTimeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemDateTimeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DateTime(struct soap *soap, tt__DateTime *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DateTime))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DateTime(struct soap *soap, const char *tag, int id, tt__DateTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DateTime);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__DateTime ** SOAP_FMAC4 soap_in_PointerTott__DateTime(struct soap *soap, const char *tag, tt__DateTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DateTime **)soap_malloc(soap, sizeof(tt__DateTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DateTime *)soap_instantiate_tt__DateTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__DateTime ** p = (tt__DateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DateTime, sizeof(tt__DateTime), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DateTime(struct soap *soap, tt__DateTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DateTime);
	if (soap_out_PointerTott__DateTime(soap, tag?tag:"tt:DateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DateTime ** SOAP_FMAC4 soap_get_PointerTott__DateTime(struct soap *soap, tt__DateTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TimeZone(struct soap *soap, tt__TimeZone *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TimeZone))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TimeZone(struct soap *soap, const char *tag, int id, tt__TimeZone *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TimeZone);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__TimeZone ** SOAP_FMAC4 soap_in_PointerTott__TimeZone(struct soap *soap, const char *tag, tt__TimeZone **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__TimeZone **)soap_malloc(soap, sizeof(tt__TimeZone *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__TimeZone *)soap_instantiate_tt__TimeZone(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__TimeZone ** p = (tt__TimeZone **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TimeZone, sizeof(tt__TimeZone), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TimeZone(struct soap *soap, tt__TimeZone *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__TimeZone);
	if (soap_out_PointerTott__TimeZone(soap, tag?tag:"tt:TimeZone", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__TimeZone ** SOAP_FMAC4 soap_get_PointerTott__TimeZone(struct soap *soap, tt__TimeZone **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TimeZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AttachmentData(struct soap *soap, tt__AttachmentData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AttachmentData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AttachmentData(struct soap *soap, const char *tag, int id, tt__AttachmentData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AttachmentData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__AttachmentData ** SOAP_FMAC4 soap_in_PointerTott__AttachmentData(struct soap *soap, const char *tag, tt__AttachmentData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AttachmentData **)soap_malloc(soap, sizeof(tt__AttachmentData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AttachmentData *)soap_instantiate_tt__AttachmentData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__AttachmentData ** p = (tt__AttachmentData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AttachmentData, sizeof(tt__AttachmentData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AttachmentData(struct soap *soap, tt__AttachmentData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AttachmentData);
	if (soap_out_PointerTott__AttachmentData(soap, tag?tag:"tt:AttachmentData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AttachmentData ** SOAP_FMAC4 soap_get_PointerTott__AttachmentData(struct soap *soap, tt__AttachmentData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AttachmentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemCapabilitiesExtension(struct soap *soap, tt__SystemCapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemCapabilitiesExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemCapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__SystemCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__SystemCapabilitiesExtension(struct soap *soap, const char *tag, tt__SystemCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SystemCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__SystemCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SystemCapabilitiesExtension *)soap_instantiate_tt__SystemCapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__SystemCapabilitiesExtension ** p = (tt__SystemCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemCapabilitiesExtension, sizeof(tt__SystemCapabilitiesExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemCapabilitiesExtension(struct soap *soap, tt__SystemCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SystemCapabilitiesExtension);
	if (soap_out_PointerTott__SystemCapabilitiesExtension(soap, tag?tag:"tt:SystemCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__SystemCapabilitiesExtension(struct soap *soap, tt__SystemCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OnvifVersion(struct soap *soap, tt__OnvifVersion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OnvifVersion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OnvifVersion(struct soap *soap, const char *tag, int id, tt__OnvifVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OnvifVersion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__OnvifVersion ** SOAP_FMAC4 soap_in_PointerTott__OnvifVersion(struct soap *soap, const char *tag, tt__OnvifVersion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OnvifVersion **)soap_malloc(soap, sizeof(tt__OnvifVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OnvifVersion *)soap_instantiate_tt__OnvifVersion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__OnvifVersion ** p = (tt__OnvifVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OnvifVersion, sizeof(tt__OnvifVersion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OnvifVersion(struct soap *soap, tt__OnvifVersion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__OnvifVersion);
	if (soap_out_PointerTott__OnvifVersion(soap, tag?tag:"tt:OnvifVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OnvifVersion ** SOAP_FMAC4 soap_get_PointerTott__OnvifVersion(struct soap *soap, tt__OnvifVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OnvifVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, tt__SecurityCapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SecurityCapabilitiesExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__SecurityCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SecurityCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, tt__SecurityCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SecurityCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__SecurityCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SecurityCapabilitiesExtension *)soap_instantiate_tt__SecurityCapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__SecurityCapabilitiesExtension ** p = (tt__SecurityCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SecurityCapabilitiesExtension, sizeof(tt__SecurityCapabilitiesExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, tt__SecurityCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SecurityCapabilitiesExtension);
	if (soap_out_PointerTott__SecurityCapabilitiesExtension(soap, tag?tag:"tt:SecurityCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, tt__SecurityCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SecurityCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, tt__NetworkCapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkCapabilitiesExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__NetworkCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, tt__NetworkCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__NetworkCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkCapabilitiesExtension *)soap_instantiate_tt__NetworkCapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__NetworkCapabilitiesExtension ** p = (tt__NetworkCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkCapabilitiesExtension, sizeof(tt__NetworkCapabilitiesExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, tt__NetworkCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkCapabilitiesExtension);
	if (soap_out_PointerTott__NetworkCapabilitiesExtension(soap, tag?tag:"tt:NetworkCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, tt__NetworkCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, tt__RealTimeStreamingCapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__RealTimeStreamingCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, tt__RealTimeStreamingCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RealTimeStreamingCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__RealTimeStreamingCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RealTimeStreamingCapabilitiesExtension *)soap_instantiate_tt__RealTimeStreamingCapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__RealTimeStreamingCapabilitiesExtension ** p = (tt__RealTimeStreamingCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, sizeof(tt__RealTimeStreamingCapabilitiesExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, tt__RealTimeStreamingCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RealTimeStreamingCapabilitiesExtension);
	if (soap_out_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, tag?tag:"tt:RealTimeStreamingCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, tt__RealTimeStreamingCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ProfileCapabilities(struct soap *soap, tt__ProfileCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ProfileCapabilities))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ProfileCapabilities(struct soap *soap, const char *tag, int id, tt__ProfileCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ProfileCapabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ProfileCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ProfileCapabilities(struct soap *soap, const char *tag, tt__ProfileCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ProfileCapabilities **)soap_malloc(soap, sizeof(tt__ProfileCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ProfileCapabilities *)soap_instantiate_tt__ProfileCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ProfileCapabilities ** p = (tt__ProfileCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileCapabilities, sizeof(tt__ProfileCapabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ProfileCapabilities(struct soap *soap, tt__ProfileCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ProfileCapabilities);
	if (soap_out_PointerTott__ProfileCapabilities(soap, tag?tag:"tt:ProfileCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ProfileCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ProfileCapabilities(struct soap *soap, tt__ProfileCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaCapabilitiesExtension(struct soap *soap, tt__MediaCapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaCapabilitiesExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaCapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__MediaCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__MediaCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__MediaCapabilitiesExtension(struct soap *soap, const char *tag, tt__MediaCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MediaCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__MediaCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MediaCapabilitiesExtension *)soap_instantiate_tt__MediaCapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__MediaCapabilitiesExtension ** p = (tt__MediaCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(tt__MediaCapabilitiesExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaCapabilitiesExtension(struct soap *soap, tt__MediaCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MediaCapabilitiesExtension);
	if (soap_out_PointerTott__MediaCapabilitiesExtension(soap, tag?tag:"tt:MediaCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MediaCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__MediaCapabilitiesExtension(struct soap *soap, tt__MediaCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, tt__RealTimeStreamingCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RealTimeStreamingCapabilities))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, int id, tt__RealTimeStreamingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RealTimeStreamingCapabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilities ** SOAP_FMAC4 soap_in_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, tt__RealTimeStreamingCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RealTimeStreamingCapabilities **)soap_malloc(soap, sizeof(tt__RealTimeStreamingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RealTimeStreamingCapabilities *)soap_instantiate_tt__RealTimeStreamingCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__RealTimeStreamingCapabilities ** p = (tt__RealTimeStreamingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(tt__RealTimeStreamingCapabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, tt__RealTimeStreamingCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RealTimeStreamingCapabilities);
	if (soap_out_PointerTott__RealTimeStreamingCapabilities(soap, tag?tag:"tt:RealTimeStreamingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilities ** SOAP_FMAC4 soap_get_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, tt__RealTimeStreamingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RealTimeStreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IOCapabilitiesExtension(struct soap *soap, tt__IOCapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IOCapabilitiesExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IOCapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__IOCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IOCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__IOCapabilitiesExtension(struct soap *soap, const char *tag, tt__IOCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IOCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__IOCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IOCapabilitiesExtension *)soap_instantiate_tt__IOCapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__IOCapabilitiesExtension ** p = (tt__IOCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IOCapabilitiesExtension, sizeof(tt__IOCapabilitiesExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IOCapabilitiesExtension(struct soap *soap, tt__IOCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IOCapabilitiesExtension);
	if (soap_out_PointerTott__IOCapabilitiesExtension(soap, tag?tag:"tt:IOCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__IOCapabilitiesExtension(struct soap *soap, tt__IOCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IOCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, tt__DeviceCapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DeviceCapabilitiesExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__DeviceCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DeviceCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__DeviceCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, tt__DeviceCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DeviceCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__DeviceCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DeviceCapabilitiesExtension *)soap_instantiate_tt__DeviceCapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__DeviceCapabilitiesExtension ** p = (tt__DeviceCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceCapabilitiesExtension, sizeof(tt__DeviceCapabilitiesExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, tt__DeviceCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DeviceCapabilitiesExtension);
	if (soap_out_PointerTott__DeviceCapabilitiesExtension(soap, tag?tag:"tt:DeviceCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DeviceCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, tt__DeviceCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DeviceCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SecurityCapabilities(struct soap *soap, tt__SecurityCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SecurityCapabilities))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SecurityCapabilities(struct soap *soap, const char *tag, int id, tt__SecurityCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SecurityCapabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__SecurityCapabilities ** SOAP_FMAC4 soap_in_PointerTott__SecurityCapabilities(struct soap *soap, const char *tag, tt__SecurityCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SecurityCapabilities **)soap_malloc(soap, sizeof(tt__SecurityCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SecurityCapabilities *)soap_instantiate_tt__SecurityCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__SecurityCapabilities ** p = (tt__SecurityCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SecurityCapabilities, sizeof(tt__SecurityCapabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SecurityCapabilities(struct soap *soap, tt__SecurityCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SecurityCapabilities);
	if (soap_out_PointerTott__SecurityCapabilities(soap, tag?tag:"tt:SecurityCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SecurityCapabilities ** SOAP_FMAC4 soap_get_PointerTott__SecurityCapabilities(struct soap *soap, tt__SecurityCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IOCapabilities(struct soap *soap, tt__IOCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IOCapabilities))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IOCapabilities(struct soap *soap, const char *tag, int id, tt__IOCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IOCapabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__IOCapabilities ** SOAP_FMAC4 soap_in_PointerTott__IOCapabilities(struct soap *soap, const char *tag, tt__IOCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IOCapabilities **)soap_malloc(soap, sizeof(tt__IOCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IOCapabilities *)soap_instantiate_tt__IOCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__IOCapabilities ** p = (tt__IOCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IOCapabilities, sizeof(tt__IOCapabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IOCapabilities(struct soap *soap, tt__IOCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IOCapabilities);
	if (soap_out_PointerTott__IOCapabilities(soap, tag?tag:"tt:IOCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IOCapabilities ** SOAP_FMAC4 soap_get_PointerTott__IOCapabilities(struct soap *soap, tt__IOCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemCapabilities(struct soap *soap, tt__SystemCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemCapabilities))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemCapabilities(struct soap *soap, const char *tag, int id, tt__SystemCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemCapabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__SystemCapabilities ** SOAP_FMAC4 soap_in_PointerTott__SystemCapabilities(struct soap *soap, const char *tag, tt__SystemCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SystemCapabilities **)soap_malloc(soap, sizeof(tt__SystemCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SystemCapabilities *)soap_instantiate_tt__SystemCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__SystemCapabilities ** p = (tt__SystemCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemCapabilities, sizeof(tt__SystemCapabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemCapabilities(struct soap *soap, tt__SystemCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SystemCapabilities);
	if (soap_out_PointerTott__SystemCapabilities(soap, tag?tag:"tt:SystemCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SystemCapabilities ** SOAP_FMAC4 soap_get_PointerTott__SystemCapabilities(struct soap *soap, tt__SystemCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkCapabilities(struct soap *soap, tt__NetworkCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkCapabilities))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkCapabilities(struct soap *soap, const char *tag, int id, tt__NetworkCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkCapabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__NetworkCapabilities ** SOAP_FMAC4 soap_in_PointerTott__NetworkCapabilities(struct soap *soap, const char *tag, tt__NetworkCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkCapabilities **)soap_malloc(soap, sizeof(tt__NetworkCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkCapabilities *)soap_instantiate_tt__NetworkCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__NetworkCapabilities ** p = (tt__NetworkCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkCapabilities, sizeof(tt__NetworkCapabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkCapabilities(struct soap *soap, tt__NetworkCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkCapabilities);
	if (soap_out_PointerTott__NetworkCapabilities(soap, tag?tag:"tt:NetworkCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkCapabilities ** SOAP_FMAC4 soap_get_PointerTott__NetworkCapabilities(struct soap *soap, tt__NetworkCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CapabilitiesExtension(struct soap *soap, tt__CapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CapabilitiesExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__CapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__CapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__CapabilitiesExtension(struct soap *soap, const char *tag, tt__CapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__CapabilitiesExtension **)soap_malloc(soap, sizeof(tt__CapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__CapabilitiesExtension *)soap_instantiate_tt__CapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__CapabilitiesExtension ** p = (tt__CapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CapabilitiesExtension, sizeof(tt__CapabilitiesExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CapabilitiesExtension(struct soap *soap, tt__CapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__CapabilitiesExtension);
	if (soap_out_PointerTott__CapabilitiesExtension(soap, tag?tag:"tt:CapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__CapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__CapabilitiesExtension(struct soap *soap, tt__CapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZCapabilities(struct soap *soap, tt__PTZCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZCapabilities))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZCapabilities(struct soap *soap, const char *tag, int id, tt__PTZCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZCapabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PTZCapabilities ** SOAP_FMAC4 soap_in_PointerTott__PTZCapabilities(struct soap *soap, const char *tag, tt__PTZCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZCapabilities **)soap_malloc(soap, sizeof(tt__PTZCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZCapabilities *)soap_instantiate_tt__PTZCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PTZCapabilities ** p = (tt__PTZCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZCapabilities, sizeof(tt__PTZCapabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZCapabilities(struct soap *soap, tt__PTZCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZCapabilities);
	if (soap_out_PointerTott__PTZCapabilities(soap, tag?tag:"tt:PTZCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZCapabilities ** SOAP_FMAC4 soap_get_PointerTott__PTZCapabilities(struct soap *soap, tt__PTZCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaCapabilities(struct soap *soap, tt__MediaCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaCapabilities))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaCapabilities(struct soap *soap, const char *tag, int id, tt__MediaCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaCapabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__MediaCapabilities ** SOAP_FMAC4 soap_in_PointerTott__MediaCapabilities(struct soap *soap, const char *tag, tt__MediaCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MediaCapabilities **)soap_malloc(soap, sizeof(tt__MediaCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MediaCapabilities *)soap_instantiate_tt__MediaCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__MediaCapabilities ** p = (tt__MediaCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaCapabilities, sizeof(tt__MediaCapabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaCapabilities(struct soap *soap, tt__MediaCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MediaCapabilities);
	if (soap_out_PointerTott__MediaCapabilities(soap, tag?tag:"tt:MediaCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MediaCapabilities ** SOAP_FMAC4 soap_get_PointerTott__MediaCapabilities(struct soap *soap, tt__MediaCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingCapabilities(struct soap *soap, tt__ImagingCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingCapabilities))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingCapabilities(struct soap *soap, const char *tag, int id, tt__ImagingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingCapabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ImagingCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ImagingCapabilities(struct soap *soap, const char *tag, tt__ImagingCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingCapabilities **)soap_malloc(soap, sizeof(tt__ImagingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingCapabilities *)soap_instantiate_tt__ImagingCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ImagingCapabilities ** p = (tt__ImagingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingCapabilities, sizeof(tt__ImagingCapabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingCapabilities(struct soap *soap, tt__ImagingCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingCapabilities);
	if (soap_out_PointerTott__ImagingCapabilities(soap, tag?tag:"tt:ImagingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ImagingCapabilities(struct soap *soap, tt__ImagingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventCapabilities(struct soap *soap, tt__EventCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventCapabilities))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventCapabilities(struct soap *soap, const char *tag, int id, tt__EventCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventCapabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__EventCapabilities ** SOAP_FMAC4 soap_in_PointerTott__EventCapabilities(struct soap *soap, const char *tag, tt__EventCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EventCapabilities **)soap_malloc(soap, sizeof(tt__EventCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__EventCapabilities *)soap_instantiate_tt__EventCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__EventCapabilities ** p = (tt__EventCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventCapabilities, sizeof(tt__EventCapabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventCapabilities(struct soap *soap, tt__EventCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__EventCapabilities);
	if (soap_out_PointerTott__EventCapabilities(soap, tag?tag:"tt:EventCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EventCapabilities ** SOAP_FMAC4 soap_get_PointerTott__EventCapabilities(struct soap *soap, tt__EventCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DeviceCapabilities(struct soap *soap, tt__DeviceCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DeviceCapabilities))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DeviceCapabilities(struct soap *soap, const char *tag, int id, tt__DeviceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DeviceCapabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__DeviceCapabilities ** SOAP_FMAC4 soap_in_PointerTott__DeviceCapabilities(struct soap *soap, const char *tag, tt__DeviceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DeviceCapabilities **)soap_malloc(soap, sizeof(tt__DeviceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DeviceCapabilities *)soap_instantiate_tt__DeviceCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__DeviceCapabilities ** p = (tt__DeviceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceCapabilities, sizeof(tt__DeviceCapabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DeviceCapabilities(struct soap *soap, tt__DeviceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DeviceCapabilities);
	if (soap_out_PointerTott__DeviceCapabilities(soap, tag?tag:"tt:DeviceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DeviceCapabilities ** SOAP_FMAC4 soap_get_PointerTott__DeviceCapabilities(struct soap *soap, tt__DeviceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsCapabilities(struct soap *soap, tt__AnalyticsCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsCapabilities))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsCapabilities(struct soap *soap, const char *tag, int id, tt__AnalyticsCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsCapabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__AnalyticsCapabilities ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsCapabilities(struct soap *soap, const char *tag, tt__AnalyticsCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsCapabilities **)soap_malloc(soap, sizeof(tt__AnalyticsCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsCapabilities *)soap_instantiate_tt__AnalyticsCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__AnalyticsCapabilities ** p = (tt__AnalyticsCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsCapabilities, sizeof(tt__AnalyticsCapabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsCapabilities(struct soap *soap, tt__AnalyticsCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsCapabilities);
	if (soap_out_PointerTott__AnalyticsCapabilities(soap, tag?tag:"tt:AnalyticsCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsCapabilities ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsCapabilities(struct soap *soap, tt__AnalyticsCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPAddressFilterExtension(struct soap *soap, tt__IPAddressFilterExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPAddressFilterExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPAddressFilterExtension(struct soap *soap, const char *tag, int id, tt__IPAddressFilterExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPAddressFilterExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__IPAddressFilterExtension ** SOAP_FMAC4 soap_in_PointerTott__IPAddressFilterExtension(struct soap *soap, const char *tag, tt__IPAddressFilterExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPAddressFilterExtension **)soap_malloc(soap, sizeof(tt__IPAddressFilterExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPAddressFilterExtension *)soap_instantiate_tt__IPAddressFilterExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__IPAddressFilterExtension ** p = (tt__IPAddressFilterExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddressFilterExtension, sizeof(tt__IPAddressFilterExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPAddressFilterExtension(struct soap *soap, tt__IPAddressFilterExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPAddressFilterExtension);
	if (soap_out_PointerTott__IPAddressFilterExtension(soap, tag?tag:"tt:IPAddressFilterExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPAddressFilterExtension ** SOAP_FMAC4 soap_get_PointerTott__IPAddressFilterExtension(struct soap *soap, tt__IPAddressFilterExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPAddressFilterExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, tt__NetworkZeroConfigurationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, int id, tt__NetworkZeroConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkZeroConfigurationExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, tt__NetworkZeroConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkZeroConfigurationExtension **)soap_malloc(soap, sizeof(tt__NetworkZeroConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkZeroConfigurationExtension *)soap_instantiate_tt__NetworkZeroConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__NetworkZeroConfigurationExtension ** p = (tt__NetworkZeroConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, sizeof(tt__NetworkZeroConfigurationExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, tt__NetworkZeroConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkZeroConfigurationExtension);
	if (soap_out_PointerTott__NetworkZeroConfigurationExtension(soap, tag?tag:"tt:NetworkZeroConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, tt__NetworkZeroConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkZeroConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_tt__IPv6DHCPConfiguration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6DHCPConfiguration(struct soap *soap, const char *tag, int id, enum tt__IPv6DHCPConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6DHCPConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6DHCPConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration ** SOAP_FMAC4 soap_in_PointerTott__IPv6DHCPConfiguration(struct soap *soap, const char *tag, enum tt__IPv6DHCPConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__IPv6DHCPConfiguration **)soap_malloc(soap, sizeof(enum tt__IPv6DHCPConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6DHCPConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__IPv6DHCPConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6DHCPConfiguration, sizeof(enum tt__IPv6DHCPConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv6DHCPConfiguration);
	if (soap_out_PointerTott__IPv6DHCPConfiguration(soap, tag?tag:"tt:IPv6DHCPConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration ** SOAP_FMAC4 soap_get_PointerTott__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6DHCPConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceSetConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, tt__NetworkInterfaceSetConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceSetConfigurationExtension **)soap_malloc(soap, sizeof(tt__NetworkInterfaceSetConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceSetConfigurationExtension *)soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__NetworkInterfaceSetConfigurationExtension ** p = (tt__NetworkInterfaceSetConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, sizeof(tt__NetworkInterfaceSetConfigurationExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceSetConfigurationExtension);
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, tag?tag:"tt:NetworkInterfaceSetConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv6NetworkInterfaceSetConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, tt__IPv6NetworkInterfaceSetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__IPv6NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_in_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, tt__IPv6NetworkInterfaceSetConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv6NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(tt__IPv6NetworkInterfaceSetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv6NetworkInterfaceSetConfiguration *)soap_instantiate_tt__IPv6NetworkInterfaceSetConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__IPv6NetworkInterfaceSetConfiguration ** p = (tt__IPv6NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, sizeof(tt__IPv6NetworkInterfaceSetConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv6NetworkInterfaceSetConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv6NetworkInterfaceSetConfiguration);
	if (soap_out_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, tag?tag:"tt:IPv6NetworkInterfaceSetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv6NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_get_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv6NetworkInterfaceSetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv4NetworkInterfaceSetConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, tt__IPv4NetworkInterfaceSetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__IPv4NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_in_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, tt__IPv4NetworkInterfaceSetConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv4NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(tt__IPv4NetworkInterfaceSetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv4NetworkInterfaceSetConfiguration *)soap_instantiate_tt__IPv4NetworkInterfaceSetConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__IPv4NetworkInterfaceSetConfiguration ** p = (tt__IPv4NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, sizeof(tt__IPv4NetworkInterfaceSetConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv4NetworkInterfaceSetConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv4NetworkInterfaceSetConfiguration);
	if (soap_out_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, tag?tag:"tt:IPv4NetworkInterfaceSetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv4NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_get_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv4NetworkInterfaceSetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DynamicDNSInformationExtension(struct soap *soap, tt__DynamicDNSInformationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DynamicDNSInformationExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DynamicDNSInformationExtension(struct soap *soap, const char *tag, int id, tt__DynamicDNSInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DynamicDNSInformationExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__DynamicDNSInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__DynamicDNSInformationExtension(struct soap *soap, const char *tag, tt__DynamicDNSInformationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DynamicDNSInformationExtension **)soap_malloc(soap, sizeof(tt__DynamicDNSInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DynamicDNSInformationExtension *)soap_instantiate_tt__DynamicDNSInformationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__DynamicDNSInformationExtension ** p = (tt__DynamicDNSInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DynamicDNSInformationExtension, sizeof(tt__DynamicDNSInformationExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DynamicDNSInformationExtension(struct soap *soap, tt__DynamicDNSInformationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DynamicDNSInformationExtension);
	if (soap_out_PointerTott__DynamicDNSInformationExtension(soap, tag?tag:"tt:DynamicDNSInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DynamicDNSInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__DynamicDNSInformationExtension(struct soap *soap, tt__DynamicDNSInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DynamicDNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__duration(struct soap *soap, LONG64 *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__duration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__duration(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__duration);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__duration(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToxsd__duration(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__duration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__duration, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__duration(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__duration);
	if (soap_out_PointerToxsd__duration(soap, tag?tag:"xsd:duration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToxsd__duration(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NTPInformationExtension(struct soap *soap, tt__NTPInformationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NTPInformationExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NTPInformationExtension(struct soap *soap, const char *tag, int id, tt__NTPInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NTPInformationExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__NTPInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__NTPInformationExtension(struct soap *soap, const char *tag, tt__NTPInformationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NTPInformationExtension **)soap_malloc(soap, sizeof(tt__NTPInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NTPInformationExtension *)soap_instantiate_tt__NTPInformationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__NTPInformationExtension ** p = (tt__NTPInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NTPInformationExtension, sizeof(tt__NTPInformationExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NTPInformationExtension(struct soap *soap, tt__NTPInformationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NTPInformationExtension);
	if (soap_out_PointerTott__NTPInformationExtension(soap, tag?tag:"tt:NTPInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NTPInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__NTPInformationExtension(struct soap *soap, tt__NTPInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NTPInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkHost(struct soap *soap, tt__NetworkHost *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkHost))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkHost(struct soap *soap, const char *tag, int id, tt__NetworkHost *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkHost);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__NetworkHost ** SOAP_FMAC4 soap_in_PointerTott__NetworkHost(struct soap *soap, const char *tag, tt__NetworkHost **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkHost **)soap_malloc(soap, sizeof(tt__NetworkHost *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkHost *)soap_instantiate_tt__NetworkHost(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__NetworkHost ** p = (tt__NetworkHost **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkHost, sizeof(tt__NetworkHost), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkHost(struct soap *soap, tt__NetworkHost *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkHost);
	if (soap_out_PointerTott__NetworkHost(soap, tag?tag:"tt:NetworkHost", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkHost ** SOAP_FMAC4 soap_get_PointerTott__NetworkHost(struct soap *soap, tt__NetworkHost **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkHost(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DNSInformationExtension(struct soap *soap, tt__DNSInformationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DNSInformationExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DNSInformationExtension(struct soap *soap, const char *tag, int id, tt__DNSInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DNSInformationExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__DNSInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__DNSInformationExtension(struct soap *soap, const char *tag, tt__DNSInformationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DNSInformationExtension **)soap_malloc(soap, sizeof(tt__DNSInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DNSInformationExtension *)soap_instantiate_tt__DNSInformationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__DNSInformationExtension ** p = (tt__DNSInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DNSInformationExtension, sizeof(tt__DNSInformationExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DNSInformationExtension(struct soap *soap, tt__DNSInformationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DNSInformationExtension);
	if (soap_out_PointerTott__DNSInformationExtension(soap, tag?tag:"tt:DNSInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DNSInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__DNSInformationExtension(struct soap *soap, tt__DNSInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__HostnameInformationExtension(struct soap *soap, tt__HostnameInformationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__HostnameInformationExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__HostnameInformationExtension(struct soap *soap, const char *tag, int id, tt__HostnameInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__HostnameInformationExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__HostnameInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__HostnameInformationExtension(struct soap *soap, const char *tag, tt__HostnameInformationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__HostnameInformationExtension **)soap_malloc(soap, sizeof(tt__HostnameInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__HostnameInformationExtension *)soap_instantiate_tt__HostnameInformationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__HostnameInformationExtension ** p = (tt__HostnameInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__HostnameInformationExtension, sizeof(tt__HostnameInformationExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__HostnameInformationExtension(struct soap *soap, tt__HostnameInformationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__HostnameInformationExtension);
	if (soap_out_PointerTott__HostnameInformationExtension(soap, tag?tag:"tt:HostnameInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__HostnameInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__HostnameInformationExtension(struct soap *soap, tt__HostnameInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__HostnameInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__token(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__token))
		soap_serialize_xsd__token(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__token(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__token);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__token(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__token(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__token(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__token, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__token(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__token);
	if (soap_out_PointerToxsd__token(soap, tag?tag:"xsd:token", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__token(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkHostExtension(struct soap *soap, tt__NetworkHostExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkHostExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkHostExtension(struct soap *soap, const char *tag, int id, tt__NetworkHostExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkHostExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__NetworkHostExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkHostExtension(struct soap *soap, const char *tag, tt__NetworkHostExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkHostExtension **)soap_malloc(soap, sizeof(tt__NetworkHostExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkHostExtension *)soap_instantiate_tt__NetworkHostExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__NetworkHostExtension ** p = (tt__NetworkHostExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkHostExtension, sizeof(tt__NetworkHostExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkHostExtension(struct soap *soap, tt__NetworkHostExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkHostExtension);
	if (soap_out_PointerTott__NetworkHostExtension(soap, tag?tag:"tt:NetworkHostExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkHostExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkHostExtension(struct soap *soap, tt__NetworkHostExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkHostExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DNSName(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DNSName))
		soap_serialize_tt__DNSName(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DNSName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DNSName);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DNSName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__DNSName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DNSName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DNSName, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DNSName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DNSName);
	if (soap_out_PointerTott__DNSName(soap, tag?tag:"tt:DNSName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__DNSName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DNSName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6Address(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6Address))
		soap_serialize_tt__IPv6Address(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6Address(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6Address);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__IPv6Address(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6Address, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6Address(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv6Address);
	if (soap_out_PointerTott__IPv6Address(soap, tag?tag:"tt:IPv6Address", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__IPv6Address(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4Address(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4Address))
		soap_serialize_tt__IPv4Address(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4Address(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4Address);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv4Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__IPv4Address(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv4Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4Address, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4Address(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv4Address);
	if (soap_out_PointerTott__IPv4Address(soap, tag?tag:"tt:IPv4Address", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__IPv4Address(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkProtocolExtension(struct soap *soap, tt__NetworkProtocolExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkProtocolExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkProtocolExtension(struct soap *soap, const char *tag, int id, tt__NetworkProtocolExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkProtocolExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__NetworkProtocolExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkProtocolExtension(struct soap *soap, const char *tag, tt__NetworkProtocolExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkProtocolExtension **)soap_malloc(soap, sizeof(tt__NetworkProtocolExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkProtocolExtension *)soap_instantiate_tt__NetworkProtocolExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__NetworkProtocolExtension ** p = (tt__NetworkProtocolExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkProtocolExtension, sizeof(tt__NetworkProtocolExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkProtocolExtension(struct soap *soap, tt__NetworkProtocolExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkProtocolExtension);
	if (soap_out_PointerTott__NetworkProtocolExtension(soap, tag?tag:"tt:NetworkProtocolExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkProtocolExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkProtocolExtension(struct soap *soap, tt__NetworkProtocolExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkProtocolExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6ConfigurationExtension(struct soap *soap, tt__IPv6ConfigurationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6ConfigurationExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6ConfigurationExtension(struct soap *soap, const char *tag, int id, tt__IPv6ConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6ConfigurationExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__IPv6ConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__IPv6ConfigurationExtension(struct soap *soap, const char *tag, tt__IPv6ConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv6ConfigurationExtension **)soap_malloc(soap, sizeof(tt__IPv6ConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv6ConfigurationExtension *)soap_instantiate_tt__IPv6ConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__IPv6ConfigurationExtension ** p = (tt__IPv6ConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6ConfigurationExtension, sizeof(tt__IPv6ConfigurationExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6ConfigurationExtension(struct soap *soap, tt__IPv6ConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv6ConfigurationExtension);
	if (soap_out_PointerTott__IPv6ConfigurationExtension(soap, tag?tag:"tt:IPv6ConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv6ConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__IPv6ConfigurationExtension(struct soap *soap, tt__IPv6ConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6ConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PrefixedIPv6Address(struct soap *soap, tt__PrefixedIPv6Address *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PrefixedIPv6Address))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PrefixedIPv6Address(struct soap *soap, const char *tag, int id, tt__PrefixedIPv6Address *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PrefixedIPv6Address);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PrefixedIPv6Address ** SOAP_FMAC4 soap_in_PointerTott__PrefixedIPv6Address(struct soap *soap, const char *tag, tt__PrefixedIPv6Address **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PrefixedIPv6Address **)soap_malloc(soap, sizeof(tt__PrefixedIPv6Address *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PrefixedIPv6Address *)soap_instantiate_tt__PrefixedIPv6Address(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PrefixedIPv6Address ** p = (tt__PrefixedIPv6Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PrefixedIPv6Address, sizeof(tt__PrefixedIPv6Address), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PrefixedIPv6Address(struct soap *soap, tt__PrefixedIPv6Address *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PrefixedIPv6Address);
	if (soap_out_PointerTott__PrefixedIPv6Address(soap, tag?tag:"tt:PrefixedIPv6Address", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PrefixedIPv6Address ** SOAP_FMAC4 soap_get_PointerTott__PrefixedIPv6Address(struct soap *soap, tt__PrefixedIPv6Address **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PrefixedIPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PrefixedIPv4Address(struct soap *soap, tt__PrefixedIPv4Address *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PrefixedIPv4Address))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PrefixedIPv4Address(struct soap *soap, const char *tag, int id, tt__PrefixedIPv4Address *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PrefixedIPv4Address);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PrefixedIPv4Address ** SOAP_FMAC4 soap_in_PointerTott__PrefixedIPv4Address(struct soap *soap, const char *tag, tt__PrefixedIPv4Address **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PrefixedIPv4Address **)soap_malloc(soap, sizeof(tt__PrefixedIPv4Address *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PrefixedIPv4Address *)soap_instantiate_tt__PrefixedIPv4Address(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PrefixedIPv4Address ** p = (tt__PrefixedIPv4Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PrefixedIPv4Address, sizeof(tt__PrefixedIPv4Address), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PrefixedIPv4Address(struct soap *soap, tt__PrefixedIPv4Address *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PrefixedIPv4Address);
	if (soap_out_PointerTott__PrefixedIPv4Address(soap, tag?tag:"tt:PrefixedIPv4Address", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PrefixedIPv4Address ** SOAP_FMAC4 soap_get_PointerTott__PrefixedIPv4Address(struct soap *soap, tt__PrefixedIPv4Address **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PrefixedIPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4Configuration(struct soap *soap, tt__IPv4Configuration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4Configuration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4Configuration(struct soap *soap, const char *tag, int id, tt__IPv4Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4Configuration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__IPv4Configuration ** SOAP_FMAC4 soap_in_PointerTott__IPv4Configuration(struct soap *soap, const char *tag, tt__IPv4Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv4Configuration **)soap_malloc(soap, sizeof(tt__IPv4Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv4Configuration *)soap_instantiate_tt__IPv4Configuration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__IPv4Configuration ** p = (tt__IPv4Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4Configuration, sizeof(tt__IPv4Configuration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4Configuration(struct soap *soap, tt__IPv4Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv4Configuration);
	if (soap_out_PointerTott__IPv4Configuration(soap, tag?tag:"tt:IPv4Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv4Configuration ** SOAP_FMAC4 soap_get_PointerTott__IPv4Configuration(struct soap *soap, tt__IPv4Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6Configuration(struct soap *soap, tt__IPv6Configuration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6Configuration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6Configuration(struct soap *soap, const char *tag, int id, tt__IPv6Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6Configuration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__IPv6Configuration ** SOAP_FMAC4 soap_in_PointerTott__IPv6Configuration(struct soap *soap, const char *tag, tt__IPv6Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv6Configuration **)soap_malloc(soap, sizeof(tt__IPv6Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv6Configuration *)soap_instantiate_tt__IPv6Configuration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__IPv6Configuration ** p = (tt__IPv6Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6Configuration, sizeof(tt__IPv6Configuration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6Configuration(struct soap *soap, tt__IPv6Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv6Configuration);
	if (soap_out_PointerTott__IPv6Configuration(soap, tag?tag:"tt:IPv6Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv6Configuration ** SOAP_FMAC4 soap_get_PointerTott__IPv6Configuration(struct soap *soap, tt__IPv6Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, tt__NetworkInterfaceConnectionSetting *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceConnectionSetting *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__NetworkInterfaceConnectionSetting ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, tt__NetworkInterfaceConnectionSetting **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceConnectionSetting **)soap_malloc(soap, sizeof(tt__NetworkInterfaceConnectionSetting *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceConnectionSetting *)soap_instantiate_tt__NetworkInterfaceConnectionSetting(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__NetworkInterfaceConnectionSetting ** p = (tt__NetworkInterfaceConnectionSetting **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, sizeof(tt__NetworkInterfaceConnectionSetting), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, tt__NetworkInterfaceConnectionSetting *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceConnectionSetting);
	if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, tag?tag:"tt:NetworkInterfaceConnectionSetting", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceConnectionSetting ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, tt__NetworkInterfaceConnectionSetting **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Transport(struct soap *soap, tt__Transport *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Transport))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Transport(struct soap *soap, const char *tag, int id, tt__Transport *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Transport);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Transport ** SOAP_FMAC4 soap_in_PointerTott__Transport(struct soap *soap, const char *tag, tt__Transport **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Transport **)soap_malloc(soap, sizeof(tt__Transport *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Transport *)soap_instantiate_tt__Transport(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Transport ** p = (tt__Transport **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Transport, sizeof(tt__Transport), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Transport(struct soap *soap, tt__Transport *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Transport);
	if (soap_out_PointerTott__Transport(soap, tag?tag:"tt:Transport", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Transport ** SOAP_FMAC4 soap_get_PointerTott__Transport(struct soap *soap, tt__Transport **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Transport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPAddress(struct soap *soap, tt__IPAddress *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPAddress))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPAddress(struct soap *soap, const char *tag, int id, tt__IPAddress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPAddress);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__IPAddress ** SOAP_FMAC4 soap_in_PointerTott__IPAddress(struct soap *soap, const char *tag, tt__IPAddress **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPAddress **)soap_malloc(soap, sizeof(tt__IPAddress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPAddress *)soap_instantiate_tt__IPAddress(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__IPAddress ** p = (tt__IPAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddress, sizeof(tt__IPAddress), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPAddress(struct soap *soap, tt__IPAddress *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPAddress);
	if (soap_out_PointerTott__IPAddress(soap, tag?tag:"tt:IPAddress", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPAddress ** SOAP_FMAC4 soap_get_PointerTott__IPAddress(struct soap *soap, tt__IPAddress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZStatusFilterOptions(struct soap *soap, tt__PTZStatusFilterOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZStatusFilterOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZStatusFilterOptions(struct soap *soap, const char *tag, int id, tt__PTZStatusFilterOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZStatusFilterOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PTZStatusFilterOptions ** SOAP_FMAC4 soap_in_PointerTott__PTZStatusFilterOptions(struct soap *soap, const char *tag, tt__PTZStatusFilterOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZStatusFilterOptions **)soap_malloc(soap, sizeof(tt__PTZStatusFilterOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZStatusFilterOptions *)soap_instantiate_tt__PTZStatusFilterOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PTZStatusFilterOptions ** p = (tt__PTZStatusFilterOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZStatusFilterOptions, sizeof(tt__PTZStatusFilterOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZStatusFilterOptions(struct soap *soap, tt__PTZStatusFilterOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZStatusFilterOptions);
	if (soap_out_PointerTott__PTZStatusFilterOptions(soap, tag?tag:"tt:PTZStatusFilterOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZStatusFilterOptions ** SOAP_FMAC4 soap_get_PointerTott__PTZStatusFilterOptions(struct soap *soap, tt__PTZStatusFilterOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZStatusFilterOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, _tt__EventSubscription_SubscriptionPolicy *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, int id, _tt__EventSubscription_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tt__EventSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, _tt__EventSubscription_SubscriptionPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tt__EventSubscription_SubscriptionPolicy **)soap_malloc(soap, sizeof(_tt__EventSubscription_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tt__EventSubscription_SubscriptionPolicy *)soap_instantiate__tt__EventSubscription_SubscriptionPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tt__EventSubscription_SubscriptionPolicy ** p = (_tt__EventSubscription_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, sizeof(_tt__EventSubscription_SubscriptionPolicy), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, _tt__EventSubscription_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tt__EventSubscription_SubscriptionPolicy);
	if (soap_out_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, tag?tag:"tt:EventSubscription-SubscriptionPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tt__EventSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, _tt__EventSubscription_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnb__FilterType(struct soap *soap, wsnb__FilterType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnb__FilterType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnb__FilterType(struct soap *soap, const char *tag, int id, wsnb__FilterType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnb__FilterType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 wsnb__FilterType ** SOAP_FMAC4 soap_in_PointerTowsnb__FilterType(struct soap *soap, const char *tag, wsnb__FilterType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnb__FilterType **)soap_malloc(soap, sizeof(wsnb__FilterType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnb__FilterType *)soap_instantiate_wsnb__FilterType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	wsnb__FilterType ** p = (wsnb__FilterType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnb__FilterType, sizeof(wsnb__FilterType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnb__FilterType(struct soap *soap, wsnb__FilterType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnb__FilterType);
	if (soap_out_PointerTowsnb__FilterType(soap, tag?tag:"wsnb:FilterType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnb__FilterType ** SOAP_FMAC4 soap_get_PointerTowsnb__FilterType(struct soap *soap, wsnb__FilterType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnb__FilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntList(struct soap *soap, tt__IntList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntList(struct soap *soap, const char *tag, int id, tt__IntList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__IntList ** SOAP_FMAC4 soap_in_PointerTott__IntList(struct soap *soap, const char *tag, tt__IntList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IntList **)soap_malloc(soap, sizeof(tt__IntList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IntList *)soap_instantiate_tt__IntList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__IntList ** p = (tt__IntList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntList, sizeof(tt__IntList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntList(struct soap *soap, tt__IntList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IntList);
	if (soap_out_PointerTott__IntList(soap, tag?tag:"tt:IntList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IntList ** SOAP_FMAC4 soap_get_PointerTott__IntList(struct soap *soap, tt__IntList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioEncoderConfigurationOption(struct soap *soap, tt__AudioEncoderConfigurationOption *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioEncoderConfigurationOption))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, int id, tt__AudioEncoderConfigurationOption *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioEncoderConfigurationOption);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOption ** SOAP_FMAC4 soap_in_PointerTott__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, tt__AudioEncoderConfigurationOption **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioEncoderConfigurationOption **)soap_malloc(soap, sizeof(tt__AudioEncoderConfigurationOption *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioEncoderConfigurationOption *)soap_instantiate_tt__AudioEncoderConfigurationOption(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__AudioEncoderConfigurationOption ** p = (tt__AudioEncoderConfigurationOption **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioEncoderConfigurationOption, sizeof(tt__AudioEncoderConfigurationOption), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioEncoderConfigurationOption(struct soap *soap, tt__AudioEncoderConfigurationOption *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioEncoderConfigurationOption);
	if (soap_out_PointerTott__AudioEncoderConfigurationOption(soap, tag?tag:"tt:AudioEncoderConfigurationOption", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOption ** SOAP_FMAC4 soap_get_PointerTott__AudioEncoderConfigurationOption(struct soap *soap, tt__AudioEncoderConfigurationOption **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioEncoderConfigurationOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioSourceOptionsExtension(struct soap *soap, tt__AudioSourceOptionsExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioSourceOptionsExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioSourceOptionsExtension(struct soap *soap, const char *tag, int id, tt__AudioSourceOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioSourceOptionsExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__AudioSourceOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__AudioSourceOptionsExtension(struct soap *soap, const char *tag, tt__AudioSourceOptionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioSourceOptionsExtension **)soap_malloc(soap, sizeof(tt__AudioSourceOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioSourceOptionsExtension *)soap_instantiate_tt__AudioSourceOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__AudioSourceOptionsExtension ** p = (tt__AudioSourceOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSourceOptionsExtension, sizeof(tt__AudioSourceOptionsExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioSourceOptionsExtension(struct soap *soap, tt__AudioSourceOptionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioSourceOptionsExtension);
	if (soap_out_PointerTott__AudioSourceOptionsExtension(soap, tag?tag:"tt:AudioSourceOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioSourceOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__AudioSourceOptionsExtension(struct soap *soap, tt__AudioSourceOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioSourceOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoResolution(struct soap *soap, tt__VideoResolution *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoResolution))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoResolution(struct soap *soap, const char *tag, int id, tt__VideoResolution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoResolution);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__VideoResolution ** SOAP_FMAC4 soap_in_PointerTott__VideoResolution(struct soap *soap, const char *tag, tt__VideoResolution **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoResolution **)soap_malloc(soap, sizeof(tt__VideoResolution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoResolution *)soap_instantiate_tt__VideoResolution(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__VideoResolution ** p = (tt__VideoResolution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoResolution, sizeof(tt__VideoResolution), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoResolution(struct soap *soap, tt__VideoResolution *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoResolution);
	if (soap_out_PointerTott__VideoResolution(soap, tag?tag:"tt:VideoResolution", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoResolution ** SOAP_FMAC4 soap_get_PointerTott__VideoResolution(struct soap *soap, tt__VideoResolution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoResolution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, tt__VideoEncoderOptionsExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderOptionsExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, int id, tt__VideoEncoderOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderOptionsExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__VideoEncoderOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, tt__VideoEncoderOptionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoEncoderOptionsExtension **)soap_malloc(soap, sizeof(tt__VideoEncoderOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoEncoderOptionsExtension *)soap_instantiate_tt__VideoEncoderOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__VideoEncoderOptionsExtension ** p = (tt__VideoEncoderOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderOptionsExtension, sizeof(tt__VideoEncoderOptionsExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, tt__VideoEncoderOptionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoEncoderOptionsExtension);
	if (soap_out_PointerTott__VideoEncoderOptionsExtension(soap, tag?tag:"tt:VideoEncoderOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoEncoderOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, tt__VideoEncoderOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Options(struct soap *soap, tt__H264Options *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Options))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Options(struct soap *soap, const char *tag, int id, tt__H264Options *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Options);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__H264Options ** SOAP_FMAC4 soap_in_PointerTott__H264Options(struct soap *soap, const char *tag, tt__H264Options **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__H264Options **)soap_malloc(soap, sizeof(tt__H264Options *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__H264Options *)soap_instantiate_tt__H264Options(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__H264Options ** p = (tt__H264Options **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Options, sizeof(tt__H264Options), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Options(struct soap *soap, tt__H264Options *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__H264Options);
	if (soap_out_PointerTott__H264Options(soap, tag?tag:"tt:H264Options", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__H264Options ** SOAP_FMAC4 soap_get_PointerTott__H264Options(struct soap *soap, tt__H264Options **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Options(struct soap *soap, tt__Mpeg4Options *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Options))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Options(struct soap *soap, const char *tag, int id, tt__Mpeg4Options *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Options);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Mpeg4Options ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Options(struct soap *soap, const char *tag, tt__Mpeg4Options **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Mpeg4Options **)soap_malloc(soap, sizeof(tt__Mpeg4Options *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Mpeg4Options *)soap_instantiate_tt__Mpeg4Options(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Mpeg4Options ** p = (tt__Mpeg4Options **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Options, sizeof(tt__Mpeg4Options), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Options(struct soap *soap, tt__Mpeg4Options *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Mpeg4Options);
	if (soap_out_PointerTott__Mpeg4Options(soap, tag?tag:"tt:Mpeg4Options", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Mpeg4Options ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Options(struct soap *soap, tt__Mpeg4Options **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__JpegOptions(struct soap *soap, tt__JpegOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__JpegOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__JpegOptions(struct soap *soap, const char *tag, int id, tt__JpegOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__JpegOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__JpegOptions ** SOAP_FMAC4 soap_in_PointerTott__JpegOptions(struct soap *soap, const char *tag, tt__JpegOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__JpegOptions **)soap_malloc(soap, sizeof(tt__JpegOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__JpegOptions *)soap_instantiate_tt__JpegOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__JpegOptions ** p = (tt__JpegOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__JpegOptions, sizeof(tt__JpegOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__JpegOptions(struct soap *soap, tt__JpegOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__JpegOptions);
	if (soap_out_PointerTott__JpegOptions(soap, tag?tag:"tt:JpegOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__JpegOptions ** SOAP_FMAC4 soap_get_PointerTott__JpegOptions(struct soap *soap, tt__JpegOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__JpegOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, tt__VideoSourceConfigurationOptionsExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, tt__VideoSourceConfigurationOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, tt__VideoSourceConfigurationOptionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoSourceConfigurationOptionsExtension **)soap_malloc(soap, sizeof(tt__VideoSourceConfigurationOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoSourceConfigurationOptionsExtension *)soap_instantiate_tt__VideoSourceConfigurationOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__VideoSourceConfigurationOptionsExtension ** p = (tt__VideoSourceConfigurationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, sizeof(tt__VideoSourceConfigurationOptionsExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, tt__VideoSourceConfigurationOptionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoSourceConfigurationOptionsExtension);
	if (soap_out_PointerTott__VideoSourceConfigurationOptionsExtension(soap, tag?tag:"tt:VideoSourceConfigurationOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, tt__VideoSourceConfigurationOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRectangleRange(struct soap *soap, tt__IntRectangleRange *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRectangleRange))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRectangleRange(struct soap *soap, const char *tag, int id, tt__IntRectangleRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRectangleRange);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__IntRectangleRange ** SOAP_FMAC4 soap_in_PointerTott__IntRectangleRange(struct soap *soap, const char *tag, tt__IntRectangleRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IntRectangleRange **)soap_malloc(soap, sizeof(tt__IntRectangleRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IntRectangleRange *)soap_instantiate_tt__IntRectangleRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__IntRectangleRange ** p = (tt__IntRectangleRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRectangleRange, sizeof(tt__IntRectangleRange), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRectangleRange(struct soap *soap, tt__IntRectangleRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IntRectangleRange);
	if (soap_out_PointerTott__IntRectangleRange(soap, tag?tag:"tt:IntRectangleRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IntRectangleRange ** SOAP_FMAC4 soap_get_PointerTott__IntRectangleRange(struct soap *soap, tt__IntRectangleRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRectangleRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
	if (soap_out_PointerTobool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ProfileExtension(struct soap *soap, tt__ProfileExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ProfileExtension))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ProfileExtension(struct soap *soap, const char *tag, int id, tt__ProfileExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ProfileExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ProfileExtension ** SOAP_FMAC4 soap_in_PointerTott__ProfileExtension(struct soap *soap, const char *tag, tt__ProfileExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ProfileExtension **)soap_malloc(soap, sizeof(tt__ProfileExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ProfileExtension *)soap_instantiate_tt__ProfileExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ProfileExtension ** p = (tt__ProfileExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileExtension, sizeof(tt__ProfileExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ProfileExtension(struct soap *soap, tt__ProfileExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ProfileExtension);
	if (soap_out_PointerTott__ProfileExtension(soap, tag?tag:"tt:ProfileExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ProfileExtension ** SOAP_FMAC4 soap_get_PointerTott__ProfileExtension(struct soap *soap, tt__ProfileExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ProfileExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfiguration(struct soap *soap, tt__MetadataConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataConfiguration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfiguration(struct soap *soap, const char *tag, int id, tt__MetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__MetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfiguration(struct soap *soap, const char *tag, tt__MetadataConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MetadataConfiguration **)soap_malloc(soap, sizeof(tt__MetadataConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MetadataConfiguration *)soap_instantiate_tt__MetadataConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__MetadataConfiguration ** p = (tt__MetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfiguration, sizeof(tt__MetadataConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfiguration(struct soap *soap, tt__MetadataConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MetadataConfiguration);
	if (soap_out_PointerTott__MetadataConfiguration(soap, tag?tag:"tt:MetadataConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfiguration(struct soap *soap, tt__MetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfiguration(struct soap *soap, tt__PTZConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfiguration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfiguration(struct soap *soap, const char *tag, int id, tt__PTZConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PTZConfiguration ** SOAP_FMAC4 soap_in_PointerTott__PTZConfiguration(struct soap *soap, const char *tag, tt__PTZConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZConfiguration **)soap_malloc(soap, sizeof(tt__PTZConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZConfiguration *)soap_instantiate_tt__PTZConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PTZConfiguration ** p = (tt__PTZConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfiguration, sizeof(tt__PTZConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfiguration(struct soap *soap, tt__PTZConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZConfiguration);
	if (soap_out_PointerTott__PTZConfiguration(soap, tag?tag:"tt:PTZConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZConfiguration ** SOAP_FMAC4 soap_get_PointerTott__PTZConfiguration(struct soap *soap, tt__PTZConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, tt__VideoAnalyticsConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoAnalyticsConfiguration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, tt__VideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoAnalyticsConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__VideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, tt__VideoAnalyticsConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(tt__VideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoAnalyticsConfiguration *)soap_instantiate_tt__VideoAnalyticsConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__VideoAnalyticsConfiguration ** p = (tt__VideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoAnalyticsConfiguration, sizeof(tt__VideoAnalyticsConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, tt__VideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoAnalyticsConfiguration);
	if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, tag?tag:"tt:VideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, tt__VideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioEncoderConfiguration(struct soap *soap, tt__AudioEncoderConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioEncoderConfiguration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioEncoderConfiguration(struct soap *soap, const char *tag, int id, tt__AudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__AudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AudioEncoderConfiguration(struct soap *soap, const char *tag, tt__AudioEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioEncoderConfiguration **)soap_malloc(soap, sizeof(tt__AudioEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioEncoderConfiguration *)soap_instantiate_tt__AudioEncoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__AudioEncoderConfiguration ** p = (tt__AudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioEncoderConfiguration, sizeof(tt__AudioEncoderConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioEncoderConfiguration(struct soap *soap, tt__AudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioEncoderConfiguration);
	if (soap_out_PointerTott__AudioEncoderConfiguration(soap, tag?tag:"tt:AudioEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AudioEncoderConfiguration(struct soap *soap, tt__AudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderConfiguration(struct soap *soap, tt__VideoEncoderConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderConfiguration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderConfiguration(struct soap *soap, const char *tag, int id, tt__VideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__VideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderConfiguration(struct soap *soap, const char *tag, tt__VideoEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoEncoderConfiguration **)soap_malloc(soap, sizeof(tt__VideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoEncoderConfiguration *)soap_instantiate_tt__VideoEncoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__VideoEncoderConfiguration ** p = (tt__VideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(tt__VideoEncoderConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderConfiguration(struct soap *soap, tt__VideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoEncoderConfiguration);
	if (soap_out_PointerTott__VideoEncoderConfiguration(soap, tag?tag:"tt:VideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderConfiguration(struct soap *soap, tt__VideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioSourceConfiguration(struct soap *soap, tt__AudioSourceConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioSourceConfiguration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioSourceConfiguration(struct soap *soap, const char *tag, int id, tt__AudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioSourceConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__AudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AudioSourceConfiguration(struct soap *soap, const char *tag, tt__AudioSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioSourceConfiguration **)soap_malloc(soap, sizeof(tt__AudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioSourceConfiguration *)soap_instantiate_tt__AudioSourceConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__AudioSourceConfiguration ** p = (tt__AudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(tt__AudioSourceConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioSourceConfiguration(struct soap *soap, tt__AudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioSourceConfiguration);
	if (soap_out_PointerTott__AudioSourceConfiguration(soap, tag?tag:"tt:AudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AudioSourceConfiguration(struct soap *soap, tt__AudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfiguration(struct soap *soap, tt__VideoSourceConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfiguration))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfiguration(struct soap *soap, const char *tag, int id, tt__VideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__VideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfiguration(struct soap *soap, const char *tag, tt__VideoSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoSourceConfiguration **)soap_malloc(soap, sizeof(tt__VideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoSourceConfiguration *)soap_instantiate_tt__VideoSourceConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__VideoSourceConfiguration ** p = (tt__VideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(tt__VideoSourceConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfiguration(struct soap *soap, tt__VideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoSourceConfiguration);
	if (soap_out_PointerTott__VideoSourceConfiguration(soap, tag?tag:"tt:VideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfiguration(struct soap *soap, tt__VideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRange(struct soap *soap, tt__IntRange *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRange))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRange(struct soap *soap, const char *tag, int id, tt__IntRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRange);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__IntRange ** SOAP_FMAC4 soap_in_PointerTott__IntRange(struct soap *soap, const char *tag, tt__IntRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IntRange **)soap_malloc(soap, sizeof(tt__IntRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IntRange *)soap_instantiate_tt__IntRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__IntRange ** p = (tt__IntRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRange, sizeof(tt__IntRange), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRange(struct soap *soap, tt__IntRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IntRange);
	if (soap_out_PointerTott__IntRange(soap, tag?tag:"tt:IntRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IntRange ** SOAP_FMAC4 soap_get_PointerTott__IntRange(struct soap *soap, tt__IntRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SupportedAnalyticsModules(struct soap *soap, tt__SupportedAnalyticsModules *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SupportedAnalyticsModules))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SupportedAnalyticsModules(struct soap *soap, const char *tag, int id, tt__SupportedAnalyticsModules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SupportedAnalyticsModules);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__SupportedAnalyticsModules ** SOAP_FMAC4 soap_in_PointerTott__SupportedAnalyticsModules(struct soap *soap, const char *tag, tt__SupportedAnalyticsModules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SupportedAnalyticsModules **)soap_malloc(soap, sizeof(tt__SupportedAnalyticsModules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SupportedAnalyticsModules *)soap_instantiate_tt__SupportedAnalyticsModules(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__SupportedAnalyticsModules ** p = (tt__SupportedAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportedAnalyticsModules, sizeof(tt__SupportedAnalyticsModules), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SupportedAnalyticsModules(struct soap *soap, tt__SupportedAnalyticsModules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SupportedAnalyticsModules);
	if (soap_out_PointerTott__SupportedAnalyticsModules(soap, tag?tag:"tt:SupportedAnalyticsModules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SupportedAnalyticsModules ** SOAP_FMAC4 soap_get_PointerTott__SupportedAnalyticsModules(struct soap *soap, tt__SupportedAnalyticsModules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SupportedAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Config(struct soap *soap, tt__Config *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Config))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Config(struct soap *soap, const char *tag, int id, tt__Config *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Config);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Config ** SOAP_FMAC4 soap_in_PointerTott__Config(struct soap *soap, const char *tag, tt__Config **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Config **)soap_malloc(soap, sizeof(tt__Config *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Config *)soap_instantiate_tt__Config(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Config ** p = (tt__Config **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Config, sizeof(tt__Config), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Config(struct soap *soap, tt__Config *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Config);
	if (soap_out_PointerTott__Config(soap, tag?tag:"tt:Config", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Config ** SOAP_FMAC4 soap_get_PointerTott__Config(struct soap *soap, tt__Config **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Config(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SupportedRules(struct soap *soap, tt__SupportedRules *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SupportedRules))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SupportedRules(struct soap *soap, const char *tag, int id, tt__SupportedRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SupportedRules);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__SupportedRules ** SOAP_FMAC4 soap_in_PointerTott__SupportedRules(struct soap *soap, const char *tag, tt__SupportedRules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SupportedRules **)soap_malloc(soap, sizeof(tt__SupportedRules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SupportedRules *)soap_instantiate_tt__SupportedRules(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__SupportedRules ** p = (tt__SupportedRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportedRules, sizeof(tt__SupportedRules), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SupportedRules(struct soap *soap, tt__SupportedRules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SupportedRules);
	if (soap_out_PointerTott__SupportedRules(soap, tag?tag:"tt:SupportedRules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SupportedRules ** SOAP_FMAC4 soap_get_PointerTott__SupportedRules(struct soap *soap, tt__SupportedRules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SupportedRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__FaultTo))
		soap_serialize__wsa5__FaultTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__FaultTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__FaultTo, sizeof(struct wsa5__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__FaultTo);
	if (soap_out_PointerTo_wsa5__FaultTo(soap, tag?tag:"wsa5:FaultTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__ReplyTo))
		soap_serialize__wsa5__ReplyTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__ReplyTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__ReplyTo, sizeof(struct wsa5__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__ReplyTo);
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, tag?tag:"wsa5:ReplyTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__From))
		soap_serialize__wsa5__From(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__From(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__From);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__From(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__From, sizeof(struct wsa5__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__From);
	if (soap_out_PointerTo_wsa5__From(soap, tag?tag:"wsa5:From", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__RelatesTo))
		soap_serialize__wsa5__RelatesTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa5__RelatesToType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__RelatesTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, struct wsa5__RelatesToType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__RelatesToType **)soap_malloc(soap, sizeof(struct wsa5__RelatesToType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__RelatesToType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__RelatesTo, sizeof(struct wsa5__RelatesToType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__RelatesTo);
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, tag?tag:"wsa5:RelatesTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Security))
		soap_serialize__wsse__Security(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Security(struct soap *soap, const char *tag, int id, struct _wsse__Security *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Security);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Security(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_in_PointerTo_wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Security **)soap_malloc(soap, sizeof(struct _wsse__Security *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Security(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Security);
	if (soap_out_PointerTo_wsse__Security(soap, tag?tag:"wsse:Security", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_get_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureType))
		soap_serialize_ds__SignatureType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureType(struct soap *soap, const char *tag, int id, struct ds__SignatureType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_in_PointerTods__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureType **)soap_malloc(soap, sizeof(struct ds__SignatureType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignatureType);
	if (soap_out_PointerTods__SignatureType(soap, tag?tag:"ds:SignatureType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_get_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__BinarySecurityToken))
		soap_serialize__wsse__BinarySecurityToken(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, struct _wsse__BinarySecurityToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__BinarySecurityToken);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__BinarySecurityToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__BinarySecurityToken **)soap_malloc(soap, sizeof(struct _wsse__BinarySecurityToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__BinarySecurityToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__BinarySecurityToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__BinarySecurityToken);
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag?tag:"wsse:BinarySecurityToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__UsernameToken))
		soap_serialize__wsse__UsernameToken(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, int id, struct _wsse__UsernameToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__UsernameToken);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__UsernameToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__UsernameToken **)soap_malloc(soap, sizeof(struct _wsse__UsernameToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__UsernameToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__UsernameToken);
	if (soap_out_PointerTo_wsse__UsernameToken(soap, tag?tag:"wsse:UsernameToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsu__Timestamp))
		soap_serialize__wsu__Timestamp(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, int id, struct _wsu__Timestamp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsu__Timestamp);
	if (id < 0)
		return soap->error;
	return soap_out__wsu__Timestamp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_in_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsu__Timestamp **)soap_malloc(soap, sizeof(struct _wsu__Timestamp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsu__Timestamp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsu__Timestamp);
	if (soap_out_PointerTo_wsu__Timestamp(soap, tag?tag:"wsu:Timestamp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_get_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509IssuerSerialType))
		soap_serialize_ds__X509IssuerSerialType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, int id, struct ds__X509IssuerSerialType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509IssuerSerialType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509IssuerSerialType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_in_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509IssuerSerialType **)soap_malloc(soap, sizeof(struct ds__X509IssuerSerialType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509IssuerSerialType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__X509IssuerSerialType);
	if (soap_out_PointerTods__X509IssuerSerialType(soap, tag?tag:"ds:X509IssuerSerialType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_get_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RSAKeyValueType))
		soap_serialize_ds__RSAKeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__RSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RSAKeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__RSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__RSAKeyValueType);
	if (soap_out_PointerTods__RSAKeyValueType(soap, tag?tag:"ds:RSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DSAKeyValueType))
		soap_serialize_ds__DSAKeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__DSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DSAKeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__DSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__DSAKeyValueType);
	if (soap_out_PointerTods__DSAKeyValueType(soap, tag?tag:"ds:DSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformType))
		soap_serialize_ds__TransformType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformType(struct soap *soap, const char *tag, int id, struct ds__TransformType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_in_PointerTods__TransformType(struct soap *soap, const char *tag, struct ds__TransformType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformType **)soap_malloc(soap, sizeof(struct ds__TransformType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__TransformType);
	if (soap_out_PointerTods__TransformType(soap, tag?tag:"ds:TransformType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_get_PointerTods__TransformType(struct soap *soap, struct ds__TransformType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DigestMethodType))
		soap_serialize_ds__DigestMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DigestMethodType(struct soap *soap, const char *tag, int id, struct ds__DigestMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DigestMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DigestMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_in_PointerTods__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DigestMethodType **)soap_malloc(soap, sizeof(struct ds__DigestMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DigestMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__DigestMethodType);
	if (soap_out_PointerTods__DigestMethodType(soap, tag?tag:"ds:DigestMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_get_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformsType))
		soap_serialize_ds__TransformsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformsType(struct soap *soap, const char *tag, int id, struct ds__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformsType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_in_PointerTods__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformsType **)soap_malloc(soap, sizeof(struct ds__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__TransformsType);
	if (soap_out_PointerTods__TransformsType(soap, tag?tag:"ds:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_get_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTods__ReferenceType))
		soap_serialize_PointerTods__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTods__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTods__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_in_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType ***)soap_malloc(soap, sizeof(struct ds__ReferenceType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTods__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTods__ReferenceType, sizeof(struct ds__ReferenceType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTods__ReferenceType);
	if (soap_out_PointerToPointerTods__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_get_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__ReferenceType))
		soap_serialize_ds__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_in_PointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType **)soap_malloc(soap, sizeof(struct ds__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__ReferenceType);
	if (soap_out_PointerTods__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_get_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureMethodType))
		soap_serialize_ds__SignatureMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, int id, struct ds__SignatureMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_in_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureMethodType **)soap_malloc(soap, sizeof(struct ds__SignatureMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignatureMethodType);
	if (soap_out_PointerTods__SignatureMethodType(soap, tag?tag:"ds:SignatureMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_get_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__CanonicalizationMethodType))
		soap_serialize_ds__CanonicalizationMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, struct ds__CanonicalizationMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__CanonicalizationMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__CanonicalizationMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_in_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__CanonicalizationMethodType **)soap_malloc(soap, sizeof(struct ds__CanonicalizationMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__CanonicalizationMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__CanonicalizationMethodType);
	if (soap_out_PointerTods__CanonicalizationMethodType(soap, tag?tag:"ds:CanonicalizationMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_get_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__SecurityTokenReference))
		soap_serialize__wsse__SecurityTokenReference(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, struct _wsse__SecurityTokenReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__SecurityTokenReference);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__SecurityTokenReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_in_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__SecurityTokenReference **)soap_malloc(soap, sizeof(struct _wsse__SecurityTokenReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__SecurityTokenReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__SecurityTokenReference);
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag?tag:"wsse:SecurityTokenReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_get_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509DataType))
		soap_serialize_ds__X509DataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509DataType(struct soap *soap, const char *tag, int id, struct ds__X509DataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509DataType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509DataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_in_PointerTods__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509DataType **)soap_malloc(soap, sizeof(struct ds__X509DataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509DataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__X509DataType);
	if (soap_out_PointerTods__X509DataType(soap, tag?tag:"ds:X509DataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_get_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RetrievalMethodType))
		soap_serialize_ds__RetrievalMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, int id, struct ds__RetrievalMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RetrievalMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RetrievalMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_in_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RetrievalMethodType **)soap_malloc(soap, sizeof(struct ds__RetrievalMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RetrievalMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__RetrievalMethodType);
	if (soap_out_PointerTods__RetrievalMethodType(soap, tag?tag:"ds:RetrievalMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_get_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyValueType))
		soap_serialize_ds__KeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyValueType(struct soap *soap, const char *tag, int id, struct ds__KeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_in_PointerTods__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyValueType **)soap_malloc(soap, sizeof(struct ds__KeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__KeyValueType);
	if (soap_out_PointerTods__KeyValueType(soap, tag?tag:"ds:KeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_get_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__c14n__InclusiveNamespaces))
		soap_serialize__c14n__InclusiveNamespaces(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, struct _c14n__InclusiveNamespaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__c14n__InclusiveNamespaces);
	if (id < 0)
		return soap->error;
	return soap_out__c14n__InclusiveNamespaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_in_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _c14n__InclusiveNamespaces **)soap_malloc(soap, sizeof(struct _c14n__InclusiveNamespaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__c14n__InclusiveNamespaces(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces);
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag?tag:"c14n:InclusiveNamespaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_get_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyInfoType))
		soap_serialize_ds__KeyInfoType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyInfoType(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyInfoType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTods__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__KeyInfoType);
	if (soap_out_PointerTods__KeyInfoType(soap, tag?tag:"ds:KeyInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignedInfoType))
		soap_serialize_ds__SignedInfoType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignedInfoType(struct soap *soap, const char *tag, int id, struct ds__SignedInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignedInfoType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignedInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_in_PointerTods__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignedInfoType **)soap_malloc(soap, sizeof(struct ds__SignedInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignedInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignedInfoType);
	if (soap_out_PointerTods__SignedInfoType(soap, tag?tag:"ds:SignedInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_get_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Embedded))
		soap_serialize__wsse__Embedded(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, int id, struct _wsse__Embedded *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Embedded);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Embedded(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_in_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Embedded **)soap_malloc(soap, sizeof(struct _wsse__Embedded *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Embedded(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Embedded);
	if (soap_out_PointerTo_wsse__Embedded(soap, tag?tag:"wsse:Embedded", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_get_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__KeyIdentifier))
		soap_serialize__wsse__KeyIdentifier(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, struct _wsse__KeyIdentifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__KeyIdentifier);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__KeyIdentifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_in_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__KeyIdentifier **)soap_malloc(soap, sizeof(struct _wsse__KeyIdentifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__KeyIdentifier(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__KeyIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__KeyIdentifier);
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, tag?tag:"wsse:KeyIdentifier", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_get_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Reference))
		soap_serialize__wsse__Reference(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Reference(struct soap *soap, const char *tag, int id, struct _wsse__Reference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Reference);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Reference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_in_PointerTo_wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Reference **)soap_malloc(soap, sizeof(struct _wsse__Reference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Reference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Reference);
	if (soap_out_PointerTo_wsse__Reference(soap, tag?tag:"wsse:Reference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_get_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Password))
		soap_serialize__wsse__Password(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Password(struct soap *soap, const char *tag, int id, struct _wsse__Password *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Password);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Password(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_in_PointerTo_wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Password **)soap_malloc(soap, sizeof(struct _wsse__Password *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Password(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Password **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Password);
	if (soap_out_PointerTo_wsse__Password(soap, tag?tag:"wsse:Password", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_get_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__ProblemHeaderQName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__wsa5__ProblemHeaderQName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__wsa5__ProblemHeaderQName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__wsa5__ProblemHeaderQName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemHeaderQName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa5__ProblemHeaderQName);
	if (soap_out__wsa5__ProblemHeaderQName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__wsa5__ProblemHeaderQName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa5__ProblemHeaderQName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__MetadataType))
		soap_serialize_wsa5__MetadataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, int id, struct wsa5__MetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__MetadataType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__MetadataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_in_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__MetadataType **)soap_malloc(soap, sizeof(struct wsa5__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__MetadataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa5__MetadataType);
	if (soap_out_PointerTowsa5__MetadataType(soap, tag?tag:"wsa5:MetadataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_get_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__ReferenceParametersType))
		soap_serialize_wsa5__ReferenceParametersType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa5__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__ReferenceParametersType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa5__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa5__ReferenceParametersType);
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, tag?tag:"wsa5:ReferenceParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
	if (soap_out_wsa5__FaultCodesOpenEnumType(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__FaultCodesOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
	if (soap_out_wsa5__RelationshipTypeOpenEnum(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, std::vector<wstop__TopicType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, const std::vector<wstop__TopicType * >*a)
{
	for (std::vector<wstop__TopicType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTowstop__TopicType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, const char *tag, int id, const std::vector<wstop__TopicType * >*a, const char *type)
{
	for (std::vector<wstop__TopicType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTowstop__TopicType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wstop__TopicType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, const char *tag, std::vector<wstop__TopicType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTowstop__TopicType(soap, -1)))
		return NULL;
	wstop__TopicType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_wstop__TopicType, SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType, sizeof(wstop__TopicType), 1))
				break;
			if (!soap_in_PointerTowstop__TopicType(soap, tag, NULL, "wstop:TopicType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTowstop__TopicType(soap, tag, &n, "wstop:TopicType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wstop__TopicType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTowstop__TopicType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<wstop__TopicType * >);
		if (size)
			*size = sizeof(std::vector<wstop__TopicType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<wstop__TopicType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<wstop__TopicType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<wstop__TopicType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<wstop__TopicType * > %p -> %p\n", q, p));
	*(std::vector<wstop__TopicType * >*)p = *(std::vector<wstop__TopicType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__QName(struct soap *soap, std::vector<xsd__QName >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__QName(struct soap *soap, const std::vector<xsd__QName >*a)
{
	for (std::vector<xsd__QName >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__QName(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, int id, const std::vector<xsd__QName >*a, const char *type)
{
	for (std::vector<xsd__QName >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		std::string soap_tmp(soap_QName2s(soap, (*i).c_str()));
		if (soap_out_xsd__QName(soap, tag, id, &soap_tmp, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xsd__QName >* SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, std::vector<xsd__QName >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfxsd__QName(soap, -1)))
		return NULL;
	xsd__QName n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_xsd__QName(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_xsd__QName, SOAP_TYPE_std__vectorTemplateOfxsd__QName, sizeof(xsd__QName), 0))
				break;
			if (!soap_in_xsd__QName(soap, tag, NULL, "xsd:QName"))
				break;
		}
		else
		{
			if (!soap_in_xsd__QName(soap, tag, &n, "xsd:QName"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<xsd__QName > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__QName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfxsd__QName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<xsd__QName >);
		if (size)
			*size = sizeof(std::vector<xsd__QName >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<xsd__QName >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<xsd__QName >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<xsd__QName >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfxsd__QName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<xsd__QName > %p -> %p\n", q, p));
	*(std::vector<xsd__QName >*)p = *(std::vector<xsd__QName >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__AuxiliaryData(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__AuxiliaryData(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOftt__AuxiliaryData(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_tt__AuxiliaryData(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__AuxiliaryData, SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData, sizeof(std::string), 0))
				break;
			if (!soap_in_tt__AuxiliaryData(soap, tag, NULL, "tt:AuxiliaryData"))
				break;
		}
		else
		{
			if (!soap_in_tt__AuxiliaryData(soap, tag, &n, "tt:AuxiliaryData"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__AuxiliaryData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowsnb__NotificationMessageHolderType(struct soap *soap, std::vector<wsnb__NotificationMessageHolderType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowsnb__NotificationMessageHolderType(struct soap *soap, const std::vector<wsnb__NotificationMessageHolderType * >*a)
{
	for (std::vector<wsnb__NotificationMessageHolderType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTowsnb__NotificationMessageHolderType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowsnb__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, const std::vector<wsnb__NotificationMessageHolderType * >*a, const char *type)
{
	for (std::vector<wsnb__NotificationMessageHolderType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTowsnb__NotificationMessageHolderType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsnb__NotificationMessageHolderType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowsnb__NotificationMessageHolderType(struct soap *soap, const char *tag, std::vector<wsnb__NotificationMessageHolderType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTowsnb__NotificationMessageHolderType(soap, -1)))
		return NULL;
	wsnb__NotificationMessageHolderType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_wsnb__NotificationMessageHolderType, SOAP_TYPE_std__vectorTemplateOfPointerTowsnb__NotificationMessageHolderType, sizeof(wsnb__NotificationMessageHolderType), 1))
				break;
			if (!soap_in_PointerTowsnb__NotificationMessageHolderType(soap, tag, NULL, "wsnb:NotificationMessageHolderType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTowsnb__NotificationMessageHolderType(soap, tag, &n, "wsnb:NotificationMessageHolderType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsnb__NotificationMessageHolderType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTowsnb__NotificationMessageHolderType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTowsnb__NotificationMessageHolderType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTowsnb__NotificationMessageHolderType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<wsnb__NotificationMessageHolderType * >);
		if (size)
			*size = sizeof(std::vector<wsnb__NotificationMessageHolderType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<wsnb__NotificationMessageHolderType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<wsnb__NotificationMessageHolderType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<wsnb__NotificationMessageHolderType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTowsnb__NotificationMessageHolderType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<wsnb__NotificationMessageHolderType * > %p -> %p\n", q, p));
	*(std::vector<wsnb__NotificationMessageHolderType * >*)p = *(std::vector<wsnb__NotificationMessageHolderType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowsnb__TopicExpressionType(struct soap *soap, std::vector<wsnb__TopicExpressionType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowsnb__TopicExpressionType(struct soap *soap, const std::vector<wsnb__TopicExpressionType * >*a)
{
	for (std::vector<wsnb__TopicExpressionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTowsnb__TopicExpressionType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowsnb__TopicExpressionType(struct soap *soap, const char *tag, int id, const std::vector<wsnb__TopicExpressionType * >*a, const char *type)
{
	for (std::vector<wsnb__TopicExpressionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTowsnb__TopicExpressionType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsnb__TopicExpressionType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowsnb__TopicExpressionType(struct soap *soap, const char *tag, std::vector<wsnb__TopicExpressionType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTowsnb__TopicExpressionType(soap, -1)))
		return NULL;
	wsnb__TopicExpressionType *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_wsnb__TopicExpressionType, SOAP_TYPE_std__vectorTemplateOfPointerTowsnb__TopicExpressionType, sizeof(wsnb__TopicExpressionType), 1))
				break;
			if (!soap_in_PointerTowsnb__TopicExpressionType(soap, tag, NULL, "wsnb:TopicExpressionType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTowsnb__TopicExpressionType(soap, tag, &n, "wsnb:TopicExpressionType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsnb__TopicExpressionType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTowsnb__TopicExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTowsnb__TopicExpressionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTowsnb__TopicExpressionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<wsnb__TopicExpressionType * >);
		if (size)
			*size = sizeof(std::vector<wsnb__TopicExpressionType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<wsnb__TopicExpressionType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<wsnb__TopicExpressionType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<wsnb__TopicExpressionType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTowsnb__TopicExpressionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<wsnb__TopicExpressionType * > %p -> %p\n", q, p));
	*(std::vector<wsnb__TopicExpressionType * >*)p = *(std::vector<wsnb__TopicExpressionType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__ConfigDescription(struct soap *soap, std::vector<tt__ConfigDescription * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__ConfigDescription(struct soap *soap, const std::vector<tt__ConfigDescription * >*a)
{
	for (std::vector<tt__ConfigDescription * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__ConfigDescription(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__ConfigDescription(struct soap *soap, const char *tag, int id, const std::vector<tt__ConfigDescription * >*a, const char *type)
{
	for (std::vector<tt__ConfigDescription * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__ConfigDescription(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__ConfigDescription * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__ConfigDescription(struct soap *soap, const char *tag, std::vector<tt__ConfigDescription * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__ConfigDescription(soap, -1)))
		return NULL;
	tt__ConfigDescription *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__ConfigDescription, SOAP_TYPE_std__vectorTemplateOfPointerTott__ConfigDescription, sizeof(tt__ConfigDescription), 1))
				break;
			if (!soap_in_PointerTott__ConfigDescription(soap, tag, NULL, "tt:ConfigDescription"))
				break;
		}
		else
		{
			if (!soap_in_PointerTott__ConfigDescription(soap, tag, &n, "tt:ConfigDescription"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__ConfigDescription * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__ConfigDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__ConfigDescription(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTott__ConfigDescription, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__ConfigDescription * >);
		if (size)
			*size = sizeof(std::vector<tt__ConfigDescription * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__ConfigDescription * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tt__ConfigDescription * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tt__ConfigDescription * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTott__ConfigDescription(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tt__ConfigDescription * > %p -> %p\n", q, p));
	*(std::vector<tt__ConfigDescription * >*)p = *(std::vector<tt__ConfigDescription * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__anyURI(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__anyURI(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__anyURI(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfxsd__anyURI(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_xsd__anyURI(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_xsd__anyURI, SOAP_TYPE_std__vectorTemplateOfxsd__anyURI, sizeof(std::string), 0))
				break;
			if (!soap_in_xsd__anyURI(soap, tag, NULL, "xsd:anyURI"))
				break;
		}
		else
		{
			if (!soap_in_xsd__anyURI(soap, tag, &n, "xsd:anyURI"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__anyURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__anyURI(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfxsd__anyURI, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfxsd__anyURI(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Merge(struct soap *soap, std::vector<tt__Merge * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Merge(struct soap *soap, const std::vector<tt__Merge * >*a)
{
	for (std::vector<tt__Merge * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Merge(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Merge(struct soap *soap, const char *tag, int id, const std::vector<tt__Merge * >*a, const char *type)
{
	for (std::vector<tt__Merge * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Merge(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Merge * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Merge(struct soap *soap, const char *tag, std::vector<tt__Merge * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Merge(soap, -1)))
		return NULL;
	tt__Merge *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__Merge, SOAP_TYPE_std__vectorTemplateOfPointerTott__Merge, sizeof(tt__Merge), 1))
				break;
			if (!soap_in_PointerTott__Merge(soap, tag, NULL, "tt:Merge"))
				break;
		}
		else
		{
			if (!soap_in_PointerTott__Merge(soap, tag, &n, "tt:Merge"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Merge * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Merge(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Merge(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTott__Merge, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__Merge * >);
		if (size)
			*size = sizeof(std::vector<tt__Merge * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__Merge * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tt__Merge * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tt__Merge * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTott__Merge(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tt__Merge * > %p -> %p\n", q, p));
	*(std::vector<tt__Merge * >*)p = *(std::vector<tt__Merge * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Split(struct soap *soap, std::vector<tt__Split * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Split(struct soap *soap, const std::vector<tt__Split * >*a)
{
	for (std::vector<tt__Split * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Split(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Split(struct soap *soap, const char *tag, int id, const std::vector<tt__Split * >*a, const char *type)
{
	for (std::vector<tt__Split * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Split(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Split * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Split(struct soap *soap, const char *tag, std::vector<tt__Split * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Split(soap, -1)))
		return NULL;
	tt__Split *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__Split, SOAP_TYPE_std__vectorTemplateOfPointerTott__Split, sizeof(tt__Split), 1))
				break;
			if (!soap_in_PointerTott__Split(soap, tag, NULL, "tt:Split"))
				break;
		}
		else
		{
			if (!soap_in_PointerTott__Split(soap, tag, &n, "tt:Split"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Split * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Split(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Split(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTott__Split, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__Split * >);
		if (size)
			*size = sizeof(std::vector<tt__Split * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__Split * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tt__Split * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tt__Split * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTott__Split(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tt__Split * > %p -> %p\n", q, p));
	*(std::vector<tt__Split * >*)p = *(std::vector<tt__Split * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Rename(struct soap *soap, std::vector<tt__Rename * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Rename(struct soap *soap, const std::vector<tt__Rename * >*a)
{
	for (std::vector<tt__Rename * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Rename(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Rename(struct soap *soap, const char *tag, int id, const std::vector<tt__Rename * >*a, const char *type)
{
	for (std::vector<tt__Rename * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Rename(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Rename * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Rename(struct soap *soap, const char *tag, std::vector<tt__Rename * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Rename(soap, -1)))
		return NULL;
	tt__Rename *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__Rename, SOAP_TYPE_std__vectorTemplateOfPointerTott__Rename, sizeof(tt__Rename), 1))
				break;
			if (!soap_in_PointerTott__Rename(soap, tag, NULL, "tt:Rename"))
				break;
		}
		else
		{
			if (!soap_in_PointerTott__Rename(soap, tag, &n, "tt:Rename"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Rename * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Rename(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Rename(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTott__Rename, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__Rename * >);
		if (size)
			*size = sizeof(std::vector<tt__Rename * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__Rename * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tt__Rename * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tt__Rename * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTott__Rename(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tt__Rename * > %p -> %p\n", q, p));
	*(std::vector<tt__Rename * >*)p = *(std::vector<tt__Rename * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__ObjectId(struct soap *soap, std::vector<tt__ObjectId * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__ObjectId(struct soap *soap, const std::vector<tt__ObjectId * >*a)
{
	for (std::vector<tt__ObjectId * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__ObjectId(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__ObjectId(struct soap *soap, const char *tag, int id, const std::vector<tt__ObjectId * >*a, const char *type)
{
	for (std::vector<tt__ObjectId * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__ObjectId(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__ObjectId * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__ObjectId(struct soap *soap, const char *tag, std::vector<tt__ObjectId * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__ObjectId(soap, -1)))
		return NULL;
	tt__ObjectId *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__ObjectId, SOAP_TYPE_std__vectorTemplateOfPointerTott__ObjectId, sizeof(tt__ObjectId), 1))
				break;
			if (!soap_in_PointerTott__ObjectId(soap, tag, NULL, "tt:ObjectId"))
				break;
		}
		else
		{
			if (!soap_in_PointerTott__ObjectId(soap, tag, &n, "tt:ObjectId"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__ObjectId * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__ObjectId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__ObjectId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTott__ObjectId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__ObjectId * >);
		if (size)
			*size = sizeof(std::vector<tt__ObjectId * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__ObjectId * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tt__ObjectId * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tt__ObjectId * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTott__ObjectId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tt__ObjectId * > %p -> %p\n", q, p));
	*(std::vector<tt__ObjectId * >*)p = *(std::vector<tt__ObjectId * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Object(struct soap *soap, std::vector<tt__Object * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Object(struct soap *soap, const std::vector<tt__Object * >*a)
{
	for (std::vector<tt__Object * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Object(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Object(struct soap *soap, const char *tag, int id, const std::vector<tt__Object * >*a, const char *type)
{
	for (std::vector<tt__Object * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Object(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Object * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Object(struct soap *soap, const char *tag, std::vector<tt__Object * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Object(soap, -1)))
		return NULL;
	tt__Object *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__Object, SOAP_TYPE_std__vectorTemplateOfPointerTott__Object, sizeof(tt__Object), 1))
				break;
			if (!soap_in_PointerTott__Object(soap, tag, NULL, "tt:Object"))
				break;
		}
		else
		{
			if (!soap_in_PointerTott__Object(soap, tag, &n, "tt:Object"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Object * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Object(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Object(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTott__Object, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__Object * >);
		if (size)
			*size = sizeof(std::vector<tt__Object * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__Object * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tt__Object * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tt__Object * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTott__Object(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tt__Object * > %p -> %p\n", q, p));
	*(std::vector<tt__Object * >*)p = *(std::vector<tt__Object * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Polygon(struct soap *soap, std::vector<tt__Polygon * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Polygon(struct soap *soap, const std::vector<tt__Polygon * >*a)
{
	for (std::vector<tt__Polygon * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Polygon(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Polygon(struct soap *soap, const char *tag, int id, const std::vector<tt__Polygon * >*a, const char *type)
{
	for (std::vector<tt__Polygon * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Polygon(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Polygon * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Polygon(struct soap *soap, const char *tag, std::vector<tt__Polygon * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Polygon(soap, -1)))
		return NULL;
	tt__Polygon *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__Polygon, SOAP_TYPE_std__vectorTemplateOfPointerTott__Polygon, sizeof(tt__Polygon), 1))
				break;
			if (!soap_in_PointerTott__Polygon(soap, tag, NULL, "tt:Polygon"))
				break;
		}
		else
		{
			if (!soap_in_PointerTott__Polygon(soap, tag, &n, "tt:Polygon"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Polygon * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Polygon(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Polygon(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTott__Polygon, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__Polygon * >);
		if (size)
			*size = sizeof(std::vector<tt__Polygon * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__Polygon * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tt__Polygon * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tt__Polygon * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTott__Polygon(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tt__Polygon * > %p -> %p\n", q, p));
	*(std::vector<tt__Polygon * >*)p = *(std::vector<tt__Polygon * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, std::vector<tt__Vector * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, const std::vector<tt__Vector * >*a)
{
	for (std::vector<tt__Vector * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Vector(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, const char *tag, int id, const std::vector<tt__Vector * >*a, const char *type)
{
	for (std::vector<tt__Vector * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Vector(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Vector * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, const char *tag, std::vector<tt__Vector * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Vector(soap, -1)))
		return NULL;
	tt__Vector *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__Vector, SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector, sizeof(tt__Vector), 1))
				break;
			if (!soap_in_PointerTott__Vector(soap, tag, NULL, "tt:Vector"))
				break;
		}
		else
		{
			if (!soap_in_PointerTott__Vector(soap, tag, &n, "tt:Vector"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Vector * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Vector(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__Vector * >);
		if (size)
			*size = sizeof(std::vector<tt__Vector * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__Vector * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tt__Vector * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tt__Vector * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tt__Vector * > %p -> %p\n", q, p));
	*(std::vector<tt__Vector * >*)p = *(std::vector<tt__Vector * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, std::vector<enum tt__BacklightCompensationMode >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, const std::vector<enum tt__BacklightCompensationMode >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__BacklightCompensationMode >*a, const char *type)
{
	for (std::vector<enum tt__BacklightCompensationMode >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__BacklightCompensationMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__BacklightCompensationMode >* SOAP_FMAC4 soap_in_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, const char *tag, std::vector<enum tt__BacklightCompensationMode >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOftt__BacklightCompensationMode(soap, -1)))
		return NULL;
	enum tt__BacklightCompensationMode n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_tt__BacklightCompensationMode(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__BacklightCompensationMode, SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode, sizeof(enum tt__BacklightCompensationMode), 0))
				break;
			if (!soap_in_tt__BacklightCompensationMode(soap, tag, NULL, "tt:BacklightCompensationMode"))
				break;
		}
		else
		{
			if (!soap_in_tt__BacklightCompensationMode(soap, tag, &n, "tt:BacklightCompensationMode"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__BacklightCompensationMode > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__BacklightCompensationMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum tt__BacklightCompensationMode >);
		if (size)
			*size = sizeof(std::vector<enum tt__BacklightCompensationMode >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum tt__BacklightCompensationMode >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<enum tt__BacklightCompensationMode >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum tt__BacklightCompensationMode >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum tt__BacklightCompensationMode > %p -> %p\n", q, p));
	*(std::vector<enum tt__BacklightCompensationMode >*)p = *(std::vector<enum tt__BacklightCompensationMode >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, std::vector<enum tt__WhiteBalanceMode >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, const std::vector<enum tt__WhiteBalanceMode >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__WhiteBalanceMode >*a, const char *type)
{
	for (std::vector<enum tt__WhiteBalanceMode >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__WhiteBalanceMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__WhiteBalanceMode >* SOAP_FMAC4 soap_in_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, const char *tag, std::vector<enum tt__WhiteBalanceMode >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOftt__WhiteBalanceMode(soap, -1)))
		return NULL;
	enum tt__WhiteBalanceMode n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_tt__WhiteBalanceMode(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__WhiteBalanceMode, SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode, sizeof(enum tt__WhiteBalanceMode), 0))
				break;
			if (!soap_in_tt__WhiteBalanceMode(soap, tag, NULL, "tt:WhiteBalanceMode"))
				break;
		}
		else
		{
			if (!soap_in_tt__WhiteBalanceMode(soap, tag, &n, "tt:WhiteBalanceMode"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__WhiteBalanceMode > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__WhiteBalanceMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum tt__WhiteBalanceMode >);
		if (size)
			*size = sizeof(std::vector<enum tt__WhiteBalanceMode >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum tt__WhiteBalanceMode >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<enum tt__WhiteBalanceMode >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum tt__WhiteBalanceMode >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum tt__WhiteBalanceMode > %p -> %p\n", q, p));
	*(std::vector<enum tt__WhiteBalanceMode >*)p = *(std::vector<enum tt__WhiteBalanceMode >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, std::vector<enum tt__ExposurePriority >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, const std::vector<enum tt__ExposurePriority >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, const char *tag, int id, const std::vector<enum tt__ExposurePriority >*a, const char *type)
{
	for (std::vector<enum tt__ExposurePriority >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ExposurePriority(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__ExposurePriority >* SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, const char *tag, std::vector<enum tt__ExposurePriority >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOftt__ExposurePriority(soap, -1)))
		return NULL;
	enum tt__ExposurePriority n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_tt__ExposurePriority(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__ExposurePriority, SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority, sizeof(enum tt__ExposurePriority), 0))
				break;
			if (!soap_in_tt__ExposurePriority(soap, tag, NULL, "tt:ExposurePriority"))
				break;
		}
		else
		{
			if (!soap_in_tt__ExposurePriority(soap, tag, &n, "tt:ExposurePriority"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__ExposurePriority > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__ExposurePriority(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum tt__ExposurePriority >);
		if (size)
			*size = sizeof(std::vector<enum tt__ExposurePriority >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum tt__ExposurePriority >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<enum tt__ExposurePriority >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum tt__ExposurePriority >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum tt__ExposurePriority > %p -> %p\n", q, p));
	*(std::vector<enum tt__ExposurePriority >*)p = *(std::vector<enum tt__ExposurePriority >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ExposureMode(struct soap *soap, std::vector<enum tt__ExposureMode >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ExposureMode(struct soap *soap, const std::vector<enum tt__ExposureMode >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ExposureMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__ExposureMode >*a, const char *type)
{
	for (std::vector<enum tt__ExposureMode >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ExposureMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__ExposureMode >* SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ExposureMode(struct soap *soap, const char *tag, std::vector<enum tt__ExposureMode >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOftt__ExposureMode(soap, -1)))
		return NULL;
	enum tt__ExposureMode n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_tt__ExposureMode(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__ExposureMode, SOAP_TYPE_std__vectorTemplateOftt__ExposureMode, sizeof(enum tt__ExposureMode), 0))
				break;
			if (!soap_in_tt__ExposureMode(soap, tag, NULL, "tt:ExposureMode"))
				break;
		}
		else
		{
			if (!soap_in_tt__ExposureMode(soap, tag, &n, "tt:ExposureMode"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__ExposureMode > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__ExposureMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__ExposureMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOftt__ExposureMode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum tt__ExposureMode >);
		if (size)
			*size = sizeof(std::vector<enum tt__ExposureMode >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum tt__ExposureMode >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<enum tt__ExposureMode >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum tt__ExposureMode >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOftt__ExposureMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum tt__ExposureMode > %p -> %p\n", q, p));
	*(std::vector<enum tt__ExposureMode >*)p = *(std::vector<enum tt__ExposureMode >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, std::vector<enum tt__AutoFocusMode >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, const std::vector<enum tt__AutoFocusMode >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__AutoFocusMode >*a, const char *type)
{
	for (std::vector<enum tt__AutoFocusMode >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__AutoFocusMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__AutoFocusMode >* SOAP_FMAC4 soap_in_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, const char *tag, std::vector<enum tt__AutoFocusMode >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOftt__AutoFocusMode(soap, -1)))
		return NULL;
	enum tt__AutoFocusMode n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_tt__AutoFocusMode(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__AutoFocusMode, SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode, sizeof(enum tt__AutoFocusMode), 0))
				break;
			if (!soap_in_tt__AutoFocusMode(soap, tag, NULL, "tt:AutoFocusMode"))
				break;
		}
		else
		{
			if (!soap_in_tt__AutoFocusMode(soap, tag, &n, "tt:AutoFocusMode"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__AutoFocusMode > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__AutoFocusMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum tt__AutoFocusMode >);
		if (size)
			*size = sizeof(std::vector<enum tt__AutoFocusMode >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum tt__AutoFocusMode >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<enum tt__AutoFocusMode >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum tt__AutoFocusMode >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum tt__AutoFocusMode > %p -> %p\n", q, p));
	*(std::vector<enum tt__AutoFocusMode >*)p = *(std::vector<enum tt__AutoFocusMode >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, std::vector<enum tt__WideDynamicMode >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, const std::vector<enum tt__WideDynamicMode >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__WideDynamicMode >*a, const char *type)
{
	for (std::vector<enum tt__WideDynamicMode >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__WideDynamicMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__WideDynamicMode >* SOAP_FMAC4 soap_in_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, const char *tag, std::vector<enum tt__WideDynamicMode >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOftt__WideDynamicMode(soap, -1)))
		return NULL;
	enum tt__WideDynamicMode n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_tt__WideDynamicMode(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__WideDynamicMode, SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode, sizeof(enum tt__WideDynamicMode), 0))
				break;
			if (!soap_in_tt__WideDynamicMode(soap, tag, NULL, "tt:WideDynamicMode"))
				break;
		}
		else
		{
			if (!soap_in_tt__WideDynamicMode(soap, tag, &n, "tt:WideDynamicMode"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__WideDynamicMode > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__WideDynamicMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum tt__WideDynamicMode >);
		if (size)
			*size = sizeof(std::vector<enum tt__WideDynamicMode >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum tt__WideDynamicMode >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<enum tt__WideDynamicMode >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum tt__WideDynamicMode >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum tt__WideDynamicMode > %p -> %p\n", q, p));
	*(std::vector<enum tt__WideDynamicMode >*)p = *(std::vector<enum tt__WideDynamicMode >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, std::vector<enum tt__IrCutFilterMode >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, const std::vector<enum tt__IrCutFilterMode >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__IrCutFilterMode >*a, const char *type)
{
	for (std::vector<enum tt__IrCutFilterMode >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__IrCutFilterMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__IrCutFilterMode >* SOAP_FMAC4 soap_in_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, const char *tag, std::vector<enum tt__IrCutFilterMode >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOftt__IrCutFilterMode(soap, -1)))
		return NULL;
	enum tt__IrCutFilterMode n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_tt__IrCutFilterMode(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__IrCutFilterMode, SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode, sizeof(enum tt__IrCutFilterMode), 0))
				break;
			if (!soap_in_tt__IrCutFilterMode(soap, tag, NULL, "tt:IrCutFilterMode"))
				break;
		}
		else
		{
			if (!soap_in_tt__IrCutFilterMode(soap, tag, &n, "tt:IrCutFilterMode"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__IrCutFilterMode > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__IrCutFilterMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum tt__IrCutFilterMode >);
		if (size)
			*size = sizeof(std::vector<enum tt__IrCutFilterMode >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum tt__IrCutFilterMode >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<enum tt__IrCutFilterMode >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum tt__IrCutFilterMode >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum tt__IrCutFilterMode > %p -> %p\n", q, p));
	*(std::vector<enum tt__IrCutFilterMode >*)p = *(std::vector<enum tt__IrCutFilterMode >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Space1DDescription(struct soap *soap, std::vector<tt__Space1DDescription * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Space1DDescription(struct soap *soap, const std::vector<tt__Space1DDescription * >*a)
{
	for (std::vector<tt__Space1DDescription * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Space1DDescription(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Space1DDescription(struct soap *soap, const char *tag, int id, const std::vector<tt__Space1DDescription * >*a, const char *type)
{
	for (std::vector<tt__Space1DDescription * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Space1DDescription(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Space1DDescription * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Space1DDescription(struct soap *soap, const char *tag, std::vector<tt__Space1DDescription * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Space1DDescription(soap, -1)))
		return NULL;
	tt__Space1DDescription *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__Space1DDescription, SOAP_TYPE_std__vectorTemplateOfPointerTott__Space1DDescription, sizeof(tt__Space1DDescription), 1))
				break;
			if (!soap_in_PointerTott__Space1DDescription(soap, tag, NULL, "tt:Space1DDescription"))
				break;
		}
		else
		{
			if (!soap_in_PointerTott__Space1DDescription(soap, tag, &n, "tt:Space1DDescription"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Space1DDescription * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Space1DDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Space1DDescription(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTott__Space1DDescription, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__Space1DDescription * >);
		if (size)
			*size = sizeof(std::vector<tt__Space1DDescription * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__Space1DDescription * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tt__Space1DDescription * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tt__Space1DDescription * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTott__Space1DDescription(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tt__Space1DDescription * > %p -> %p\n", q, p));
	*(std::vector<tt__Space1DDescription * >*)p = *(std::vector<tt__Space1DDescription * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Space2DDescription(struct soap *soap, std::vector<tt__Space2DDescription * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Space2DDescription(struct soap *soap, const std::vector<tt__Space2DDescription * >*a)
{
	for (std::vector<tt__Space2DDescription * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Space2DDescription(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Space2DDescription(struct soap *soap, const char *tag, int id, const std::vector<tt__Space2DDescription * >*a, const char *type)
{
	for (std::vector<tt__Space2DDescription * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Space2DDescription(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Space2DDescription * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Space2DDescription(struct soap *soap, const char *tag, std::vector<tt__Space2DDescription * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Space2DDescription(soap, -1)))
		return NULL;
	tt__Space2DDescription *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__Space2DDescription, SOAP_TYPE_std__vectorTemplateOfPointerTott__Space2DDescription, sizeof(tt__Space2DDescription), 1))
				break;
			if (!soap_in_PointerTott__Space2DDescription(soap, tag, NULL, "tt:Space2DDescription"))
				break;
		}
		else
		{
			if (!soap_in_PointerTott__Space2DDescription(soap, tag, &n, "tt:Space2DDescription"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Space2DDescription * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Space2DDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Space2DDescription(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTott__Space2DDescription, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__Space2DDescription * >);
		if (size)
			*size = sizeof(std::vector<tt__Space2DDescription * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__Space2DDescription * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tt__Space2DDescription * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tt__Space2DDescription * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTott__Space2DDescription(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tt__Space2DDescription * > %p -> %p\n", q, p));
	*(std::vector<tt__Space2DDescription * >*)p = *(std::vector<tt__Space2DDescription * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, std::vector<tt__OnvifVersion * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, const std::vector<tt__OnvifVersion * >*a)
{
	for (std::vector<tt__OnvifVersion * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__OnvifVersion(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, const char *tag, int id, const std::vector<tt__OnvifVersion * >*a, const char *type)
{
	for (std::vector<tt__OnvifVersion * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__OnvifVersion(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__OnvifVersion * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, const char *tag, std::vector<tt__OnvifVersion * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__OnvifVersion(soap, -1)))
		return NULL;
	tt__OnvifVersion *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__OnvifVersion, SOAP_TYPE_std__vectorTemplateOfPointerTott__OnvifVersion, sizeof(tt__OnvifVersion), 1))
				break;
			if (!soap_in_PointerTott__OnvifVersion(soap, tag, NULL, "tt:OnvifVersion"))
				break;
		}
		else
		{
			if (!soap_in_PointerTott__OnvifVersion(soap, tag, &n, "tt:OnvifVersion"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__OnvifVersion * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__OnvifVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTott__OnvifVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__OnvifVersion * >);
		if (size)
			*size = sizeof(std::vector<tt__OnvifVersion * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__OnvifVersion * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tt__OnvifVersion * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tt__OnvifVersion * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tt__OnvifVersion * > %p -> %p\n", q, p));
	*(std::vector<tt__OnvifVersion * >*)p = *(std::vector<tt__OnvifVersion * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__IPv6Address(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__IPv6Address(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__IPv6Address(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__IPv6Address(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__IPv6Address(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOftt__IPv6Address(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOftt__IPv6Address(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_tt__IPv6Address(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__IPv6Address, SOAP_TYPE_std__vectorTemplateOftt__IPv6Address, sizeof(std::string), 0))
				break;
			if (!soap_in_tt__IPv6Address(soap, tag, NULL, "tt:IPv6Address"))
				break;
		}
		else
		{
			if (!soap_in_tt__IPv6Address(soap, tag, &n, "tt:IPv6Address"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__IPv6Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__IPv6Address(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOftt__IPv6Address, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOftt__IPv6Address(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__IPv4Address(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__IPv4Address(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__IPv4Address(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__IPv4Address(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__IPv4Address(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOftt__IPv4Address(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOftt__IPv4Address(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_tt__IPv4Address(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__IPv4Address, SOAP_TYPE_std__vectorTemplateOftt__IPv4Address, sizeof(std::string), 0))
				break;
			if (!soap_in_tt__IPv4Address(soap, tag, NULL, "tt:IPv4Address"))
				break;
		}
		else
		{
			if (!soap_in_tt__IPv4Address(soap, tag, &n, "tt:IPv4Address"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__IPv4Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__IPv4Address(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOftt__IPv4Address, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOftt__IPv4Address(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, std::vector<tt__NetworkHost * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, const std::vector<tt__NetworkHost * >*a)
{
	for (std::vector<tt__NetworkHost * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__NetworkHost(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, const char *tag, int id, const std::vector<tt__NetworkHost * >*a, const char *type)
{
	for (std::vector<tt__NetworkHost * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__NetworkHost(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__NetworkHost * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, const char *tag, std::vector<tt__NetworkHost * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__NetworkHost(soap, -1)))
		return NULL;
	tt__NetworkHost *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__NetworkHost, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkHost, sizeof(tt__NetworkHost), 1))
				break;
			if (!soap_in_PointerTott__NetworkHost(soap, tag, NULL, "tt:NetworkHost"))
				break;
		}
		else
		{
			if (!soap_in_PointerTott__NetworkHost(soap, tag, &n, "tt:NetworkHost"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__NetworkHost * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__NetworkHost(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkHost, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__NetworkHost * >);
		if (size)
			*size = sizeof(std::vector<tt__NetworkHost * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__NetworkHost * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tt__NetworkHost * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tt__NetworkHost * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tt__NetworkHost * > %p -> %p\n", q, p));
	*(std::vector<tt__NetworkHost * >*)p = *(std::vector<tt__NetworkHost * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, std::vector<tt__IPAddress * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, const std::vector<tt__IPAddress * >*a)
{
	for (std::vector<tt__IPAddress * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__IPAddress(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, const char *tag, int id, const std::vector<tt__IPAddress * >*a, const char *type)
{
	for (std::vector<tt__IPAddress * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__IPAddress(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__IPAddress * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, const char *tag, std::vector<tt__IPAddress * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__IPAddress(soap, -1)))
		return NULL;
	tt__IPAddress *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__IPAddress, SOAP_TYPE_std__vectorTemplateOfPointerTott__IPAddress, sizeof(tt__IPAddress), 1))
				break;
			if (!soap_in_PointerTott__IPAddress(soap, tag, NULL, "tt:IPAddress"))
				break;
		}
		else
		{
			if (!soap_in_PointerTott__IPAddress(soap, tag, &n, "tt:IPAddress"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__IPAddress * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__IPAddress(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTott__IPAddress, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__IPAddress * >);
		if (size)
			*size = sizeof(std::vector<tt__IPAddress * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__IPAddress * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tt__IPAddress * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tt__IPAddress * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tt__IPAddress * > %p -> %p\n", q, p));
	*(std::vector<tt__IPAddress * >*)p = *(std::vector<tt__IPAddress * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__token(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__token(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__token(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__token(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__token(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__token(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfxsd__token(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_xsd__token(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_xsd__token, SOAP_TYPE_std__vectorTemplateOfxsd__token, sizeof(std::string), 0))
				break;
			if (!soap_in_xsd__token(soap, tag, NULL, "xsd:token"))
				break;
		}
		else
		{
			if (!soap_in_xsd__token(soap, tag, &n, "xsd:token"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__token(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__token(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfxsd__token, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfxsd__token(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, std::vector<tt__PrefixedIPv6Address * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, const std::vector<tt__PrefixedIPv6Address * >*a)
{
	for (std::vector<tt__PrefixedIPv6Address * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PrefixedIPv6Address(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, const char *tag, int id, const std::vector<tt__PrefixedIPv6Address * >*a, const char *type)
{
	for (std::vector<tt__PrefixedIPv6Address * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PrefixedIPv6Address(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PrefixedIPv6Address * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, const char *tag, std::vector<tt__PrefixedIPv6Address * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, -1)))
		return NULL;
	tt__PrefixedIPv6Address *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__PrefixedIPv6Address, SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv6Address, sizeof(tt__PrefixedIPv6Address), 1))
				break;
			if (!soap_in_PointerTott__PrefixedIPv6Address(soap, tag, NULL, "tt:PrefixedIPv6Address"))
				break;
		}
		else
		{
			if (!soap_in_PointerTott__PrefixedIPv6Address(soap, tag, &n, "tt:PrefixedIPv6Address"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PrefixedIPv6Address * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv6Address, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__PrefixedIPv6Address * >);
		if (size)
			*size = sizeof(std::vector<tt__PrefixedIPv6Address * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__PrefixedIPv6Address * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tt__PrefixedIPv6Address * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tt__PrefixedIPv6Address * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tt__PrefixedIPv6Address * > %p -> %p\n", q, p));
	*(std::vector<tt__PrefixedIPv6Address * >*)p = *(std::vector<tt__PrefixedIPv6Address * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, std::vector<tt__PrefixedIPv4Address * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, const std::vector<tt__PrefixedIPv4Address * >*a)
{
	for (std::vector<tt__PrefixedIPv4Address * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PrefixedIPv4Address(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, const char *tag, int id, const std::vector<tt__PrefixedIPv4Address * >*a, const char *type)
{
	for (std::vector<tt__PrefixedIPv4Address * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PrefixedIPv4Address(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PrefixedIPv4Address * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, const char *tag, std::vector<tt__PrefixedIPv4Address * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, -1)))
		return NULL;
	tt__PrefixedIPv4Address *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__PrefixedIPv4Address, SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv4Address, sizeof(tt__PrefixedIPv4Address), 1))
				break;
			if (!soap_in_PointerTott__PrefixedIPv4Address(soap, tag, NULL, "tt:PrefixedIPv4Address"))
				break;
		}
		else
		{
			if (!soap_in_PointerTott__PrefixedIPv4Address(soap, tag, &n, "tt:PrefixedIPv4Address"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PrefixedIPv4Address * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv4Address, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__PrefixedIPv4Address * >);
		if (size)
			*size = sizeof(std::vector<tt__PrefixedIPv4Address * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__PrefixedIPv4Address * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tt__PrefixedIPv4Address * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tt__PrefixedIPv4Address * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tt__PrefixedIPv4Address * > %p -> %p\n", q, p));
	*(std::vector<tt__PrefixedIPv4Address * >*)p = *(std::vector<tt__PrefixedIPv4Address * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(struct soap *soap, std::vector<tt__AudioEncoderConfigurationOption * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(struct soap *soap, const std::vector<tt__AudioEncoderConfigurationOption * >*a)
{
	for (std::vector<tt__AudioEncoderConfigurationOption * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__AudioEncoderConfigurationOption(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, int id, const std::vector<tt__AudioEncoderConfigurationOption * >*a, const char *type)
{
	for (std::vector<tt__AudioEncoderConfigurationOption * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__AudioEncoderConfigurationOption(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__AudioEncoderConfigurationOption * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, std::vector<tt__AudioEncoderConfigurationOption * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(soap, -1)))
		return NULL;
	tt__AudioEncoderConfigurationOption *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__AudioEncoderConfigurationOption, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption, sizeof(tt__AudioEncoderConfigurationOption), 1))
				break;
			if (!soap_in_PointerTott__AudioEncoderConfigurationOption(soap, tag, NULL, "tt:AudioEncoderConfigurationOption"))
				break;
		}
		else
		{
			if (!soap_in_PointerTott__AudioEncoderConfigurationOption(soap, tag, &n, "tt:AudioEncoderConfigurationOption"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__AudioEncoderConfigurationOption * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__AudioEncoderConfigurationOption * >);
		if (size)
			*size = sizeof(std::vector<tt__AudioEncoderConfigurationOption * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__AudioEncoderConfigurationOption * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tt__AudioEncoderConfigurationOption * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tt__AudioEncoderConfigurationOption * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tt__AudioEncoderConfigurationOption * > %p -> %p\n", q, p));
	*(std::vector<tt__AudioEncoderConfigurationOption * >*)p = *(std::vector<tt__AudioEncoderConfigurationOption * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__H264Profile(struct soap *soap, std::vector<enum tt__H264Profile >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__H264Profile(struct soap *soap, const std::vector<enum tt__H264Profile >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__H264Profile(struct soap *soap, const char *tag, int id, const std::vector<enum tt__H264Profile >*a, const char *type)
{
	for (std::vector<enum tt__H264Profile >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__H264Profile(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__H264Profile >* SOAP_FMAC4 soap_in_std__vectorTemplateOftt__H264Profile(struct soap *soap, const char *tag, std::vector<enum tt__H264Profile >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOftt__H264Profile(soap, -1)))
		return NULL;
	enum tt__H264Profile n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_tt__H264Profile(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__H264Profile, SOAP_TYPE_std__vectorTemplateOftt__H264Profile, sizeof(enum tt__H264Profile), 0))
				break;
			if (!soap_in_tt__H264Profile(soap, tag, NULL, "tt:H264Profile"))
				break;
		}
		else
		{
			if (!soap_in_tt__H264Profile(soap, tag, &n, "tt:H264Profile"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__H264Profile > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__H264Profile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__H264Profile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOftt__H264Profile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum tt__H264Profile >);
		if (size)
			*size = sizeof(std::vector<enum tt__H264Profile >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum tt__H264Profile >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<enum tt__H264Profile >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum tt__H264Profile >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOftt__H264Profile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum tt__H264Profile > %p -> %p\n", q, p));
	*(std::vector<enum tt__H264Profile >*)p = *(std::vector<enum tt__H264Profile >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__Mpeg4Profile(struct soap *soap, std::vector<enum tt__Mpeg4Profile >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__Mpeg4Profile(struct soap *soap, const std::vector<enum tt__Mpeg4Profile >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__Mpeg4Profile(struct soap *soap, const char *tag, int id, const std::vector<enum tt__Mpeg4Profile >*a, const char *type)
{
	for (std::vector<enum tt__Mpeg4Profile >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__Mpeg4Profile(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__Mpeg4Profile >* SOAP_FMAC4 soap_in_std__vectorTemplateOftt__Mpeg4Profile(struct soap *soap, const char *tag, std::vector<enum tt__Mpeg4Profile >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOftt__Mpeg4Profile(soap, -1)))
		return NULL;
	enum tt__Mpeg4Profile n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_tt__Mpeg4Profile(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__Mpeg4Profile, SOAP_TYPE_std__vectorTemplateOftt__Mpeg4Profile, sizeof(enum tt__Mpeg4Profile), 0))
				break;
			if (!soap_in_tt__Mpeg4Profile(soap, tag, NULL, "tt:Mpeg4Profile"))
				break;
		}
		else
		{
			if (!soap_in_tt__Mpeg4Profile(soap, tag, &n, "tt:Mpeg4Profile"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__Mpeg4Profile > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__Mpeg4Profile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__Mpeg4Profile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOftt__Mpeg4Profile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum tt__Mpeg4Profile >);
		if (size)
			*size = sizeof(std::vector<enum tt__Mpeg4Profile >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum tt__Mpeg4Profile >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<enum tt__Mpeg4Profile >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum tt__Mpeg4Profile >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOftt__Mpeg4Profile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum tt__Mpeg4Profile > %p -> %p\n", q, p));
	*(std::vector<enum tt__Mpeg4Profile >*)p = *(std::vector<enum tt__Mpeg4Profile >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__VideoResolution(struct soap *soap, std::vector<tt__VideoResolution * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__VideoResolution(struct soap *soap, const std::vector<tt__VideoResolution * >*a)
{
	for (std::vector<tt__VideoResolution * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__VideoResolution(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__VideoResolution(struct soap *soap, const char *tag, int id, const std::vector<tt__VideoResolution * >*a, const char *type)
{
	for (std::vector<tt__VideoResolution * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__VideoResolution(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__VideoResolution * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__VideoResolution(struct soap *soap, const char *tag, std::vector<tt__VideoResolution * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__VideoResolution(soap, -1)))
		return NULL;
	tt__VideoResolution *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__VideoResolution, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoResolution, sizeof(tt__VideoResolution), 1))
				break;
			if (!soap_in_PointerTott__VideoResolution(soap, tag, NULL, "tt:VideoResolution"))
				break;
		}
		else
		{
			if (!soap_in_PointerTott__VideoResolution(soap, tag, &n, "tt:VideoResolution"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__VideoResolution * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__VideoResolution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__VideoResolution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoResolution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__VideoResolution * >);
		if (size)
			*size = sizeof(std::vector<tt__VideoResolution * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__VideoResolution * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tt__VideoResolution * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tt__VideoResolution * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTott__VideoResolution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tt__VideoResolution * > %p -> %p\n", q, p));
	*(std::vector<tt__VideoResolution * >*)p = *(std::vector<tt__VideoResolution * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__ReferenceToken(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ReferenceToken(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOftt__ReferenceToken(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_tt__ReferenceToken(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__ReferenceToken, SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken, sizeof(std::string), 0))
				break;
			if (!soap_in_tt__ReferenceToken(soap, tag, NULL, "tt:ReferenceToken"))
				break;
		}
		else
		{
			if (!soap_in_tt__ReferenceToken(soap, tag, &n, "tt:ReferenceToken"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__ReferenceToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__anyType(struct soap *soap, std::vector<struct soap_dom_element >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__anyType(struct soap *soap, const std::vector<struct soap_dom_element >*a)
{
	for (std::vector<struct soap_dom_element >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__anyType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__anyType(struct soap *soap, const char *tag, int id, const std::vector<struct soap_dom_element >*a, const char *type)
{
	for (std::vector<struct soap_dom_element >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__anyType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<struct soap_dom_element >* SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__anyType(struct soap *soap, const char *tag, std::vector<struct soap_dom_element >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfxsd__anyType(soap, -1)))
		return NULL;
	struct soap_dom_element n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_xsd__anyType(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_xsd__anyType, SOAP_TYPE_std__vectorTemplateOfxsd__anyType, sizeof(struct soap_dom_element), 0))
				break;
			if (!soap_in_xsd__anyType(soap, tag, NULL, "xsd:anyType"))
				break;
		}
		else
		{
			if (!soap_in_xsd__anyType(soap, tag, &n, "xsd:anyType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<struct soap_dom_element > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfxsd__anyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<struct soap_dom_element >);
		if (size)
			*size = sizeof(std::vector<struct soap_dom_element >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<struct soap_dom_element >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<struct soap_dom_element >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<struct soap_dom_element >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfxsd__anyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<struct soap_dom_element > %p -> %p\n", q, p));
	*(std::vector<struct soap_dom_element >*)p = *(std::vector<struct soap_dom_element >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfint(struct soap *soap, std::vector<int >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfint(struct soap *soap, const std::vector<int >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfint(struct soap *soap, const char *tag, int id, const std::vector<int >*a, const char *type)
{
	for (std::vector<int >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_int(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<int >* SOAP_FMAC4 soap_in_std__vectorTemplateOfint(struct soap *soap, const char *tag, std::vector<int >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfint(soap, -1)))
		return NULL;
	int n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_int(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_int, SOAP_TYPE_std__vectorTemplateOfint, sizeof(int), 0))
				break;
			if (!soap_in_int(soap, tag, NULL, "xsd:int"))
				break;
		}
		else
		{
			if (!soap_in_int(soap, tag, &n, "xsd:int"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<int > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<int >);
		if (size)
			*size = sizeof(std::vector<int >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<int >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<int >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<int >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<int > %p -> %p\n", q, p));
	*(std::vector<int >*)p = *(std::vector<int >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Config(struct soap *soap, std::vector<tt__Config * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Config(struct soap *soap, const std::vector<tt__Config * >*a)
{
	for (std::vector<tt__Config * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Config(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Config(struct soap *soap, const char *tag, int id, const std::vector<tt__Config * >*a, const char *type)
{
	for (std::vector<tt__Config * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Config(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Config * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Config(struct soap *soap, const char *tag, std::vector<tt__Config * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Config(soap, -1)))
		return NULL;
	tt__Config *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_tt__Config, SOAP_TYPE_std__vectorTemplateOfPointerTott__Config, sizeof(tt__Config), 1))
				break;
			if (!soap_in_PointerTott__Config(soap, tag, NULL, "tt:Config"))
				break;
		}
		else
		{
			if (!soap_in_PointerTott__Config(soap, tag, &n, "tt:Config"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Config * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Config(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Config(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTott__Config, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__Config * >);
		if (size)
			*size = sizeof(std::vector<tt__Config * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tt__Config * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tt__Config * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tt__Config * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTott__Config(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tt__Config * > %p -> %p\n", q, p));
	*(std::vector<tt__Config * >*)p = *(std::vector<tt__Config * >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of AnalyticsC.cpp */
